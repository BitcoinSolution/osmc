From 9926b41b8942b07087007b0900fe6f45db8d36da Mon Sep 17 00:00:00 2001
From: phil65 <phil65.kodi.tv>
Date: Fri, 20 May 2016 03:27:14 +0200
Subject: [PATCH 001/175] - deprecate listitem.getduration(), .getfilename(),
 .getdescription()

---
 xbmc/interfaces/legacy/ListItem.cpp |  6 ++++++
 xbmc/interfaces/legacy/ListItem.h   | 25 ++++++++++++++++++-------
 2 files changed, 24 insertions(+), 7 deletions(-)

diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index 2da85b6..6cf419e 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -312,6 +312,12 @@ namespace XBMCAddon
       return item->GetPath();
     }
 
+    String ListItem::getPath()
+    {
+      LOCKGUI;
+      return item->GetPath();
+    }
+
     void ListItem::setInfo(const char* type, const InfoLabelDict& infoLabels)
     {
       LOCKGUI;
diff --git a/xbmc/interfaces/legacy/ListItem.h b/xbmc/interfaces/legacy/ListItem.h
index 911a6c9..e3e974d 100644
--- a/xbmc/interfaces/legacy/ListItem.h
+++ b/xbmc/interfaces/legacy/ListItem.h
@@ -785,7 +785,7 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// self.list.getSelectedItem().setPath(path='ActivateWindow(Weather)')
+      /// self.list.getSelectedItem().setPath(path='/path/to/some/file.ext')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -856,9 +856,8 @@ namespace XBMCAddon
       /// \ingroup python_xbmcgui_listitem
       /// @brief \python_func{ getdescription() }
       ///-----------------------------------------------------------------------
-      /// Returns the description of this PlayListItem.
+      /// @warning Deprecated.
       ///
-      /// @return Description string of play list item
       ///
       getdescription();
 #else
@@ -870,9 +869,8 @@ namespace XBMCAddon
       /// \ingroup python_xbmcgui_listitem
       /// @brief \python_func{ getduration() }
       ///-----------------------------------------------------------------------
-      /// Returns the duration of this PlayListItem
+      /// @warning Deprecated.
       ///
-      /// @return duration as string
       ///
       getduration();
 #else
@@ -884,9 +882,8 @@ namespace XBMCAddon
       /// \ingroup python_xbmcgui_listitem
       /// @brief \python_func{ getfilename() }
       ///-----------------------------------------------------------------------
-      /// Returns the filename of this PlayListItem.
+      /// @warning Deprecated.
       ///
-      /// @return [string] filename
       ///
       getfilename();
 #else
@@ -896,6 +893,20 @@ namespace XBMCAddon
 #ifdef DOXYGEN_SHOULD_USE_THIS
       ///
       /// \ingroup python_xbmcgui_listitem
+      /// @brief \python_func{ getPath() }
+      ///-----------------------------------------------------------------------
+      /// Returns the path of this listitem.
+      ///
+      /// @return [string] filename
+      ///
+      getPath();
+#else
+      String getPath();
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmcgui_listitem
       /// @brief \python_func{ getVideoInfoTag() }
       ///-----------------------------------------------------------------------
       /// Returns the VideoInfoTag for this item.
-- 
2.7.4


From 0ea739f25c31bccefbf483a7898394c68a661685 Mon Sep 17 00:00:00 2001
From: Ryan Rector <rmrector@gmail.com>
Date: Mon, 21 Dec 2015 16:15:13 -0700
Subject: [PATCH 002/175] Add TV show artwork to episodes/seasons with their
 own "fanart".

---
 xbmc/video/VideoThumbLoader.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/video/VideoThumbLoader.cpp b/xbmc/video/VideoThumbLoader.cpp
index 9213c17..ae1b99e 100644
--- a/xbmc/video/VideoThumbLoader.cpp
+++ b/xbmc/video/VideoThumbLoader.cpp
@@ -466,7 +466,7 @@ bool CVideoThumbLoader::FillLibraryArt(CFileItem &item)
     if (tag.m_type == MediaTypeEpisode || tag.m_type == MediaTypeSeason)
     {
       // For episodes and seasons, we want to set fanart for that of the show
-      if (!item.HasArt("fanart") && tag.m_iIdShow >= 0)
+      if (!item.HasArt("tvshow.fanart") && tag.m_iIdShow >= 0)
       {
         ArtCache::const_iterator i = m_showArt.find(tag.m_iIdShow);
         if (i == m_showArt.end())
-- 
2.7.4


From 65e8db16cf1b4618967f88f9d354642a2d89e4fe Mon Sep 17 00:00:00 2001
From: Christian Fetzer <fetzer.ch@gmail.com>
Date: Thu, 22 Sep 2016 20:32:03 +0200
Subject: [PATCH 003/175] Improve documentation

---
 project/cmake/README.md | 124 +++++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 106 insertions(+), 18 deletions(-)

diff --git a/project/cmake/README.md b/project/cmake/README.md
index 26815f6..10c2c14 100644
--- a/project/cmake/README.md
+++ b/project/cmake/README.md
@@ -3,13 +3,12 @@
 This files describes Kodi's CMake based buildsystem. CMake is a cross-platform
 tool for generating makefiles as well as project files used by IDEs.
 
-The current version of the buildsystem is capable of building the main Kodi
-executable (but no packaging or dependency management yet) for the following
-platforms:
+The current version of the buildsystem is capable of building and packaging
+Kodi for the following platforms:
 
 - Linux (GNU Makefiles, Ninja)
 - Windows (NMake Makefiles, Visual Studio 14 (2015), Ninja)
-- OSX and IOS (GNU Makefiles, Xcode, Ninja)
+- macOS and iOS (GNU Makefiles, Xcode, Ninja)
 - Android (GNU Makefiles)
 - FreeBSD (GNU Makefiles)
 
@@ -45,12 +44,12 @@ are downloaded using `DownloadBuildDeps.bat` and `DownloadMingwBuildEnv.bat`
 and that the mingw libs (ffmpeg, libdvd and others) are built using
 `make-mingwlibs.bat`.
 
-### OSX
+### macOS
 
-For OSX the required dependencies can be found in
+For macOS the required dependencies can be found in
 [docs/README.osx](https://github.com/xbmc/xbmc/tree/master/docs/README.osx).
 
-On OSX it is necessary to build the dependencies in `tools/depends` using
+On macOS it is necessary to build the dependencies in `tools/depends` using
 `./bootstrap && ./configure --host=<PLATFORM> && make`. The other steps such
 as `make -C tools/depends/target/xbmc` and `make xcode_depends` are not needed
 as these steps are covered already by the CMake project.
@@ -113,23 +112,28 @@ cmake -DCMAKE_TOOLCHAIN_FILE=<KODI_SRC>/tools/depends/target/Toolchain.cmake <KO
 cmake --build . -- VERBOSE=1 -j$(nproc)  # or: make VERBOSE=1 -j$(nproc)
 ```
 
-### Windows with NMake Makefiles
+### Windows with Visual Studio project files
 
 ```
-cmake -G "NMake Makefiles" -DCMAKE_BUILD_TYPE=Release <KODI_SRC>/project/cmake/
-cmake --build .  # or: nmake
-kodi.exe
+cmake -G "Visual Studio 14" <KODI_SRC>/project/cmake/
+cmake --build . --config "Debug"  # or: Build solution with Visual Studio
+Debug\kodi.exe
 ```
 
-### Windows with Visual Studio project files
+#### Windows installer generation
+
+The script [project/Win32BuildSetup](https://github.com/xbmc/xbmc/blob/master/project/Win32BuildSetup/BuildSetup.bat)
+builds an installable package for Windows.
+
+### Windows with NMake Makefiles
 
 ```
-cmake -G "Visual Studio 14" <KODI_SRC>/project/cmake/
-cmake --build . --config "Debug"  # or: Build solution with Visual Studio
-set KODI_HOME="%CD%" && Debug\kodi.exe
+cmake -G "NMake Makefiles" -DCMAKE_BUILD_TYPE=Release <KODI_SRC>/project/cmake/
+cmake --build .  # or: nmake
+kodi.exe
 ```
 
-### OSX with GNU Makefiles
+### macOS with GNU Makefiles
 
 ```
 cmake -DCMAKE_TOOLCHAIN_FILE=<KODI_SRC>/tools/depends/target/Toolchain.cmake <KODI_SRC>/project/cmake/
@@ -137,12 +141,28 @@ cmake --build . -- VERBOSE=1 -j$(sysctl -n hw.ncpu)  # or: make VERBOSE=1 -j$(sy
 ./kodi.bin
 ```
 
-### OSX with Xcode project files
+### macOS with Xcode project files
 
 ```
 cmake -DCMAKE_TOOLCHAIN_FILE=<KODI_SRC>/tools/depends/target/Toolchain.cmake -G "Xcode" <KODI_SRC>/project/cmake/
 cmake --build . --config "Release" -- -verbose -jobs $(sysctl -n hw.ncpu)  # or: Build solution with Xcode
-KODI_HOME=$(pwd) ./Release/kodi.bin
+./Release/kodi.bin
+```
+
+#### macOS installer generation
+
+Afterwards an installable DMG for macOS can be built with the following command:
+
+```
+cmake --build . --config "Release" --target "dmg"  # or: make dmg
+```
+
+#### iOS package generation
+
+Consequently an installable DEB for iOS can be built with the following command:
+
+```
+make deb
 ```
 
 ### Android with GNU Makefiles
@@ -152,6 +172,39 @@ cmake -DCMAKE_TOOLCHAIN_FILE=<KODI_SRC>/tools/depends/target/Toolchain.cmake <KO
 cmake --build . -- VERBOSE=1 -j$(nproc)  # or: make VERBOSE=1 -j$(nproc)
 ```
 
+#### Android package generation
+
+An installable APK for Android can be built with the following command:
+
+```
+make apk
+```
+
+## Options
+
+Kodi supports a number of build options that can enable or disable certain
+functionality.i These options must be set when running CMake with
+`-DENABLE_<OPTION>=<ON|OFF|AUTO`. The default is `AUTO` which enables
+the option if a certain dependency is found. For example CEC support is
+enabled if libCEC is available. `ON` forcefully enables the dependency
+and the CMake run will fail if the related dependency is not available.
+This is mostly useful for packagers. `OFF` will disable the feature.
+
+Example for forcefully enabling VAAPI and disabling VDPAU:
+
+```
+cmake ... -DENABLE_VAAPI=ON -DENABLE_VDPAU=OFF ...
+```
+
+Example for building with external FFMPEG:
+
+```
+cmake ... -DFFMPEG_PATH=/opt/ffmpeg -DENABLE_INTERNAL_FFMPEG=OFF ...
+```
+
+For more information and an updated list of option, please check the
+main [project/cmake/CMakeLists.txt](https://github.com/xbmc/xbmc/tree/master/project/cmake/CMakeLists.txt).
+
 ## Tests
 
 Kodi uses Google Test as its testing framework. Each test file is scanned for tests and these
@@ -168,6 +221,7 @@ scanning them would take up an unreasonable amount of configure time.
 When using the makefile builds a few extra targets are defined:
 
 - `make check` builds and executes the test suite.
+- `make check-valgrind` builds and executes the test suite with valgrind memcheck.
 
 Code coverage (with Gcov, LCOV and Gcovr) can be built on Linux:
 
@@ -175,6 +229,40 @@ Code coverage (with Gcov, LCOV and Gcovr) can be built on Linux:
 - `make coverage` generates an HTML code coverage report.
 - `make coverage_xml` generates an XML code coverage report.
 
+## Building binary addons
+
+The CMake build system integrates with the addon build system if the GNU
+Makefile generator is used. This offers an easy way to build addons for
+packagers or Kodi developers who don't work on addons.
+
+```
+make binary-addons
+```
+
+Specific addons can be built with:
+
+```
+make binary-addons ADDONS="visualization.spectrum pvr.demo"
+```
+
+Addon developers can build single addons into the Kodi build directory
+so that the addon can be tested with self-compiled specific versions of Kodi.
+
+```
+mkdir pvr.demo-build && cd pvr.demo-build
+cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_PREFIX_PATH=<KODI_BUILD_DIR>/build -DCORE_BUILD_DIR=<KODI_BUILD_DIR> <pvr.demo-SRC>
+make
+```
+
+It is recommended to specify the directories as absolute paths. If relative
+paths are used, they are considered relative to the build directory in which
+`cmake` was executed (aka the current working working directory).
+
+Both methods work only for already existing addons. See this
+[forum thread](http://forum.kodi.tv/showthread.php?tid=219166&pid=1934922#pid1934922)
+and [addons/README.md](https://github.com/xbmc/xbmc/blob/master/project/cmake/addons/README.md)
+for addon development and detailed documentation about the addon build system.
+
 ## Sanitizers
 
 Clang and GCC support different kinds of Sanitizers. To enable a Sanitizer call CMake with the
-- 
2.7.4


From b84d2da78d29514a3882a6b6eaf1101474dfc297 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 06:35:55 +0200
Subject: [PATCH 004/175] change order-by selection from spinner to
 selectdialog

---
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp | 25 +++++++++++++++----------
 1 file changed, 15 insertions(+), 10 deletions(-)

diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
index 35b6aa9..ec4d565 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
@@ -26,6 +26,7 @@
 #include "filesystem/File.h"
 #include "GUIDialogContextMenu.h"
 #include "GUIDialogSmartPlaylistRule.h"
+#include "GUIDialogSelect.h"
 #include "guilib/GUIKeyboardFactory.h"
 #include "guilib/GUIWindowManager.h"
 #include "guilib/LocalizeStrings.h"
@@ -294,9 +295,18 @@ void CGUIDialogSmartPlaylistEditor::OnType()
 
 void CGUIDialogSmartPlaylistEditor::OnOrder()
 {
-  CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_ORDER_FIELD);
-  OnMessage(msg);
-  m_playlist.m_orderField = (SortBy)msg.GetParam1();
+  std::vector<SortBy> orders = CSmartPlaylistRule::GetOrders(m_playlist.GetType());
+  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  dialog->Reset();
+  for (auto order: orders)
+    dialog->Add(g_localizeStrings.Get(SortUtils::GetSortLabel(order)));
+  dialog->SetHeading(CVariant{ 21429 });
+  dialog->SetSelected(g_localizeStrings.Get(SortUtils::GetSortLabel(m_playlist.m_orderField)));
+  dialog->Open();
+  int newSelected = dialog->GetSelectedItem();
+  if (!dialog->IsConfirmed() || newSelected < 0 || orders[newSelected] == m_playlist.m_orderField)
+    return;
+  m_playlist.m_orderField = orders[newSelected];
   UpdateButtons();
 }
 
@@ -374,15 +384,10 @@ void CGUIDialogSmartPlaylistEditor::UpdateButtons()
     CONTROL_DESELECT(CONTROL_ORDER_DIRECTION);
   }
 
-  // sort out the order fields
-  std::vector< std::pair<std::string, int> > labels;
-  std::vector<SortBy> orders = CSmartPlaylistRule::GetOrders(m_playlist.GetType());
-  for (unsigned int i = 0; i < orders.size(); i++)
-    labels.push_back(make_pair(g_localizeStrings.Get(SortUtils::GetSortLabel(orders[i])), orders[i]));
-  SET_CONTROL_LABELS(CONTROL_ORDER_FIELD, m_playlist.m_orderField, &labels);
+  SET_CONTROL_LABEL2(CONTROL_ORDER_FIELD, g_localizeStrings.Get(SortUtils::GetSortLabel(m_playlist.m_orderField)));
 
   // setup groups
-  labels.clear();
+  std::vector< std::pair<std::string, int> > labels;
   std::vector<Field> groups = CSmartPlaylistRule::GetGroups(m_playlist.GetType());
   Field currentGroup = CSmartPlaylistRule::TranslateGroup(m_playlist.GetGroup().c_str());
   for (unsigned int i = 0; i < groups.size(); i++)
-- 
2.7.4


From 3b6675d42e6140df6bb6a2758e8fdf819f30a975 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 06:35:46 +0200
Subject: [PATCH 005/175] change button type for order-by to "button"

---
 addons/skin.estuary/1080i/SmartPlaylistEditor.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
index 8e8133d..8cfe688 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
@@ -56,7 +56,7 @@
 					<label>$LOCALIZE[21427]</label>
 					<include>SettingsItemCommon</include>
 				</control>
-				<control type="spincontrolex" id="18">
+				<control type="button" id="18">
 					<label>$LOCALIZE[21429]</label>
 					<width>660</width>
 					<include>SettingsItemCommon</include>
-- 
2.7.4


From 8880f56eb22ff41ac72f32739bb040a18b25829d Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 03:23:58 +0200
Subject: [PATCH 006/175] smartplaylisteditor: change another two buttons to
 "regular" button controls

---
 addons/skin.estuary/1080i/SmartPlaylistEditor.xml |  7 +++---
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp     | 26 ++++++++++++-----------
 2 files changed, 17 insertions(+), 16 deletions(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
index 8cfe688..ecf425b 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
@@ -46,7 +46,7 @@
 					<label>$LOCALIZE[31042]</label>
 					<include>SettingsLabelCommon</include>
 				</control>
-				<control type="spincontrolex" id="16">
+				<control type="button" id="16">
 					<width>660</width>
 					<label>$LOCALIZE[21424]</label>
 					<include>SettingsItemCommon</include>
@@ -61,11 +61,10 @@
 					<width>660</width>
 					<include>SettingsItemCommon</include>
 				</control>
-				<control type="togglebutton" id="19">
+				<control type="button" id="19">
 					<width>660</width>
 					<include>SettingsItemCommon</include>
-					<label>$LOCALIZE[31032]: $LOCALIZE[21431]</label>
-					<altlabel>$LOCALIZE[31032]: $LOCALIZE[21430]</altlabel>
+					<label>$LOCALIZE[31032]</label>
 				</control>
 				<control type="spincontrolex" id="23">
 					<width>660</width>
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
index ec4d565..d17b5d4 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
@@ -271,9 +271,11 @@ void CGUIDialogSmartPlaylistEditor::OnCancel()
 
 void CGUIDialogSmartPlaylistEditor::OnMatch()
 {
-  CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_MATCH);
-  OnMessage(msg);
-  m_playlist.m_ruleCombination.SetType(msg.GetParam1() == 0 ? CSmartPlaylistRuleCombination::CombinationAnd : CSmartPlaylistRuleCombination::CombinationOr);
+  // toggle between AND and OR setting
+  if (m_playlist.m_ruleCombination.GetType() == CSmartPlaylistRuleCombination::CombinationOr)
+    m_playlist.m_ruleCombination.SetType(CSmartPlaylistRuleCombination::CombinationAnd);
+  else
+    m_playlist.m_ruleCombination.SetType(CSmartPlaylistRuleCombination::CombinationOr);
   UpdateButtons();
 }
 
@@ -355,7 +357,12 @@ void CGUIDialogSmartPlaylistEditor::UpdateButtons()
     SET_CONTROL_LABEL2(CONTROL_NAME, m_playlist.m_playlistName);
   
   UpdateRuleControlButtons();
+  
 
+  if (m_playlist.m_ruleCombination.GetType() == CSmartPlaylistRuleCombination::CombinationOr)
+    SET_CONTROL_LABEL2(CONTROL_MATCH, g_localizeStrings.Get(21426));
+  else
+    SET_CONTROL_LABEL2(CONTROL_MATCH, g_localizeStrings.Get(21425));
   CONTROL_ENABLE_ON_CONDITION(CONTROL_MATCH, m_playlist.m_ruleCombination.m_rules.size() > 1);
 
   int currentItem = GetSelectedItem();
@@ -377,11 +384,11 @@ void CGUIDialogSmartPlaylistEditor::UpdateButtons()
 
   if (m_playlist.m_orderDirection != SortOrderDescending)
   {
-    CONTROL_SELECT(CONTROL_ORDER_DIRECTION);
+    SET_CONTROL_LABEL2(CONTROL_ORDER_DIRECTION, g_localizeStrings.Get(21430));
   }
   else
   {
-    CONTROL_DESELECT(CONTROL_ORDER_DIRECTION);
+    SET_CONTROL_LABEL2(CONTROL_ORDER_DIRECTION, g_localizeStrings.Get(21431));
   }
 
   SET_CONTROL_LABEL2(CONTROL_ORDER_FIELD, g_localizeStrings.Get(SortUtils::GetSortLabel(m_playlist.m_orderField)));
@@ -430,14 +437,9 @@ void CGUIDialogSmartPlaylistEditor::OnWindowLoaded()
   CGUIDialog::OnWindowLoaded();
 
   SendMessage(GUI_MSG_SET_TYPE, CONTROL_NAME, 0, 16012);
-  // setup the match spinner
-  std::vector< std::pair<std::string, int> > labels;
-  labels.push_back(make_pair(g_localizeStrings.Get(21425), 0));
-  labels.push_back(make_pair(g_localizeStrings.Get(21426), 1));
-  SET_CONTROL_LABELS(CONTROL_MATCH, m_playlist.m_ruleCombination.GetType() == CSmartPlaylistRuleCombination::CombinationAnd ? 0 : 1, &labels);
 
-  // and now the limit spinner
-  labels.clear();
+  // set up the limit spinner
+  std::vector< std::pair<std::string, int> > labels;
   labels.push_back(make_pair(g_localizeStrings.Get(21428), 0));
   const int limits[] = { 10, 25, 50, 100, 250, 500, 1000 };
   for (unsigned int i = 0; i < sizeof(limits) / sizeof(int); i++)
-- 
2.7.4


From b50f184beee95d3d7ded7ce25d5e7dec472d9676 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Thu, 29 Sep 2016 18:28:52 +0200
Subject: [PATCH 007/175] SmartPlaylistEditor.xml - add missing 'add rule'
 button (reverted from commit fc87499d3dfd95790be7e2df52b094d98b939d6b)

(cherry picked from commit beec7522e84e799e4021d985b88874a38a937ffe)
---
 addons/skin.estuary/1080i/SmartPlaylistEditor.xml | 20 +++-----------------
 1 file changed, 3 insertions(+), 17 deletions(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
index ecf425b..ad4ab44 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
@@ -109,32 +109,18 @@
 				<height>435</height>
 				<onleft>500</onleft>
 				<onright>500</onright>
-				<ondown>13</ondown>
+				<ondown>9001</ondown>
 				<onup>9001</onup>
 				<include content="DefaultSimpleListLayout">
 					<param name="width" value="600" />
 					<param name="list_id" value="10" />
 				</include>
 			</control>
-			<control type="button" id="13">
-				<description>Add rule Button</description>
-				<left>650</left>
-				<top>555</top>
-				<width>300</width>
-				<height>90</height>
-				<include>SettingsItemCommon</include>
-				<align>center</align>
-				<label>$LOCALIZE[15019]</label>
-				<onleft>500</onleft>
-				<onright>500</onright>
-				<ondown>9001</ondown>
-				<onup>10</onup>
-			</control>
 			<control type="textbox">
 				<left>680</left>
-				<top>640</top>
+				<top>570</top>
 				<width>540</width>
-				<height>188</height>
+				<height>248</height>
 				<aligny>top</aligny>
 				<label>$LOCALIZE[31043]</label>
 				<textcolor>grey</textcolor>
-- 
2.7.4


From 6a7ca0f510d443e2b3e00509f6a18d5422d6de05 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Thu, 29 Sep 2016 18:28:38 +0200
Subject: [PATCH 008/175] Always show "Add rule" button in smartplaylisteditor
 rule list

(cherry picked from commit e6daef4f7674d4ba0fda531e73491231ec0e6060)
---
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp | 49 ++++++++++-----------------
 1 file changed, 18 insertions(+), 31 deletions(-)

diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
index d17b5d4..e5169cf 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
@@ -189,9 +189,7 @@ bool CGUIDialogSmartPlaylistEditor::OnMessage(CGUIMessage& message)
 
 void CGUIDialogSmartPlaylistEditor::OnPopupMenu(int item)
 {
-  if (item < 0 || item >= m_ruleLabels->Size())
-    return;
-  if (m_playlist.m_ruleCombination.m_rules.size() == 1 && m_playlist.m_ruleCombination.m_rules[0]->m_field == FieldNone)
+  if (item < 0 || static_cast<size_t>(item) >= m_playlist.m_ruleCombination.m_rules.size())
     return;
   // highlight the item
   m_ruleLabels->Get(item)->Select(true);
@@ -209,14 +207,17 @@ void CGUIDialogSmartPlaylistEditor::OnPopupMenu(int item)
 }
 
 void CGUIDialogSmartPlaylistEditor::OnRuleList(int item)
-{
-  if (item < 0 || item >= (int)m_playlist.m_ruleCombination.m_rules.size()) return;
-
-  CSmartPlaylistRule rule = *std::static_pointer_cast<CSmartPlaylistRule>(m_playlist.m_ruleCombination.m_rules[item]);
-
-  if (CGUIDialogSmartPlaylistRule::EditRule(rule,m_playlist.GetType()))
-    *m_playlist.m_ruleCombination.m_rules[item] = rule;
-
+{ 
+  if (item == static_cast<int>(m_playlist.m_ruleCombination.m_rules.size()))
+    OnRuleAdd();
+  else if (item < 0 || item > static_cast<int>(m_playlist.m_ruleCombination.m_rules.size()))
+    return;
+  else
+  {
+    CSmartPlaylistRule rule = *std::static_pointer_cast<CSmartPlaylistRule>(m_playlist.m_ruleCombination.m_rules[item]);
+    if (CGUIDialogSmartPlaylistRule::EditRule(rule,m_playlist.GetType()))
+      *m_playlist.m_ruleCombination.m_rules[item] = rule;
+  }
   UpdateButtons();
 }
 
@@ -343,11 +344,6 @@ void CGUIDialogSmartPlaylistEditor::UpdateButtons()
 {
   CONTROL_ENABLE(CONTROL_OK); // always enabled since we can have no rules -> match everything (as we do with default partymode playlists)
   
-  // if there's no rule available, add a dummy one the user can edit
-  if (m_playlist.m_ruleCombination.m_rules.size() <= 0)
-    m_playlist.m_ruleCombination.AddRule(CSmartPlaylistRule());
-
-  // name
   if (m_mode == "partyvideo" || m_mode == "partymusic")
   {
     SET_CONTROL_LABEL2(CONTROL_NAME, g_localizeStrings.Get(16035));
@@ -369,15 +365,15 @@ void CGUIDialogSmartPlaylistEditor::UpdateButtons()
   CGUIMessage msgReset(GUI_MSG_LABEL_RESET, GetID(), CONTROL_RULE_LIST);
   OnMessage(msgReset);
   m_ruleLabels->Clear();
-  for (unsigned int i = 0; i < m_playlist.m_ruleCombination.m_rules.size(); i++)
+  for (const auto& rule: m_playlist.m_ruleCombination.m_rules)
   {
     CFileItemPtr item(new CFileItem("", false));
-    if (m_playlist.m_ruleCombination.m_rules[i]->m_field == FieldNone)
-      item->SetLabel(g_localizeStrings.Get(21423));
-    else
-      item->SetLabel(std::static_pointer_cast<CSmartPlaylistRule>(m_playlist.m_ruleCombination.m_rules[i])->GetLocalizedRule());
+    item->SetLabel(std::static_pointer_cast<CSmartPlaylistRule>(rule)->GetLocalizedRule());
     m_ruleLabels->Add(item);
   }
+  CFileItemPtr item(new CFileItem("", false));
+  item->SetLabel(g_localizeStrings.Get(21423));
+  m_ruleLabels->Add(item);
   CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_RULE_LIST, 0, 0, m_ruleLabels);
   OnMessage(msg);
   SendMessage(GUI_MSG_ITEM_SELECT, GetID(), CONTROL_RULE_LIST, currentItem);
@@ -563,22 +559,13 @@ void CGUIDialogSmartPlaylistEditor::OnRuleRemove(int item)
     HighlightItem(m_ruleLabels->Size() - 1);
   else
     HighlightItem(item);
-  if (m_ruleLabels->Size() <= 1)
-  {
-    SET_CONTROL_FOCUS(CONTROL_RULE_ADD, 0);
-  }
 }
 
 void CGUIDialogSmartPlaylistEditor::OnRuleAdd()
 {
   CSmartPlaylistRule rule;
   if (CGUIDialogSmartPlaylistRule::EditRule(rule,m_playlist.GetType()))
-  {
-    if (m_playlist.m_ruleCombination.m_rules.size() == 1 && m_playlist.m_ruleCombination.m_rules[0]->m_field == FieldNone)
-      *m_playlist.m_ruleCombination.m_rules[0] = rule;
-    else
-      m_playlist.m_ruleCombination.AddRule(rule);
-  }
+    m_playlist.m_ruleCombination.AddRule(rule);
   UpdateButtons();
 }
 
-- 
2.7.4


From 978587d40135cc5d0fc1796d440ee77647e3ac9b Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Thu, 29 Sep 2016 21:29:59 +0200
Subject: [PATCH 009/175] change smartplaylistrule button type to "button"

(cherry picked from commit 3d7fb0ee97fb3d00985fb1a5cb4b8a6c756aae4c)
---
 addons/skin.estuary/1080i/SmartPlaylistRule.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistRule.xml b/addons/skin.estuary/1080i/SmartPlaylistRule.xml
index c2c49f9..ac01302 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistRule.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistRule.xml
@@ -27,7 +27,7 @@
 			<orientation>vertical</orientation>
 			<onup>9000</onup>
 			<ondown>9000</ondown>
-			<control type="spincontrolex" id="15">
+			<control type="button" id="15">
 				<description>Rule Field</description>
 				<include>SettingsItemCommon</include>
 				<width>900</width>
-- 
2.7.4


From 18156a78249d79a14f744f0d0b282f97842f6cb2 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Thu, 29 Sep 2016 21:46:21 +0200
Subject: [PATCH 010/175] change rule type selection from spinner to
 selectdialog

(cherry picked from commit 37babb04e5de2dad84379e3f57142c13cf78cf74)
---
 .../resource.language.en_gb/resources/strings.po   |  4 ++-
 xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp        | 40 +++++++++++++---------
 2 files changed, 26 insertions(+), 18 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 7d8a53c..80f8d89 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -12419,7 +12419,9 @@ msgctxt "#20426"
 msgid "Export to a single file or separate files per entry?"
 msgstr ""
 
-#empty string with id 20427
+msgctxt "#20427"
+msgid "Choose rule type"
+msgstr ""
 
 msgctxt "#20428"
 msgid "Single file"
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
index 91fad1d..d8bb940 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
@@ -379,9 +379,26 @@ void CGUIDialogSmartPlaylistRule::OnCancel()
 
 void CGUIDialogSmartPlaylistRule::OnField()
 {
-  CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_FIELD);
-  OnMessage(msg);
-  m_rule.m_field = (Field)msg.GetParam1();
+
+  std::vector<Field> fields = CSmartPlaylistRule::GetFields(m_type);
+  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  dialog->Reset();
+  dialog->SetHeading(CVariant{20427});
+  int selected = -1;
+  for (unsigned int i = 0; i < fields.size(); i++)
+  {
+    dialog->Add(CSmartPlaylistRule::GetLocalizedField(fields[i]));
+    if (fields[i] == m_rule.m_field)
+      selected = i;
+  }
+  if (selected > -1)
+    dialog->SetSelected(selected);
+  dialog->Open();
+  int newSelected = dialog->GetSelectedItem();
+  // check if selection has changed
+  if (!dialog->IsConfirmed() || newSelected < 0 || newSelected == selected)
+    return;
+  m_rule.m_field = fields[newSelected];
 
   UpdateButtons();
 }
@@ -402,12 +419,9 @@ std::pair<std::string, int> OperatorLabel(CDatabaseQueryRule::SEARCH_OPERATOR op
 
 void CGUIDialogSmartPlaylistRule::UpdateButtons()
 {
-  // update the field control
-  SendMessage(GUI_MSG_ITEM_SELECT, CONTROL_FIELD, m_rule.m_field);
-  CGUIMessage msg2(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_FIELD);
-  OnMessage(msg2);
-  m_rule.m_field = (Field)msg2.GetParam1();
-
+  if (m_rule.m_field == 0)
+    m_rule.m_field = CSmartPlaylistRule::GetFields(m_type)[0];
+  SET_CONTROL_LABEL2(CONTROL_FIELD, CSmartPlaylistRule::GetLocalizedField(m_rule.m_field));
   // and now update the operator set
   SendMessage(GUI_MSG_LABEL_RESET, CONTROL_OPERATOR);
 
@@ -507,14 +521,6 @@ void CGUIDialogSmartPlaylistRule::OnInitWindow()
 {
   CGUIDialog::OnInitWindow();
 
-  // add the fields to the field spincontrol
-  std::vector< std::pair<std::string, int> > labels;
-  std::vector<Field> fields = CSmartPlaylistRule::GetFields(m_type);
-  for (unsigned int i = 0; i < fields.size(); i++)
-    labels.emplace_back(CSmartPlaylistRule::GetLocalizedField(fields[i]), fields[i]);
-
-  SET_CONTROL_LABELS(CONTROL_FIELD, 0, &labels);
-
   UpdateButtons();
 
   CGUIEditControl *editControl = dynamic_cast<CGUIEditControl*>(GetControl(CONTROL_VALUE));
-- 
2.7.4


From 0be00f4f13183017d3795c1352f8f0426c622d79 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 01:04:11 +0200
Subject: [PATCH 011/175] change group-by selection from spinner to
 selectdialog

---
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp | 25 ++++++++++++++++---------
 1 file changed, 16 insertions(+), 9 deletions(-)

diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
index e5169cf..fdea884 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
@@ -324,11 +324,22 @@ void CGUIDialogSmartPlaylistEditor::OnOrderDirection()
 
 void CGUIDialogSmartPlaylistEditor::OnGroupBy()
 {
-  CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_GROUP_BY);
-  OnMessage(msg);
-  m_playlist.SetGroup(CSmartPlaylistRule::TranslateGroup((Field)msg.GetParam1()));
+  std::vector<Field> groups = CSmartPlaylistRule::GetGroups(m_playlist.GetType());
+  Field currentGroup = CSmartPlaylistRule::TranslateGroup(m_playlist.GetGroup().c_str());
+  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  dialog->Reset();
+  for (auto group : groups)
+    dialog->Add(CSmartPlaylistRule::GetLocalizedGroup(group));
+  dialog->SetHeading(CVariant{ 21458 });
+  dialog->SetSelected(CSmartPlaylistRule::GetLocalizedGroup(currentGroup));
+  dialog->Open();
+  int newSelected = dialog->GetSelectedItem();
+   // check if selection has changed
+  if (!dialog->IsConfirmed() || newSelected < 0 || groups[newSelected] == currentGroup)
+    return;
+  m_playlist.SetGroup(CSmartPlaylistRule::TranslateGroup(groups[newSelected]));
 
-  if (m_playlist.IsGroupMixed() && !CSmartPlaylistRule::CanGroupMix((Field)msg.GetParam1()))
+  if (m_playlist.IsGroupMixed() && !CSmartPlaylistRule::CanGroupMix(currentGroup))
     m_playlist.SetGroupMixed(false);
 
   UpdateButtons();
@@ -390,13 +401,9 @@ void CGUIDialogSmartPlaylistEditor::UpdateButtons()
   SET_CONTROL_LABEL2(CONTROL_ORDER_FIELD, g_localizeStrings.Get(SortUtils::GetSortLabel(m_playlist.m_orderField)));
 
   // setup groups
-  std::vector< std::pair<std::string, int> > labels;
   std::vector<Field> groups = CSmartPlaylistRule::GetGroups(m_playlist.GetType());
   Field currentGroup = CSmartPlaylistRule::TranslateGroup(m_playlist.GetGroup().c_str());
-  for (unsigned int i = 0; i < groups.size(); i++)
-    labels.push_back(make_pair(CSmartPlaylistRule::GetLocalizedGroup(groups[i]), groups[i]));
-  SET_CONTROL_LABELS(CONTROL_GROUP_BY, currentGroup, &labels);
-
+  SET_CONTROL_LABEL2(CONTROL_GROUP_BY, CSmartPlaylistRule::GetLocalizedGroup(currentGroup));
   if (m_playlist.IsGroupMixed())
     CONTROL_SELECT(CONTROL_GROUP_MIXED);
   else
-- 
2.7.4


From 8c0b2315da6e5b8f2a9d65efe0c6a6feeef2e3ed Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 01:04:32 +0200
Subject: [PATCH 012/175] change button type for group-by to "button"

(cherry picked from commit a3ad5a39df941289db3c9d54fe6d1bc15a03d6b9)
---
 addons/skin.estuary/1080i/SmartPlaylistEditor.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
index ad4ab44..e4d71bb 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
@@ -66,7 +66,7 @@
 					<include>SettingsItemCommon</include>
 					<label>$LOCALIZE[31032]</label>
 				</control>
-				<control type="spincontrolex" id="23">
+				<control type="button" id="23">
 					<width>660</width>
 					<label>$LOCALIZE[21458]</label>
 					<include>SettingsItemCommon</include>
-- 
2.7.4


From 1dd6f338fee8583763fd53700cf73dccbf31dd1a Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 04:46:26 +0200
Subject: [PATCH 013/175] change button type for playlist type selection to
 "button" + some refactoring

---
 addons/skin.estuary/1080i/SmartPlaylistEditor.xml |  2 +-
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp     | 89 +++++++++++++----------
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.h       |  1 +
 3 files changed, 52 insertions(+), 40 deletions(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
index e4d71bb..87ea65d 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
@@ -23,7 +23,7 @@
 				<ondown>9001</ondown>
 				<onup>9001</onup>
 				<itemgap>-20</itemgap>
-				<control type="spincontrolex" id="22">
+				<control type="button" id="22">
 					<description>Set Playlist type</description>
 					<width>660</width>
 					<include>SettingsItemCommon</include>
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
index fdea884..4064621 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
@@ -290,9 +290,19 @@ void CGUIDialogSmartPlaylistEditor::OnLimit()
 
 void CGUIDialogSmartPlaylistEditor::OnType()
 {
-  CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_TYPE);
-  OnMessage(msg);
-  m_playlist.SetType(ConvertType((PLAYLIST_TYPE)msg.GetParam1()));
+  std::vector<PLAYLIST_TYPE> allowedTypes = GetAllowedTypes(m_mode);
+  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  dialog->Reset();
+  for (auto allowedType: allowedTypes)
+    dialog->Add(GetLocalizedType(allowedType));
+  dialog->SetHeading(CVariant{ 564 });
+  dialog->SetSelected(GetLocalizedType(ConvertType(m_playlist.GetType())));
+  dialog->Open();
+  int newSelected = dialog->GetSelectedItem();
+  if (!dialog->IsConfirmed() || newSelected < 0 || allowedTypes[newSelected] == ConvertType(m_playlist.GetType()))
+    return;
+ 
+  m_playlist.SetType(ConvertType(allowedTypes[newSelected]));
   UpdateButtons();
 }
 
@@ -399,6 +409,7 @@ void CGUIDialogSmartPlaylistEditor::UpdateButtons()
   }
 
   SET_CONTROL_LABEL2(CONTROL_ORDER_FIELD, g_localizeStrings.Get(SortUtils::GetSortLabel(m_playlist.m_orderField)));
+  SET_CONTROL_LABEL2(CONTROL_TYPE, GetLocalizedType(ConvertType(m_playlist.GetType())));
 
   // setup groups
   std::vector<Field> groups = CSmartPlaylistRule::GetGroups(m_playlist.GetType());
@@ -456,47 +467,16 @@ void CGUIDialogSmartPlaylistEditor::OnInitWindow()
 
   SendMessage(GUI_MSG_ITEM_SELECT, CONTROL_LIMIT, m_playlist.m_limit);
 
-  std::vector<PLAYLIST_TYPE> allowedTypes;
-  if (m_mode == "partymusic")
-  {
-    allowedTypes.push_back(TYPE_SONGS);
-    allowedTypes.push_back(TYPE_MIXED);
-  }
-  else if (m_mode == "partyvideo")
-  {
-    allowedTypes.push_back(TYPE_MUSICVIDEOS);
-    allowedTypes.push_back(TYPE_MIXED);
-  }
-  else if (m_mode == "music")
-  { // music types + mixed
-    allowedTypes.push_back(TYPE_SONGS);
-    allowedTypes.push_back(TYPE_ALBUMS);
-    allowedTypes.push_back(TYPE_ARTISTS);
-    allowedTypes.push_back(TYPE_MIXED);
-  }
-  else if (m_mode == "video")
-  { // general category for videos
-    allowedTypes.push_back(TYPE_MOVIES);
-    allowedTypes.push_back(TYPE_TVSHOWS);
-    allowedTypes.push_back(TYPE_EPISODES);
-    allowedTypes.push_back(TYPE_MUSICVIDEOS);
-    allowedTypes.push_back(TYPE_MIXED);
-  }
-  // add to the spinner
-  std::vector< std::pair<std::string, int> > labels;
-  for (unsigned int i = 0; i < allowedTypes.size(); i++)
-    labels.push_back(make_pair(GetLocalizedType(allowedTypes[i]), allowedTypes[i]));
-  // check our playlist type is allowed
+  std::vector<PLAYLIST_TYPE> allowedTypes = GetAllowedTypes(m_mode);
+  // check if our playlist type is allowed
   PLAYLIST_TYPE type = ConvertType(m_playlist.GetType());
   bool allowed = false;
-  for (unsigned int i = 0; i < allowedTypes.size(); i++)
-    if (type == allowedTypes[i])
+  for (auto allowedType: allowedTypes)
+    if (type == allowedType)
       allowed = true;
   if (!allowed && allowedTypes.size())
-    type = allowedTypes[0];
+    m_playlist.SetType(ConvertType(allowedTypes[0]));
 
-  SET_CONTROL_LABELS(CONTROL_TYPE, type, &labels);
-  m_playlist.SetType(ConvertType(type));
   UpdateButtons();
 
   SET_CONTROL_LABEL(CONTROL_HEADING, 21432);
@@ -556,6 +536,37 @@ void CGUIDialogSmartPlaylistEditor::HighlightItem(int item)
   OnMessage(msg);
 }
 
+std::vector<CGUIDialogSmartPlaylistEditor::PLAYLIST_TYPE> CGUIDialogSmartPlaylistEditor::GetAllowedTypes(std::string mode)
+{
+  std::vector<PLAYLIST_TYPE> allowedTypes;
+  if (mode == "partymusic")
+  {
+    allowedTypes.push_back(TYPE_SONGS);
+    allowedTypes.push_back(TYPE_MIXED);
+  }
+  else if (mode == "partyvideo")
+  {
+    allowedTypes.push_back(TYPE_MUSICVIDEOS);
+    allowedTypes.push_back(TYPE_MIXED);
+  }
+  else if (mode == "music")
+  { // music types + mixed
+    allowedTypes.push_back(TYPE_SONGS);
+    allowedTypes.push_back(TYPE_ALBUMS);
+    allowedTypes.push_back(TYPE_ARTISTS);
+    allowedTypes.push_back(TYPE_MIXED);
+  }
+  else if (mode == "video")
+  { // general category for videos
+    allowedTypes.push_back(TYPE_MOVIES);
+    allowedTypes.push_back(TYPE_TVSHOWS);
+    allowedTypes.push_back(TYPE_EPISODES);
+    allowedTypes.push_back(TYPE_MUSICVIDEOS);
+    allowedTypes.push_back(TYPE_MIXED);
+  }
+  return allowedTypes;
+}
+
 void CGUIDialogSmartPlaylistEditor::OnRuleRemove(int item)
 {
   if (item < 0 || item >= (int)m_playlist.m_ruleCombination.m_rules.size()) return;
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h
index 2c68c19..4a55797 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h
@@ -60,6 +60,7 @@ protected:
   void UpdateRuleControlButtons();
   int GetSelectedItem();
   void HighlightItem(int item);
+  std::vector<PLAYLIST_TYPE> GetAllowedTypes(std::string mode);
   PLAYLIST_TYPE ConvertType(const std::string &type);
   std::string ConvertType(PLAYLIST_TYPE type);
   std::string GetLocalizedType(PLAYLIST_TYPE type);
-- 
2.7.4


From 2a73682057570dcbd014f4bd99f48b911bae7f52 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 06:16:21 +0200
Subject: [PATCH 014/175] change playlist limit selection to "button"

---
 addons/skin.estuary/1080i/SmartPlaylistEditor.xml |  2 +-
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp     | 37 ++++++++++++++---------
 2 files changed, 24 insertions(+), 15 deletions(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
index 87ea65d..1e1a5cc 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
@@ -51,7 +51,7 @@
 					<label>$LOCALIZE[21424]</label>
 					<include>SettingsItemCommon</include>
 				</control>
-				<control type="spincontrolex" id="17">
+				<control type="button" id="17">
 					<width>660</width>
 					<label>$LOCALIZE[21427]</label>
 					<include>SettingsItemCommon</include>
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
index 4064621..8ccf179 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
@@ -282,9 +282,25 @@ void CGUIDialogSmartPlaylistEditor::OnMatch()
 
 void CGUIDialogSmartPlaylistEditor::OnLimit()
 {
-  CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIMIT);
-  OnMessage(msg);
-  m_playlist.m_limit = msg.GetParam1();
+  const int limits[] = {0, 10, 25, 50, 100, 250, 500, 1000, -1 };
+  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  dialog->Reset();
+  int selected = -1;
+  for (unsigned int i = 0; limits[i] > -1; i++) {
+    if (limits[i] == m_playlist.m_limit)
+      selected = i;
+    if (limits[i] == 0)
+      dialog->Add(g_localizeStrings.Get(21428));
+    else
+      dialog->Add(StringUtils::Format(g_localizeStrings.Get(21436).c_str(), limits[i]));
+  }
+  dialog->SetHeading(CVariant{ 21427 });
+  dialog->SetSelected(selected);
+  dialog->Open();
+  int newSelected = dialog->GetSelectedItem();
+  if (!dialog->IsConfirmed() || newSelected < 0 || limits[newSelected] == m_playlist.m_limit)
+    return;
+  m_playlist.m_limit = limits[newSelected];
   UpdateButtons();
 }
 
@@ -381,7 +397,10 @@ void CGUIDialogSmartPlaylistEditor::UpdateButtons()
   else
     SET_CONTROL_LABEL2(CONTROL_MATCH, g_localizeStrings.Get(21425));
   CONTROL_ENABLE_ON_CONDITION(CONTROL_MATCH, m_playlist.m_ruleCombination.m_rules.size() > 1);
-
+  if (m_playlist.m_limit == 0)
+    SET_CONTROL_LABEL2(CONTROL_LIMIT, g_localizeStrings.Get(21428));
+  else
+    SET_CONTROL_LABEL2(CONTROL_LIMIT, StringUtils::Format(g_localizeStrings.Get(21436).c_str(), m_playlist.m_limit));
   int currentItem = GetSelectedItem();
   CGUIMessage msgReset(GUI_MSG_LABEL_RESET, GetID(), CONTROL_RULE_LIST);
   OnMessage(msgReset);
@@ -451,22 +470,12 @@ void CGUIDialogSmartPlaylistEditor::OnWindowLoaded()
   CGUIDialog::OnWindowLoaded();
 
   SendMessage(GUI_MSG_SET_TYPE, CONTROL_NAME, 0, 16012);
-
-  // set up the limit spinner
-  std::vector< std::pair<std::string, int> > labels;
-  labels.push_back(make_pair(g_localizeStrings.Get(21428), 0));
-  const int limits[] = { 10, 25, 50, 100, 250, 500, 1000 };
-  for (unsigned int i = 0; i < sizeof(limits) / sizeof(int); i++)
-    labels.push_back(make_pair(StringUtils::Format(g_localizeStrings.Get(21436).c_str(), limits[i]), limits[i]));
-  SET_CONTROL_LABELS(CONTROL_LIMIT, 0, &labels);
 }
 
 void CGUIDialogSmartPlaylistEditor::OnInitWindow()
 {
   m_cancelled = false;
 
-  SendMessage(GUI_MSG_ITEM_SELECT, CONTROL_LIMIT, m_playlist.m_limit);
-
   std::vector<PLAYLIST_TYPE> allowedTypes = GetAllowedTypes(m_mode);
   // check if our playlist type is allowed
   PLAYLIST_TYPE type = ConvertType(m_playlist.GetType());
-- 
2.7.4


From 7f196f535d3497964a9b9ec30421f3ed2a72d0d2 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 06:26:31 +0200
Subject: [PATCH 015/175] smartplaylisteditor: change edit control to "button"

---
 addons/skin.estuary/1080i/SmartPlaylistEditor.xml |  9 ++-------
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp     | 19 +++++++++++--------
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.h       |  2 +-
 3 files changed, 14 insertions(+), 16 deletions(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
index 1e1a5cc..288d33a 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
@@ -29,14 +29,9 @@
 					<include>SettingsItemCommon</include>
 					<label>$LOCALIZE[467]</label>
 				</control>
-				<control type="label" id="1100">
-					<description>Name Label</description>
-					<width>660</width>
-					<label>$LOCALIZE[21433]</label>
-					<include>SettingsLabelCommon</include>
-				</control>
-				<control type="edit" id="12">
+				<control type="button" id="12">
 					<description>Name Button</description>
+					<label>$LOCALIZE[21433]</label>
 					<width>660</width>
 					<include>SettingsItemCommon</include>
 				</control>
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
index 8ccf179..5f0f75f 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
@@ -111,7 +111,7 @@ bool CGUIDialogSmartPlaylistEditor::OnMessage(CGUIMessage& message)
       else if (iControl == CONTROL_RULE_REMOVE)
         OnRuleRemove(GetSelectedItem());
       else if (iControl == CONTROL_NAME)
-        OnEditChanged(iControl, m_playlist.m_playlistName);
+        OnName();
       else if (iControl == CONTROL_OK)
         OnOK();
       else if (iControl == CONTROL_CANCEL)
@@ -280,6 +280,16 @@ void CGUIDialogSmartPlaylistEditor::OnMatch()
   UpdateButtons();
 }
 
+void CGUIDialogSmartPlaylistEditor::OnName()
+{
+  std::string name = m_playlist.m_playlistName;
+  if (CGUIKeyboardFactory::ShowAndGetInput(name, CVariant{g_localizeStrings.Get(16012)}, false))
+  {
+    m_playlist.m_playlistName = name;
+    UpdateButtons();
+  }
+}
+
 void CGUIDialogSmartPlaylistEditor::OnLimit()
 {
   const int limits[] = {0, 10, 25, 50, 100, 250, 500, 1000, -1 };
@@ -465,13 +475,6 @@ void CGUIDialogSmartPlaylistEditor::UpdateRuleControlButtons()
                               m_playlist.m_ruleCombination.m_rules[iItem]->m_field != FieldNone); // and it is not be empty
 }
 
-void CGUIDialogSmartPlaylistEditor::OnWindowLoaded()
-{
-  CGUIDialog::OnWindowLoaded();
-
-  SendMessage(GUI_MSG_SET_TYPE, CONTROL_NAME, 0, 16012);
-}
-
 void CGUIDialogSmartPlaylistEditor::OnInitWindow()
 {
   m_cancelled = false;
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h
index 4a55797..7aa19d5 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h
@@ -35,7 +35,6 @@ public:
   virtual ~CGUIDialogSmartPlaylistEditor(void);
   virtual bool OnMessage(CGUIMessage& message);
   virtual bool OnBack(int actionID);
-  virtual void OnWindowLoaded();
   virtual void OnInitWindow();
   virtual void OnDeinitWindow(int nextWindowID);
 
@@ -48,6 +47,7 @@ protected:
   void OnRuleRemove(int item);
   void OnMatch();
   void OnLimit();
+  void OnName();
   void OnType();
   void OnOrder();
   void OnOrderDirection();
-- 
2.7.4


From 99991a244498d7547993d986fef0de0c31e6b953 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 05:51:40 +0200
Subject: [PATCH 016/175] - adjust smartplaylisteditor layout

---
 addons/skin.estuary/1080i/SmartPlaylistEditor.xml | 87 +++++++++++------------
 1 file changed, 42 insertions(+), 45 deletions(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
index 288d33a..678b419 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
@@ -2,15 +2,15 @@
 <window>
 	<defaultcontrol always="true">22</defaultcontrol>
 	<coordinates>
-		<left>310</left>
-		<top>80</top>
+		<left>110</left>
+		<top>150</top>
 	</coordinates>
 	<include>Animation_DialogPopupOpenClose</include>
 	<controls>
 		<control type="group">
 			<include content="DialogBackgroundCommons">
-				<param name="DialogBackgroundWidth" value="1300" />
-				<param name="DialogBackgroundHeight" value="920" />
+				<param name="DialogBackgroundWidth" value="1700" />
+				<param name="DialogBackgroundHeight" value="790" />
 				<param name="DialogHeaderLabel" value="" />
 				<param name="DialogHeaderId" value="2" />
 			</include>
@@ -19,108 +19,105 @@
 				<left>10</left>
 				<top>95</top>
 				<onright>10</onright>
-				<onleft>10</onleft>
-				<ondown>9001</ondown>
-				<onup>9001</onup>
+				<onleft>9001</onleft>
 				<itemgap>-20</itemgap>
 				<control type="button" id="22">
 					<description>Set Playlist type</description>
-					<width>660</width>
+					<width>700</width>
 					<include>SettingsItemCommon</include>
 					<label>$LOCALIZE[467]</label>
 				</control>
 				<control type="button" id="12">
 					<description>Name Button</description>
 					<label>$LOCALIZE[21433]</label>
-					<width>660</width>
+					<width>700</width>
 					<include>SettingsItemCommon</include>
 				</control>
 				<control type="label" id="1101">
 					<description>Name Label</description>
-					<width>660</width>
+					<width>700</width>
 					<label>$LOCALIZE[31042]</label>
 					<include>SettingsLabelCommon</include>
 				</control>
 				<control type="button" id="16">
-					<width>660</width>
+					<width>700</width>
 					<label>$LOCALIZE[21424]</label>
 					<include>SettingsItemCommon</include>
 				</control>
 				<control type="button" id="17">
-					<width>660</width>
+					<width>700</width>
 					<label>$LOCALIZE[21427]</label>
 					<include>SettingsItemCommon</include>
 				</control>
 				<control type="button" id="18">
 					<label>$LOCALIZE[21429]</label>
-					<width>660</width>
+					<width>700</width>
 					<include>SettingsItemCommon</include>
 				</control>
 				<control type="button" id="19">
-					<width>660</width>
+					<width>700</width>
 					<include>SettingsItemCommon</include>
 					<label>$LOCALIZE[31032]</label>
 				</control>
 				<control type="button" id="23">
-					<width>660</width>
+					<width>700</width>
 					<label>$LOCALIZE[21458]</label>
 					<include>SettingsItemCommon</include>
 				</control>
 				<control type="radiobutton" id="24">
-					<width>660</width>
+					<width>700</width>
 					<include>SettingsItemCommon</include>
 					<label>$LOCALIZE[467]: $LOCALIZE[21459]</label>
 				</control>
 			</control>
-			<control type="grouplist" id="9001">
-				<orientation>horizontal</orientation>
-				<left>0</left>
-				<width>1300</width>
-				<align>center</align>
-				<top>820</top>
-				<onup>24</onup>
-				<ondown>22</ondown>
-				<include content="DefaultDialogButton">
-					<param name="id" value="20" />
-					<param name="label" value="$LOCALIZE[186]" />
-				</include>
-				<include content="DefaultDialogButton">
-					<param name="id" value="21" />
-					<param name="label" value="$LOCALIZE[222]" />
-				</include>
-			</control>
 			<control type="image">
-				<left>650</left>
+				<left>720</left>
 				<top>95</top>
 				<width>640</width>
-				<height>485</height>
+				<height>530</height>
 				<texture border="40">buttons/dialogbutton-nofo.png</texture>
 			</control>
-			<control type="list" id="10">
+			<control type="panel" id="10">
 				<description>Rules List Control</description>
-				<left>670</left>
+				<left>740</left>
 				<top>115</top>
 				<width>600</width>
-				<height>435</height>
+				<height>480</height>
 				<onleft>500</onleft>
-				<onright>500</onright>
-				<ondown>9001</ondown>
-				<onup>9001</onup>
+				<onright>9001</onright>
+				<orientation>horizontal</orientation>
 				<include content="DefaultSimpleListLayout">
 					<param name="width" value="600" />
 					<param name="list_id" value="10" />
 				</include>
 			</control>
 			<control type="textbox">
-				<left>680</left>
-				<top>570</top>
-				<width>540</width>
-				<height>248</height>
+				<left>740</left>
+				<top>620</top>
+				<width>610</width>
+				<height>348</height>
 				<aligny>top</aligny>
 				<label>$LOCALIZE[31043]</label>
 				<textcolor>grey</textcolor>
 				<font>font12</font>
 			</control>
+			<control type="grouplist" id="9001">
+				<orientation>vertical</orientation>
+				<left>1380</left>
+				<width>1300</width>
+				<align>left</align>
+				<top>100</top>
+				<onleft>10</onleft>
+				<onright>500</onright>
+				<include content="DefaultDialogButton">
+					<param name="id" value="20" />
+					<param name="label" value="$LOCALIZE[186]" />
+				</include>
+				<include content="DefaultDialogButton">
+					<param name="id" value="21" />
+					<param name="label" value="$LOCALIZE[222]" />
+				</include>
+			</control>
 		</control>
 	</controls>
 </window>
-- 
2.7.4


From 9e1faae4a47eb115e979eb9b7959ca3c34792be5 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 30 Sep 2016 08:13:16 +0200
Subject: [PATCH 017/175] smartplaylisteditor: change operator button type to
 "button"

---
 .../resource.language.en_gb/resources/strings.po   |  5 +-
 addons/skin.estuary/1080i/SmartPlaylistRule.xml    |  2 +-
 xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp        | 53 +++++++++++-----------
 3 files changed, 32 insertions(+), 28 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 80f8d89..b34a458 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -8453,7 +8453,10 @@ msgctxt "#16022"
 msgid "Bob - Inverted"
 msgstr ""
 
-#empty string with id 16023
+#: xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
+msgctxt "#16023"
+msgid "Choose operator"
+msgstr ""
 
 #: xbmc/dialogs/GUIDialogProgress.cpp
 msgctxt "#16024"
diff --git a/addons/skin.estuary/1080i/SmartPlaylistRule.xml b/addons/skin.estuary/1080i/SmartPlaylistRule.xml
index ac01302..44afebe 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistRule.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistRule.xml
@@ -32,7 +32,7 @@
 				<include>SettingsItemCommon</include>
 				<width>900</width>
 			</control>
-			<control type="spincontrolex" id="16">
+			<control type="button" id="16">
 				<description>Rule operator</description>
 				<width>900</width>
 				<include>SettingsItemCommon</include>
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
index d8bb940..3e34c99 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
@@ -403,33 +403,13 @@ void CGUIDialogSmartPlaylistRule::OnField()
   UpdateButtons();
 }
 
-void CGUIDialogSmartPlaylistRule::OnOperator()
-{
-  CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_OPERATOR);
-  OnMessage(msg);
-  m_rule.m_operator = (CDatabaseQueryRule::SEARCH_OPERATOR)msg.GetParam1();
-
-  UpdateButtons();
-}
-
 std::pair<std::string, int> OperatorLabel(CDatabaseQueryRule::SEARCH_OPERATOR op)
 {
   return std::make_pair(CSmartPlaylistRule::GetLocalizedOperator(op), op);
 }
 
-void CGUIDialogSmartPlaylistRule::UpdateButtons()
+void CGUIDialogSmartPlaylistRule::OnOperator()
 {
-  if (m_rule.m_field == 0)
-    m_rule.m_field = CSmartPlaylistRule::GetFields(m_type)[0];
-  SET_CONTROL_LABEL2(CONTROL_FIELD, CSmartPlaylistRule::GetLocalizedField(m_rule.m_field));
-  // and now update the operator set
-  SendMessage(GUI_MSG_LABEL_RESET, CONTROL_OPERATOR);
-
-  CONTROL_ENABLE(CONTROL_VALUE);
-  if (CSmartPlaylistRule::IsFieldBrowseable(m_rule.m_field))
-    CONTROL_ENABLE(CONTROL_BROWSE);
-  else
-    CONTROL_DISABLE(CONTROL_BROWSE);
 
   std::vector< std::pair<std::string, int> > labels;
   switch (m_rule.GetFieldType(m_rule.m_field))
@@ -479,13 +459,34 @@ void CGUIDialogSmartPlaylistRule::UpdateButtons()
     labels.push_back(OperatorLabel(CDatabaseQueryRule::OPERATOR_DOES_NOT_EQUAL));
     break;
   }
+  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  dialog->Reset();
+  dialog->SetHeading(CVariant{ 16023 });
+  for (auto label : labels)
+    dialog->Add(std::get<0>(label));
+  dialog->SetSelected(CSmartPlaylistRule::GetLocalizedOperator(m_rule.m_operator));
+  dialog->Open();
+  int newSelected = dialog->GetSelectedItem();
+  // check if selection has changed
+  if (!dialog->IsConfirmed() || newSelected < 0)
+    return;
+ 
+  m_rule.m_operator = (CDatabaseQueryRule::SEARCH_OPERATOR)std::get<1>(labels[newSelected]);
+  UpdateButtons();
+}
 
-  SET_CONTROL_LABELS(CONTROL_OPERATOR, m_rule.m_operator, &labels);
+void CGUIDialogSmartPlaylistRule::UpdateButtons()
+{
+  if (m_rule.m_field == 0)
+    m_rule.m_field = CSmartPlaylistRule::GetFields(m_type)[0];
+  SET_CONTROL_LABEL2(CONTROL_FIELD, CSmartPlaylistRule::GetLocalizedField(m_rule.m_field));
 
-  // check our operator is valid, and update if not
-  CGUIMessage selected(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_OPERATOR);
-  OnMessage(selected);
-  m_rule.m_operator = (CDatabaseQueryRule::SEARCH_OPERATOR)selected.GetParam1();
+  CONTROL_ENABLE(CONTROL_VALUE);
+  if (CSmartPlaylistRule::IsFieldBrowseable(m_rule.m_field))
+    CONTROL_ENABLE(CONTROL_BROWSE);
+  else
+    CONTROL_DISABLE(CONTROL_BROWSE);
+  SET_CONTROL_LABEL2(CONTROL_OPERATOR, std::get<0>(OperatorLabel(m_rule.m_operator)));
 
   // update the parameter edit control appropriately
   SET_CONTROL_LABEL2(CONTROL_VALUE, m_rule.GetParameter());
-- 
2.7.4


From cda1f63a35bc2a8ac194f02f85f7e6b8d70fbac9 Mon Sep 17 00:00:00 2001
From: Martijn Kaijser <mcm.kaijser@gmail.com>
Date: Sat, 1 Oct 2016 11:59:00 +0200
Subject: [PATCH 018/175] bump to 17.0 beta 4

---
 configure.ac | 2 +-
 version.txt  | 6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/configure.ac b/configure.ac
index d11bd5c..20ec1a9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2,7 +2,7 @@
 # Process this file with autoconf to produce a configure script.
 
 AC_PREREQ(2.59)
-AC_INIT([kodi], [16.9.803], [http://trac.kodi.tv])
+AC_INIT([kodi], [16.9.804], [http://trac.kodi.tv])
 AC_CONFIG_HEADERS([xbmc/config.h])
 AH_TOP([#pragma once])
 m4_include([m4/ax_prog_cc_for_build.m4])
diff --git a/version.txt b/version.txt
index cab03c4..c59cd8e 100644
--- a/version.txt
+++ b/version.txt
@@ -3,9 +3,9 @@ COMPANY_NAME XBMC-Foundation
 WEBSITE http://kodi.tv
 VERSION_MAJOR 17
 VERSION_MINOR 0
-VERSION_TAG BETA3
-VERSION_CODE 169803
-ADDON_API 16.9.803
+VERSION_TAG BETA4
+VERSION_CODE 169804
+ADDON_API 16.9.804
 
 # Notes:
 # Change AC_INIT in configure.ac
-- 
2.7.4


From 914c8d96febca8fa7e5d587d35fcb9c2adac4e82 Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Mon, 3 Oct 2016 12:25:37 +0100
Subject: [PATCH 019/175] Add compilation as an "albums" smart playlist rule.

---
 addons/resource.language.en_gb/resources/strings.po | 5 ++++-
 xbmc/dbwrappers/DatabaseQuery.cpp                   | 2 +-
 xbmc/playlists/SmartPlayList.cpp                    | 7 +++++++
 xbmc/utils/DatabaseUtils.cpp                        | 1 +
 xbmc/utils/DatabaseUtils.h                          | 1 +
 5 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index b34a458..22572e2 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -900,7 +900,10 @@ msgctxt "#203"
 msgid "Plot outline"
 msgstr ""
 
-#empty string with id 204
+#: xbmc/playlists/SmartPlaylist.cpp
+msgctxt "#204"
+msgid "Compilation"
+msgstr ""
 
 #: xbmc/playlists/SmartPlaylist.cpp
 msgctxt "#205"
diff --git a/xbmc/dbwrappers/DatabaseQuery.cpp b/xbmc/dbwrappers/DatabaseQuery.cpp
index 5ce76b6..b6c96fe 100644
--- a/xbmc/dbwrappers/DatabaseQuery.cpp
+++ b/xbmc/dbwrappers/DatabaseQuery.cpp
@@ -342,7 +342,7 @@ std::string CDatabaseQueryRule::GetWhereClause(const CDatabase &db, const std::s
   if (op == OPERATOR_DOES_NOT_CONTAIN || op == OPERATOR_FALSE ||
      (op == OPERATOR_DOES_NOT_EQUAL && GetFieldType(m_field) != REAL_FIELD && GetFieldType(m_field) != NUMERIC_FIELD &&
       GetFieldType(m_field) != SECONDS_FIELD))
-    negate = " NOT";
+    negate = " NOT ";
 
   // boolean operators don't have any values in m_parameter, they work on the operator
   if (m_operator == OPERATOR_FALSE || m_operator == OPERATOR_TRUE)
diff --git a/xbmc/playlists/SmartPlayList.cpp b/xbmc/playlists/SmartPlayList.cpp
index cde7347..0cfb158 100644
--- a/xbmc/playlists/SmartPlayList.cpp
+++ b/xbmc/playlists/SmartPlayList.cpp
@@ -68,6 +68,7 @@ static const translateField fields[] = {
   { "moods",             FieldMoods,                   CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 false, 175 },
   { "styles",            FieldStyles,                  CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 false, 176 },
   { "type",              FieldAlbumType,               CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 false, 564 },
+  { "compilation",       FieldCompilation,             CDatabaseQueryRule::BOOLEAN_FIELD,  NULL,                                 false, 204 },
   { "label",             FieldMusicLabel,              CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 false, 21899 },
   { "title",             FieldTitle,                   CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 true,  556 },
   { "sorttitle",         FieldSortTitle,               CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 false, 171 },
@@ -326,6 +327,7 @@ std::vector<Field> CSmartPlaylistRule::GetFields(const std::string &type)
     fields.push_back(FieldThemes);
     fields.push_back(FieldMoods);
     fields.push_back(FieldStyles);
+    fields.push_back(FieldCompilation);
     fields.push_back(FieldAlbumType);
     fields.push_back(FieldMusicLabel);
     fields.push_back(FieldRating);
@@ -728,6 +730,11 @@ std::string CSmartPlaylistRule::GetBooleanQuery(const std::string &negate, const
                           ")"
                        ")";
   }
+  if (strType == "albums")
+  {
+    if (m_field == FieldCompilation)
+      return negate + GetField(m_field, strType);
+  }
   return "";
 }
 
diff --git a/xbmc/utils/DatabaseUtils.cpp b/xbmc/utils/DatabaseUtils.cpp
index a766ba6..f5960d5 100644
--- a/xbmc/utils/DatabaseUtils.cpp
+++ b/xbmc/utils/DatabaseUtils.cpp
@@ -73,6 +73,7 @@ std::string DatabaseUtils::GetField(Field field, const MediaType &mediaType, Dat
     else if (field == FieldReview) return "albumview.strReview";
     else if (field == FieldMusicLabel) return "albumview.strLabel";
     else if (field == FieldAlbumType) return "albumview.strType";
+    else if (field == FieldCompilation) return "albumview.bCompilation";
     else if (field == FieldRating) return "albumview.fRating";
     else if (field == FieldVotes) return "albumview.iVotes";
     else if (field == FieldUserRating) return "albumview.iUserrating";
diff --git a/xbmc/utils/DatabaseUtils.h b/xbmc/utils/DatabaseUtils.h
index 5d428ad..5fa99d2 100644
--- a/xbmc/utils/DatabaseUtils.h
+++ b/xbmc/utils/DatabaseUtils.h
@@ -114,6 +114,7 @@ typedef enum {
   FieldStyles,
   FieldAlbumType,
   FieldMusicLabel,
+  FieldCompilation,
   FieldTrailer,
   FieldVideoResolution,
   FieldVideoAspectRatio,
-- 
2.7.4


From 556ceac1a4a61608d87af9e67a51f2802f57ebe9 Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Tue, 4 Oct 2016 16:11:25 +0100
Subject: [PATCH 020/175] Add LastPlayed as album smart playlist rule. Fix
 missing sort orders

---
 xbmc/music/GUIViewStateMusic.cpp | 15 +++++++++++++++
 xbmc/playlists/SmartPlayList.cpp |  4 ++++
 xbmc/utils/DatabaseUtils.cpp     |  2 ++
 3 files changed, 21 insertions(+)

diff --git a/xbmc/music/GUIViewStateMusic.cpp b/xbmc/music/GUIViewStateMusic.cpp
index bf6fd4c..72202b7 100644
--- a/xbmc/music/GUIViewStateMusic.cpp
+++ b/xbmc/music/GUIViewStateMusic.cpp
@@ -180,6 +180,8 @@ CGUIViewStateMusicDatabase::CGUIViewStateMusicDatabase(const CFileItemList& item
       AddSortMethod(SortByDateAdded, sortAttribute, 570, LABEL_MASKS("%F", "", strAlbum, "%a"));  // Filename, empty | Userdefined, dateAdded
       // play count
       AddSortMethod(SortByPlaycount, 567, LABEL_MASKS("%F", "", strAlbum, "%V"));  // Filename, empty | Userdefined, Play count
+      // last played
+      AddSortMethod(SortByLastPlayed, 568, LABEL_MASKS("%F", "", strAlbum, "%p"));  // Filename, empty | Userdefined, last played
       // rating
       AddSortMethod(SortByRating, 563, LABEL_MASKS("%F", "", strAlbum, "%R"));  // Filename, empty | Userdefined, Rating
       // userrating
@@ -345,6 +347,9 @@ CGUIViewStateMusicSmartPlaylist::CGUIViewStateMusicSmartPlaylist(const CFileItem
     AddSortMethod(SortByTime, 180, LABEL_MASKS("%T - %A", "%D"));  // Titel, Artist, Duration| empty, empty
     AddSortMethod(SortByRating, 563, LABEL_MASKS("%T - %A", "%R"));  // Titel, Artist, Rating| empty, empty
     AddSortMethod(SortByUserRating, 38018, LABEL_MASKS("%T - %A", "%r"));  // Title - Artist, UserRating
+    AddSortMethod(SortByYear, 562, LABEL_MASKS("%T - %A", "%Y")); // Title, Artist, Year
+    AddSortMethod(SortByDateAdded, 570, LABEL_MASKS("%T - %A", "%a"));  // Title - Artist, DateAdded | empty, empty
+    AddSortMethod(SortByPlaycount, 567, LABEL_MASKS("%T - %A", "%V"));  // Titel - Artist, PlayCount
 
     if (items.IsSmartPlayList() || items.IsLibraryFolder())
       AddPlaylistOrder(items, LABEL_MASKS(strTrack, "%D"));
@@ -369,6 +374,16 @@ CGUIViewStateMusicSmartPlaylist::CGUIViewStateMusicSmartPlaylist(const CFileItem
     AddSortMethod(SortByArtistThenYear, sortAttribute, 578, LABEL_MASKS("%F", "", strAlbum, "%A / %Y"));  // Filename, empty | Userdefined, Artist / Year
     // year
     AddSortMethod(SortByYear, 562, LABEL_MASKS("%F", "", strAlbum, "%Y"));
+    // album date added
+    AddSortMethod(SortByDateAdded, sortAttribute, 570, LABEL_MASKS("%F", "", strAlbum, "%a"));  // Filename, empty | Userdefined, dateAdded
+    // play count
+    AddSortMethod(SortByPlaycount, 567, LABEL_MASKS("%F", "", strAlbum, "%V"));  // Filename, empty | Userdefined, Play count
+    // last played
+    AddSortMethod(SortByLastPlayed, 568, LABEL_MASKS("%F", "", strAlbum, "%p"));  // Filename, empty | Userdefined, last played
+    // rating
+    AddSortMethod(SortByRating, 563, LABEL_MASKS("%F", "", strAlbum, "%R"));  // Filename, empty | Userdefined, Rating
+    // userrating
+    AddSortMethod(SortByUserRating, 38018, LABEL_MASKS("%F", "", strAlbum, "%r"));  // Filename, empty | Userdefined, UserRating
 
     if (items.IsSmartPlayList() || items.IsLibraryFolder())
       AddPlaylistOrder(items, LABEL_MASKS("%F", "", strAlbum, "%D"));
diff --git a/xbmc/playlists/SmartPlayList.cpp b/xbmc/playlists/SmartPlayList.cpp
index 0cfb158..0ac73d9 100644
--- a/xbmc/playlists/SmartPlayList.cpp
+++ b/xbmc/playlists/SmartPlayList.cpp
@@ -333,6 +333,7 @@ std::vector<Field> CSmartPlaylistRule::GetFields(const std::string &type)
     fields.push_back(FieldRating);
     fields.push_back(FieldUserRating);
     fields.push_back(FieldPlaycount);
+    fields.push_back(FieldLastPlayed);
     fields.push_back(FieldPath);
   }
   else if (type == "artists")
@@ -518,6 +519,7 @@ std::vector<SortBy> CSmartPlaylistRule::GetOrders(const std::string &type)
     orders.push_back(SortByRating);
     orders.push_back(SortByUserRating);
     orders.push_back(SortByPlaycount);
+    orders.push_back(SortByLastPlayed);
   }
   else if (type == "artists")
   {
@@ -804,6 +806,8 @@ std::string CSmartPlaylistRule::FormatWhereClause(const std::string &negate, con
       query = negate + " EXISTS (SELECT 1 FROM album_artist, artist WHERE album_artist.idAlbum = " + GetField(FieldId, strType) + " AND album_artist.idArtist = artist.idArtist AND artist.strArtist" + parameter + ")";
     else if (m_field == FieldPath)
       query = negate + " EXISTS (SELECT 1 FROM song JOIN path on song.idpath = path.idpath WHERE song.idAlbum = " + GetField(FieldId, strType) + " AND path.strPath" + parameter + ")";
+    else if (m_field == FieldLastPlayed && (m_operator == OPERATOR_LESS_THAN || m_operator == OPERATOR_BEFORE || m_operator == OPERATOR_NOT_IN_THE_LAST))
+      query = GetField(m_field, strType) + " is NULL or " + GetField(m_field, strType) + parameter;
   }
   else if (strType == "artists")
   {
diff --git a/xbmc/utils/DatabaseUtils.cpp b/xbmc/utils/DatabaseUtils.cpp
index f5960d5..0acd220 100644
--- a/xbmc/utils/DatabaseUtils.cpp
+++ b/xbmc/utils/DatabaseUtils.cpp
@@ -79,6 +79,7 @@ std::string DatabaseUtils::GetField(Field field, const MediaType &mediaType, Dat
     else if (field == FieldUserRating) return "albumview.iUserrating";
     else if (field == FieldDateAdded) return "albumview.dateAdded";
     else if (field == FieldPlaycount) return "albumview.iTimesPlayed";
+    else if (field == FieldLastPlayed) return "albumview.lastPlayed";
   }
   else if (mediaType == MediaTypeSong)
   {
@@ -494,6 +495,7 @@ int DatabaseUtils::GetField(Field field, const MediaType &mediaType, bool asInde
     else if (field == FieldVotes) return CMusicDatabase::album_iVotes;
     else if (field == FieldUserRating) return CMusicDatabase::album_iUserrating;
     else if (field == FieldPlaycount) return CMusicDatabase::album_iTimesPlayed;
+    else if (field == FieldLastPlayed) return CMusicDatabase::album_dtLastPlayed;
     else if (field == FieldDateAdded) return CMusicDatabase::album_dtDateAdded;
   }
   else if (mediaType == MediaTypeSong)
-- 
2.7.4


From 88c57e233bd2e30334ec83cdf2022d5ad9ebcc5c Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Tue, 4 Oct 2016 17:57:59 +0100
Subject: [PATCH 021/175] Add compilation as a filter on the albums node

---
 xbmc/dialogs/GUIDialogMediaFilter.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/dialogs/GUIDialogMediaFilter.cpp b/xbmc/dialogs/GUIDialogMediaFilter.cpp
index 6b39b3d..df806e5 100644
--- a/xbmc/dialogs/GUIDialogMediaFilter.cpp
+++ b/xbmc/dialogs/GUIDialogMediaFilter.cpp
@@ -108,6 +108,7 @@ static const CGUIDialogMediaFilter::Filter filterList[] = {
   { "albums",       FieldYear,          562,    SettingTypeInteger, "range",  "integer",  CDatabaseQueryRule::OPERATOR_BETWEEN },
   { "albums",       FieldGenre,         515,    SettingTypeList,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
   { "albums",       FieldMusicLabel,    21899,  SettingTypeList,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
+  { "albums",       FieldCompilation,   204,    SettingTypeBool,    "toggle", "",         CDatabaseQueryRule::OPERATOR_FALSE },
 
   { "songs",        FieldTitle,         556,    SettingTypeString,  "edit",   "string",   CDatabaseQueryRule::OPERATOR_CONTAINS },
   { "songs",        FieldAlbum,         558,    SettingTypeList,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
-- 
2.7.4


From e67c43cc78057515befb065b2ab17d0d9919727f Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Tue, 4 Oct 2016 20:53:11 +0200
Subject: [PATCH 022/175] CAnnouncementManager: fix invalid type "movies" for
 video items without video info tag

---
 xbmc/interfaces/AnnouncementManager.cpp     | 2 +-
 xbmc/interfaces/json-rpc/schema/version.txt | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/interfaces/AnnouncementManager.cpp b/xbmc/interfaces/AnnouncementManager.cpp
index 9508cac..9184e8b 100644
--- a/xbmc/interfaces/AnnouncementManager.cpp
+++ b/xbmc/interfaces/AnnouncementManager.cpp
@@ -265,7 +265,7 @@ void CAnnouncementManager::DoAnnounce(AnnouncementFlag flag, const char *sender,
   else if (item->IsVideo())
   {
     // video item but has no video info tag.
-    type = "movies";
+    type = "movie";
     object["item"]["title"] = item->GetLabel();
   }
   else if (item->HasPictureInfoTag())
diff --git a/xbmc/interfaces/json-rpc/schema/version.txt b/xbmc/interfaces/json-rpc/schema/version.txt
index f247b9f..7ffe909 100644
--- a/xbmc/interfaces/json-rpc/schema/version.txt
+++ b/xbmc/interfaces/json-rpc/schema/version.txt
@@ -1 +1 @@
-7.22.0
\ No newline at end of file
+7.22.1
\ No newline at end of file
-- 
2.7.4


From 473e8a27e6d9d0cb9db87df72f78dd22f0fad14f Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Tue, 4 Oct 2016 21:27:46 +0200
Subject: [PATCH 023/175] add support to show function with version change text

It add the doxygen ALIASES python_func_with_rev and python_class_with_rev,
with can be a second text added who is shown on right of the html.
---
 .codedocs                                       | 2 ++
 doxygen_resources/Doxyfile.doxy                 | 2 ++
 xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile | 2 ++
 3 files changed, 6 insertions(+)

diff --git a/.codedocs b/.codedocs
index 0314707..14a6f44 100644
--- a/.codedocs
+++ b/.codedocs
@@ -9,7 +9,9 @@ ALIASES                = "table_start=<table width= 100% style= border bgcolor=
                          "table_h3{3}=<tr bgcolor= 576f9f><th width= 30% align=left>\1</th><th width= 10% align=left>\2</th><th width= 60% align=left>\3</th></tr>" \
                          "table_row3{3}=<tr bgcolor=white><td width= 30% align=left>\1</td><td width= 10% align=left>\2</td><td width= 60% align=left>\3</td></tr>" \
                          "python_func{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
+                         "python_func_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
                          "python_class{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
+                         "python_class_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
                          "doc_header{1}=\htmlonly <h3><span style=\"text-decoration: underline;\"><span  style=\"font-style: italic;\"><span style=\"color: rgb(102, 102, 102);\">\1</span></span></span></h3> \endhtmlonly"
 
 # Hide undocumented class members.
diff --git a/doxygen_resources/Doxyfile.doxy b/doxygen_resources/Doxyfile.doxy
index 3cafe81..5a2b7ef 100644
--- a/doxygen_resources/Doxyfile.doxy
+++ b/doxygen_resources/Doxyfile.doxy
@@ -245,7 +245,9 @@ ALIASES                = "table_start=<table width= 100% style= border bgcolor=
                          "table_h3{3}=<tr bgcolor= 576f9f><th width= 30% align=left>\1</th><th width= 10% align=left>\2</th><th width= 60% align=left>\3</th></tr>" \
                          "table_row3{3}=<tr bgcolor=white><td width= 30% align=left>\1</td><td width= 10% align=left>\2</td><td width= 60% align=left>\3</td></tr>" \
                          "python_func{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
+                         "python_func_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
                          "python_class{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
+                         "python_class_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
                          "doc_header{1}=\htmlonly <h3><span style=\"text-decoration: underline;\"><span  style=\"font-style: italic;\"><span style=\"color: rgb(102, 102, 102);\">\1</span></span></span></h3> \endhtmlonly"
 
 # This tag can be used to specify a number of word-keyword mappings (TCL only).
diff --git a/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile b/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile
index 04ddd28..ae71b16 100644
--- a/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile
+++ b/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile
@@ -245,7 +245,9 @@ ALIASES                = "table_start=<table width= 100% style= border bgcolor=
                          "table_h3{3}=<tr bgcolor= 576f9f><th width= 30% align=left>\1</th><th width= 10% align=left>\2</th><th width= 60% align=left>\3</th></tr>" \
                          "table_row3{3}=<tr bgcolor=white><td width= 30% align=left>\1</td><td width= 10% align=left>\2</td><td width= 60% align=left>\3</td></tr>" \
                          "python_func{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
+                         "python_func_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
                          "python_class{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
+                         "python_class_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
                          "doc_header{1}=\htmlonly <h3><span style=\"text-decoration: underline;\"><span  style=\"font-style: italic;\"><span style=\"color: rgb(102, 102, 102);\">\1</span></span></span></h3> \endhtmlonly"
 
 # This tag can be used to specify a number of word-keyword mappings (TCL only).
-- 
2.7.4


From 94100213eb6059bf1b8efa98c8fc1f6899bab7bd Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Mon, 3 Oct 2016 21:05:01 +0200
Subject: [PATCH 024/175] add ctor with event log entry.

---
 xbmc/FileItem.cpp                   | 14 ++++++++++++++
 xbmc/FileItem.h                     |  6 ++++++
 xbmc/filesystem/EventsDirectory.cpp |  7 ++-----
 3 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index 9505ec1..f06f7ad 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -59,6 +59,7 @@
 #include "utils/Variant.h"
 #include "utils/Mime.h"
 #include "utils/Random.h"
+#include "events/IEvent.h"
 
 #include <assert.h>
 #include <algorithm>
@@ -321,6 +322,17 @@ CFileItem::CFileItem(std::shared_ptr<const ADDON::IAddon> addonInfo) : m_addonIn
   Initialize();
 }
 
+CFileItem::CFileItem(const EventPtr& eventLogEntry)
+{
+  Initialize();
+
+  m_eventLogEntry = eventLogEntry;
+  SetLabel(eventLogEntry->GetLabel());
+  m_dateTime = eventLogEntry->GetDateTime();
+  if (!eventLogEntry->GetIcon().empty())
+    SetIconImage(eventLogEntry->GetIcon());
+}
+
 CFileItem::~CFileItem(void)
 {
   delete m_musicInfoTag;
@@ -392,6 +404,7 @@ const CFileItem& CFileItem::operator=(const CFileItem& item)
   m_pvrTimerInfoTag = item.m_pvrTimerInfoTag;
   m_pvrRadioRDSInfoTag = item.m_pvrRadioRDSInfoTag;
   m_addonInfo = item.m_addonInfo;
+  m_eventLogEntry = item.m_eventLogEntry;
 
   m_lStartOffset = item.m_lStartOffset;
   m_lStartPartNumber = item.m_lStartPartNumber;
@@ -466,6 +479,7 @@ void CFileItem::Reset()
   m_pictureInfoTag=NULL;
   m_extrainfo.clear();
   ClearProperties();
+  m_eventLogEntry.reset();
 
   Initialize();
   SetInvalid();
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index 1630072..7def932 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -73,6 +73,9 @@ class CFileItemList;
 class CCueDocument;
 typedef std::shared_ptr<CCueDocument> CCueDocumentPtr;
 
+class IEvent;
+typedef std::shared_ptr<const IEvent> EventPtr;
+
 /* special startoffset used to indicate that we wish to resume */
 #define STARTOFFSET_RESUME (-1)
 
@@ -120,6 +123,8 @@ public:
   CFileItem(const PVR::CPVRTimerInfoTagPtr& timer);
   CFileItem(const CMediaSource& share);
   CFileItem(std::shared_ptr<const ADDON::IAddon> addonInfo);
+  CFileItem(const EventPtr& eventLogEntry);
+
   virtual ~CFileItem(void);
   virtual CGUIListItem *Clone() const { return new CFileItem(*this); };
 
@@ -542,6 +547,7 @@ private:
   PVR::CPVRRadioRDSInfoTagPtr m_pvrRadioRDSInfoTag;
   CPictureInfoTag* m_pictureInfoTag;
   std::shared_ptr<const ADDON::IAddon> m_addonInfo;
+  EventPtr m_eventLogEntry;
   bool m_bIsAlbum;
 
   CCueDocumentPtr m_cueDocument;
diff --git a/xbmc/filesystem/EventsDirectory.cpp b/xbmc/filesystem/EventsDirectory.cpp
index 1e3e03a..7edbe8a 100644
--- a/xbmc/filesystem/EventsDirectory.cpp
+++ b/xbmc/filesystem/EventsDirectory.cpp
@@ -64,13 +64,10 @@ bool CEventsDirectory::GetDirectory(const CURL& url, CFileItemList &items)
 
 CFileItemPtr CEventsDirectory::EventToFileItem(const EventPtr& eventItem)
 {
-  if (eventItem == NULL)
+  if (!eventItem)
     return CFileItemPtr();
 
-  CFileItemPtr item(new CFileItem(eventItem->GetLabel()));
-  item->m_dateTime = eventItem->GetDateTime();
-  if (!eventItem->GetIcon().empty())
-    item->SetIconImage(eventItem->GetIcon());
+  CFileItemPtr item(new CFileItem(eventItem));
 
   item->SetProperty(PROPERTY_EVENT_IDENTIFIER, eventItem->GetIdentifier());
   item->SetProperty(PROPERTY_EVENT_LEVEL, CEventLog::GetInstance().EventLevelToString(eventItem->GetLevel()));
-- 
2.7.4


From 6d320b78aa3b74df25eeaad341b3b9305e1aa0b2 Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Mon, 3 Oct 2016 21:59:03 +0200
Subject: [PATCH 025/175] implement high resolution datetime sort method
 (CDateTime granularity of 1 sec is not sufficient).

---
 xbmc/FileItem.cpp         |  3 +++
 xbmc/events/BaseEvent.cpp | 18 ++++++++++++++++++
 xbmc/events/BaseEvent.h   |  6 +++++-
 xbmc/events/IEvent.h      |  6 +++++-
 4 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index f06f7ad..66e74d7 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -685,6 +685,9 @@ void CFileItem::ToSortable(SortItem &sortable, Field field) const
         break;
     }
   }
+
+  if (m_eventLogEntry)
+    m_eventLogEntry->ToSortable(sortable, field);
 }
 
 void CFileItem::ToSortable(SortItem &sortable, const Fields &fields) const
diff --git a/xbmc/events/BaseEvent.cpp b/xbmc/events/BaseEvent.cpp
index aa73a9b..abdad4f 100644
--- a/xbmc/events/BaseEvent.cpp
+++ b/xbmc/events/BaseEvent.cpp
@@ -18,8 +18,11 @@
  *
  */
 
+#include <chrono>
+
 #include "BaseEvent.h"
 #include "guilib/LocalizeStrings.h"
+#include "utils/StringUtils.h"
 
 CBaseEvent::CBaseEvent(const std::string& identifier, const CVariant& label, const CVariant& description, EventLevel level /* = EventLevel::Information */)
   : m_level(level),
@@ -29,6 +32,7 @@ CBaseEvent::CBaseEvent(const std::string& identifier, const CVariant& label, con
     m_description(description),
     m_details(),
     m_executionLabel(),
+    m_timestamp(GetInternalTimestamp()),
     m_dateTime(CDateTime::GetCurrentDateTime())
 { }
 
@@ -40,6 +44,7 @@ CBaseEvent::CBaseEvent(const std::string& identifier, const CVariant& label, con
     m_description(description),
     m_details(),
     m_executionLabel(),
+    m_timestamp(GetInternalTimestamp()),
     m_dateTime(CDateTime::GetCurrentDateTime())
 { }
 
@@ -51,6 +56,7 @@ CBaseEvent::CBaseEvent(const std::string& identifier, const CVariant& label, con
     m_description(description),
     m_details(details),
     m_executionLabel(),
+    m_timestamp(GetInternalTimestamp()),
     m_dateTime(CDateTime::GetCurrentDateTime())
 { }
 
@@ -62,9 +68,15 @@ CBaseEvent::CBaseEvent(const std::string& identifier, const CVariant& label, con
     m_description(description),
     m_details(details),
     m_executionLabel(executionLabel),
+    m_timestamp(GetInternalTimestamp()),
     m_dateTime(CDateTime::GetCurrentDateTime())
 { }
 
+uint64_t CBaseEvent::GetInternalTimestamp()
+{
+  return std::chrono::time_point_cast<std::chrono::microseconds>(std::chrono::steady_clock::now()).time_since_epoch().count();
+}
+
 std::string CBaseEvent::GetLabel() const
 {
   return VariantToLocalizedString(m_label);
@@ -97,3 +109,9 @@ std::string CBaseEvent::VariantToLocalizedString(const CVariant& variant)
 
   return "";
 }
+
+void CBaseEvent::ToSortable(SortItem& sortable, Field field) const
+{
+  if (field == FieldDate)
+    sortable[FieldDate] = StringUtils::Format("%020llu", m_timestamp);
+}
diff --git a/xbmc/events/BaseEvent.h b/xbmc/events/BaseEvent.h
index d0f4c8a..5a7eba5 100644
--- a/xbmc/events/BaseEvent.h
+++ b/xbmc/events/BaseEvent.h
@@ -39,6 +39,8 @@ public:
 
   virtual bool CanExecute() const { return !GetExecutionLabel().empty(); }
 
+  virtual void ToSortable(SortItem& sortable, Field field) const;
+
 protected:
   CBaseEvent(const std::string& identifier, const CVariant& label, const CVariant& description, EventLevel level = EventLevel::Information);
   CBaseEvent(const std::string& identifier, const CVariant& label, const CVariant& description, const std::string& icon, EventLevel level = EventLevel::Information);
@@ -55,6 +57,8 @@ protected:
 
 private:
   static std::string VariantToLocalizedString(const CVariant& variant);
+  static uint64_t GetInternalTimestamp();
 
-  CDateTime m_dateTime;
+  uint64_t m_timestamp; // high res internal time stamp
+  CDateTime m_dateTime; // user interface time stamp
 };
diff --git a/xbmc/events/IEvent.h b/xbmc/events/IEvent.h
index 15a5762..e9598b3 100644
--- a/xbmc/events/IEvent.h
+++ b/xbmc/events/IEvent.h
@@ -22,6 +22,8 @@
 #include <memory>
 #include <string>
 
+#include "utils/ISortable.h"
+
 class CDateTime;
 
 enum class EventLevel
@@ -32,7 +34,7 @@ enum class EventLevel
   Error = 3,
 };
 
-class IEvent
+class IEvent : public ISortable
 {
 public:
   virtual ~IEvent() { }
@@ -49,6 +51,8 @@ public:
 
   virtual bool CanExecute() const = 0;
   virtual bool Execute() const = 0;
+
+  virtual void ToSortable(SortItem& sortable, Field field) const = 0;
 };
 
 typedef std::shared_ptr<const IEvent> EventPtr;
-- 
2.7.4


From 334f78e1f609b27c28004f80287aef91113f4dda Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 5 Oct 2016 07:41:49 +0200
Subject: [PATCH 026/175] VAAPI: restore accidentally lost call to sync of
 vaapi render picture

---
 .../VideoRenderers/HwDecRender/RendererVAAPI.cpp    |  8 ++++++++
 .../VideoRenderers/HwDecRender/RendererVAAPI.h      | 21 +++++++++++----------
 2 files changed, 19 insertions(+), 10 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVAAPI.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVAAPI.cpp
index ba5b774..0d196d0 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVAAPI.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVAAPI.cpp
@@ -202,5 +202,13 @@ bool CRendererVAAPI::UploadTexture(int index)
   return true;
 }
 
+void CRendererVAAPI::AfterRenderHook(int idx)
+{
+  YUVBUFFER &buf = m_buffers[idx];
+  if (buf.hwDec)
+  {
+    ((VAAPI::CVaapiRenderPicture*)buf.hwDec)->Sync();
+  }
+}
 
 #endif
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVAAPI.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVAAPI.h
index 69e3531..c2d4646 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVAAPI.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVAAPI.h
@@ -33,22 +33,23 @@ public:
   virtual ~CRendererVAAPI();
 
   // Player functions
-  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index);
-  virtual void ReleaseBuffer(int idx);
-  virtual CRenderInfo GetRenderInfo();
+  virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index) override;
+  virtual void ReleaseBuffer(int idx) override;
+  virtual CRenderInfo GetRenderInfo() override;
 
   // Feature support
-  virtual bool Supports(ERENDERFEATURE feature);
-  virtual bool Supports(ESCALINGMETHOD method);
+  virtual bool Supports(ERENDERFEATURE feature) override;
+  virtual bool Supports(ESCALINGMETHOD method) override;
 
 protected:
-  virtual bool LoadShadersHook();
-  virtual bool RenderHook(int idx);
+  virtual bool LoadShadersHook() override;
+  virtual bool RenderHook(int idx) override;
+  virtual void AfterRenderHook(int idx) override;
 
   // textures
-  virtual bool UploadTexture(int index);
-  virtual void DeleteTexture(int index);
-  virtual bool CreateTexture(int index);
+  virtual bool UploadTexture(int index) override;
+  virtual void DeleteTexture(int index) override;
+  virtual bool CreateTexture(int index) override;
 };
 
 #endif
-- 
2.7.4


From 78edbeb33d15b65e205d2743e475479034f7773d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 5 Oct 2016 11:25:22 +0200
Subject: [PATCH 027/175] paplayer: fix gapless playback

---
 xbmc/cores/paplayer/AudioDecoder.cpp | 11 ++++++++---
 xbmc/cores/paplayer/AudioDecoder.h   |  2 +-
 xbmc/cores/paplayer/PAPlayer.cpp     |  4 ++--
 3 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/paplayer/AudioDecoder.cpp b/xbmc/cores/paplayer/AudioDecoder.cpp
index ae7a88c..10744ee 100644
--- a/xbmc/cores/paplayer/AudioDecoder.cpp
+++ b/xbmc/cores/paplayer/AudioDecoder.cpp
@@ -170,7 +170,7 @@ int64_t CAudioDecoder::TotalTime()
   return 0;
 }
 
-unsigned int CAudioDecoder::GetDataSize()
+unsigned int CAudioDecoder::GetDataSize(bool checkPktSize)
 {
   if (m_status == STATUS_QUEUING || m_status == STATUS_NO_FILE)
     return 0;
@@ -178,8 +178,13 @@ unsigned int CAudioDecoder::GetDataSize()
   if (m_codec->m_format.m_dataFormat != AE_FMT_RAW)
   {
     // check for end of file and end of buffer
-    if (m_status == STATUS_ENDING && m_pcmBuffer.getMaxReadSize() < PACKET_SIZE)
-      m_status = STATUS_ENDED;
+    if (m_status == STATUS_ENDING)
+    {
+      if (m_pcmBuffer.getMaxReadSize() == 0)
+        m_status = STATUS_ENDED;
+      else if (checkPktSize && m_pcmBuffer.getMaxReadSize() < PACKET_SIZE)
+        m_status = STATUS_ENDED;
+    }
     return std::min(m_pcmBuffer.getMaxReadSize() / (m_codec->m_bitsPerSample >> 3), (unsigned int)OUTPUT_SAMPLES);
   }
   else
diff --git a/xbmc/cores/paplayer/AudioDecoder.h b/xbmc/cores/paplayer/AudioDecoder.h
index 222e162..acf6f4b 100644
--- a/xbmc/cores/paplayer/AudioDecoder.h
+++ b/xbmc/cores/paplayer/AudioDecoder.h
@@ -71,7 +71,7 @@ public:
   AEAudioFormat GetFormat();
   unsigned int GetChannels() { return GetFormat().m_channelLayout.Count(); }
   // Data management
-  unsigned int GetDataSize();
+  unsigned int GetDataSize(bool checkPktSize);
   void *GetData(unsigned int samples);
   uint8_t* GetRawData(int &size);
   ICodec *GetCodec() const { return m_codec; }
diff --git a/xbmc/cores/paplayer/PAPlayer.cpp b/xbmc/cores/paplayer/PAPlayer.cpp
index ac79338..e89c2fe 100644
--- a/xbmc/cores/paplayer/PAPlayer.cpp
+++ b/xbmc/cores/paplayer/PAPlayer.cpp
@@ -357,7 +357,7 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */, b
 
   /* decode until there is data-available */
   si->m_decoder.Start();
-  while(si->m_decoder.GetDataSize() == 0)
+  while(si->m_decoder.GetDataSize(true) == 0)
   {
     int status = si->m_decoder.GetStatus();
     if (status == STATUS_ENDED   ||
@@ -839,7 +839,7 @@ bool PAPlayer::QueueData(StreamInfo *si)
 
   if (si->m_audioFormat.m_dataFormat != AE_FMT_RAW)
   {
-    unsigned int samples = std::min(si->m_decoder.GetDataSize(), space / si->m_bytesPerSample);
+    unsigned int samples = std::min(si->m_decoder.GetDataSize(false), space / si->m_bytesPerSample);
     if (!samples)
       return true;
 
-- 
2.7.4


From cfc57da95d27b9401b0ac43f4ee5ab29658e9d78 Mon Sep 17 00:00:00 2001
From: Rechi <Rechi@users.noreply.github.com>
Date: Wed, 5 Oct 2016 12:30:48 +0200
Subject: [PATCH 028/175] Fix detecting SSE4.2 and AVX2 hardware support

---
 project/cmake/modules/FindSSE.cmake | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/project/cmake/modules/FindSSE.cmake b/project/cmake/modules/FindSSE.cmake
index 84a3105..0554663 100644
--- a/project/cmake/modules/FindSSE.cmake
+++ b/project/cmake/modules/FindSSE.cmake
@@ -45,7 +45,7 @@ if(CMAKE_SYSTEM_NAME MATCHES "Linux")
    endif()
 elseif(CMAKE_SYSTEM_NAME MATCHES "Darwin")
    if(NOT CPU MATCHES "arm")
-      exec_program("/usr/sbin/sysctl -n machdep.cpu.features" OUTPUT_VARIABLE CPUINFO)
+      exec_program("/usr/sbin/sysctl -n machdep.cpu.features machdep.cpu.leaf7_features" OUTPUT_VARIABLE CPUINFO)
 
       string(REGEX REPLACE "^.*[^S](SSE).*$" "\\1" _SSE_THERE ${CPUINFO})
       string(COMPARE EQUAL "SSE" "${_SSE_THERE}" _SSE_TRUE)
@@ -67,8 +67,8 @@ elseif(CMAKE_SYSTEM_NAME MATCHES "Darwin")
       string(COMPARE EQUAL "SSE4.1" "${_SSE_THERE}" _SSE41_TRUE)
       CHECK_CXX_ACCEPTS_FLAG("-msse4.1" _SSE41_OK)
 
-      string(REGEX REPLACE "^.*(SSE4_2).*$" "\\1" _SSE_THERE ${CPUINFO})
-      string(COMPARE EQUAL "SSE4_2" "${_SSE_THERE}" _SSE42_TRUE)
+      string(REGEX REPLACE "^.*(SSE4.2).*$" "\\1" _SSE_THERE ${CPUINFO})
+      string(COMPARE EQUAL "SSE4.2" "${_SSE_THERE}" _SSE42_TRUE)
       CHECK_CXX_ACCEPTS_FLAG("-msse4.2" _SSE42_OK)
 
       string(REGEX REPLACE "^.*(AVX).*$" "\\1" _SSE_THERE ${CPUINFO})
-- 
2.7.4


From ac18dfcc82f9d716b59d9f3022d7dc42f6e9121a Mon Sep 17 00:00:00 2001
From: ronie <ronie@users.noreply.github.com>
Date: Wed, 5 Oct 2016 13:26:57 +0200
Subject: [PATCH 029/175] use RGB color space

---
 .../skin.estuary/media/windows/subtitles/flags/-.png  | Bin 231 -> 163 bytes
 .../skin.estuary/media/windows/subtitles/flags/ar.png | Bin 906 -> 884 bytes
 .../skin.estuary/media/windows/subtitles/flags/bg.png | Bin 1308 -> 811 bytes
 .../skin.estuary/media/windows/subtitles/flags/bs.png | Bin 1121 -> 1090 bytes
 .../skin.estuary/media/windows/subtitles/flags/ca.png | Bin 620 -> 548 bytes
 .../skin.estuary/media/windows/subtitles/flags/cs.png | Bin 1073 -> 1042 bytes
 .../skin.estuary/media/windows/subtitles/flags/da.png | Bin 1512 -> 903 bytes
 .../skin.estuary/media/windows/subtitles/flags/de.png | Bin 1427 -> 788 bytes
 .../skin.estuary/media/windows/subtitles/flags/el.png | Bin 1407 -> 974 bytes
 .../skin.estuary/media/windows/subtitles/flags/en.png | Bin 1805 -> 1775 bytes
 .../skin.estuary/media/windows/subtitles/flags/es.png | Bin 1139 -> 1113 bytes
 .../skin.estuary/media/windows/subtitles/flags/et.png | Bin 1150 -> 784 bytes
 .../skin.estuary/media/windows/subtitles/flags/fa.png | Bin 1479 -> 985 bytes
 .../skin.estuary/media/windows/subtitles/flags/fi.png | Bin 1112 -> 812 bytes
 .../skin.estuary/media/windows/subtitles/flags/fo.png | Bin 1220 -> 938 bytes
 .../skin.estuary/media/windows/subtitles/flags/fr.png | Bin 989 -> 962 bytes
 .../skin.estuary/media/windows/subtitles/flags/gl.png | Bin 1285 -> 1142 bytes
 .../skin.estuary/media/windows/subtitles/flags/he.png | Bin 1294 -> 985 bytes
 .../skin.estuary/media/windows/subtitles/flags/hi.png | Bin 1476 -> 1010 bytes
 .../skin.estuary/media/windows/subtitles/flags/hr.png | Bin 1256 -> 1230 bytes
 .../skin.estuary/media/windows/subtitles/flags/hu.png | Bin 1381 -> 831 bytes
 .../skin.estuary/media/windows/subtitles/flags/hy.png | Bin 943 -> 911 bytes
 .../skin.estuary/media/windows/subtitles/flags/id.png | Bin 1227 -> 775 bytes
 .../skin.estuary/media/windows/subtitles/flags/is.png | Bin 1117 -> 1087 bytes
 .../skin.estuary/media/windows/subtitles/flags/it.png | Bin 972 -> 945 bytes
 .../skin.estuary/media/windows/subtitles/flags/ja.png | Bin 980 -> 857 bytes
 .../skin.estuary/media/windows/subtitles/flags/kk.png | Bin 1364 -> 1336 bytes
 .../skin.estuary/media/windows/subtitles/flags/ko.png | Bin 1421 -> 1390 bytes
 .../skin.estuary/media/windows/subtitles/flags/lb.png | Bin 1431 -> 871 bytes
 .../skin.estuary/media/windows/subtitles/flags/lt.png | Bin 1507 -> 907 bytes
 .../skin.estuary/media/windows/subtitles/flags/lv.png | Bin 1409 -> 890 bytes
 .../skin.estuary/media/windows/subtitles/flags/mk.png | Bin 1569 -> 1545 bytes
 .../skin.estuary/media/windows/subtitles/flags/ms.png | Bin 1306 -> 1284 bytes
 .../skin.estuary/media/windows/subtitles/flags/nl.png | Bin 1370 -> 832 bytes
 .../skin.estuary/media/windows/subtitles/flags/no.png | Bin 1133 -> 1100 bytes
 .../skin.estuary/media/windows/subtitles/flags/pb.png | Bin 1638 -> 1612 bytes
 .../skin.estuary/media/windows/subtitles/flags/pl.png | Bin 1406 -> 838 bytes
 .../skin.estuary/media/windows/subtitles/flags/pt.png | Bin 1385 -> 1359 bytes
 .../skin.estuary/media/windows/subtitles/flags/ro.png | Bin 1027 -> 997 bytes
 .../skin.estuary/media/windows/subtitles/flags/ru.png | Bin 1346 -> 740 bytes
 .../skin.estuary/media/windows/subtitles/flags/sk.png | Bin 1099 -> 1073 bytes
 .../skin.estuary/media/windows/subtitles/flags/sl.png | Bin 1478 -> 967 bytes
 .../skin.estuary/media/windows/subtitles/flags/sq.png | Bin 1267 -> 1242 bytes
 .../skin.estuary/media/windows/subtitles/flags/sr.png | Bin 1302 -> 1276 bytes
 .../skin.estuary/media/windows/subtitles/flags/sv.png | Bin 1058 -> 1032 bytes
 .../skin.estuary/media/windows/subtitles/flags/tr.png | Bin 1249 -> 1230 bytes
 .../skin.estuary/media/windows/subtitles/flags/uk.png | Bin 917 -> 891 bytes
 .../skin.estuary/media/windows/subtitles/flags/vi.png | Bin 1104 -> 1078 bytes
 .../skin.estuary/media/windows/subtitles/flags/zh.png | Bin 1144 -> 1119 bytes
 49 files changed, 0 insertions(+), 0 deletions(-)

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/-.png b/addons/skin.estuary/media/windows/subtitles/flags/-.png
index 80e33f5f1b46e20cee4a5b70a4f30ab60110dee0..43dd1d4e9b33817884fac28f1910da093e58b02b 100644
GIT binary patch
delta 147
zcmaFPxR`N*L_G%^0|P^GRn-?D#g^pl?!xdN1Q+aGJ{c&&S>O>_%)r1c48n{Iv*t(u
z1=&kHeO=ifaItcW%k0w3>jVlJc)B=-L>zv5!BLPwfq}_!Lw$PB!^3---c0b=e_iF~
lHucB3=U=k}6+(bY?7XWi8vnPL|K|Y-c)I$ztaD0e0svjMEgJv;

literal 231
zcmeAS@N?(olHy`uVBq!ia0vp^3LwnF3?v&v(vO2U$sR$z3=CCj3=9n|3=F@3LJcn%
z7)lKo7+xhXFj&oCU=S~uvn$XBC?OHx6XFV_85kLn(f|Mdfnt^y1qy%^TS<^#FaryZ
zfQo_C^PI^b#Yx`oE({&4vK~MVdx@v7EBk#;Rt6a+S?*OCKp`DZ7sn8d^T`PdxCOkO
z89RBhRxo+;q^)2&xtOViCB!MPLAZH>Ay>c>w<C-U6SAA5&)<IybS(per>mdKI;Vst
E0IWtd_5c6?

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/ar.png b/addons/skin.estuary/media/windows/subtitles/flags/ar.png
index cc2008eb222f27860c8e00ec12a4a9eb817c3377..4e2b87defdf592a28946337fc70639b95682888c 100644
GIT binary patch
delta 861
zcmV-j1ETzj2lNJzB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wit0ZBwbR9M69mrafwH5i7U?<@CDrjyQcvO#QT9X4<R
z_M9RIV8aRtaSv{QP%gkRP&7ixGN5FU$uQOJzb^}y-Bp$DiGK#6Y#2)=TdlI+$FE=8
z)o@?#%m2LyBJS5mUk0~*M7(-`^2P7IfAyb<K3+ZM-Toc?C<_Oy4fyJ(A4oU-Km{U#
zu9m2C=wiVyPp{~-Ll8RcXfFa-sZvfDM#>3*kOCnE_GyoqHGqxV@a(r|0BZ-h3|#;D
zlJNJNB95RUh<^wIs0hD5`3n(gqJm5StWp?7Y+Pq+ZGiI!=e6w|082;icjORJse>OL
z17eN`agn1Av{~ArZTSFG+kNa=$`Vh&0c3;t{u+xB8w70-uQ0(v6Z#~;+=-C`mW?Za
z)%v*F-$KMfz(m`uMFgt=IZ&F?I%6LPtXVyFVGNRukblAyAYoWa5EDkiM2ol_W*c%S
zlUBJk;g*lMkVi|9A!>v?0?0u29zqy`R%R}P69CV@eLk_jEdx{g$8~*j&g7g)DUnjb
z%y@DBg0Fx6=HS3?x5xS(RizU_k&?k-q5Hm{h@Jwd?VR(ZJq7?;-5kJsh>_xZ31JbD
zb}rloFn=$q+Mq-PRVC-#>M4K$DM5%W+Ev`JCVm%yIZR5aiHk^cXmG&FF7Tm<N_px|
zt6}`N0A}`4b|wxa03RTP5<1b*Hmp~M+#14TVq@63i?a-rZD>AVB4iPC$c7dYE-o(a
zbm7z;FovnWZMR!4FE6Jdv|$_Cu=WEwHUN0<kAELJpKxRDjG0Zwasbf`iwTPftw-@}
ztwRWRcHmTrG0p%0A4&!m2r85#c(@ZxWCCz%@MBKQ-!&l20le$jiP1SlrNfD!qSVC@
zV6j-76ufP=b8*btcs>lbVSKQnUoBa0&R8#&EV~XTTD}X0&R=Z9(S)Dc1*f25jCk+q
z`&OQRZf**|;_Qq+@}3p2(T=r(k{N3qbKtI}!o?WbY&N`k`xZguA@Brv_?f>)uYuQs
nhy&I&51+9_V0Zt&;J$nS-wF4+RNL3J00000NkvXXu0mjf^pk|6

delta 866
zcmV-o1D*Wz28sueBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00RI?L_t(o!|j$$jvPf0Mqfl_b+@PO_Hw*I
zY-bG{I01W3;RCQ?g@m{VH$avzz%h_DLa+p6FFYQmy7Mo*$ja>Ma`%`4WFavjl`=G{
z%<sh)k<|nDaUcKp5JcP$k3J4=^N4u$=H!cCe)WIrzb5*4`Iy(c*YJ(>4p<rR>9=2#
zZibNxL<C(fQ0LIT=lf5t=(Ix+I_+pL0$5p6P8deY34o9SAq946hnY2iwOjM_*;9a(
z16&5KfBuE=$IBv)pdyF}0;mW-KKUIHX`+H009d6kir93`)^dRJ2j?|+4uFLt4_k7G
zsMLSM_m2TF$Gy17Q3qO;w$Cl^VQN0afrTva1ROv%h;Od37_m{%M)3+0EHt6_0?eJ5
zIAGbh@>gw-tNSfPECfunRV^Y|1;~MtO54mtujy8+r!GuEvJp}^1V|W`62yd&Fwr6|
z`)WfDrDzpy3(H4b$deXih#DbJ05XuhhY)|pK`WKZ=mfy?FP<OR-`X&(e74pn=S<F-
zloBZ=%#0W3FZk@c&-V^&w>xYYP*pk+6e%+}HhLI_1JP3eHP1O8<Wm5kt<3?vhZrfo
zmmw@7(!L9~0n9^H8<dEks^py8dI(@ZN)Tcj?J90q6Tb_<944jI#6_ezG&*4A7WjWq
zM5R28ICU8RE`XW6Gdl+kBmf^EgfeuZlWSNo<_DYtn2Jqd=Pu4>pj<=q0TUsMpyO<4
zA>rcU;xAWRLFO>^Z=21A%gf6t0N8j9ZS4Jsj*S4``=cW7b7Ss|nH`+v0HPTd6BZL%
zKgF|NhY;@Uz^RBa&Hw-($_(@fDwKauFtmZ30-QShm=p7N4G41p?>e?(bWTy}a3ZKE
zwHX5ReScE$wrc0%n6>kK7=I1pgC)aq!D@ZRs$a0^I-F?vzhK<_(Iy<7@M9I%UZ1kx
zd(SWo{CRUz0Q$2te#$$Rz*;+23QA_Gb<BagMum$pvR<!w`RWyd$V1=>@bE4lE8H!v
sf!_oX2do(9;R8klwjWsYKK_I87T*c?x(|yh&Hw-a07*qoM6N<$f?S7zL;wH)

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/bg.png b/addons/skin.estuary/media/windows/subtitles/flags/bg.png
index 25dbea08d1d10eba2e135d7689819f13b0a68081..df6c7f60e6daab789324059cb57b45479cafec9c 100644
GIT binary patch
delta 799
zcmV+)1K|9e3abW?8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0008GNkl<ZSi|j>J(A=^5QV=?shf`8
z#loM!A{cKC3?kOwn{XZuz!|szC&0j1hZq89xB%8}>`bdv`F}7}C6zSYGmC>mS46d{
z^;7xP%a<j=wO!l)y&1sW-JRT>i1<%})>yZ<x7Gtl;^yWCNfVXX+}#~BTZqf~I<C*x
zV;$H35iy@{=fA(d2cQRt2vSN&S_O7@B+U?Qz!s{7XhCZ5h**J`*{rr#fGy#6m8-n{
z%X3@!3bj(8U4Ow=?zX>Zs?9xS_GIoBz|R3Z7w|cVOZRW*dIFGhes<DxFk54O&NFSR
zF?)cwKmW+P@4n~Lm@s#&b1=i)rb@Llfwz-4m9U(feiQ-;<v<Y}`yIdh_Ui&b1gFPG
z9>#>bVO{{tz-*ewY#s9gz&w;D?rLrcMGzsnK0|9lB!5mhGb*Dn46PLajAgv6?m}z#
z12qanU=pY7GjLHrjEErub3-xJzM=$o!?aEX+w^KZR+S#GVmd1@I~Ro33Z%#kF#<mM
zASM+sAQ$;RqYM`XW|CPEML-1m=$<Mt#K;g)a#wb`64Wqc+m&CCpd75IfF=kP6QU_r
zRlop#`hWT>z4`VV`1k=cqcg+HMMvwM@ukIYx8uoC1dyvYUVq8^KmO#0zy6+HMj4@D
zfRyHyt0=C<@wQ2|UGSr7pG&jxhJ>YoktPLMKps&ZQ7O9`Y>K@=oy~&IfYd!;drd-P
zo?=#j1Pm!bO6&~0$+>K^5k1ji{du8st$1%rMSqi)EQm3YS`!Xk&x4@z4)1*OfG?H5
z>b5L?^@gjeX^rOvCK@vig2%3J6!_x6r~QG$@imA2j(z9!?wFOAMcv=E?9Ar?=E}1r
z|50QQ43iks$m8k6us<vSyW=Z<KLrQiRc9P<JdBsCUN3#^HK~~@?_q=wr=UL`uOGzM
db{K5{`~%yd>6V{9|5pG2002ovPDHLkV1g1ab147-

delta 1300
zcmV+v1?&2&2Am3z8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0$5N?R7C&)00032009920RaF30RRC3*VotC+1b|C*7x`K
z_V)Jp`1twx`TP6({QUg={r&#_{{R2~)YR1S^78TV@$>WZ^?&vC`uh6P($eto@bvWb
z(9qD%&d%@e@5{@}26$Rbtdc^gjYF!BM6HoTu98KtlSQzUMX{7dvXw@&mIiiMMWl*3
zpoKf4hCHN*Jf(>}riwkMi#(@`JgAI4sf<0UjRtjBKB0#-pMo@?gEgXsHKT?$rH3}A
zh&QK+H>ipRbAMJkp@uJ=fH0qdFQ9@kqJ%J`g)yauGNp$yriU`8hX!(0HJ^hin|vvq
zekz}UE1-cZp@J)-f-9nfETe-gq=W`=R4<)>Bbj<5ntLRjeI=fLC7*sJpnoQyfF+@T
zC8B^OqJf(r6U#_B%RDU1JuS~ZF3~<N(mpQKJ}uQhE`QcQFV{dXm>?3$LNm%YC(Jk~
z&p9a2IVjRPDAPJ9)H^BFJ1N#XDc3tG%R@7lAQF`y63Ra>$uuL&H6+e8B+xY^(KRH~
zHYC(GCDk`2);A^BI3>(AB+4`+%0Doa9}<us62v+x#4jGnFdoe?AI~u#&@ms<G9c44
zAk;G;)qgV~)-xd2Ga$|}AImTv$1fhmJ1dVK5sD%fyE!VpF(Jk@Bhfb{(l;g3Hzm|J
zCD=G6**PZ9HYC3~D~BN!g()7fKQg&PHpWRi(o8+pPCwUAKiN+|+E75-Pe9vHK-^G3
z-B3W@Q9;*EKGjY?&`mzaNIJJcGl3@^iZdyOIDasXKQ@_0JfTTHqe?)eN<f%II*U3n
zg)t|lR^g%m000JbQchC<1Pl-)FdFA<lK=n!0b)x>L=ob(J-Pq@00(qQO+^Ra2?YQg
z0v!vgXaE2LAxT6*R5;6HU>FvFk&T@VCtzn|WMJap<l^Gw=Hcbz<Kq_)5EK*;;0H2!
zd4IS;;v7s2%tFE<!lGiF+~T}^{QMvV{QP{p;@q5KqCg2DW(H;n5lLYwE>0eh0+<QB
z;yj#OQo@oV5<msgk{|_810V{(Mt~GZN&^+h$Vv)}!3+Q^fEpntEGa7kR3HaY05bq)
z1Vn)xP=UOHqLQ+Ts+zjGx`u`(5NK!snSW}kD#}WV3i3b&TG~3gdin;2M#d&4CZ<3D
zq>POW4fOSNb+omB3e3zcEUm0<Y;EoA;lR$;*2db((!$&fsKCL|$=Su#&CT7z)6>%n
z2!ND_yPKP<i?frX15kmtkFTG9KwwaCNGKeH1P28M`1|?#cmoxLg-1k2MaRU(#ec^q
zBqRbsLPC6eTx?8qRAfYW7*Ih{a!P7idPZhec6JUFWM^k(W~8U3rX(i;73AjS7Zes1
zmz0*313^Uvh%75DDK083$givdDyXiht*dWnY-(<4X=!b3Yin%<GMbwj8|vFTI=g@h
zx_f&2`X@}BG<nLDsne!SpFVBc)PE^cCQq6;VaCi^v*!R6%$+xXLHoi*i<h(jwJ%+^
zY$?!?mL-c9EnHr=V8u$Hf>o>6tX;Q$!^Vx9HgDOwZTt3ZTeoc9v~lBx9XogJ-m@2|
zVBh`&2M--Sf(Z^EI(qClGXoO~D;~hY#K6eJj0Z3=4s@mh0RTW|v(+0runmd;0000<
KMNUMnLSTa9@-V^x

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/bs.png b/addons/skin.estuary/media/windows/subtitles/flags/bs.png
index 582ff41fd309b4429b6a2de8b4c3827394e1f5f9..d32de5804ca2d15bc57fa7483fba4d906b38e5d7 100644
GIT binary patch
delta 1069
zcmV+|1k(HA2*L=EB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9nCIY9{>OY&q+i<R9M69m(Pn_MG(h7)$h&h&Q7vfyhK4v+@L`(
z(Oi;6(GbW%%*BXcF8)9W0Y%9{QNf#+oCW^?LGa{F5Z!<gRDTc^FM_UwAQ3bYLbC2M
zJFmN|JaoSwGrNo6VJ~h&Q}tdCUEi*6)wkck?${mw_aTUs96#yzoju2G-I<{K`aNz}
z9xgoFD}h<Qxx~enUt<065f}_JE@7r{^a@AMIRFYL2ttvck-VcN6IC&csOg1Q#Ybfv
z6*FsoI4ld!e}DQlz-$SW04qOy$Ms9gaN;x^ybo~>5djgzxds%HqKeS?m|;f8Pr*#J
zd9Hmh_Rsb~6`(8u`u#qm(Fni32A_O{9DM{?Itk7p2&gr&FiSwJn*qzlCP7$!mjRj?
zs4@zXzCcx<9$<BK74Lo8{M*aOAJ>p4o`K<f6Q@q0On*K$P78n>JX_6xvR(C|&H%37
z!h7G$5CZ<{3jTxl@V{Tho8dLhU^Kor`}Z{iZ=|)(Z|kfz83-W|Ldg7PzHi+`K71b@
ze-e(J0BdPSgqHX%Xuz7&lWU;%gBfU?1W;8KRaLdYGY|ki`<P=lmU;dBK?Z}OEkZWM
zZva?bn12RQ4OJtmqR}vB_<8M19_<1ckH?HgBV1km9ROy=7hjE7xpIrQUb&aW0|VR?
z0JTXps<{*_1y==CB}T)fZB^F=5JF%)9&egeRpGtow`*&>_Rddye)&2OCZ<eHCmx5#
zNyyWuHA(9+F)&#JH3epdbFN8emlh|Es!E$}H-D_t3X;1<P(+f264j|9^xjid)uw=r
zW{Ysw{uwU5eTe%P2U`HJEupk;6{-7^*if*k2)6<tB0P3{fp_0nWbd%dDc|PwmQI{>
zDs_Tj+0PbFjJ7=m-QXsIoIcC)sWU8J>8g-yoq<j_m>FVOf=#igm?`sx<JVt)1iqil
zK!2@-R?F@D0=#emIea83mk3yU16kcIW|Kg=GF(fu8j@SHGJ_bl7a{--Jpkw4goQhD
z>STMa%{C>Yx&3O@(*z1Nf<WB{<+Kz7aOw;^{bIU|v`cD|LYq#%)ugniuQOq)6JlX8
zCMgcS1<>pD5E06`A@ba-$ique6d*45kbi5XuVcGHm9ijRNd!}nB3W~oDMUj;MbB65
zZ8$eK$Kakt_CEDI<=qExgBheOQ!sH&Czz0^m<H438bc=duO(3-6a-PK)rwK9Sg!#L
zAAAURbcyojU-ZW76#W^*6>QsU|794MMr31yu=Y2@evcdZGiMKQC$MLSzem@AKPJ;h
nDa>{Ya)(9$Hg^9P?2dl`vLlrGyvpti00000NkvXXu0mjf#D3qs

delta 1083
zcmV-B1jPHo2;m5jBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00Y-aL_t(o!|j&OiycJ}$3N9G@9n;Q$!75q
z1u=1h2E9acNft#zAO|rQBZ9g310e(=N)Cz&-n`^2_y-7rCvSr228^JBsCW@{B?O6}
zkr0w~m$z@ar^-Y3{CaN}MPw1&f~LA>hOTedx9We}13R{3|92Baa*iJNdrqI>mTphb
zJ^dcH3J>R>?&ZKNUtZ+GxffVJcnAi=giDyo9KFoZa}I#a34)NNHIjC;=t@-#qty7o
ztKv&#Tq<T(e>luD&VKX-z-$iW04v{q&9#fmaO@=PzXx#+5djgzxf&D_ql!?^F~f}3
zJO+O=)p}jc!Pq<72UUPP2k7_vj7B5;`Wk%rK63aWWa&6KhajL<$HFWEv33S5IqQP3
z^eh21Gf-s|O8Nptb$Wo+)m6Orar3V(A-`Tl9(xLg^L3mmh0<NtlLi1Oc=DP6CBN!J
zl>uC}h4;Q5Aq4!D75uwz<A1q=H^XZj!Ki=d-t4d68F(YUYkgZ~t<FFQfe=FCH}QS*
z2J+rJ@aW@k<QP~(J0dj1Z$blBpPp0$)jXJimR$fvQBV{`6FdO{;NuTCa($Us&hBS0
z$eJQ#Dt-;Xs=_oV)lfA`RkSpW8Gcy%jECC*#^W)g(Fj*ne+z(_@#*IyRxaP<^%sBd
zW^vyDHvvGci$*n-g2mvfpsJLmVbZj!YXb-&FdmPmMo|=a@A>)a8ZW>3J)c~<287O#
ziQ&ZK@Hh!+`1nrZ`!X`nt$~UHGs8Jor?X9q6Gu_R&9*XYwSuIs5fqW=AxCwh2)*|d
zMKKkyG7;g9y)#^R;{f+A4mJT`n?iqSo+?uHCuL2+R1t0lKty=t=mKxOy2$Qfo>IQW
z=`Ef(>Qw9m!O}c=JY~5_8%}lsfQcX{PqTdD6w8-ssn8?@>$;?dVo8Ecu~IQp<}=4n
zKYj;%)6GDogjUJz`~p089yxd@DwhaYa|2n`EoNOHZ5d8!F*PK$W?=?pn9hGdB}4!m
zxDU>}1`D^P)J<G{lX+(nL*lzqJ&mAHBM4M&&?!RieO#P41y4R7FC%S}8l})C({B|i
z&FQO5n6`d0)UdLQQXG5(px5gmBII*J<e8U{2bUnrKwRn}*GON>w}mQZLE4fCrXX4L
z<}gzz4G9H3Uo^Mj+}s?4yB2@h{lv56ckaUtW{^CO!Nk>_U_zu~5=@(G4C(M+Nuol?
z2%;3L1*5WHy#g@2{{h_LCGs1;(;Kgo^=A;5v1PCQ6EiR^k&O+)+8+%2J+2dfb9Mo@
z1H1mkaDT_vfZyUzDa_I;$ZfI!Y;1GP9s3X3pRyyA`mozWEC2ui07(Z$PDHLkV1lMZ
B>fitX

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/ca.png b/addons/skin.estuary/media/windows/subtitles/flags/ca.png
index 1d94f956513d021a248d49882a14491384f8d1d1..fc9edaf8d3cfe240a6706c728c40ac7859529bd6 100644
GIT binary patch
delta 534
zcmV+x0_pwi1f&Fz8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn00058Nkl<ZSi|j>KW`K<5XFDqf46t!
zu8krZDn0-$71V%4K}XL=qKZV52<7`w(18%pa70}0pV#&bMSrq*wXjhlfg5(JU2Cj)
ze)HzpFvb}Fdl-Q5^@&nHPFuNoM}By03V<)KrqmA=S*<|3(1`zC$ohxx-;On$mn{}F
z?@Is*0Pz9YS!8F^oW8PX<062=*XNkYH;`2t09ga>98RtPC?3KFWSa(n=BPB0fzK~z
zl=mcA{cI-qWq%a`c<(Ul3uL=X13(0^HUc<$vxF>w?t4^q6l@08`>HoL*l%i33-{Y8
z2p(h&+6>HEAJuhLuWkNiuJM46419Vq0}SemH11dAkav6_IEQSv;CvbtmIe9zpre7e
z-!ZxYLLwi|QDfmj%YZmCqo9)L2FeiWXyD_s8CjV8vVX^aUcV}lqKE*T50oe>w`8Dy
z8JU4G?Qc`X`3?g|XG<nk0qhfLpk{9aJZhaV2&Dq5$zCBLNMzu{^Er3w8rfB8tav(Q
zV=b`0Vn78ogDv~}m!SbKAu@3H^at}rKov~SRokw#>q9xl+y=r02dgza9pA)bi~&CZ
Y5MsVtpAW76h5!Hn07*qoM6N<$f*M8SZU6uP

delta 606
zcmV-k0-^n+1ndNm8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0Q^u)R7C&)0R87o{qK(b>0{$gRqKh3>3e_adVlMPjpboz
z;Yw2JfQILCc;s7S_~AkM=yLhyWclM#_u)PG<!AWgTKC~h+<!es;az3lQ(E0hQrI~{
z-BDQEM^D>BOYzw+@!LP~+BfmpH}Tpy@762t*E8?dE$`MY@7FKVD>c$9Hqj?B(k?j9
zCNRw$Ce0Tj&?z$L&K~K_6Y0$m=*}PI%o*p+66eeg<;)w#8Y9RTAjc6K#v3HT79hqJ
zAH@$D#Sj_67k?nyzzyNX5#h!O*}o3fy$j#P5#PiJ*1Qb14j8`;7q$->vJDo%7a+b3
z7tON=+QAdqz!S`~2LJ#7a}{!)00001bW%=J06^y0W&i*H0b)x>L;#2d9Y_EG00(qQ
zO+^Ra2?YQg0v!vgXaE2J(n&-?R5;7s)5i{iP!NS-Y=2<yy*IG;uGo7A-~VAeKup|>
zD-#nx?j45Y-@-8eL8t$~fWT;CIgZ7}R1c?pDx2AYz-qITYz_oYmz(7BAn^M9BwqkQ
zFcc<*A_$_fI4PDukW8f^gGZg2^lQURWfA1^JTKsYGSx-H3;6<qVyR3jRS;BbbyBT?
zpxJ7ZT2~ze-Cm#68z2~t#-z~%fjFJLnJag$zF@jQuw1Q4s||wfZco}B5FEu5NjxLC
sTyLc71;JgCC6F<-MSAo2^$+nSPnd{gmzOsKYybcN07*qoM6N<$g1v(bwEzGB

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/cs.png b/addons/skin.estuary/media/windows/subtitles/flags/cs.png
index 7de1aefba39d343c9879012efbe5b0517dfe0c08..51578848d4c46dc8e0c20b0055bff935adfae621 100644
GIT binary patch
delta 1020
zcmV<Y0|WfA2$BepB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2witpGibPR9M69mrH0|RT#&A-^ra!I%!fOC<UQiiL_>+
z2&T~@bmvknZdHU@P;u$Toe1Jaaa9mE?!<+-EVw9?EG%{~wSV})7SpEYwTkT|%-nk(
zpNn(Poja3E8aLUP!`wM%&fLrY_dVwf9FD{Be;<NKcK-d(><6!(W4hHm5K&_cAp}mH
zKHbQGi64Ht#rc=c^30Qua`N~LB2rz(7(}E`T<)hefT~t=TBpw;gla#1Cn78@Edfkq
zK!z&6{<X@L_J5x|{lw$EdTy5K$s-tJP}K^eE?9@EL)1Z%cnDztL_`Q70AvPWJTr82
zi*=sszu)7NudndS?X>|b2jcc0_lDsU6o3Ixl+JdJa{=cAo1HF~zWb3czrV&-w-^Y?
zLzAj@@2F>X0HBI>K3?AAykfoQ+Hd#x@X}@4f2{0j>3_q#FbuK_K){D+y>$WWJkAH4
z3v6z6`TU!!eDUo954L-|iVX|z$79}m0J7wP!aA(;h%tx&LE;?mW8uafZr)z!;wxvE
zd+Nmg>wH8w1_224dO6*^z=%PNDO-er@)<?w^?H2t)n(>qPw@83XPBOx7+D3$#q}!i
z-dDmqJ%8Xl&M7JZkwmV5#Fq$(=IY`dZrobu-PfLHe)i<ZW>c^G)O^xB0HCV)5U}2Z
zm}qb5h2b(vBj5ao)sH`AxwDdN=zE}i4?#g703j#=@F>!1akt&BdmtuXVLeC`myoQN
zh*1N0wzI~Y8;eZ&f??Uz;j8YL_EpOZXjpu?oqwf=3+u5ilmJ@hfK(6wQ@-GhjYZ}k
z{JleRHw-F>xUQfIODONGa=?d}2O_2d06|Ol&vjP0u-0bU=V%q25yCZ#wfs&~qN+l(
znTo3)f>?$jihC1XFT#||xv=pwXYViX5R_fSwKfk{Mi~%Q#1?}9s<8<<?~!1j%>KE~
z3V-jdUFVp~t1#?l{hscxhau&J^Ej=CAb6~`SZl$Iam+g|uD5yd{xU|Sa-r-YUWXX=
zf})6))qoPL#ny8mGl~Sum?+O}uky~uA~T`Dj5jLLcu55yL+616sHK$&!Vrb)9w~r4
z%lZIE8p0!z^Hy((7yKrZkIm4K*pkbi%XQcbsQOas5Ov3v*<Oo(*#lDb35v6hUXhbG
zn|**&(q;bc0;Vy>&GB)X0%M|mcS|jby6?l@z*+&XN|!*#I~uK4btXIt90!gb@Og9#
qSQkVxV4~lY4s1A}clf{HaQq7)Lqh4C`t5xH0000<MNUMnLSTYBJM@JB

delta 1034
zcmV+l1oiup2(bu|Bq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00XB<L_t(o!|j$$XdP7)$A9N$US66sDG`){
z(5^&UvrvSl(IRx`QY~&(gj!H>>BgN1#f{>sP~5l^7vi$uqENE1*oUdb4{R}QYQ9#n
zeF^W)+>hg8=FXdWnIsjZAm;Gy-23jGng9R%&&Pjzuy6bJe>XuSIrH8p_WjpRGd13R
zD4@m|LI@l?e!P_cW8Z#%lQS=#;+ZEO<>=vQM5G+X7(`^ixY&<t097sLxQ^dL2<3h}
z6A=~{7Xii+AVHO%eqZ5o=Qo~y;&EO%J;T(*0gN%IYDuCBSS3{@Q6&<=LkKk@B0>lO
zATfUcqluxHTCDS2`{gd@zqrhgw^nOj*5dXz_lC(wQUC@(QMy|x&IOzgY;=2E`1(68
zesh)0URDdqo=H`?cc*8z5kM8|d_KI#dBu9q)t~S3!G%k7eqG+x)4fy}CelD4;6v`c
zbph)<&Ig<eY;5-U^vf%J_SHQ1xB87>!@z$JqL}v{fFvrAS%-BVF$NJJNIvKHF@OCw
zH*T$Q?&XurK6PZzQ0x?vW&#BI{ghssVZ<QDkhcf}#WRY~@Avue^GnRl9O12(PBJwy
zR+F_!;%XIm?@QqA3OJ8*ib_BvGFL$Ij|h>?m4(|}zq!UcuRh1z%+W^AV+ltUV)K8A
zbB%zi;zPiC4`OnE3l*v|RxRE5la-G?W~sXzeHbWETtiS02tWu*06dC}k8`KfsVa~s
zUuHc>4lW^jFFB10foHp`ys^H(q|X?JEh0bYj&WbL7(mP7i|r&noLP@`p&+0|4oFD?
zVA5y2zP`ZR{Xe!rHqoFYk*`ZqnI(S|ca}NeL!JjBrX&D@7V^(_S2(-cValh((;a~;
z9&2%?F;P{a-HydI2ti(kAqV#+mtKTPmvVOf2Tt8v+6E{M;98mMl~Dvl6|q^JfNI`^
zocBmDP-OpXcbRuruW`twWf+>g-&Ou<7-CL1kJD-hg2!5mwHC|>hrHw5T8DoZ?k!<N
zN(p5b@G6O66%<9Zs0Nf^Ew-8iiBTk2MnpNWwZhx$3rvR$GukRa^C2Yxq5gj$64b)W
zNWzc<R~5;CG)V>o4zz?vB<0QiBG3B`CLWunC3#COelGJ~P#_PK7-T`|xmMy|^nh4>
zg5s>BpQWVj_JF`K=`nX_9@ADD;l}7FZGjQdf!tDwVpHuknbg+`cvX4?y57+mA1{tX
z4g!aPgAe%Xf6F$3H9;f+#weT8Lo)~T|M6S)?LTjS0U<*|>G$FVW&i*H07*qoM6N<$
Ef+Ts{-v9sr

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/da.png b/addons/skin.estuary/media/windows/subtitles/flags/da.png
index 59eb0b33791acd89415dd426c7382d864793cddb..d4d0f2ad0ac1629d2a6e9b602114ab9578a468d2 100644
GIT binary patch
delta 891
zcmV->1BCqO3x@}g8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0009NNkl<ZSi|j>J&znk5Qd+snc2HN
z;m83ZJ><jz0qOk&i+~7;oE$Ps&Pbj4KM*)YB6h+_L?973Ab&U{az}Uj+1*tRx@Wd$
zc2*W28QapRdq$(Kr{3y%XW%@}<NrPc;MeQVTpvBc?(b(`TK@EUbiaA_)xQeb$NK#4
zcWD6}`1JXA_-1>c5<wRo(snGKJUI}HV6R@zZfq$5;4#k@BOU{`58#gXdn_;c<Hh#?
zv;gL?|MM^G-G4hk5I{vx$?NvZXNU+Q0zmlrmwaC~bimz5Yj-d=958om0C4p2W313*
zfUd>1TP(y9R1lStu^!j0WLOhO1(Bb5d1eS8<~SLI?H23W3IOnj6~qW4d1sZ9r48Bl
z3J~KFKpk`p;Tg<4zvzxXtT1W?+_4yu7(p}#OCUOvy?@96;1hyVDu`tja0fRm#;imS
zkZ?!|VgfN-Bwxu8on#MqjL0}wh6>jJfEVfAy#VA`2_GLq_5nhyq%T2b=D3G=y2l29
zqKbo*QqY&83Bw^2fZN+!zrMZ(plKSKra@Iv)gkkGJ(OY;*GFqJ8?DWZloF}5>fPNP
zH#axg2Y>p9eUN^hyG{WdnT_fI)$eI$!`#QrB`_OhTEqNPfGJE$X$USNgF=G>b%1*Q
zF96*AXz!5%t8cz#_w*^U*`h#GTu{qdzxwfq(FU6@zCJpeJ~Ml9KPv{5+_UE_FIl~P
zJJW_C3?|g~xmHR{ec%IWBPHN~)tk|xn`y%kk$=!TVg49NmC>jqAsiW@Ox5s%4SUs|
z;tnB_Y9op`9wQbbjmQDwRJ--xf)ix`M+!yVo>EHTDG_Rby&L-w&=?T3K;#nm1VBWx
zWi#(l2S=>Gk_RAjCx$Qv*ftGooK6+hhDMb}6fH)0)Cp}nJny58%W%kAONo0sHZyka
zY;+o}6u4OM(6wAHFX=8WST=2T!qNrP7SvBZMkZ&V&sHWK;6-|Y+yx=9-fq||x&uIS
zwdA+mnhO?uq_Fff{EPrB-n<#fyx*<<_HS7KW3mo=?sse2tL6EJ_&m-7fcM|W<9U#)
R9hLw9002ovPDHLkV1fuKjluu`

delta 1505
zcmV<71s?i`2j~ls8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0^d+fR7C&)00032009920RaF30RRC3&LS?*FFV)Q*Ucg>
z^QWxxo}}}hr1PJp^`)xzsjvL}{Qdp?`?R_Fv9|cFv&$ha?SF=j>vMbSbA0S`eC~98
z@O6Iib$<H#`uqF)_IQE!d4l+Pg7tWT^ml;sc7VwyGV6YZ>27!HZ+Pu*dGB$0@Ns(b
za(wr6e)x5M_H%vpbA9x4ee-gB$0joBa(n4&bL(q#?Q3=KZFcc)ck^y|_i%dnaeDS|
zdG&93^ly2^C4VvKZg=TsZ|i4q?r3uGXmavubn|L-{{H^=Y<Bl-clK*_^=ozXYjwgU
zFz9P^>0)f_V{PqZZtrDp@nvxHXL0sua`$L+^=EPPXK}zJFz97(>0M~+Uuo`OYVcrd
z@?mWAVr=$fZuetu^<r)GVr<35#pmbe>gww4?d|XH?|<>}@$&NW^z`)g_4W4l_QJx#
z>FMd~>+A6F@bmNY_xJa}z`*F}==k{fy}iBp`T4RUE#gd9<3ms7Lr>^LQ0hfd>_t-T
zMN;raQ}ISq??zMZMpLgMEaFL2<338|K1=98OzJ>P>p)HJKuz#MPw_%e??O-RK~Ak9
zEaF5^<bOFv<vK^`I!Ed|NbEaE?K?>EJxcODO7J~O?>$QHJWAt4P^=*<sUa)jKuqE_
zLgh9?=r=^_H$?0=MD936@i|BGIY;n0NAEdC?>I*0H$&q#LgGP9rywe$ASv5BN8K?!
z<1s(zGC=AxK<hI>?KDF2HAC|?L-933@HIm3HGe|xG(zbzK;|+(;W0klJV>G+DVrlK
z(K|-gGe6%oLgqI_>o`X3IY#a|M)NsG^g2lJIY#L?Mddd{);mX;A}f_DGQ~hj%|uSy
zOI7GjS?y3;?@(OuP+as<UiDI5_EKK+QC;#;UGY#{?oeCoP+R6tTHQ)j%tB0%C@`2b
zJAafpK$}2Dr$$b&N>Z{*Q?pA`xw*NfMNFAHLX<K&|NsAl1Pa{%000JbQchC<1Pl-)
zFdFA<lK=n!0b)x>MD#M%D@_0Z00(qQO+^Ra2?YQg0v!vgXaE2LW=TXrR5;6HU>FvF
zk&T@V3^;&*4GplfF)}c5a&dF>@bd8s2!99&3W0&Ju!smhA1@C#Hy0-p1GA`@xP+vX
zw2Z8rfS|mBqN0MlyppntjI@-bgt(X}GXt}#n!1LjmbMN^fv&Eep02LGfuWI(ww9)b
zx|%9bfw76HnYo3f6;NK#+S<m(+S=CE&fdz>!raW%#2Bc+!O_Xt#nsInsKCS1(|^m$
z)6>)2$JgD>)y3J#(E+Hy&p#kAC^#e(Xn;ppI1q$|MMOk~h6D!%2Kf5{6+}hH#Ky%Z
zB!UzqB?CcHQc6l{VnTdeY)o_%P(fOHdPZhec1})iUS3{45CEy%oSf{e%#8H(G@ycl
z^unU7;+&FPkZdUsfYjuc<P>KW6@R7|02P##7iMOG<$;nFKmbw$QjwKeSY8HHP+6Ff
zS)2os2TE1}0Z0u{MNV;MMqwpTL3K@SU427i6HvaYxdjNCn_FAkni?DG>uPJNfeP9?
zI=i}idi#L7W&0-pL4W_miIe(zd%C+iJKBK?CQq3<ZTgIvvnr}&<z~;GGk<6H?AdeY
z&7U=M#`I}Z7c2xSShRS_(q+q6tOP2MUA1cU>Q$@OtXaEm<%;FY)^FIj38-N6maW^i
z@7TEuWWw&<d-m+!y?5XK1G{$aIC$vrk)uEb$Bv&kdFu3;vp{)))#uKiKL<4A!rHTE
zPG7uq^70j+f~(iA-?(|}_F5fTIXQv5_wL`nclW`AhmY>ue*EO=v*#~>3SPc?{pRhv
z_wPRd!Fy!z?(N4<pP3n$SXl7@7A6KpCT2W<iE*Ga6$k(T#L@o-oon+|00000NkvXX
Hu0mjf*|hqu

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/de.png b/addons/skin.estuary/media/windows/subtitles/flags/de.png
index 6c8b61002b6f8a94589632a9a73fc13ccfbe3efd..5603cc9180ad062d590abec49aab9f14a0148dc3 100644
GIT binary patch
delta 776
zcmV+j1NZ!s3zP<s8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0007^Nkl<ZSi|j>O>WyT5JumSl3dp<
zvdj^>?XpM8qG#zk=jpyccSUo909`q76!CAmASqLFg4RLNm462yNZAs<H{Xzy;1ZX(
zL=L^Wx>Df3v_=c50Jpcd91e$>NJQ9dHuQZ@-}eAmYY`Ewwa;b|V?<SnF#_Pd$9vB-
zO{nU8-)^_#=H>=Ky87eY-5vM$_X_|Kna6Fv9s>)3I&S;+|Lg1PdE5aE!@xL>c<)~&
zelEl~jts+qbAOK6f&G4u_kJPxocP}Yyd<uw?DzYn18u!toBcU1RHqjJAp}AQug?A)
z7pl$-@D=#r9O4{S1S^68j0jS;imU+E7`hg0T2dteQI)8Qb{#)~PZb~nPtyeBh&AQ}
z09DMo6fXc&h?Hqh0a5~MiLC<>V45%?AgagATL&u43x5FXFsd_@lmt?lJ5AFPAOR8r
zIEN9*85@JB9>vcDKsC4GWK1cGt0H}$9cmpA?-A#Ybzar~RRB$SqyR}icuq?oWf873
zp0CS<@&^E|{}m_ey`nlhigPP~FTlrusLKyp$xj&&qX_M`WYM2)gVq5>ljIsJ5Ho~I
zAbtlvSAT#As6(`zgsMl&(@{;N$y{5tWqEYogL>S;S`tx3#1UfSK!|__GzC=J4V+z=
zO)u+e?Lsa0@(d~$>GXxHDNxU%4#0VE&STXx)QPn&9$6GOyPz+u136}2o>9#cnOcPe
zJ_Vd_0G@o$;Yk=whgiWP7*jy1Xw&9$G#1Rxw11fbVu~{<n~_wRJUmW4P~L`9c+11M
zWxIJ#Cmq|tU^+nzm^o_!$u`U&6{ZT7bs?pWMj<KK(u;=}1Bc1+=tkg>0c^kH+YiHL
z)A4TCvwdT+MiBXj-+T%&DdQ;Y9|B#!1AbjThA(jmegmsM%gZH24@3X}002ovPDHLk
GU;%<T+D$qD

delta 1420
zcmV;71#|k829pbr8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0;5n&R7C&)00032009920RaF30RRC30000F4-c4_n2n8%
zj*gC%m6e*BnxCJaqN1Xsqoby#rgCy}TU%RPTwGmUU0z;ZUw>a;U|?Vd1_o(qX;xNN
zS65e9SXfzESz20JQBhG+Qc_b>Q&dz`RaI3?OiWEpO-@cuPft%!P*6xnNJ&XaN=iyg
zOH0TG2JcKv@IpfKLqqmNMEFER`b9<iMMeBYMg2uZ{zgXsMn=U32IoaZ=Q%m*J3H+>
zJnuX_@jX5AJ%2s&JUsL~JoP<2_B}nq1_tLoKIt_z>ohd)H8t=xHS#t#^ENj0Ha7J)
zH}*F-_cu4d1_tOlI_WPj?JzL!FE8>jG4n7m^e`~>F){WsGWRkv_%brR1_tUWDeWmK
z@G2_uD=YLXEA=ZY_A4v*EG+meEcq-fx&{X7FE8sOBY*BABk?38^CczqB_;MHCHE#K
z_$4LzB_;YLCAX9Y>clJT!yWF#9`VN?^T;3d${+X49{9{3`OP5u&LI2GAheMN>cb`N
z!Wi$w8S%y#^vD_Z${F{{8TiW@`OF&n%^Lg88vD)}>%=9qkp{4i2I|5g?7$T6!xZtw
z6!gaw_J7C}_sSIb%M|&{75dB-`^^>n&K2*&6z#zjuZ;$(i3a4n9Ot_a?Z6N6#1Hhw
z5B0|n_sJ0W$`JX=5c<my`^*sh%@6&~5A($j@WT)4zYpcT9jS;0qJ#_Cv>o5J6X?Da
z@Wd7L$QAa<75B;&`O6jk&lUdA7W2jx?!y({xPKj=feV{}70jz9)v_w%zb^60F!s(d
z_s}u<(J}hcG5gXo`_nP}(=z?kGXB*v{?;=0&oTARG4IJS<-je|u_u*#6rP13nSv;w
zi7u>^Gqs#HxSlt;pEs<NGM<JhnSdYv|Nl7hjGF)e00wkYPE!B`3=kwR8s}`200001
zVt-3VMBpe7|1bam00(qQO+^Ra2?YQg0v!vgXaE2LO-V#SR5;6HU>FvFk&T@VCtzn|
zWME?B;N;}w;^yJy<>MCs1AabUULI~PpfCp;69Y4wppcM|u!xALsF;|TI1m6SQBe^Q
zVW6-e8#4p5grt;|w2X|btel*j5EuX%vVXENGSX5~k`f>VLh=d<ib_h#Kp+JMAeNGn
zqJo0F5LkhfimIBLy1IsjhCCDind<6lYN{$yU<C@Anp)c0IzXTT1t7Mzww9)*0!V?b
zp1y&hk+F%XnVGq{1rV5<o0*xK7#kTH=<DeM6<AtX+t}LKJ2*NyJ3G4o0g!TXbbqk7
zv$e6dvIHt{b#wRd^z!!c_4D`l4*&un<>%|;?d9p=?&b<q5Ev935*ijB5g8R79UTJ%
zKq@LSB0MZKBseG#s36uoE<PbKDLExIEiEk_2!K>-N^(+SLVTQiEKos4W>$7iZeD&t
zVPR2GF%T3L6&4oc=jG;PXJuvp6@QeJmX%jjR#n&3*4EY413_I~ZEa0;Rb@qaS!oGS
zK|^Cxb4zPmdq-zicXxMB50L2U>}YRmZE0@m?E@<4pD=OK<SA39O`kDy=B!z>XV027
zbLNcc)22?DJZJ8Nc|Zm87c5+~c*)Xb%U7&iwR-iMHLF*zTDfBRvZYJbu76v<VIxq%
zrp;TnZri?N=dPJR?YsBv*$p&g=B}MPw(s4yb^igNf`f++A31vL_=%IJPM<k@?)>?4
zXV08Ib@IgV3l}e4zH$|);M(;YH*ej(g9&cmx_j?FGXoO~D;~hY#K6eJj0Z3=4s@mh
a0RStJ*R6BC8K?jN002ovP6b4+LSTabhJH!_

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/el.png b/addons/skin.estuary/media/windows/subtitles/flags/el.png
index f0eb6e52168231e590db49082b4be79d0d0c77bc..6441a307c9c11d3c09d0cae6c6a76ffb409d57ce 100644
GIT binary patch
delta 963
zcmV;!13diy3eE?R8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn000A9Nkl<ZSi|j>v1=Sh6vlsV_V#4y
zgxv(}@){EqiGT}1FfRND2vW%4$SKm=B>#x}To(-Cz>T=Zq<=QJ5V$Z{Rw4wJI^%$Y
zT-ZoH?aa<hin-aH-8(5@k}CILnRj!`eBXQTdv6xzHn;z~NmzdJSFT**!-q2f4i0_<
zU}a_SpMcg_KT9WUc^*Ez!|AC8px^H!A`AxKljj+E9$w2bg$QI>HuGR>E#8B*4gh0H
zjIk6&iT42qpnuova{vAifQrED*MITu-3cI+<qeclJb(TM5JUtJ9zFVY;)94(zV{v<
z5Gvn$k8`eCqwl>(M7VY90c&f6K%m=IjK>CJYy~JH7~?AN2o}MoYAI5YXz#`IQliee
zS_8YgyT0G=1E7?edg1|FTcZ|%xYp6v7QtdhT;(q<<$r8%@1XS{XdtGio!)k&bw>QT
z0*j!jU#|}D9mc5Y9SJ3P;5RnD;nODr2&2(=D5cok+^$Lh@Z`x>gXA<YQ(B1icg|t0
zt%5x|I%0i&J$8XZYm3$v5!KK@Gu5Bb=SenG($?B$7Zk-A<FP?0#dthMDaF~@7?4Q|
z3Ab<mGJicnlA71q2)_efvjomLmX~v$J=;wQIEunjmLWY+ctufXV3zVPvZfYXML@(;
z6c$Lj;PK<%{Oalo-iINhR5s}VX|&}<t(bN|It#$#T-1WaT8jwm?;mjQ-bT>C)vJqK
zyS9vokY(9~M6(4ymq02+YwcuOdXA45>k_<p@qZSrzreXL2eK@i0IDhQe=5bSi5S|?
zS6!eK?Crfx+wcc}{rVaoKk5oN{3UoldnQ~Y!jynW)Iv?<^5rgvhku~;ub~8Y?|#MV
z>em?KCsEhwPc_g6PVa&?kyHcqy%3%}SM2XwhQmn-HaEZI=FJ;b-BTUR(m;DXZwRFt
zh=1vi{?5)R!yzaDtu<O}j4_Ro+`e394VLpn+SWu2#yW>7OSIOt2uGve+1nGWRpj{s
zdEP~-Y*G#?O@#B)=%sb>M4zPQRJC``Qd$FEb8zsgCh+v>AunHAI-Q(OX9=Y)A(ABk
z0Xztj#(q<P0bIm4K0u-f!BUn5TA%R#{XAh!px0YKsXys-7Rd8OvaCCa`roxM2@A^d
lgkEof<Ky`^@!aMHe*=gUNRvbYw%q^#002ovPDHLkV1llI$GiXl

delta 1399
zcmV--1&I322mcC?8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0+&!sR7C&)00032009920RaF30RRC3003+c4|Lbp*8l)(
zn3%|ojl%c$_xSkum6gYun#!M_&Z45wqodHKrqhm&!;Ou@0Dk~#a&od;Tc%rEr}Ojk
z_4V~#U8-GOt6pBLUS6&I{QUj>{r>*`|NsB{`}_L(`ttJf@$vE0)YJwBY-wq&R#u}{
zR;2Xw^!E1lSXii8S*clBs#;pB`T6<q@bJ>o($LV*RaL20R;pH3t5sE~R8*%_RHjo?
zrBYI(Qc|K(QGcNZ25ZjF&hPK<P*A5)QK(Q*rcY0$Pfw&yPNPmvqD@VpOiZ2z25JTd
zX;M<5NJyMWNS#VbqDxDoOG~87%gY7^XF@`mLqnTIMW97Rp~%R{1_owDMV2`^kvlt+
z?d|P7J(oQ_m^?g~JUp2_J()c{nmjy~JUo>K24p@ylYccek2ExpHa3+uHkLOxmo+t$
zH8ql^rnJ$~-O$k8)6?M9)#KOK<=NTh+1cmX+UVQc>D=7v-QDZGy}jw_>FVn0iHV}O
zx6!q=(YLqLy1Lf8yVtzD*}c8mzP{VPzudsU-3A6<D=Ui~9fckqh94h@A0LSyABr9x
ziyt41Ab%i@ARvxiU5SW@xr2kagoL_<g}jG{zKDpwh={<6iNT7B!itK+i;KjFh`L=}
zh_JA*?Ck9B?(VOzud1r5<mBY%=jZC{>*eO=si~<~SABeZt9f~?etxurgSv%<y@rOr
zhljt2h{1@6!ikB(iHXCCio}YF#e{^sf`Ykze}A-oey&wjdKDE|CMJ3+Dt|66i7+sc
zF)@@eF_kefmNGJyF)^1iGM6$km@+b%F)@=dF_0}Si6<w06ckk;AYUjbU@k6aGc#~D
zHg-2Rcrr3?DJf$gA6$O$$~FK100wkYPE!B`3=kwR8s}`200001VoOIvBPwESIsgCw
z2Y+-)O+^Ra2?YQg0v!vgXaE2LMM*?KR5;6HU>FvFk&T^=je~;?D`011WMJat;^yYz
z<>MC+5EK#y10g{H0e(IaQEqN7P9_FsF>wh=DQOv5Ie7&|MI~irB}GLA6;)myX(=^z
zH4SD4W=$<^9bG+r14APPMJ12|C6EGR9)CSuH4}AHpaL@!6E$5uUR4zZb8`y|OG^t2
zb8~YmYa3fTdj|<epaLgn6E$fbW1s>TS153Cb949b^z!!6_5~{N^A8A=<_QW82?5&x
zwgYI1F^{yGiE}7WL6}c?gdT5XWK<N20##l;DHG>tpn{m#xcCI;#H8eu)YQ~8Ab$W-
zDalER=^62Hu`xgenOWI6&L+9JdHF~nFE_WKFef`J6R4o5xTLhKyrQzIx~8V476^b;
zbya0Wd0A;maS>2KU426W(4*3NJiNTT#y|k1c=V)!p^(r}Uk6ms*woz8+ScCD+11qz
z1zla89qnzcEzM1hKm|R$ef<+APJfy_WhxL%0|F2|W%8tn6Z-pldw>e2&zL!D_MEx%
z<}X;VaN)v5i-5#}1@q_4oilsZ%*9K93YIo3TduAPbb+y|s)~w&f{Kc&sxi<Ny6Vme
z4J&{OR<2r|0CXcr0Z<wkMxdwyMy9Tm$(pt6fC|=c*tlu)maW^i@7TF(*KqDVdv@>I
zwR6YzZCkhO-M9b1L7;*|hmRaRcKpPNlc!FfIeYfpxwB`_oIZ8(#EIkQFI>EI8K~gO
z)oa&p+{6ZM+`4^-nSqIg6%SxxVqj!q#siob2Rc)M006TG+9qZpHGKd8002ovPDHLk
FV1n^Mf`|YB

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/en.png b/addons/skin.estuary/media/windows/subtitles/flags/en.png
index 60d099cd0b9e594f9b5e22140968aebda22c4123..b780b85615188f746f43e64d6625eb4ab25fc87b 100644
GIT binary patch
delta 1738
zcmV;*1~vJO4(|<+B!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wiwd`Uz>R9M69mu*l~*BQru=k6}A%bO7)4m1H0EJhhR
zRBVf_f<jR{RcWdulh&9px{X6ynx^B#6vuIrPMc)3nyC$9l7B{%U{Ya5u_`D^2CcPY
zQzc3ng@_=igcq~Gy7%Rrez?m5G0n$(sn6`0Js<8l|NniS=l?(F!o9c`|L-9X!dYKb
zWF&3cgc%vdpFX(AuG;@#N%f@*FMY6*wz)Z2UN4WdwvxB5jvM`>U%F;xK^i~P{>^CJ
z0j7F9%zgG*mw!MA_pzV+)SHo?N93G2grua<H*|;NXM6DZEnH3qE~f(kheIHQz~Rs+
zDNJK%|9+HV5LZ&dfe$<Jj_4?*uq>OrVOkibMW{<7FFlg*^M6N+h#+dg0y?huFnji_
zC@0`7?aAbDdM4i8y9r53VoFH~KgxfQzn$vh$mwnr0)P7_KnMU<6{O*9Y()Be#FdoL
zbgqYi&-|bi3Iz(3l6>zQi4>_T4FCB!k;TP?XJ>Qswx7qJKL+4*0`&BGdF@0$b8{c(
zy8|E5TTwy$lTWgIK{i=4rcznk#?5{opzNw?HVI{#D8m52v=oLR1JA(Jm{6Y1jU(#F
zKFsK7?tkC75fu^1q2{ZcY3ZY_a}WThy^~^S*iUV9H)p1%;3=8KK=nI}o<2>=Q%~{I
z`W$K+KjFZKok*n+GC;sECKIqE01M|#XSuk{$ewqIdF(O5b8@(TYna#H{TJ=sLqvo*
zL8%D@P#C7fFeP0#hp9N^V@2N6EbRX$UFGG(dw)EvDx6F9%y@R}yF^dl$lU}?$&~0Y
z*3X|p%)vdFF)>Vk@kMaEscGz>w(%4Ex`9$Q&RC`b8IYKk#IzJ3F)i44vWw>UhbUi@
z#lT;x7-?!E)#G97uf9$7(JKfcf+Y|_@SUs#mij)%yK6VGYt|4sZyw#ZhS|E~ESIkh
zp?{=ADI3_dBq%vC0}@@A=!S(54uqz_l3eW_rhNYhC57uLx^<ds9uL#X%6MW)E<%9P
zb(F5#X+QNAMpzihTel*jqp7ZM=e;9W&<!gHtfWFI3#TRk8T5hJQ_anTsi~;}sX1^s
z9B7(`rfG;k*H4@S2q9=ME=G=w@bJ;2C`mQ$8%impl#}LCN-WF5vMc~PIy%UmH!n^g
zMC_X}F@x!unc(xGDTPA_1fT`}#{k772b&z~bMrAm3Xn>n081&P5D*?t>zOl?{{tC+
zzX<RPLn%}M7$Hzn2KUxnE<{8G+`eu1K<eScq|KTYaJjonFmX&QL2Gt4n%m8crlz|}
zFmZgo1WGAJTRw(@MK*!OWrxU^d5vM82|`1Nv3d(aL!7KF&Y*O826AYS-p!k_Mn_4h
zszUkw;Bp0td5<5bXUi7ci<eM4J)g>dx{g3EjFGXs-yQCx^-_!7TVpCPEro7M48zu`
zZb)W45X<|&U&PwtnG7F2Li>spxE{&muk*`nP{Tl(CPE0dz1u?g{Cv`CYLM5vDcrk}
zJx?SuJw6gWu%}^2baPzp;{=o~LBp^ONeIFERkL{ScZ*04HR$ws__V5u!40o}u=4CQ
zY8tQF%lv)_$ncNV7x{kKVJ`M7lDBUsp}ZXDre9K(@DXd5rea!SB<vR*^8szL5m{uU
z#!>r90na=-6K~x?t}IzX$m}dC^EUA4j>~lPcmr<$n5I1d!<4jj4)MeCdj9bCdBPVK
zl3rhr+1<tBw|_(R>ibDfbO&&MBq(bl0TWF~p84_DseUP+2f|G{OH1k7wTpq@ZfDs)
z5_s!iTi|$=7^bpIpzEOP2qDl-J9~F@lUMg%AaC74F7!#hwsR+m&pk)T3uU}9?HucV
zkb*Q#kP`?zoD|9H8**5)G?k%4bzEMyjF4~U@J3MuB|F>c?e_)m1@^Fin^X%8MTCYT
zgdoJJO?syD#xTXdZs66uErb^ok$&O?)<8dt->+cj$|)qpyT+~f=c{HAWqn4+<{d=%
zeE7G##xEKM>Fw_&DZw3-UEnY#;l2nPG${$q?M4Vea)R6LcKh}alx6M7tDI~7lov{~
zcxc-;ZZ$M8`0~q?CMNQA{1^eVt&L-ql|<)!i}UwoapBFA2%!;jm*3f84TaFq;G`!Y
z!On&TT)wvd=}9*_p{(LOxtY_*$%w_fdNq!^y5L#h1`+}HS9~8G25tz1Z~|fDC*xNZ
gCUEE8cfq~*FUovMW1)`SHvj+t07*qoM6N<$f^P>&IRF3v

delta 1772
zcmV<I1{3-34UG<vBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~2?0{hYc00x6eL_t(o!|j%ROqJIi$3N$}_wssqvm(^M
zTA;;Yk+3jvn{EmULv5zAPHEH4+7i91VH@kZnA%~CX_u{SblS`nv2WTI+X;!{R8W)#
zopW)WQe{M;A_yww#a`fgpO<s?$8)*h?7DxJX32m2<vDrIAI~}8@ALcpzTb1;ZrqLk
z_Yer-tS>4uk~VC>jEv&<ADm}L?LV-j`oe`5K3GoMtXwRwmxo$g$y-y$wf@mBT(i6&
zjUQ`&XS8k~lRX}0J@br9AcXtK4}av%$j>8k=1f9TQs^7H#nIC}`1}?wrvsPM0f56H
z5JG?8aA=eirZKd4FUl~8D=A^$hn;vwbd*w9mQCI;Eez8l)TNP^9!dDwKchuN5H)We
z9anppF(Wg|2{=o8vN)KYg?HypLXwi0R8qqC^Y7<RC%QOvvKxiKegp^sz>0!2yp4@W
zpO3hb5}MBRFz}flltQ6Efl`w1d@Ye8b%}rBKO7~pxR~&q9IoH=^VoAo0Gv*Mo<1+H
z9_we;?8o@_z(@2}R1p8f6D*yVL-w@ERMxg}z265YyK0(ELYXGYFaR(ug<;6RH!wLS
zl&5CL5p`$}W^^?7u3wLeh~z-?Wlpv9(bhQ#fYaVdF*NL_wz->AlT+}NWHM0w4x@i3
zPm=QFlf1Y#mzu^;*!N*4QYnNC5HO6}30M+<`7@`oR9s|a*E_^K`Y7SKxm>+5%xmxd
zjrQ&#BEp=Y)C2-33{zs5lCJB+R2=ZJEbl4i_y3iy@^a!m9#$02B4>I$+xA?br*Gs=
z0;XhAbQo*rP9kRiF3gx1roQk3xZQu$G<Hzi_z8a9Kq(t%EK`9DNK8v&S_+Vu7VJ6R
zMRWWEl&{KW;H@e~nwm)Uc-Z{&Z&H2u5<-Yz34{=QD?5S3zK`+l*h%cFRYcC2L-&ng
zHg7x4#VbQ7DN)J>HZ2KCPRxKr*Co1PA%p{=DX=7$dxt6CJ3>j}T8eI*<cfdC!<4cz
z9$z#YAwcOmO4seQpLi1^ER5vMn-S5`RM)rj-l0qAh7|->QlXTEQxkv;`atZ7=H|iF
z)YO2~95@^fG)+U(G(@25C(Z$c5VRK;BS%Jf@bF=j8utyQ6jI9D=2A*5%fhlO06IE4
zm_27soIr@!H)3K2)3dU`=R<!}3WpE~KnuLb0LS6EZBDSF<MS~>3Xn>n081&P5D*?t
z>#0+e8b+KGz#JV#m?l!!K?sym2u%xaBE-1<KM(M8Ln%}M7$Hzn2KUxnE<{8G+`MV`
zK<dGRq-ACXT<*>iOdJzS(3+Ej=5{l!sp*aqOdS7O0;LqAEgwU{0-Jxp!m<NoOuxdg
z&jg_%#8|xrp&?FI7iUnqGy^#_NbkmtSfit)R8^t;esH;h#Joq3(z9t3?uCn}otjT&
zT}Pl7#>m*+?+$m;dZESctuYmtmO?irhGFYeHzd>Ui{<^_EMRr<bcPQfqJ7yiTn}aO
z$GK%Ts9~T?6Cng!-fe#&d~QBzH8seq-4yO#&#uQ4nHnF79@x_`B)T~+_i+NsmY`wS
zh9rbw?TSp^`}G2nLk&7T9zLzAVsPEdEI&Pkn#RlaGQS@JGW=cjdA?hAkn{bD<gHst
zC@;sk;b&AOe8lR-shHLn3HwLKd>}}`HX@6R)HrHiF5u}$rsIFD+s~y%iwK#KO=aFX
z9@%!0jvjB|4*=7&2Vj_zw$35GS6<I=-#$zD{6f;}>oL2#SoroYsa|<6$%*a&js#^*
zBw(Tm$<sghD%CIMb6>bgXK5*YJ9aSetF0{gO9F51Zwnl+62nw>33MHF9U%m|X=m@2
zZt}|RbL6er&$)j-$yc^-C-K>533<MZ*QcCe&BG~3(*!wzz=KJVytXcvRf|&@I#9>O
zB})kTdM>XQRZz0Mo!)+5@LpgKyGgasP()}bLI^^f+HK!-UK^(P7Y)3!yM^$ABGQi?
z!y4#k;rkVAUp|SXc-OcU|7689qO8y8*tm@dpAY}0SNVTw!yvu=y(A^LgR%=8#w6Sm
zVS^?mp}E}%AxKVe+ud&89)hy0J${)pt)KFIX*LgR*}{#61_obxiPFSGo*N@zwzYAj
zvXbcBZ*caWY|g!L93eD9?(jQ1tf3GZ8l3b5B-q)|fXmnRZ$0T+CzMs3Wp>sSax-G_
zu3U+ut}Zxu7Px^#!2O@h?Y|tuz%_voP9Tin$@ry(3EcXUG4ICzVEhxxd`e^B#6he8
O0000<MNUMnLSTZDA6feV

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/es.png b/addons/skin.estuary/media/windows/subtitles/flags/es.png
index e8c4ce3e58af6f6d5d0c52a6ce0786bfc8424846..84d0a44a6a9ee5d81208482ae0b6f4e5c1b57986 100644
GIT binary patch
delta 1092
zcmV-K1iSn52-ygbB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wit=1D|BR9M69m(6Y*MHGd<Q{6o?9-D;NAqhzq{74}v
zh-Fyv99i-JY+12E;stmL-T|>>0ULINpdc@ZAdX2S#~yoTx_`RwWl_~VZF|B7DH~i;
z&GgiC*E#pxTldVs#kd&%_aUV6+sTbsUA{zodH7mDJFEwby{ZHz4&49xOWKopW|dxw
z(U?$`gsMvGMS&zjQRJ<>j|0Hk7I(+nHhqo}iw$kP1Yg}<OgH%9^Dh7<B~UtW^!qOL
zv*##p7lH^%8-E80AtX=+lUBgsxc67Mr+3SX=8l=;neyoR)s9SA0{E!H<_o-uIV*q(
zM@ULHXEF}`n$GCp8PJE<o?(4JY`(xp6)d3a9%v3{SZoM+bC)1TJ_H|x-;c8dR$q8l
zB+slyb2#gtDFN<%v&TChJwtXv2%-oggp>vW3PK@8EPts-?05`uy^GXYftq6mt>sjN
zDgNmme3l8cE#OU_fGf`|w*rUr5`fFomf)7aeN}?Kk^ym=P|iu72`krWCSZWo;5G7G
zaGoNMO~Iod$IOp}yR&(z;KTco@wkO{Z5~do$w8TvIuceU%prlrVhJ{<2!Wyyp@f&u
zgaI)|c7LB1RGS;Tx6`oy_l!btWt*PFY1||^DB+o74sGkSW)O<=1n?z+2H}LPz_Pr~
z{Geq2m*<oxSGaZW0oAo72mT!s4%zno^_|8c;DavV1i<p%=F8Ir%s@2YH35M;!2|W)
zCdYq_*grbp#bm<f%$ROpXZhDQVbY>2aUlH~7JoVC0nxf;a7U`LLIVZl5qX{SmfBG>
zYpHf3x30Zl|HTfEfBT-dW`~U4oX{M5fB#wneZi&6F8^}CM`u#dg1ko5sb~-~QNF!|
zvEzR(`Cz`wXc3q{Ib`eZ$Arp|Ezhg(xk0)5!bp31UyOLY<`mH6hy*4G@Vq`IE*9Lm
z8-Lk7dKaCPyubA`yUk02i93p5|B?b6x7;@@A5nK)&6*;#I;SBqS1Ufb`D;2pmAK7M
zNR9&Bj1SY(ZD#;FbN2gwoR41zuB3w3G(!a*esz_N+dJ57LXaqckfrPlNm_x3R~G*{
zFR-o~Dv4n3gg3T$_~aOPng~Rkx@qtjsecfm^8&y$jPA7koHHY|a>M}<?|lJUoF+zM
zeku{DN)|YwEGQH}AzLtO=gO0G&V>9G)7()$5>Zf>#h?Z@CM-6_jJGxk)rfHjlnUAZ
za}{@~$S#!D1}9FdD0@@Vzy`9?)<o*%l6qqd2bn-Mo$|;c<4SB6#-tDdJL|gtX+5~7
zPB=H?h{$L<?SB()0XKlH*Zg~Q2J8u`1SVZNUgKzh#l`=Ei}4TB8ed-9?I#%k0000<
KMNUMnLSTYH=>jJJ

delta 1101
zcmV-T1hV_t2=fS#Bq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~2?0{hYc00ZesL_t(o!|j#NZX87r#(!VW%<g(^2(d#F
zk{tLWg`gmg;mC93$OCZY#07~L;3;?q#E}DBxDkRtJ`h11lSs~b?cJT8>Eh5evtwsL
zNT3Lbl+-&jz1{tN^;K0Dys#Jce>WkOUresX>cW4^#HX|80@`8ST^>{=FfriHXP?lX
zE}T{VDMn*LRT8Qy&ld%f2u0yXS?>oxYFo?<Yuo%CBPlkt^$Kjgx|nY9^+z8AOiG|M
z;P~f#>PL@}9~XiM$_EDtAtaE4No!y*%=$OX@-z8lG9x9!obu?(rH)Kl0@$b`EtXgl
zJt}`d5{8hJ7dsh)eop6fFbA~ZyE&{4h%J`bsDdSw-G*j1C&h-~hnocM`4D{IesAXq
ztp6}q#D}ZV%;x=`65#gd2fY67Ba}`FK@>rRki#HAK`3O8CH06Mk0Gvgo*HY=WTXUb
z@=$~+_Q3&s=mgppu*L^q^5JqTFk6%WT$q2h1WOsbBQhjmhB!;eW8x!Yd7e6f1f&|Q
zM&=1;+4I;G-2Z0G;#im&+b<Wqb0;z$x6p2k!<ji5$VsUqk;;rYB(PkrAT20DpeRHr
z;prohfEXkD4-2a8E#BN~IQ)H1A-K3pPvR_YmK>Dvl93GB)@W0LP&`WjTM=jwMsR-x
zR^=5IM<s{fKc+mr$o1QIsV=WLvM-r1W7iJZXa)fr+!96rlAoPyb(TO%AR4fmfWVAk
zf%;&ZlV3(09v|^!GGTk3nC@O-_1i9C(xQuTApHgw9`k@`EjhR$Rj$xL0a-*=d))GM
z)XZC|y~y>;PdI$C$4@_g#jEofqgQ_>G$+=t-$<ZOxcu71Uk2FdTnJi_)rdML4MItj
zudQHg*sm+zUhFek1{M!y?A&^fP$iUB&#G^JL7Do*$Y)xgj99&)3TWITK@tRbT%Qn^
zOK#qZ>>s~@PD|d}`HubODItlQije*y1Q?e5-bh}eW|*1{NtkL6LuRg4ynlb~hg?3D
zxWTtbh5}rR_ww$xYXCY|`}DOhS0IBct6(+FP=R}&USjLU9%()yNEASDDZ7RwtwF?Q
z8>WK|8j+DjP5vET+Tq@V6X0Pc5Haee!D6IB1iTjjNki|>wx4I35naz%cfRgA#-A-l
z6C=@gWdc>n5+jrag#sve3ub@g=;?G#YH$nLpNwRNyd<KaE{j19Y)x2hjT!H36RHv8
z5GWPA|9cj9p~%QSH>fzRz3fPNJLxMjVx%TguU6DsV>ogG)pW}J6d6}yyGTq55lH8|
z?msfKd=oBG;+V*2I(3Jn9pEak^Y6j^Et>-eLMnkt7mnv>4X}L9m@gUZKWKjd(;8o1
TAC{Y{00000NkvXXu0mjf>Lc=0

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/et.png b/addons/skin.estuary/media/windows/subtitles/flags/et.png
index 38147aa53478d95b8c71dac1e657224c89d1dae7..29b8c174e9d647514cc2ffa8a89cdefb632680ef 100644
GIT binary patch
delta 771
zcmV+e1N{8{2#^Ml8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0007=Nkl<ZSi|j>KaSHt6o<bzP8?-f
zM9DqaJ0NXINw+0e;Sz|Fj&h~F0Yxsr4Yoldk?q*yd5>Z|6Mx5vwF^iz<Vn_yUp({s
z-k*sL7rWU1ZUVsFS9`Ty@U!XviD=gP{7x3pWqf@9hN=q#mLLeLrDIvd3!o^XzZmYP
z7J_0JAs7HYC_X5ykA5urUz7zOK79iq0+{msvEp&(V^Rb}9O4`xhfyM2Or7L8W>Fx`
zEe2((c{EcP{C}@sF2VEwP&#OQzy}3!hzR0<V2G1AW^qG?@nAM+k0A!1rg8Y)l*R{2
z2i-UW+kL<XL&RbUY!I?RR}O+HaMEZK0F0b*i+<As*mfU|Gk__+*9hQjh@Lo#MV*v-
zIYc}KIGU!iSk}VSFg1LyrvSY|uMs;&A2$&vqcq#l4}Zt0A6u;Z_}+5lY2K?$0KVMO
z{dh}P*RlRNS~)$pXM9J3X0tvUKo(b5@bEAK0NS>tX&Rh!Cje=Kr^Kg%)AeSCs!|k1
ze)b5U?|UpY-$d}a;^#6k1`rY2wmk*t`<|}r5E0A_=iE^we*!RGuc~?P<#Krn;Jv5o
zx>>=$$$!8Us4UA<fUfIi0TTIdy<{e9#sEntpXB@dd%L;0!8wO>j-n{?JT>LCFQyr>
z$)8aYRMmWi5b}Jp*>HP%8(&5tgp<hU$}m@ov40%-xjjXMzK?HSml|-Irsvdl3iRAE
znb|Qws=xRC=op^ca2&<CYYsS-GN|H*6PKHCzkJ_QRTX7fA|km5&ZTayL}T!&FF~jo
z8UpQpPhHoC476>_ZnvYZYrOY}NCucT;oK=Xcc0egfQEjnswx94;+IarX0u_nT5)}S
z&3e72D2m@c`%l$9gh10YY`0q$i^b)G_+l3W;1^V2=8|Yse4GFP002ovPDHLkV1hFQ
BUHt$6

delta 1140
zcmV-)1dIES2L1?;8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0q;;uR7C&)00032009920RaF30RRC30AQ~VX|n)eu9(8*
zjlANGz2lC(<dwqan#Jg!$m*iY>!Zu;rq1pFU#xPg+FPF0TYsL`Tc6fkpx9la+FhdC
zUZmY#q~2ep-e0EQV5Z<;r{M-+tZAm#R-4mSoYhyI)>xm|SfANhq1#!Z+*+dDTBF`u
zq~BYl;09o-Tb|TWn9@?2)KZ$(Q=HdSo!L~L+f|?3RiNBepxsuX-d3XD24ARFn$k>_
z(M^}rPMOwDnSa+$o7qpC+EAR^P@UXRo!wEM-BF+3241F8n9@j-&`6ZhNtV@0m)1&{
z*h`w)OPbqEoZSWn224y$LPA1ALqkMFL`6kKMn*<CIXOE!J3Kr*Jv}`>K0Y-yH8eCd
zHa0dlH#a&uIxjCTFfcGNF)=bSGASu3Dk>@~D=RE4EPo>-BP1jwB_$;$CMLJHx9aNZ
z?Ck9B?(XsN@$>WZ_4W1l_xJet`1$$y`uh6&`}?%CwC(Nf@9*#Q^z`=j_Ur5Gv$M0X
zu(166{I9RCs;a8w<mBh)=koIM{r&y$@bK#E>*eO=si~==qN3T^+27ya=;-MF{{HUo
z@7~_tpMRg9o12@=%*@r*)#Kyi<>lqm)6<oem7boSnVFfOprEX*thKeZxVX5vxw-%U
z|Gh$K?*IS*26R$RQvd`E5F{`f=WLSz0004EOGiYcS-yI?00007bV*G`2j2+=02~2?
z0{hYc00HbtL_t(I%iYswPr^_XfZ@_ADh}LR+<z0?3tTvHD=u(W6ciOvv=l)B2kyQ1
z_K$k*1rrjZUrl_IHa)#hPWq(;@h{?Vy|_Q-#pMvBw-1l!>*pW9=LZG_<AMVD`~ZJH
zUmnlLn<S`^(6I1`$f)R;*f@b8J|Q7qAc%{NiH?el2oDPlp$IB5DLExIEj=SMODGhH
zvVXHhBB3xVGb24MH6=MI5kO9EUVcGgQE^GBSS*p0l}RLGacN0$QDH%TUTzM6@`}nT
zX?0C)U44U0CTnbjTSI+aZB4bbs<NUSKvQ!|Yg>Cqr(7=Yas`i_9qnzcEzL~;x_f&2
z6bdD(-xVGdioV{SZUmGAgF{2Z!|3|TIe!lhC@~nJM`>E6QjNI<BMq-dFc?>B)Ds%b
z#H3qjhS%d5&|2-(G&JKDny0i{8UwXXH>=m{=k#u&VOFP8BQS4RSY(W>X~}H1Se7A+
z#cW<Ou|{Tb!7vYC#bC8D_EiA*7!v@icE)C1TL-X#HaGzYhXb#00mCMMt?eD_u5F#g
z8yt?kJs=3McH{oR;Sqr2lhd<(*x)=rKX(e)V7xfHyaI52b9=|&^JR371o{e-iM8E7
zJOX%netCU+|M=ef+w0RaMUWnzzvMv@9FqDalJnO;73vf5anYYr58^Ta0000<MNUMn
GLSTYSASrVI

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/fa.png b/addons/skin.estuary/media/windows/subtitles/flags/fa.png
index c0c356a2a9b79f736f78dcaadd3ab84bc5a72f79..99c9a567290983ab8c07ee116415b602c85cdacf 100644
GIT binary patch
delta 974
zcmV;<12O!^3)u&d8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn000AKNkl<ZSi|j>&59&N6otPVSyf$K
z)i$kz3Nqld4C*upf+E6f#aHkNd<1vCfsf$Mojcb)!JsbO*ngwrPY;S<D>dCcU0qfA
zcaMvV%*w2v>7@(%LSzO6#5r;9jdKHT;wJv@VE}_qKGJ^yo_+SE^#Di`K799mW<`#L
zfF%LUuwWHOYcV#fC*9qo_-ma-)kiLnQ0d5>QLoR}-#q}JBH&KCSTHYgLNF{u0%l-V
z?PJ!(+(Mw4N`Dn^sUjsIcictNE5W@*Kq4(m3YEwWLtO;`V>w@*ZcEgl_1u>POd>5q
zLpUlR3Pk3P1w$@E2*@LNFihQ4V5^|rxoYVFlkf;G7yTe`brs0HB=Z6YRULSx0tS>(
z{#DtZsX)V|QAF<G&cKs(1u`$l++*$(^B;4MAzMB97Jmui&!P&bBB5A>sKTlhFo5IZ
zV;vqIHhHsHfM!MrVOjZc?P~HHSMwP=qgxCHJ(6U=V7SkGcFu5g&=R7OUbO<P{ZCF#
zI66A2uA#e==Q)x(z##-AH6+Xo&*xm6KIF;IU-2~U@#ontd%J<#ci-ccSKnedI%vRZ
zaCh$zF@H0>eG66>>(ROQG1Byk%gHaC{qcY&XH)LKvBR%_@9_J>3+~*z-*q{&&Yo=*
zHWFB~$rhP<WQ!@&e|}<iIU%22aB)87wU=Ka-76W5_tyy5z}*_vW&-U~w^eAz!Hb97
z``}X^CsX?Scd_1>tMrUr{RPUOd5En9%Cg+vEPqxu$mSQEeES8brxV7yO>zDWMYbTH
zpY!}XPubgfVGV3k)R+eF`JG#O`_0#3dWo5lm=WS)K;4?S&H`G%lJLq`aiFYgVDCA;
z|M3wYKb};#phPIkAkUloujo5!`M#|fo^5eu)uU-pEr*n_JfomxM5TbTKxKhq^Qplq
z?0+Sxjb5Y;MCwksx+bBbtT1Z=IgsT!<T-tV&~iT6N;_WDq5Hg0T#F7|rJ|LVQs6~S
z-nQZ_=`j~1At5B8s)4ZVf1P2=!`F3DgBXqTHW4BjZ&`9CSR}oc0y{%ygCWDw9>YPO
zK@#YNfLXOca~rgLpKKz~^dDR1-=pk~VMh{0Ua&}0vcYgkpg$V(L+T8HabgS!1UIhl
weY)<o*Gf&*f93^TrcQ4(x_J=a#7zM3FR-&MT8ONmp8x;=07*qoM6N<$f(AIrsQ>@~

delta 1472
zcmV;x1wZ=P2geJL8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0^CqcR7C&)00032009920RaF30RRC326a~kcv?)Xl0vAB
zL#mHNt&v2ol0~qSMX;1bv6M!#l}59c26k9Qq>4G9g*&2#Jb$E!Jf(>}riwkMi#(@`
zJgAI4sf<0UjXt4=HJ^espo2A{g*BswHl>F)rieGEi8rW<26I+Ap@uJ=fH0qdFQ9@k
zqJ%J`g)yauGNp$yriU`8hX!(0HJ^hin|vvqekz}UE1-cZp@J)-f-9nfETe-gq=W`=
zR4<)>Bbj<5ntyvFoqZ*qekGrNC7^#MpnxTzfF+`UC8B}W*4Fp;_xASo`1ttw`T6_%
z`~3X;{r&y&>f7hx(eCTy^zrET^zQxq{Pgnd)YR1S^78TV@$>WZ_4W1o`uh9$^yAaA
z(XL{{r)H>@Z?vCr(8H(d;?&a8((v%`^z`)f@#)sUj(@<BDz1PY<EJISku0*BV({$Z
z(9qEC>D|h!XSReFsdfm|mlNWsDciJP`uFh8&d%@e@BaS&^Y7!+u3Ol=f7!r_*SUG%
zxMBMC>&wf_`1SA7x`n%!NXD&q!ktOJmqEFXG4bo&n;;X*NIA<qEX+ME&ps~EJ}%Ne
zF4R6P)qg)O)<7@UKrfge63Rj|$~Py>I4I9KD9|}5(mE*9Iw;gTDb+hE);lTJJ1NUU
zGnXI|l^+tyKQGBNBg-`;&NU>^H6+nBB-1t|)HWs6Hzn3LCD%A5%rzv+G$YDCFq9t>
zkRKAnIx5639?38s%`hL&F(1$|AJQ@)(=#B{Gk+k}Ga=S9AlEY>&M_a$FdoM*9>qH=
zj~)?<A{M(jD!wrx#xx_*Hzm?HCDS)0)HfyAI3?LRCeJn`zd9?2Ar*xw9<e_%xkEO_
zNjuU^J=RV?*H1s$Pe0mFK-*71+fYE<P(a;KK;BV7*G@jwPCw91KF3Hpw?Q+3Cmo72
zDSw7IFpfVqnMORJNk5}XK%`1Qm_#~@Ix&SYCjbBdsX{lu00006bW%=J00ayWBrqE1
zY?A;000Cl4M??UK1szBL000McNliru-w6c(907y^`_cda0!T?jK~y-)V_+B-fRPO^
zU}Ruo=iubx=Hcbz=jRs?5Cj4N0U(o)mw$(wi<5($iGf*2SVUAzTtZSxT1G}j76^cp
zw3MWTxR|Jjun;o?Gn<^ef})bLii)Zl9H^?OC@U!{$jh+-6{u@yYH91}>gwqm7#J7=
z0g%$y)790{*3#5a2P!Z!HZe6bx3ILbwt)j{D@zM=GgA{|BcK9XJ9`I5CubK|H-9&G
zcMl+NcXxAhb#Zobbg;Lx1uF3L^7i)f@%8if_YVjR3JwVk3kNd&e0@OTo<Ic=kx`M+
zF<w5ge*SUs35iL`DXIQ`u|8fg(Ljj^pn|lh^vDcvFJGX7%&hF3+`Rk(paNen?~KUw
zs5GF0!gP=VkO2Wj#U-U><rS3yAb%r33epRK3aYBpBV)h@1k}{l)i*RYH3xu=h>1+E
zt^z7(fhYjV2eh`ecXW1j_XGe{Koqn974-J?PnbAq@|3C5rcH-}Y15`onLKIYg#Nx>
zpn@4QXU(27ci#L33l{;w;>93x;ez?|=FXWtYspfef@RBBtX#Ev&DwSA*MG0yuwmoI
z4I6-rb!*qGUbSiSmaRYq+qUo6xoh{Hz5Dj>KXCBip+g4`9@xKs-`+jD4<9*t>^M-t
ziIb;JZ#r}K-1+rD?H4XyyZ|(0{rPie&s<u0`tlW^f~(iA-?(|}_MJO-@7;g!@X@1(
z5ANT)d*{yW$4{O<d;S8b;5p^1*Kgjwdyfg;z5Vd<6Eg!73o9PL!o<MH#Eb_pF%ER5
a0s#PNvHPcr1R-1i0000<MNUMnLSTZ{e7HOS

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/fi.png b/addons/skin.estuary/media/windows/subtitles/flags/fi.png
index 39cdec884ef5df54c0c41d2915ddf8e0ce10dbe5..faf499af595ffa279adc725bf6a8517d748650e8 100644
GIT binary patch
delta 800
zcmV+*1K<4E2&@K>8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0008HNkl<ZSi|j>v2GJV5Qe|mJ=;3T
z5*-yv8@WKZrJ{>?0h)9a)QFd$rQiWlBi<m2gs5nUWC<i!D1Q|%kl@(9yWOF<+x6c0
z>?ESZBb|J+zMKD_*_nS24tB8r-2`AhpQ|wj?|tt>lUE;F{`~X1e*z6ylgUIf09EDa
z=m=G<S&78U7{l57Hvm{`5QO97<M>>7Km3OK;Ct`mdK&-g>I#4iz<W<wmZ)kA*cgMV
z^5y$4K&bJA(|?!GB6tdx-lyQ+`xX%qiPeq-(m%r$*p`)Rd}(Fg+DnlZiF7T*ORLaJ
zpf9M1P&oxO64={R9ddodLRGd1q*<p`C@Z%&`@5=;#_A>DoZB0;tbF2|Eh1guE?A!h
z%q;>b;}EDQU97&~A2#Pb@ls3y7(RWiFP=~Nvn(;jG=Et(FNmN~G$f5oXJa?F%^T9J
z*Hutd>uDJ01HOKnQT#ZobpZ9OOGj0CR1}fA;l!9uS>>L2cl5yfNI+Csmku=P0Z=NZ
z6qT>{Q^1Izt}RRtB@l%N#j7G(H~Sz?RUn{BS-EDf1u>cc?&$tKThMMk-4OB~R2dFT
zd|m*~&wtN#I-MdSSZlG?MkN#xrl%iCdYqr1-tJVwt}LfY=$ykjhpIB0%{VzZk=7LK
zQn+>Lw#IIs9_*6nbYy$Suq(lBA>vLc?gQ<MDI!!=wIL9k?r9dRZcetEu<tayZ&g|Z
zilU$>3aqsZhr?FjnypKkuAR|cB@cc$S)KQkRewcM6dMAo)r!Sp5y3+f27tl9CfQ4G
zAEakVcP*ZPs(9yEuU6dN-fjr2*K2NWZpibTEX&CAJQ6U*@Z|BMCQ$$3(%p*Shc6#%
zE#7;i>9@sV(I#N6<?`~9(P+eYJSNX`thF)FaQVBH*~P`hgFnMU=P#E_uCK4jvh46d
ed>OEV0q_@CDdxruW`wu^0000<MNUMnLSTZpm3qJc

delta 1102
zcmV-U1hM<92G|IY8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0l!d8R7C&)00032009920RaF30RRC3*VotC+1UUrX4cl$
z_xJbq_V)Pr`1$$y`}_N!vdf~i&7-x>{{H^||Ns5{{rvp=)PK~}^78WW@$vKX^Y!)h
zUVf-veyLx7sb7Dp`uh6P($eto@bvWbS$d^fd!|}@r_j*QRd=LSccsqG&hPK<P;;SB
zbD~jnqsz<7OK+b{aG}V^$VF<LMQfZ!Yn=uyVMS(<IbDo9UyeLrkUU_KJz<hPVv{^#
zlRaXTJ!6#yEPr1<VU9IfiZoh_HCv4}TaGqekT+hDH(rtkEM7WZjW1P*Fjk2#SBo)N
zj4)V@F<Fi>T8}bXkOnJVHCl=(P=zT`hALBtD^!UqREjH9i!4=)ELM%Wy1MG>>g((4
z?(Xg;P>Cf_i6u~qx3{<K?Cc*)h9FFbw6wJC?d=*zgMS)FgtN1=u&}TcLxB}UffYo8
zudlDFs;cDV<mcz-5I=qpKz|TGfa>e(<>uz8si~r(qTk=&=;-JbM1$_{@7~_tpP!$b
zo14tc%+=M^<KyEoT97hZkuh44GFy`6<>k}U)0LH#o}QkWnVF!VpscK{wY9alxVX8w
zxi?XDXn)}MH2?qr26R$RQvd`E5F{`f=WLSz0004EOGiW#47*&G00007bV*G`2j2+=
z02~2?0{hYc00H(%L_t(I%iYuIQ`0~g2Jke&RyGG(5^{KijdDe#B68EpS>!CpT_r^X
zYrz9AJn_C21nM8`vq@nXKk(HVpD#Pf{^r@4eSZ^<`!5m-N5X!NBH_Oh35Phon1~{g
zWTm9!*zstzv@{x3HBD1wiM=o8IiXB9bkicziIb;Js|={Brq~j(Ol*`1oKS91-4Tg=
z=4?g9UV~!GM09j&lmk>!1|++xs=B%W{0atWB|wc!b&JUMx!T(E0Vq^hI(2IR>H?s|
zVt=s<*x#!NKpjB6OHG`hTx@8#bO7KCle+Z)jZMuht!?cc@pvMUxQt+l$2;2FT3ec%
z8UZ@Hx_f&2lF4NMmHqVNv9GtMyQ>pmU~p)7WHgl;8^5}r@v&5DbYysFZ~$Opa%y^J
zb}pU1hFnM3noiHn&P-2DP5{h%nFYhN#D5!$i#KH(k!1<jY?;PF#+wIN@|GDOx3bx+
ztsp)j3@m#~0JpuIYv8U|R#sP)AU2znW4O7@9e}&60pQ;KwKYY-99cyHcn<&`K6;$f
z9g93!Uw^7;xFgMPupE;<d;S98W#rWcMFR?6YpVY>1j97nY`lF3@czTcPX@;Q`A5sw
zZ`k)o#RRe3?>~M5Y;OJ9-r3FPe<S&W+1=UR+!8px=*S@{;<*qn91=eCuYW3*KT~OS
Uaj;J)y#N3J07*qoM6N<$g5i1=;{X5v

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/fo.png b/addons/skin.estuary/media/windows/subtitles/flags/fo.png
index e565104f9fe95f74f41713520a8eadfc8f39ff29..844cb7953017e7f3d86a56e355b3d939525b4e75 100644
GIT binary patch
delta 927
zcmV;Q17Q5b391K>8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0009wNkl<ZSi|j>J&Pn&6o#L3Z%xk@
zbTEl5f=)O?gUb%eDuTF}7;LiOPcSmjPy`b(k_`;RA7EhO4}TD&fkhP59cCF<VfI6q
zKr}GYneD0Wx*x~j_N}R|uIbsu(7w=g-|DLKK6O6cDp;-6`oAv$I6OR5V+=9I-jhbR
z4!HCEM*zJ1+Q%Gzu=Afpv({)dk^(?g+1%VjRTGs+^D)No#XB3kaPt;oEnhzS3ftSy
zH0R~(^LPH8_kS_Q=6E~)(a}+Y0f;f;oWnVX_a5&(Ap~NKgb=v>+uyi5d$=EdV)xNM
zb0TfAu5dd>j+=FIwi|#hVZJ*N!372H!FybY&3|*XTym@(FY9E0q7Bd&Kt%A71i%bt
zSyOdDL}VfMxd2__yl*nV3}%UVSF9VW7a)YNG^mS;cz>T@qAuKNSGX(Ix3cB}K$|!R
zs)K?{0JYbroAaJ{3jnWwevj)f);z8iV+>*ph)EZSpa@k}fk0JNT>tDYbepa-1)vBD
zxw$o>F%n~BI1s+Qd;iRczS-K=t!vki$pnjFMKA(JOmmWmAYBJ*>vw*uYI7`VBq{_|
z0*YR`#DBxRJ#IXFkc=oQm=M5w1OWjN1B5g23jlhIA>DmGS0kbzC=vp*R!Sv!>!tU&
zdgTg_>j=go#v}j{W;ERX@e=^vc=f|4%0a3^Dn%+oDgiMt92kD)7kKn;0{HsvEp~QB
zhzQnNthE?pQa^~W^XWar)c{Nb{QCaYg?Vq=aev!z^2lXJ3?ZPZ92`t}^Q+DjoabiK
z))cs)3mv_@658t(y<^z5;5j35t{KUTthnn5eFo=ezES|qru#I@s}2ewHDorT^PYxJ
znw2?#x~{3~8fz_s!C)?MdKM@;%YX~>mVHsm^WGSfQXeDEd+NGA1DH%EjK||fJU3w$
zSbwtyv$lo+Yt}BLwhh}AZ`*WKC5FIsGU4>}^bBA+opN$=LRpp+ML}7X4S+F*=Qh?c
zmoFp0^BaQ&@op*dKEL@`Yl$%;vwj<o$MXQzTK4z%SzljgI2=-zCDz&|(BRMC`L3R(
zZ2Ym$?(Sbt{Th}#zp5&ZkB=#eV)a72S{SPZz`sU8E5>vmqNxA?002ovPDHLkV1ir^
BrcnR@

delta 1211
zcmV;s1VsC)2gC`G8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0t!$}R7C&)00032009920RaF30RRC3*VotC+1UVKr^+NI
z*4Ebd_xJYp_W1bt`T6<#`}?2B=k~9!_p-91%jy39{{R2~{eS)a{QUgX)YS6w^6~NU
z^Yiod_4Qt)*YSCJ@_Bn-rrP@Y`qI+U@bK{T^z>Pw*70?A@^yDwqu9{U&{dz-@o{qU
zadTCm*Urw)@9*zWoYnDdZt`t!QJ&Y!%gale)beR+Oq|xp$jC*P)AD3yMwrzGTbf0U
z!a0Y*JBh<Qi+{yDjK@8V$UTn9JdVogTV3f~T|JM?J&?^jj?1<tC)`_H-BVQHQ&r<s
zR^?Sz=T=zgR#@p*S?X6=>sMK{B`4lkS>8`j;ZITHP*LVlQ|D1r=uuPYQdH_wRqIn#
z>{C?+Sd=w|!6|>gDS^T&gTyO@#w&%#D}~4_hRNzqP=D)AP%MYaEQiZ1hsnCSy6Woc
z>+9?8?(Qao$m>Z;C4|bix3}!<>>q%~>qJH%fyuPAwC(Nf8hys=KS3IP$g{Jvu&}Tc
zdd2HJKI}X`6@169udk}As^sM4=jZ1Tc*N>AIqNq$5P8Px>+9v_=BcTvqN1YT-{0uy
z=oNd$?SDKz6@1C=@9*B;-k+bJo12@=%*@r*)#KyiF^kRaQ&sO%RWgjv<>lqm)6<oe
zm7boSnVFfOprEX*thKeZxVX5vxw$uSoUu(#N^F6!00006bW%=J00ayWBrqE1Y?A;0
z00Cl4M?@9n*!iOX000McNliru-w6c(90DB+s()wz00I|DL_t(I%iYuGQ`A5h2Jl>h
zcfclD%aM>`35f+oVnIZtgGQ+bC%v3>&?q@X5IwPB?_%!_1P=a3-%XAg#t(dD#^=k<
zWPkJQ%)T3n`Y+=12mEf5Q&N)s|0Lk|QFJO|S;X;p<EG79g2A-3U{DZ65%V1Ro=Q_p
zx_=}~ii)_c+qUlz2oMAjYaCJ)*hpt6CPUUGgGKz#UAy<JG+>QKtRd-g27pYR08ZPx
zFKd4SxD^EGnE<j)T~ZOR9XNRCum=(qs-&CQ0CGHlkL2bah5eNZ599#IGj#<{z{m3Q
zkFNr7hN7E!0166=ic3n%$}3Ksw5(GQ%YU*?SCp5PmJ}Bi767QMs;;T63x(<%!r|~4
z2rLctp-^3IO?6czfX1fgme#iRj?S(~Bytu4OIK${ds}Nub5kRL?w;Ph{(-@v;dAG0
z`vSza?Tf=hg9H72y*=FkMx5xVtf=gzv9Zg%2H|-Qu31&&(Wo;5VBDD?09~1!ynm`;
zh)WOw6V5n*Yfj9R;jXVwP2Ip=G%_heHe=D70B(^60JrZ<-^Cc_NGcM*xd-6>gNHH6
zP|>5uPo9b*+>z)usD`3Hd;S8z%fPD{9U5Lwzj-SP?rZRdsl1zc{{g_qPoKZYFz&D4
zzW;!IcT_|m)%^MEH-Oo>Kl2NV@ih3-^72xAbru)qXXhA-PTH_Wl4#0DGi!wQt@lqw
Z@)u8QhO(2U<`4h?002ovPDHLkV1j=(bbbH;

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/fr.png b/addons/skin.estuary/media/windows/subtitles/flags/fr.png
index bca5912ac311ec687256a11c17953d792781d6d3..5033a7e393949f7860c838de3a34ec15492cab18 100644
GIT binary patch
delta 940
zcmV;d15^Cn2f_!CB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2witPf0{UR9M69m%WZ0MHGd<Thl#1>qST)S)>m93WP*R
zM5JU$L_CKRgdFikegI1r2@;5e2niyC?b)8`s=9}us(N~Uc7MH*6SkzD>glQOd+s^s
z-s*ve@i6}H!!Yak>UsS5YQ?`d`#Tr^`qS6<dg$BlzPa=F@aP)fzT@+kzw{ljM)3Um
zFWK%=g=HA9>KF7~IRKtMeS(=`W_4MaB~7y=#%Dj2?=j&i;c)~BwXD}0e*5tmz`6rE
zaDM;uHGlsz0Do2hm|+&Cb1=UB;>i@K1#hE)0Ej=oLJ0Q~)FoU_TM|C`6ffsp2e4ci
z!#)v{g9XgM0)ST##{o}+w`&uKoIt`FSb<dlF2R0>m(X+-K5vFd%uY$xFb@?(4Q{#^
z_!1CO#_Ds8B1=iR%-U}8y1uIf5>uW4SO_Js8Vf~&+kdh@V<9KhWT}S%xPw%Dp*a9K
z$wkTnbIc734igIn<XNVd=m#vNnKv9%4eDN=l5>$_4q%MVm>dfMvl`qS{E+><M~Wqo
z%AF>ke1HqWf_w^Kzuz(J5+N*#1T*)mwv63wcdHTS3=G3iH8xx-6(Pv-sWLJr66|A<
zLGFe2T7M1oIY;&XJ};0nR_i`UxP;ZC)M-3rKqMDq5*CD9gwPs?uwd9^#`goTlqU13
z3Fuzs5Z3kQCX88($syEi-J!YP!S2xu<{p^3PBnwIQk0<U$efxmIb$x1%xbn3fSI9_
zGQ16dBrFya+SH=!M>V5jI<JBvfzP^N0U*MZ{ePu>;4%ZLc%Vw4hN2z5B%ew!rXqux
zBd4@r0LxP~oEq`AzCetP4q6=@SP+&X>6n2`%1+9;q(8a8$uLbv8_}iRuvJ0nKJA(&
zOCX_~PXKr(#z>4A!lDND+6zMMD2JeT$sh@}Ml?}hyGbp{6eH1R0D2OZ_jHtfz!p}3
zaDOo3rQmY_b7n%<m*!LNl&T>m+?~CPA%p{ft6pqE<fH2)-FijnH&|FyIqYKZzf_V<
zg7Elp0aVl{6cTWEJVtJY9Yfb206bbR39tX4TdnB#S1kHfrT&=W7cZ9g+6s1WhjVFw
zEHR8DZ?-pdo6Yo2cny38Tz}yA(RaXK<t3#Q)`xe44>l68d-z}QF#ZGUmNQd+?QvfK
O0000<MNUMnLSTaW%&;~9

delta 950
zcmV;n14;bC2i*sdBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~2?0{hYc00UD=L_t(o!|j$&izG!5#eb1qJ>4@qA}B0g
z_po2VqbI?WS8swRKgV7~_T)F(4<LvaLGj{A(9`Pf&Qy12W;_p(SyTOIW(O2OoPg@8
zuFlGM@!pH5hKG2F|9co_1D`z4?_R9<^Ll&d;vav%`Sf0!zW(B~JAY4)F7c~3eE97T
z%K=y;c>d+bTy08&Wf-tpE?5q606cyA1T(|T+OjxHn$D8gJ^L!Y=Yp4l=N(9>SG_*x
zr>~y@tOsBK=jUHv^7|hnU;)4kvou|U@%cwjrbIn?j}8JLfBzjqxJOc#a5;TRdhdNa
zu7`gC;A~-x+d?i5mM{ZL0Nz0CCp=8v?@b_T0SW711=aw#1ltWBsTmr4UX7Vtoha5Y
zPYpy%ZaSIx6c9?q+P+4}5+%o3S66sjKQsc#rA`1WrAVyKLP&61^+zn!g1Rj2FaURu
z!WWtYkW*ZgDlo^~u;ehY5Fn2#Jw-oYrObc4;h<(v_t>S@kYWyCmz`a4EG5iZa&z#T
z>hB#TM<T_OCZBwO3(|sm2w=P2Fm4JdEkc5s`(vrG*=%k#;+%nT9Gk|5OVJU6DxW%|
z?s-7YHiryy587Kdw0-va|7~8NR;=}Xl5h!Y2LL%AG9ZeJT@jXqT%^<ohp=SWWX6BD
z1F%vi^QjBy-sBKAERRi?tJoEX)T(ud?tTZm$1Iq8V46D34Axswf?=R?Xu{&`YAiBq
z)iwZTh7Q{BHUN^a9454BM7NJ-M&)wc1tEdYreFXNX{!Fzd*Cz!B|Ok1P)E@ZKcgN>
zuqz>hnIk7gFo4ym8xD=Qr~CYV&Ygb_dLP}eAgpA{J_D6fol<L*Ke@llFrD^ZM5o?{
zy$fRc^n02tfrM&30N|CJGdWjCi<a2iEQqnpEa_b`NJ4!OP1Lt((ps|QO!gUoB?YTn
z2I4(n3kx9J81Yo{Ie<AcX;{YaX-`VckP`0B*2S384S<WKI8T{(F3%X&E7E`R97~HP
z$8oi{4W%wYdi*#5h5Do*0e8o9=6c*P4$B(=kJe|Tm%lKqRxGy{ES9TA{XWGnUYv2C
z*t{N(r2(qMxZCmS>YCyFJiudi348!t-fQ=NF5UpY#h+4GGyOOC*P;NMzrD*t{O98@
Y>y|T9(OLNh00000NkvXXu0jG}g0h*lUH||9

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/gl.png b/addons/skin.estuary/media/windows/subtitles/flags/gl.png
index 33c459ef0f9f07c305baa0c6051db962d663f71b..e47642d1d6708837313bdabbcd2cf0f8af65c0c7 100644
GIT binary patch
delta 1132
zcmV-y1e5!P3ib$)8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn000C7Nkl<ZSi|j=O>9(E7>1v7@62@m
zm@?B&r$3ZZsF*5B%1`PK3qu1+q9z(iG$t-&Ym96(F-A;SxPLJwuIq*bP26ar5+No~
zG2(&{qX<&kPK#4$%e2!n?a-M!_ngng1=}fwOfjtNm%NMl&YAan^Pcyf1FN-K|MyY=
zdyid~o|ZLUM+5{q6Jd6@tRdpF9^7!Hln=nwhN5e@;b=rWRTF>Da4tK?i*0eb>O&7q
zgbzS#&Aj6>?|+(##rcB6=YNi~EfwXJjd5ZDyJFpSOBk&Q)P(=r5%i5t%gL*=T$w3>
zt!{M}PZDAwo7Xz(*qIC?#()ye^$#;OlV@-DR*V7LwpTRV@AoSO;5d#HT+Nq*IZkC}
zy;XaO3N3)*>823R1hd?n7-Kqf6|ohuWRk?X7FwG(6Mqg@??xaH@B|c#MY-KPJ6WLj
z;w0Hw2Yl8NHxxd1o;{gg*>QCMUAO^03(JaNwYJjy>V8s*rm6)5gF!EZ#w?uu_C$z>
zx|`|!YmyUJW|nco<`Nd|)@6!~5tJD8>?j-J>q)LnRd7`u!li$T+KPi)l04ZE=F{IN
z7|WNyZ+`=xQRl4ngy&MUrROmQCR6pqHf*C*Hr}?ChA^Mc%iT82I-1WeT<4pi94PNj
zsJk%EOgYNt;51Rc%h_C#hH#O$Uub7v*Se~Q$6_&$(HL`AM0|?(x2E{ysaE1an?hOB
zy(vjNP-M&vGU<lU;;>^=oP+%{e4EMNlW#Hpb$=k2%SkngXI<gLQ)zzw;Ud?aTJ~?L
z;gLq0Lnn%~M{Y3O)e1&<uC12CJDX_=1@6h0NF=<kAe+sKQmSg}-aT@j^Me<8Y2#5q
z@%6wy9)EZjU)X?cL9tAI)X$+EExg>mc3BP)A(>2iN1(N?+BRbhr~k+>m~X@w!5G7E
zp?{5E&W|BRBcc%>WD5>&^`$xR(+Hz;#XC5()&N-EmFliYK+j{fM16|W=}u0kJDDrj
z^F(J7BXVnxU=$cjacp3cJ>T{7)!<YGhwHiv0#@okJR0R%2I@j1)P+WHr%N2aG>zXa
zBSjZ6W&yS$ceBhpeZ#!jm*!fbRN;UE7=IcXlA4;Dsxwe@TzZcWFrGO<z`BXVdidz|
zZq8&2ymw}lk?DExTX()Gj-f6R;DhbWJl`Coqoc!1UVneTghDHSa$OBZAmCf*&AFP7
ze;eoMr71+jyUv%qDIp7XHPrCqfj#QJGH@G~GWe{@Uf5C`-rmHK-5Y4D4M52SV`Ubg
z1Z68urgQfn!fLQ973TYAH}b}#^(bvTyF@%-FqT;mV2nX-C0Il%aGP-P@8$L^?TH9s
y+u~4HBS(AM=}d%(AVho$B_Lv0t<_pBfPVmN{|dy<*^Ds&0000<MNUMnLSTZPrx#BE

delta 1276
zcmV<Y1Oxl_2!#re8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0=Q62R7C&)00032009920RaF30RRC3Mzz|B(C3NI=84Yc
zvf%La`~Cm_|3b3Zfz0J{#^Q0s;&R2}a>C$$%jC`K_5S|;KYy>)c*fyr!ry7Y-f6zw
zo7L&>_xk<){rUO!_xAI^<nMmT;$OMjU%cF3z1(fW-p1zf`}_O)`T6?#_{Y=Nw8P2x
z`1tzz`tSDlmD1%@wb)d+*;KXJkIv%H*3HGgw6vm`v!$BBy06pL%JA^;!{qH=y4gvs
z(@C+_NwU>RvVYc1uFaB>l*V>%!)su}Z(_x9ZO4v^;pX4=_V(!U^MlCWJgLt-tk7za
zma}+CtAkXmf>Nn<M#-Ox^z`(+-swuO(lMdSF{aKjrp-5#v~+A>lU7%eR8)OyTDQNw
z@A35V^77^E?{>l2C7#D6pUF6Mu_$l7PIs(Ye5fUAy?;A&wW-0@vDoA`r_36f#&4I#
zId!!)bF@Zyu_9@=q}Al^?(X60?O&<OB4D8mTCib;w~L;-3Rki#VxtO^zzUJSQn1d|
z<>>3{>+J08VvWBwX_bbHIfjcmG-iVbkiQ3$!3T@H8<)YF%iQSb=<4d~BwwNtTdjnN
zI1^i<Cx2k329CT2lD-CyyatTB28+5+t<2Ei<mBY!XN<8OU#>=HVFy;WUx~W}jk^Sp
zyab526_dS_#@FHD;pXP%c$mEdLateGK?6mv7h$RiiM9iXxC4v11Bti;hPFzm#?Ia0
z-QC^X-r#qZyI*;9WqWF5iLI*7*&&s^0fe*xiGQ{MinbJwx{$)u+}zyR+1cXa;@;ol
z+}`5W-rrrV#{q@30EDvuh_wKPv<Zi_MV-6V)z#qO;G)OWACtKNfw2IFvkHo}1AD2_
z(b3-C-qYIKUaZ9dgRuaDumFX!3W~D<eW%aQ&!xuFDU`Vjg|Q2XvjBXh0002q4vIto
z0Dk}mbW%=J00ayWBrqE1Y?A;000Cl4M??UK1szBL000McNliru-w6c(90DB+s%QWJ
z0jfzvK~y-)V_+B-fRT-zor9B$n+H2!WMJau;};MV5*87~3YZv}#l$6mKvGItMivO<
z<YiF+GXt}NqLQ)-5GbjtscUFzX>01JBYy#)0$n|Q0|P@KFfcMUF*P%{u(Z-e0H6XL
z9UW^MTRVGudk04+XBSsDcMlx|04neV0xxeLA73Ew^A89N3id<-Km{RS5E>R95g8d3
z9TOWDpAdooKm~~qkd&N~nwplLk(rg9lZXI71y(SSo0nfuSX5k6kY5THvjQq8gMWka
zipr|$n%cVhhQ=nC7*IiT3j(yZwRd#3c6Imk_CW-ifeQL3Ai%^)lP6D^I&J!lnX_ik
z0SWX270m5NfO+#5ELgZ`@sh=h7cX7594Igss9?oP1X#6t&6>6A)^FGd1e-Q**}8HC
zP{Fpj2(W#}&Rx6b?%BI<{{bM_cXja4VW5H|N0Gs?<3QrX$y2A#0KwUF=Ya|?T*Lw{
zUA}S^2(DcRD!6eI8@P4*&fR<W?mqx3c)0EGHXt|*Bq5A#5b)^nlc!IgF*7i+u;KwM
mObm=n%y<A3<3MLB5C8zF=L+wMSx$if0000<MNUMnLSTY;Ie#($

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/he.png b/addons/skin.estuary/media/windows/subtitles/flags/he.png
index 3d6dc042e2422dd224367602026a320c8a0fc45f..ef2627307b66b87d1593e7677dd900c66ee8e762 100644
GIT binary patch
delta 974
zcmV;<12O!L3fTvc8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn000AKNkl<ZSi|j>&x;&I6vscWx@U*k
zOeQM3Bqp+9BBCo^vKI|r#Dgg0qNw1>s}ND};(sBce}NYXcz;okA_lV;A?zx8*n@^a
zF>H)+BD2|@AKg{YLv{79=~?jN#d%P4^{cM;{nmT0-fLLOQvUBE0DF6TYK*}-_n&|U
ztj*0$i2+oVjg1Xd)w2@GhcN~bDHvz^Fc15~Gt9%gb1v7H?GFY60AheA-`M88Hz)it
zoMuiD#0VnB&ws^$fFMu-55!8qswfHysxDh|s8hg?(+{=z;FB8#ft47>Q%jOMz#sym
z0%(TkJfM*2Om3_!9xx-JS|O$`%pK#YWhI7LAb={P!;~adL>!1gTm~+Zk<d~YTsejE
zwZi@3y&$8ipgtU<!!%pWEbQ*?YQNvlV;)5j#+W?*^?wm0wf-4LRN`JA&N-ZOSZni~
z7z_q%ZEcAGu+}cVCJn$rfA#BqKK*LHajj`jSpsHUC$Q+WL2msy<=}q8--nj%AMT;R
zV~?!zU^k+BBIewBdm)*!y*UDt$pnBXisnKP?yiXN-H&(q;@WKzglC>Qg+ch}>d&l*
za{0N_Tz`IcJ$HNgDuxgQ;6@JwkVUZ<5njBs#<lN<^v|sF*2^0{7aaWZ`ynq~TCWf;
z-}_K}!m~oaIak?OCQ~0qz*=xx6e6cSA&qGcn=uA!Z4NFXxrcHOG*!4J0$*<5VgL4o
zU-zf}8w20mxW|eppMQIYSD!yKM?h8QY|n*Yk$=nU3AFXZDK0#`%H4yMk3ahjRe0z1
z^Q@hWd7#&-fE<^IjXBWdzWT=g*;P2}^*`Obk5%P`r`Ia|pnm$gJyl&ypzi)AGC|&c
z?R;ge3AD+kh>)gfLEx45cQ|*!ad2dPP$kNWr18y1#5bbCYGWy;+zEX*%5=Udp$^n>
z@_&Tk*3I350Gf~_Gm=C>;tbS)xKiWEx}S(QUUhUqN43(ZR9&G{Mb(ld4m2qUv`mV)
zDX|eGGKh&Y0w!Ff(#ea{2S@mWml{#-2?s>k$wNZ|(HSjCif;JfyN`15;^TBW9eTYU
zy<U%2t2I}Yj;r(apN?`P3bkf7n{jk>#7A&A<ofl$xN;>U5JeF?J3F-7ZMxkqolb`+
wijHk2|5ifgkH=$1qY-f&FMo)avJ?RR0YfSB;-zw1E&u=k07*qoM6N<$g3Ln8!~g&Q

delta 1285
zcmV+g1^W8g2aXDm8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0xnQYR7C&)00032009920RaF30RRC3*VotC+1b|C*7x`K
z_V)Jp`1twx`TP6({QUg={r&#_{{R2~056$xj?P<r$6I{JTYr4XTz<-3f6QHf&0c`d
zUV+bFfzV%q(O`qpV1v^JGnr|J%T{>BR(Qu(dB|9M%2<2LS$xb{e9c;Y&RTxYTYu38
zGMG_x#8P#|Qg+8vcga+E%2avGReH@;dd^mR&sKZT&d$#7@9*&N@bdEV_4W1o`uh6&
z{>#hDqPOLswSVQv$jI~a^W*9F*4^^P((h%5)MSU$#nJEL==R0M#pmbe>gww4?d|dL
z@$~fctGnS`ddXLM%8#bmk*3;LdCFaS$*H>F!otGo>FMk1>+|&WYKqT`qS=k4+G&W-
z^7Hk;z`*F}==JsXXNS*;q1lV0+GT~$^!4_=y}hTn;eSqV$4G9-ilf=2w&1$Dy6*1o
z+2HWW(d)Iu=SXkKM{dd4-|)A$x9sffh@snspxU&wwDk7+v$L}XD}f<RvJ^wF6hyHU
zMYI$}wG>6S6h^odN4XV8x)n&f6-c}kM6wh^upv&e1}lIDDtsJBtPeh`4?nLDK(Y@(
zv=2hH5Pw6r5JR{SL%9${x(`IU4@A2UL9-7)u?|1297(PQDtikocpXNi6F{aEL#-7>
zvlT|R6-T%gNWB(Gy%j~Z9Z0APD|VZko6OA2)z#JG<KyM!<<ryCm6esAo}QVRnV_Jc
ztgNiHwY9joxVgEx$o4kT00006bW%=J00ayWB!4g(=WLSz0004EOGiWz;<Y`x00007
zbV*G`2j2+=02~4x3#w=U00KQpL_t(I%iYuWSJO}w2k<n-LKY2BHf7JsZVOqUL|i0k
z+>$y$Q4tgb6;xcTwz!1?#Vt~B4-oLb^S<^+kNoO6-XC(_$^GQL`_A_S!~TmhSz;}J
zt$$dH3B%(Ek|ZdaiI0!BvTQ;E%UWT{&=h(fhhyf%BwKPyYFc_mW|rNaos*Mow`XN$
zq^G5(B-@e_&6qhiFTbF$sJNuG%;DG^DTkx1w4}JGupmD#7eKkKqOz*Grq=0nx!mr$
zI=9>9ayn~ks;eq1Y~=vzIbIM6T4K-$Y=1)oi-uq%nh*t^s|U~+1<*$`ZrO^a1Q7*|
z0Gc>nCMmRmbzAfH9Xoe5??ynPNSWuF0JJEIs&O7c(8WD__w7G$@X%pV7X%NdsfyA9
zpj9!vaEh#p<dLJt2;%sOlccE2u)o((S^>1R8yXks6Q@phP}G^T=ZJ{lG^4!@K!2y9
zYP^8@)cLONjtkvg7bzqJUQ>-u06nU=*CV4ob*Zoa@|FI+s}vHlr`N0Y02ojQ5r8;o
zNn);DXC#S+AP^W-2LRkachFH@62mY<L-3GLQaaqjdlSH|+js5`kBp9u`+PpXKM?Ty
zVKF{7Ix;+Q@BRY-4<9{#@^o@47=E0dnGJ>J=0c&_ndx9~YVz6h7cXA{c>U(>{JVv4
z7`_h#7MGS5VH2M(9A0=oG5_HsfKQ*leD#nht!P{*DwGu=a^JrH0I<CBb9HU~*Ppe%
vwz|Ax#_*U;8&nLAnQ-$4g`58MPlf6?$UUR<wM|k&00000NkvXXu0mjfX0(q8

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/hi.png b/addons/skin.estuary/media/windows/subtitles/flags/hi.png
index 0b70b661dcaa35b7c514aaedda98f45d9d067d84..c7333a335bcdb9dc932448f4a5928537607915a5 100644
GIT binary patch
delta 999
zcmV<D0~q|o3-Sk$8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn000AjNkl<ZSi|j>%W7Ol5Qe|%b4D|o
zTbvjSvTn#Yh~SMk!8RDY&LSIQ@&b8<>~ndK<Oyu@1hQ9Nd4Fj_FpiK%kf4PnA~CXN
z=A5p|qWfIthO^2h)6jJHnd$of`m4IDVbxac|K0@P_aE<=Yj)A`@IL`9u)g^IH%S4^
zVCSpvu<R<Z5<vtcS;HkMlBAJt5`J?@#U8L?RF9c~`LOmm>T}FbFeCg1NMoI&Uw;4~
z1yD1xvjO(uG=BgC&N-Y2Cg7YP1X74#VVI&|C5tdO4An4KGgK9e&Pw|_8aD(2(!lZ&
z=5xeF1x&#NaRMH25?mD!ah2P(Sej||T`hc5Lomb)Gs6_fN2oNW6|nIoXdV#&TqF_+
zX&3_uT^w8sprssUNFlvOavHFv6)-T(kw`$CAgaN8Er0a}k&48Uj1D<4O+Yj#fQD|G
zqwy~(fdBeuxP3bSIR{A+M&}S0m8g*bm`pr_!36+2JAInXWL^a`Of`6~3f@O048QRW
z{Pblc;C<yq1e*e#X@kKzFJJz}_I3{uc=hUp2M;#b+q*We$`X48W=UW)8Uc_b2}zQK
zQxLr;o_`7v;p!^q;NTDL-P`2!^a@qDd-qdbyf~!S`<zavfyJyRhD23SRlN5la51{6
zMFep**=N_s#~0kZ+2j5DE1o@j!_%j4I61jwbF<H2aItVteeIl^S3p&#Jgt+N?Pe0r
zwi;Pho%LXcg<*5f;l0N>S7H?kl?v2jR3B&i?tgBdqoZ?f-01N5@jg$U?6a}a<?!%t
zZr%E1;hse{=R&Y(<03=7UXw?Uc6k2$m@M<;xpHuD%)^J<^!u%)#Ao|l64qHR%i?0a
zzki*rtv+wxo?!;}?{CrVHkRB?HfPVwDolXSzU|oFon4065OMLVlk%z;spiN>N}W|>
z34d<IZ3m{%UF&i5`W<J#T!w0hLasTv=7`0>#Csp9ico1?J_3%EMJZOMvYQ%SbBe1l
z5b%&?Ia!uL675S-c&5D<z?Kk@h&87|0d56WR#fajAk`EmkXVXKVl5~_AT}evlxRg>
z1d!V6phf_biiidU$RYK$YS^MpOV{bHbzo_<8@QIkB@$#8n@`YsZZH$;+2pg3bQ0ew
z`8a1hoY1llz<D6hX|~Znfo6iNr?|BwB;&u#x212r*|`E^Lx<3AwpS10Ra-Rx{s9NC
V?wUT{TfqPT002ovPDHLkV1f{o(X#*m

delta 1469
zcmV;u1w#7r2gD1I8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0>MyBR7C&)00032009920RaF30RRC3*MTe9h&R@NEBDc>
z_ROO9&7=6vqxsRP`_!%c*RlNAwEfw&{@b|!+ql$!D)PUK@qe{>^0s;Nwt4lqd-u6~
z__}=hynXw;e*C?D{l0(xzkmO~fYN|3@w<fZvUT#bb@a7%_P2NUw|M!vdHT6|`@4Gl
zyL$b+dj7q9|Gj+Be=hK}dGN4t^0IRDvvT&ebojP)`nYxbxpw@ycKy0{{=0bpyLiri
zF7L8+@UCt0uzzm#vTygZaQU@y`nGZVw{rZqa{ah-{<(Djxpd3R%kS^+@bK{R^78fd
z_4oJp`T6<#`}_R-{Qdp?{{H^>`1{$}?f3Wl$jHd^^Yixh_W1bt`uh6c-|wWP)xp8y
z!ouR+-R{N3#pmbe>gww4?d|dL@$~fc?CkNJoXgYG=6}Gz-M_!x)YRtc>hQwC!s+Sh
z>+9>z&f~VW*llgLYiqW=yxX_8*~`n~z`(%h=;+PO<h8Zfy}jIMXtic$w7a|8$;slq
zy}j)0@|2Xx)6?g=y4<?D+tk$O>+A8ly1MS}?vatnwYAx{w%O3o=C`-E?Ck9C@Ab;c
z<H^b6?tkv}5@QQ9jw&aK9w>_*D2yH`jvpwGA1RO^DUl#4k{~mWD-vQ05@8E3j3y(8
z8YGAsB#Ig&iy9=18YGPyC5{^<j~peB8zqn%B#9a$hZ!)9ClX)^5?%``haw(=6&{5Z
zABYtni4`A;6(EZiAdD6ujTRw|79frm9)}ekgntz)h$0bP3Km=sDuE&)fEgo&8YGGv
zC5#*;jT|MA93_z(CXyT^iyI_~8!Ln&6<QA-Tp2QdD>j8LJC8Fxmo-0{Hb0v;Kb$r|
zoi{+9H$k5`KAJW^nKnL_Had?oGlMK0Sr{o}BQRtuHfu3FbT>bGIzW6nI&(EKXDlaR
zB7gt?{}~#&Y5)KL26R$RQvd`E5F{`f=WLSz0004EOGiZN$l4Yz00007bV*G`2j2+=
z02~4x3#w=U00Ll1L_t(I%VS^|7J!kBoed{oXJcew;^5@s;^yJy<L4I;6cQ2^77`K^
z;OFP#<>BVy;^bgrU=|S-6PJ*bl9rK`lYf_2P*hZqmzR^3k(QE_5El~_VP;@fQdUt_
zQ`gYc($>+{)6>`2)6><_*3#5aS5s9{Rst$8Ff=kYF*P%{u(YzWwzjdcwzjgev@ka_
zH8D0aGyp2FwX=6{baHlab#wRd@bL5m67FuUF3wJl4)%7oKm}gjKE8hb0f9lm!G9qk
zp<!X+AtAxRL4g7Oe!f25UO)vA-ae60(J^2Jv2pPUafx6BG0{<xKHd>P1xd-tDXHFR
zzP{;x8JStxIk}m6e(AoxY2K+R$;nAT1^LMZg+N;()BU1~igQXz%gQUF{L&+V<`)(u
z=K~c~Ru!argXR6JYijH28_FB~!G9{eQwyppfeM-mQc`_<LGsbfEv;?s9W9;FAQiqo
zsVN0bKm}bXh23e9Ao=Kk)}G$Jp8kMnkc!B(?!uHVpn?f06G006qXPnBVkS+VGBqY9
zARyWwq+nvo1fYUx(`U?_HG9sSx%1}Dhk|+Y=FXWjd)CYu3l;(uELyx|>3_22D^{*r
zy=Ki?Fj%u@^{SOCmM>eke#1tff=!#ZY~8kf$Ie~5cJJ8>277kz+O>1X_HFz2A2<k9
zaOm)nqsNY)SOwI7^5m)0r%#<c2{dEXiQ{L^9zAy+sNllIOP8-)y>|WjjT<*^-n@0|
z=1m~u`t@tK@7%q2{{c|J!!}2cpFDkr4Lp7R;w3W!6ALRIz{149$i$2XFfk5vrUC%~
X)F1r9aLj_@00000NkvXXu0mjfA7JsZ

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/hr.png b/addons/skin.estuary/media/windows/subtitles/flags/hr.png
index f8f652a90eb58f65fc052a3d596595385042213f..89bf6c7302b96b617eaa8f0804b9954edb2464ef 100644
GIT binary patch
delta 1210
zcmV;r1V#Jk3C;<SB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wiuTS-JgR9M69m(PzBMHI(BRoy*1J3F)Ng6OhBLJUYE
za4;rDgIB!~*YF4U<KU4C7Y{~mob&|I1QITC(2LQF7ZXE7$bU*Snm~+zt4LUWtuV9O
zyF*V`S3M8a)icA6H^aq!N##}5RMq>w?|b#C2R39w{_mntD*k56786fSQmm{z7Nfz|
ztM~6GF;Ev^-_fJEZns1QD21-o&`E+$5<eeBem;u)Ng|~i3IJy<h#=Pbu`#~oxt}iq
z=thH|j~oH0$A3U9KzCsQyR=jR&`P1TuKEg4r4B|zUk1PkAf+)Ev~yJ-AlkY$^y3&n
zk_4A!IAgpqrMy?xf>M5Q>7}iYqoRo0@n)J$#kK9TY`=b&b_&mO7u{W}Kn${^L=X|2
z2rA2vlGPZ%0WM9EqCiT60fY*GN;&t!UhYbrnX`Y<oqtT|?Y_s&8px97#^&dF?Yp!6
zFqTGx4!~TR;zB-D0E_`+yr)`MG|MA&H*c+S;l-C|HSeJxCNvit*iOpClmUtT83Umh
z$`$881Q*A{0IUdDi&)#ITPfrb?*-U@V}YqBo?>>-BsEtc3rpzf%@jRhtyo5iVkqMS
z1A{CmYk$4X(#xs&`FUx#+tTTDBu!K4cDs^gndEsc#uzDzLaeo7trfGlDEAH@7Q67f
zNaum19~>1iMjl?cD0kj_uUc0Wg&1Qb&vVJLOuF5!q-iRhPDk49w#?7Z3rbCS2COB^
zGM}MQL=;76t^F-183_GiWrb+(b38bI9zo%@&3}-6{uxpj;$6GQvdqWXxrzbj9L_nc
zwb=5C2Cat%rIDaR8yrWQHZeB$2F0!0<d-kgI&_Ha-1kUssUJKza?jvcm-#gWz&SVM
z=^&VOtyW|C#0ip}J82v^!1D3qH0S2fwS@Ha>5+Q|&!oIzfuV|l!Rt1t*BzGka94gq
z*MG-}rl&DiuM*A7c(1Nr8M$ZFnd?F@(%TUS$wZSaAAf@V=|@)2oMGnFDVC2NLv>e~
z{_vxJ1^#FY02E41)t-5`y?f7oR#r{9K$n$IA*?S(Z@=;+hi8|ty&T<Y;g*-ttrqY9
z+T`nB9#qLEBKS%YuAxIjm~19oyK;&AkAIWXaVQkIv6#Z=LRAR~wCSNo=j6Ay*!KDk
z=3buV#+z@k<Et+?_300Md2z|F3Gafqs)Beh9zbp!l)rffcD~bodgngUH3OCR+5;$o
zc-v~-Yd-KC4VIr0Ls^9UlT;O?Rx@Go&r9UjPX`7p#u$t-pyCn)BfSq{8D+Sldw=kC
z3@nHTA!2>CmZD#ZlgObYCyoTA1*J8pXvk>a+dd0bVu}oT-`C=q45b*r2}%l*$dU&D
zjWHOnIa-Z`c&ver>Zl4p|N4jzMjy!V2SFeoH3VuP3}PuvkGz-iuqLbp027Tdbnhmy
z)JSxLNNRoR|3eXRDAS|JR+$(d<1_CvyPCiZ(0t6_qpQFjg;Ft44{SU}DS&L_f5C?Q
Y1FRr>^us+nO8@`>07*qoM6N<$f@(@RegFUf

delta 1199
zcmV;g1W^0V3FrxsBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00dr1L_t(o!|j&Oj}%1|$3IowJv%!)v+RQC
zvO=;kAc?@im>3OS^+sI7AK;IJM=o4A7`buM6GRh8xX3{-MlW7W3=ttK(P#oO0<I!q
z`L)8#Zto5~U0wA&R9DXoyLuwTL|#&<A5&G|@B4qgSFZ;i+hhB`n?kAh>rI<XJU&jb
zy!=Q&1J<i|?<O%&7hw0{!?<p@WCbXNuGP><f=&{@9z}jViu_F?r5g$WXDx^z*7~_I
zzU8@JFA3;IgP#r_1gOVAEI@aD9=o_$5ztDZwXVhrP-P!L!&nB$2p}bx3%zsI7$Dlb
zIgEef7(kK)mt{C(JeX46D{Db1zq$0%)<;oM#Lajk&8FhY)@in0y-hoXXSt2;u2v)l
zRZ=2|2u=i*Wk{)N4B!BlrbtmBC14<-0-@5*ys(SgQfKP)pLE9)dOPlLy#}(Vxwi3n
zUi<cRKa3@4=mRmArnry~6#-+w81JdpmCS#^`#_<2V})}szC^2e2Yo-GxzNCNQpP3>
zNbK(z2*psYI0quQI36ZoMZj9b+P>UMArE*jz@BUKOg!-v(>uqhxdNGAL{Dy{=n1RE
z5>gaH86OlFR6$wmF-tEe=H}+4-EK>#(~&eyrQ7XFmSvLXxfo-lC<?LGinUhE!h#vx
zIdDMi{BI(idy>9?Si~5)f9|~8I&`SolVAcEf6dJaN=<kLtR>4bpP^Ai6h&yQ{VOOH
z2;*XTnP}H@+&g;~LE*Mck$v_lQW)ax+sU%b$Jx0`0p}dfIjptV@`;9C4^2vt(1$iS
zk2Y*zWcCe;8#l=>UZk~uKiQe@kla$=w{P7ugL7Tx*AM~c+>ob(WY)A=jiqD9NM>ee
zf9&1M($S+dXJ^s1g!JUeb<YgmN%_KpLX`r8&uy?@b6MWQUHTPWA0?Wc#9Y2iG&SYD
zx_oKfGwa>CCIstxyUs;2)@0L1A7g*~ft6FIm^yKSr6WgB-4!N3`0yWzKiC2Rg;Eo>
zXWnh^*tv)06;p1|W#v-{Ym3p_uRO_tf9XYRFGsgpxTPg@tHpc2H2Lc1dsXs@2)>ep
zXXp?S#+wOOE?pr1{rF@Y3Po-#rtrB?RYHPn{lWxr{F@tWd3_tRFHdvr&9~V0<>#FE
z<a@q2zv%ab?}CJK6UcZ1xp7eb<`tNEr~UNIZqii)mG{~cD2aINz6vlnmj~9Rf8<aW
zA^%CL3R0_?u<*wP@~bC<0v2No#u!j>Ng_Bs?0pE!dcc+31Le0;K|Bc&>#MaC{ZgDn
z4kbBpBq%K?twBXYpnY%qDpZLngG6MY7q4U}#Q;uFQjkQJJP>G%z-Z0UY9z!X4RlmT
zRRsFaM|?2)M27zm1o2Trqz1wuU6#W1$a^XGYr<+EFxD7B_pTF5jYKzyq}G@IA)1Io
znI1*9!r15tf0fzQ1g3!ILr45~TLEq<l!}3RP~#C=0c4LD^RfL0?Qg6gd-R*Xei{G(
N002ovPDHLkV1nYAF}DB!

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/hu.png b/addons/skin.estuary/media/windows/subtitles/flags/hu.png
index 11d636932ebef03bf3e2cb3df0933e7cede7a8ee..290040f8036d232791deb752ba046d9e036ec633 100644
GIT binary patch
delta 819
zcmV-31I+y83cm)B8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0008aNkl<ZSi|j>yKdA#6o$Vuws*4$
zNrk9sP$XKKJOmX_LJKA0X()J(eE<|GLI@fflmg|poAt~&6o2CxkL_KAP(;IyG@6TS
z|KIt~TnziNFaLWHfR86ntv)%%UtRwb(WLe2>YLO62E2IphH$saR3d_#&v12(YnnJ;
zRfxnk(|7L!SO}QK7C_q;^&Y+7U}pKb>TtpG_1g#opuo+Sue3idqd0;SK|~N3^hKn%
zuj`vxo=ZYzhJQ}_aojw4j3ze#nAPZNjkX>q5g>*dt3|b`@W|RMUP77WY8Yyut2NB(
z!T|$+eS>+Ab%NH3XPDCNZahhW*_bFsZ8mVmU*DisIADOa9&1}nT#i~qu<S-3{Uq{j
zE?5Gx3>HBYtLywu4G^%naD2cBn7Ak;!<@(HU5?(iK!2F&BrRAko)&B9-VlK0a%rch
zr-%quRZ&$H&N-ZmAgPx5FTqOthtbBWs;DX<1VRXy85b89oSmJ;Z5Tpey<W#HvIPJb
z^nVAC`l>qUmjFq#PeC_GBIC%%E^GrB7w24tO5aq~+ztR#br5L@^S1zFm=Ho17m@5x
zc3@YYAAbVC%qHKSq+pljf4T^_iIuS9?+gH5et6Hb^XFW(tN4&BPC;Q3{ooYZb{G`9
zK>9-g(>Qn1EcpECyf}*0*aS}-JmMT?^bjdp=~QK^DHD)>@8=UyBaErCsXXZ@%m7{k
zUPHW^M2MjS&Vh|A-<5vbvMp8VkH$Fm8Xy#lkbj`GZA;s>P`OyUsKvCu3py8U2Y?jO
z=g5<AN<*hbC>&^1kTy`OAeBR0)k74*xlP0JI<~@wEg)!21FDEungE*wa40p4;5eQ=
zqCPyp9W+Sc0!YkCx%y>vA6l^sI?X(v(h(HD-mtk@v7+KO0UXU2xbHuy=X09F4OP>0
xi!AT~|HF*95by8tw|5-P7F_OsiT7n+fL|Mh>j$w14OsvH002ovPDHLkV1nboaGwAG

delta 1373
zcmV-j1)}=D2IUHn8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0&`GIR7C&)00032009920RaF30RRC3t_~ow94)O5AmyH>
z;*_1^l%3?2p5~mS=%A?TrLF6zu<WU@?X0uzth1{QAlZ9`)PH4h)n#$kWpdbNbJ=Hf
z+Glj!Xm#CbcHU`r-)eW@Yj~>^B-e6%(qL`WVQto7ZrEaP*<*0pWO3VMaolBc-DPs#
zWpdwUbEy*~(`9kdTxru?YSmq8*IsMbUu@c6ZQEdO++c3qU~b-FZ{J~Ws1qd6S7g#y
zX4P3|)>&uRT7PKST4~x_YTI0D++1qiU2EQ5Yo!w-(OqiLQ(@6lVboM()>UNJR%F>%
zW!hI|+gD}WSZCc>XUNFN@9*#M@bL5V^Y-@k`1ttx`uh9(`~3X;{r&y^{{H{}|HZ|{
z=jZ3@>gw(7?eX#P^78WZ^z`-h^}@o!>FMd~>+ART_kX~^!071cy}iBp`T4rKy6*1o
z24p@fkZ2u?UmlELAC6%kk76H?V;+%XAChDslVu>3Wd>qBC5>blh+7$oT^Ng98I4{U
zj$ay&U>cBM8jxWckzpB;VI_`a24FlPi(wRoSQLm^6p30Cidz(mTNI656^>pNk6sjr
zS|N;K27g~W23<NFhFlMUQxAky4~JI|h*%GaSP+U?5Q|z6j9L(kTMvy}4~A9_gH#-c
zTn1b^3tKxKfmsuOR1}0)6^U9Ej9e9sT@{X96^~yPkY5&&U=@m66ognEgIWt&Iu%?$
zCVpEggkUa?XfT#-F_~{Mns70ja50;4GMsTSoPTjLopLgsax$KCF_vvDj%O!=UKCk9
zAY(`<V@ob-QZsZ~HhEt+dtf(wU@~%8DQ8X}Uq%_)Y32X`00wkYPE!B`3=kwR8s}`2
z00001VoOIvUIf-*y8r+H2XskIMF-yr1ppiZ9Sf>x0006{Nkl<ZILl*T7#4t$jhziA
zV1H+0WMJap<l^Gy;pOA!7Z4N@5*8K`5)|O)=i}w!=HlYyU}9hv5fu}ckd%^^k(HB|
zmsd~#5^}OK(o&KV;$osA%nZzmO3Es#YU&!ATG~3gV4$O|rKzE=rmCW>qzF`?r*B|r
zWNcz;W^Q3&X=!C;X=!0$Zf0s?Y-DJluYU(rV6ALpYiIA^=;Z9;>gwv|1|(dZog5wP
z?QCt7t$_;MJv_a<eSH1=0|EjAgMc6~Fd)F+&)3J>%hSUhs315bG%P$KGAcSICN?$>
z2x4PnVxprWBf`T%LxO<{;u8`QlR}bHQc}~>(!zlNNTsHvB!?s=CM3iI6{II*WPgT)
zri7(}WV3((q$V{iB{U>6BOx8AAUh``DFiGJl#BoZkQ$JRkfe;9Y@mYNjKrkS6p%bn
zG7ktqYJe(ILX#3Ra)Ao+6Eh2v!@%-+d67T>QUX*FmRyjTm=9D?SX5k6T2@|BSp@{u
zKmejEE6U4CONxsMfeLDB>*^aCn}3>`TUy)N+S=QJL~BcPQ&VF@eO*TlP(f!`cTaC$
z|AYw>Cr+FM20+Gy3H^P&le?!(1uB>}ea6gLv**m6H*fxeg<!B?{=9i}=ggk9Xz`Mz
zKn2T|uUNTi^_n$nCr(<oZvBQ0>({NDG;!^kHLEvH-n4lOP{G!1+js2TwN`u2-hKNI
z95{IB(7^)-_V3%fXZNmMhmRaR22^nT#K}{q&z!{sXHK6xe}S2SiG>vpU}0ilWMakx
fm>35-Q-J^gG)L$^_b7-v00000NkvXXu0mjfNit=6

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/hy.png b/addons/skin.estuary/media/windows/subtitles/flags/hy.png
index 5c8201f3b23a4be207a9797d7dbd8380daffea65..88440676d36db5e3be05ab89d43a0e30ee45ec41 100644
GIT binary patch
delta 888
zcmV-;1Bd*t2agAkB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wit97#k$R9M69m%EM}MHGg=Q+?Sh7$Osq5s)AuL`06n
zn>ZsUBXr2qAn^`PNRUi`$Z&v=$KIWtuIlqUsOsvPX3g5kCVy;6qpoiC)c@6gE;R!W
z<6->Yhhf(LCdKgR5&rV!y@)PapPLOma4O)_r%%z<RiOei!%j{J!+;G#{$|(Z=UrFd
z1JH7vXC%Qq=ldA(7}4Q?r23v+T=2(}Cjh5C&^r*HKSwWKWN{#v5zJ7TFHno%GGB(I
zqqzWYuFG72J%4_T=U4k4z{e5o_bA47_eG!zHG*65#f=sMsXjBnq}7G}9v?@DkqiK6
zw}Tj0p#o8X8q2u_pcTChf(1@OyWQeI0}vxt0BmFVUAw=_1zW%hh+;ejm;qACpGB|<
z!EL*@t?*l1P_y&uLP}Y40r-X=`F8q}>&Y<-n02K>Lw_S-cRFyKjH+0Y145dSobx{L
z3tt02WB_muhXeb4B8098TfOErZ6m$~(FQ`rEHwa*`%KsMCGfNWPD+_}t$<oMx8$Av
z%ZCcl0_C;gaPTdFNJ&hSW7Z)#A%sG1O-ksU9H_mZIw9P%xa17Onl;sd7{xRRSn@ze
zi)UBtJ%1fob0GueP>iGg9fE1{2EZ`$ntWzU9=y8)W^EXb0j6mUfnoO1&)*OKeD%d=
zgt#LFqYFkb%16hY@h!cmR@){7F2e;bm|eIFA3o&SufOx%Px0g22OO9uOc8UdmRHwn
zQZ~Xzj@ar)Q|?HZAm_3$x7?I`B6-sXk^`R5oPW@^^g}&;>Q1*VY<G{Ehu*Y=5_)+e
z%?-emV2Y70MaI4e7|5EvS=%J@;<n908ArJX$OVE>oSA2cN=z-ljSpN+#;6|ajLwYE
zQA4m;-$dj1tSG14QKc5aTzdK5XK=(J!F3vdavC0V&Z~6B+4uqdY0uedAoMv0g0*5Q
zhjG>FQtO14Sd&!)Ir+Mhgf_!`lel^{aqWBHIs<g$1<(EroSgJro)4Uj9bGW)X#4Lq
zRH|TqFm|sK{dfWVjbU~Pd;(nF^Y78uz+Z-051g(|>E1>HZXW&@Jd8I>nD3`s;|JXU
O0000<MNUMnLSTXn;h@3*

delta 903
zcmV;219<$82d@W^Bq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00SjSL_t(o!|j#5j^soXg}+<=nO|5oS|Tz6
z5+sC($dP!H&B)0JH{@wn;vF_2L0SSt#s&y&@6PnJt9%bZx$Ls(VHOFEkeDmAT(;ak
zU!8lZ3LfgA{_ka&wLeKQJbHw`etj>ZMe7r@t_6Qi1$^}E8M?ZfsKCsylM_PMVO^L1
z*);ii)6DMys9eVpNidH2K1Mu7bT}Yse$Os0_~q$SfYTOe9f&VqqF1l7I1tPTW@s80
zs3KU#r6jG!0=&AGu>gDW1kbOwEr9nu+V4?}%j_qCS*Q}+iWfI(2&DO$0VXXj?Du%z
zLyUi906@DP#JC7e5HnC^IY$6$(PI!4I0@}`#eoVSMr;DGjpcXE{w^1+fK4EZaSbp6
zq?CU}uxi1v+1pn578g{_e0CwFtXTlQ<U76^KI3|D%mQW&d4+~bVv~tmYH^@M4kQPJ
zG$J|YZQuvK0KUxt;2aJI_WMK#%_MB|HGhB8HsV_lZ6Gw6r3%1tA8DF)YCJW7lTxN#
zR=~V)j^s|<UYa3lp!{t(9DEBPQWC@9m^DaF2w@_(DiXD*{VkBB$_e3~#U-cfmekA+
z#3+VAK*@ntAJ4AXt%AoLShA3Tax3~?e{I1qcm-gX`5Zp8l7n}5z^rb=8ekZf78rkK
zA3Xo2`{VOZKPJQ-As9_Cf-(KH-Wg|sjl9+vr3Eg-1uhs}xC`&z=f#gd^Y!=faoz_U
z7za!dbDJ%nU7tf)39lTn#gA&aBVmG^Wnpf4Q}TgS4g(<HctT@B+oc~Ur_Vgotqa@P
zqw1lvYzb5A<%u*_07HTyMw%4q+ev@GKvvDI+LcQ{ZJR?GtLy=CfgnuIj3Y!Ph8p0;
zJFW(!SBo`9V@7D0TTra8y0Jbhrc-XUQYXQ@^zyxr;D|$l>(l|$X?V~%Z_*iO{d=^h
zEoY~J(B=#TtHm@OR*Oru6DqwXs|IrTnkj@f!g!OodNXkCd*C_)H2noHehpKcoU~k?
zcbxSNO)&1*_Wx07S_S)qv3r|n`wQTA46{q%L*Vk?lY6In3;br7wZJL!rgU$WfSY^P
de5n6m{RvB$@26xS^34DM002ovPDHLkV1h)anFRm<

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/id.png b/addons/skin.estuary/media/windows/subtitles/flags/id.png
index 82ef12bb7afff6dd88d61f9859d63b9744c89ea2..0a5ab8fdd8adcfc3aef00b2cd501f5985b68ca90 100644
GIT binary patch
delta 762
zcmV<W0tNlc35N!d8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A)%`RRa0007%Nkl<ZSi|j>y^a$x6otP#Gn*)A
z*$Pnu)%Lu=J_Aoe3ndT28^CkWY`+bH8c`*iWa6=XC_LlLAAh?+LNw$`mdB&HKIfi$
z>;%qnj{iLj;PcfBRaZ~(>&-s_?Xcdgzgq<$;Pr=hgxx-~GBb+hf}*M@E-uphvcxRS
znSGlNpb(JK3=o@!=soe^kd(hGpRD-u_I)A)5P|!z-)MgPOyC%W8D@sT;MvTM^0m*B
z^1BX55^?gJ)_)hzpAkDX09aJSeNAjUg(U*1)HIaProba<GkBkrl!p*e5cf4Ks-6M@
zzqv==qZUvtcqY@AyIoIOAdMNNs-=N4esfP$PXPgHJZc(bMXuV+P*&qu{iO0a71R+@
zCYFdqR8={r0thG>#|K0}RwN)B_B>Tz<mxp;LW+~NpnoHHXV%bWWD`c`plK3dTlrkI
z<o?^N4!PP%Yg!*j$dyAA21H#S(0)%*6qIHZSgU*jDm1XdK$+=DfM^{pr8Oc*#27KN
zsRB3$-jj4sCQKkLg)!h`H(WmVtq0mxU;^ic3cULCk(bxkm>E@7B^Amto&C``O#w|t
z2!R+Q-hX=}ak#sKo13-;Aq)We^Qi<L3Q3c_Lwj3J2s|{#<Q@a-lO69fA@I9R|CGQS
zq49oQOJ)g-<)0%nYr6h@(F2{^)6DSRr_%-GMQ4~(D;g7eEVuvNfPixj=NwJb40<@X
z;VC|uBU}{eb`3Goc#m`L*n+yQ*>1Ni77NUbvU4nR!tYEpSN+`4?0TMl^h6ASLtV4m
z?T!i@4hJ@y4ZGcrroE0k0^K}5f~Tyz++0xWx9xVD2~+@OS#o=O%W}Eo^74|^YLzdd
szZISH_xnBT^_r@x&VPu{aSi}}0mQn?Wa<JjU;qFB07*qoM6N<$f;i?@od5s;

delta 1218
zcmV;z1U>tQ2FnSM8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0u4}1R7C&)00032009920RaF30RRC3t_~ow94)O5AmyH>
z;*_1^l%3?2p5~mS=%A?TrLF6zu<WU@?X0uzth1{QAlZ9`)PH4h)n#$kWpdbNbJ=Hf
z+Glj!Xm#CbcHU`r-)eW@Yj~>^B-e6%(qL`WVQto7ZrEaP*<*0pWO3VMaolBc-DPs#
zWpdwUbEy*~(`9kdTxru?YSmq8*IsMbUu@c6ZQEdO++c3qU~b-FZ{J~Ws1qd6S7g#y
zX4P3|)>&uRT7PKST4~x_YTI0D++1qiU2EQ5Yo!w-(OqiLQ(@6lVboM()>UNJR%F>%
zW!hI|+gD}WSZCc>XQLA%&sSv6PF&GXUDQxs)lgs8QDE3nVA)Y%+EHNJQeoRtVxSWu
z$4_0xMN`N}Rm(_L%}7_yNmtKFSkXvW(n(m;N?D#0B7et8SH?k4$UsobK~T&>QO-kB
z&qGttLsQX2RMJFLz`(%h=;-O`>Fw?9@9*#O^78ZZ^Yrxe_4W1k_V)Mp_xSkuy}iBa
z>gw?D@cH@qy1KgS>+A0B?(y;Q`uh5}x3}!<?ECxsw6wIdv$L?Uu>Ab|udlDFs;cDV
z<mcz-{eS)a>g(&}=H{uXsiLBy+1c6O-{1cJ{_gMZ-rnAypP!qXo6OA2)z#JG<KyM!
z<<ryCm6esAo}QVRnV_JctgNiHwY9joxVgEx|Ns9Zlt(21000JbQchC<1Pl-)FdFA<
zlK=n!0b)x>M6S7OlcxXx00(qQO+^Ra2?YQg0e^%7`_cda0vkz0K~y-)-P2c78c`UB
z@ntcnSWxU06}!e>z}~PIh+QFeB=!<vm$q?1Bx({;OjFYnjhgS6|5-A*$;8{t<heNK
z;{DA#XD^nb{)<GCK*?VVl!z!gC|D{D2@MOE$s!`<@~9}eJTgKi3l9qokxGMuXi6L%
z6Mq{QpOBc8oRX?gDALk!q^2Y%B__nj#l}R7DRFv+GBYbXCpRy@pzyX(VL^UgZccVq
zrZOWPps2W{w5+_MvZ`98Qmbof)M}Ngx~j6GysWgOxCo$DSy$iC*woz8+NRNH+S_ro
zwYD@jH8#}ODQf{bI=i}idi(kZv|63+4u8_=wAz9GzTTehuFejC!J*-i(XsJ~Nxj}+
zxQh%1y?%0Hd~9@NcxVt{YI<gNZhpaNTr`<X_Ykf{qj6z=ZgysR3Sen@Wp!<RV{>c!
z{_nQ8HaFJSR#%pn0Cvn4hPB%44kyQP4-hV=!)~*(jK#bIuxsHNmzB&hbR%LQtbZ<s
zx9kG!@t%FJO_;mg4-p{{Ht)WN-vc<{4+-Fe@evXTN5CO}0Pu)sSg#!m+`?EO08YD?
zWjv1oo{$ZG0O9iqD}Dj~DZsPmFBrU0*x>UWAA=Bp?{K|*^%~&K+Y_@38~pRrQ@_9l
z+nM>@dw>rgKYjKJ^CL1Rg1my`96RinuipU9FTP)1UH|yA>#NK23o%6p+`6FvniA3C
g8=^)3`lllO1c*cCYvS%A5C8xG07*qoM6N<$f?lg~a{vGU

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/is.png b/addons/skin.estuary/media/windows/subtitles/flags/is.png
index 8e09eb8bb54cf4a6abd2a1c7249cf1affeb6132b..449fa71f8362e6c17bd0b3c4b5e88b93a6a8e023 100644
GIT binary patch
delta 1047
zcmV+y1nB$S2)_uBB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wit%t=H+R9M69mraNqMHI(>uey6ab~m^|BzuX<k_~3r
zt6t182trf@(OV*T$;F%C)oTzviwDIV1iub~7lp8wh!Sra5`T$dG4Wy`5{xsM*{+Z0
zp{lEUW+xaFa&ZfquAS}a_y4H(uNv4N`{VyU1d)=>H|;|!ef}KnE_~?9=coDQnUer)
zeDf8@Ui#=i70tCSpRGz@0Ls}no@YF<4J-tq-z%xgf{l$09(ng|q$pTDdX$gfIi2yx
zp#XRvP>pv0>wi4fd3I}uqRnG04=c{R^(nxh1WHu7di@qR|G3)<V+0Wcz^l(~GWz}^
zBEsqmC;9rjUl9Z(0Z@$v@;u!&q>lm`Gy^^K@Div3lqEo~GEAlp>wI!WkYGRpl8UHv
zxuEmy%etdmq%E!)jB5P<Wa{Wuh8idv)OW_aSmzUKL4ORXxQTb?vgFo<h2F*jH0;vf
zv9N{!L?Cy@yZM<2fROwOh!8=9kihs>fuv4UYVR6o8Iy{2)W|A?^!?BQpo;UFq)i}<
z0E$SfKvO0vAagco$A<Q^XoaGoojb346{u@ZZKDN|xXdbGZGLTSeTV%V0HtF?cRfTK
zR0E}vtbc$Yvij|X3%A$T*8wPsf}$ue#$b%ei}1#4XAlt{|M30zMUln+r+ElrW*$Po
zdyn^#(9X^dPai*iP!L%?_vn$^PdxP`Os5#25J3=(NVFq)Kbv5S_|F1T6jcam?o}i2
z!GNDH{=lgl*AA96Vt9|**lL;?O6+ejDV**Pf*d9XqVzJiAQh=RO&^s2hd+3a$F{Z*
zk%bnB2s@L}0vCS(&%XWz$2PArnnVTi$|ok_kDr`^+UCMrFQ5BI6QsjBXF+Pmm0`)1
z%RhCyAht&BJVNS%M!Mv`x)wm&hW7^0u#bjn+XV!iFY@y#2LiSASQ|4yMROwN7uFU@
z0P2*4x@a}Deb`YTvX`Vn?L4TT1>k(V;@eWl#6%)(b(w!z8^v<39_Yk!=wyQCTIfs?
zI;^d+)`1l1GARk^1d+@rFb_bwV03m<BJT?xYXw3_fyx9#Eu~S!6i8tri1bPk!BkbA
z_sSxl84}-)2(9d~sL9Nu5CKs~Rk(IHT<XKH@*EiUDEmW9F+fa_w%^FQT3gEkA3k&-
z2_SoY&mC_-NA?Dg$Jr_MWW=OW#tnewVIOn%H_CpWiY1D&mk%QV+uPgRbn&=${rq{V
z$+drV6jKdIJ;hDNED!tKO7vEMHDKidpGQZ)@9|IygEkW$*l@sf|98Ru_!~HjZiC-+
RrSkv)002ovPDHLkV1mAj=`a8Q

delta 1079
zcmV-71jzfp2;B&fBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00YxWL_t(o!|j$&h#W-}#(%H6d;aWhaDzzp
z5|t$z%(7R#m}3xxs0gCBMDUV}H^HmdAbJ)Lia7}WI|yDB!d@auylF@zhQ-8-fk-gU
zWM;emJP%b}-7~wvutE^r2Tj-XRM+>t@2mH!VLyNN<NqFlNXhz}_MxRde~z|yopj~%
z)BN(xNdVTq`HEvNee|zDGuGv^RS670Is3-*j3>6Cg&_2MB~@9lwzkG2@4k%`1<OZ|
z^6@*TGyfP0fcF8_cn7e~W1VNab|~6RV{uq<=B-Zw1|?9U%GK+)xcSH3Rv06Q7yw><
zZk>P8_ZJZnmR~r@*Wdk$ARvi=Y6QsRbk~p`1vF?Tdg$Q=Pz5MUfL>*oOdZzw<cc7{
zfCMCgsB;<6`F62xbU|8h&16*L|C6bsR~c%cY*^nJZ)2TLSqoxF;3nRk%aU6ccJ(#_
z&}5f>M_>&Bh(zv;xAUAxfROwOh!9DHkjQ`dR)M5WRBGoQXfq~(b=1fzg!F#s5KzT=
zP0}V3MgT>mRiJ^13do!d+OeU17OhY;v}5OWrvi2Dscp0%CN8rISeuuvt?y(%N1(yi
z`TY=WPz{tuvI2t0^0yZ*++JN>1)wMjilV?6gE1y=!W*xhK}2}`!}sHhGD{%)pT>V7
zgqd*&0q;HD$Aq@Fws`vZ@q>cM^0`Nk+<xMzCt*6p0EGyGU__!F$@^~Xp8qT%MNx&2
z#$Gk%Js9xw#UD6z<J!TJMhx#!8%s@dh7#*rOlnT|M?sSVQF@u%kcw2ErjAO0!ymlI
zV;dWY$gUQM2wN|{f&xdr{OrCg=w5&G7N{zJUAhD(PDBFFzWxQr)~_;}L<REBCw9Ug
zKRE@p&A=NkpZiA>q?2{-1*sgDh9y@n|J1F5SQ@qS2&oDh>5~8IS^{ku-kU&^eKb_t
zDj?u|k>{sA5U8!k+SmhBG<U?jU~Q2^piZ5zfs|R~Oh{+O0ZA&<&V%|{0?vQOE3THB
zOzcQ;jZ{9W+G)i*JK+xSBzvPmgN4p?LWi|A);f?PU53~R(>m7DwBq_61f)wwXAdRv
zx!|!@AaoR{OhD998bwTj6ef~LONt1ls`9v37WtbY<=YXVl|6!*oOu)?AnK?J*Pez8
zeHd1r1H&F=e~2jth$+(X8?%3|R#vjWhYuY{0?16ZiAt(~hD>`np&n<a)RPgDN*Ol<
z7KeSz-QOtteJU0x%3l5$0odH!<fe<CYuC@8r<z=2FQFQcdWxHjSseDcmC{=RR)D2F
xt-ALZ0l&wOQW%hX!UGEjOdl}je*6dHZ#au?g94yZlK=n!07*qoM6LruV1m<r`7;0j

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/it.png b/addons/skin.estuary/media/windows/subtitles/flags/it.png
index aca9e725b8fe014d9dd0ad381fd253b1ec5bc853..ef9b11bf7192d0a7484d97d03b6c6c73d3e570e9 100644
GIT binary patch
delta 923
zcmV;M17!Tn2eAi`B!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2witK1oDDR9M69m%WZ0MHGd<TU|XnV|(QQOXdYu;u(m^
z5HX2)1D*g8St3Aw1)gOiA|yuyNJs?82?U6r_3rd`RozQaw|}~OdUn@K;)JcFM$<ig
zPMve^y*==-9@hVT2_liNK2A@!kNJDJyz}OtUVL}2hra&o^E<Eir>CTg3ts&4V;_Mn
zz_*`%$z>XxmLLKrT~FUd`Yr-+c6Nq{AR>NS-OX&;&5Wn7z5zf}rsRZ<sa|se-EPbG
zU%v#{Mj)cb&wqcs;rFXQX9B^21VjP|eDTpI6Ho(htC0Zs>xb8vftpq#W~dqU7Gv}5
z1L_rG1lWYgK3|hch9C%ns7ypKJpf#Tx9=t;a#^V2P-?D%QHG&G6a6m!xxON4L2%#(
zuE&z!87dLTxygcI*aF<l$Zs#30*wG9%_Pl;3DSl7Fn<khLABytB$^7AGq%iz>SU9e
zLe8{A#3oPHLe^4GkJi(R?=};-$%du;)q*?)t_4$lH#4jh)K&z>k{LDE@L2!_2>}WY
zF88i&OZ9|S#Rc_GR_)L(Q4TCn<9Zm_=YbGH1r}Td@ka^6Fx(o%r2_l?egdz)gJP&w
z3q)8cV1IC}iEIVaf)Lz_L+{^J3De3MmX?^G-h)U=s}QP@P2GZksS-k<RZz9%{sb&%
zDyF)1Hjw~Bjxu0I(wYGfBm_jY{#Jk@|49K$dC~cNcmEB;Vn)|hFg60_r*;3Ql&{M0
zHUegbrF2+^%YFb@Of{D?0cH!D_g;GDbD=44uYabL@+7ym`d^f!ZF&kT3&xUaBND-w
z=Kw3v+kltf>!g6TjL(*sLCTba3>0rfr9g1w9h_+($<ZLXX&Tn&Wp4oU5Ndf)Gbm+E
zKuIZ)Qi2$qzyf#`zPoHNGc>I_A(eqSfsztwNuV!+j7qfH1w}gO!dwM6Sg^KZsZ8jj
z%YP2REzqeKC<$Zqc@qI1$%b9-INh8QcU!`?uLCKx=pXm~n@X}-aPs^)a}mz|C$Esp
zVNcrhGl9pOE#b`t@nl2)sL*X<EyGp+KR-Xe*DUyTygIhVRT##Ri{XlXx0~Jxp8y{M
xPu}zU=v&~o`chio3*&nxkb&Xhf5F507ZhN|N%`8uU(f&m002ovPDHLkV1kAps<Z$A

delta 932
zcmV;V16%yD2h0bMBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00TlvL_t(o!|j$mjwD48g}=zk>gnFy(Hg9@
zTwo;5fQ^T+ah4l!0)({^2HGodma(vq*1|wS!a(bQf%uu7>6*^W2#k!Zs;-&oX#_$-
zOgP!<s?PWFy%&)U5A{(0_Yy=RpS_=+t{?OJaCv|5<?mj6b=0P>Kl=FK^ZxXdbaBCp
zAHMA)um<?@!%w+PgVPd3;H2y6yGY+f0M5?N5D`SgU#qK`jjNgQ^wk#tXv&nF&|Rv}
zoItl(^Y!O10oD<SsPX+TZ}|D@*NH%IAOVp80-wD1!3fmATQw2@zkTx>Gf>k?#0)i~
zzG8o@p1nhTLW}^b5ZUHyQppemK@gRZ2&Q|0OYrvHs6;L^RUAsqRWQmhG-#r~#UIyK
zBrOOI+`#pw<Of3~0y#HXFbtc4n;H4-WmBLLfTWqE88Jb+P&d=y7E~+lBhgf_oUwT}
zR7acC6mq5|A~t!l7P6LldbFNie6@+dZ8m?*<*ydxF>o!I>Z_SyrJ%MTuq&CJ<{CZ=
zpdcYY!NKpBe<YCV39X6?>YuFIp<SZvS)j)CFtE)7A%qGnxC-K13Bxel8N|5)+wFD)
zufBs~s8$O^SSVm{t%+;}(}ED(ihb|z>x8j#hPfr?r}rR|(jtUvWK*{wV5)==XdQo4
zZ8@HR<xIs?x6VcqV91ROn31$*00apEQLVofpvYfRz*3$~K40B`!?2jqWf$xk0rS(k
z|6|G*ZFm;}Gs9BaZ^QXK04%1O%ZUJ!1<iYJJ@b2^DR9(KN_mu9oj_a73|sXS78dME
zs)I-bW4Z@efZhc>|6WH0v}Js<#0-B@rtD>)_#i3;f*bGPj2F^$^BuYk>weh>z;p?<
zJg6CzvLv9Slt?K-3{GGMya?YR8_Wz%i%CdjU{0W<M4A)miy%8CTAhL-9du#pf?F(D
z+A&uq^wDL9;1=jO3zUSh^ZO<OJdzcg+;O@(C2rP)bzd)}(4v2H_TSc$&4O@~=g*m%
zaPmKShg=R@(yE^bJYKB{Z!U-@EBZ%;ZWU`AF6RIF`8mhbkGrdz*0>78ZpX!NMZekj
z*+iZI?*dPb+Wnuax4=*JPig&M82@Dg85sWdE)VseuRj4`#!30$Lr-`B0000<MNUMn
GLSTY`t-81X

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/ja.png b/addons/skin.estuary/media/windows/subtitles/flags/ja.png
index 77c55866c5a39aa877574c8cbd8b0183202d6ae4..d78aac1f9619f6621f346c369c2d872aa19d1b80 100644
GIT binary patch
delta 845
zcmV-T1G4<o2iXRY8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0008!Nkl<ZSi|j>L2DC16vzKF8<K{`
zY9aAZum`2khy|$;JS6rcG~lt{!Gj+_5WINs?m<NGBY5n=i+|E8f|gd$777(i5zWck
zk~W*&*_}5Y+L_F5X4~q)i+S+a-C1_t@BL@qn+1k8wEx{00Bmk<D$Y5G=${1Dv8vT7
z%K?B=3X_wQP)Z$AF=m`|4#rrY_-I_;>+khd-|J^0GUN9AtyT*FkOKfBLKH<%N+kkw
z&Y_et5OzQt%72EiL3D5;N`NrNjM`iSqzThmCf4l_$I|c`DxrX#L0WFx0pMVL3!V4t
z=(T<TL?~XmfUz4h7`-wz0Kym>m^%|7O`M*Lf)MRzFR=IaV`AL@@(nvL-{D+i787?C
zzzTV15}5!}%Iq?+CTKl+j)PBI{qnK10`Tkg3dGJHE`L6}>)ac*>6knX;F25wc9&Pt
zS=oRR0!j#wh!U>HJ1ZO5U0ywLJ{{925Cj1L!1FwKo@c5+f7D)FLJ;(<29l}*^fPTQ
zE+Jp5Cgdg}NGVO=0RY_~?Ao_I*lt6KICH6Np@Z$VDPgUGZa(^&03afhDd#)^qg}-k
zDmop2ihpH7Zq7NRlqR^{2aE!)+P48lCMpQOem@n!$V6pe*Qe(mSOQng+g_fpWAD|6
zQvsCc>(2IVC+Vz$tZv2_L%CVUnQND!qWD-JyFP<*v+nF8E(HbvT<ud^_2~mtnhhvj
zdf}lTmSKcSvw`U+_nir(m5AfGzXbXreVV1s8-Fcg>hV3CU$}*zi*Io7c?%#y>FPAf
zw{PNXWA@nQWABLsfDi&g2zZ`{d_I5dsmB<@_*@O+bF~wXWBZ*hOG$(%jv<8T0|Y^U
zZntZK>qg{~E^CRhj%fQZBBel5A`AlfzTe*iVHje6e;>Z@BZ{I#GfMvpxPoUr>u*g$
zM@IXt+wB^FoNm8sYilSJ3MiFIC>D$GJkPm{|JIaJkW!-8>!H)>AeYMxe~5=RGyuSF
X$yE9=w({Fi00000NkvXXu0mjfuXBGM

delta 969
zcmV;)12+8G2Gj?T8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0a;K?R7C&)00032009920RaF30RRC3*VotC+1b|C*7x`K
z_V)Jp`1twx`TP6({QUg={r&#_{{R2~)YR1S^78TV@$>WZ^?&vC`uh6P($eto@bvWb
z(9qEG(b(jftJ`>x+jfr5&d%@e@B8)k;f|uwQE<!4%iDXB&rEF4Ol-)=$n3t!%|&L;
zMrO`NXT`<E=jZ3@>gw(7?b33I#XVidJzm1X!s+Sh>+9>vQg6gJS;aS5z`(%h=;+B#
zY{N2D#4=UAy??#YXo12kP{S-xy1KgV?(XHVy}>0)!X-+#x3}!<?9Nzpz#vA!AV$wx
zceJ#$_wVu5X@kESLBJV7v$M0Xu(0dB$k%a-%R^+#L1M43ud1r5<mBY)>+9v_=BcTv
zqN1YT-{0=<@7~_tpP!$bo14tc%+=M^<KyGy<>k}U(|?tfm7boSnVFfOprEX*thKeZ
zxVX5vxw&?FAK?H100wkYPE!B`3=kwR8s}`200001VoOIv5#qHyx&QzG2XskIMF-yr
z1ppiZ9Sf>x0005lNkl<ZILqCW+f&m(9EH;aTaxBd*zAT4pezU#sANMWp;8J|N(G8S
zQSg4h3x5Ls{|}x`<jIj&XZ&7%nd~=bvwJ3*_FqsamWqF+R4i!vplMlV*>+sl^(vL2
zp-RQWqhpuV`$1hZhKWxoGs}VFdY%$I&vk;b$tV_v4b2$wISDP(R>Eb16WFE|67G*c
z80AXH1IEU$-xwduBb2~LAxsEPSQaojbu(jXGJlI;go_CX)470vnQHYGs8(kXkqgrh
zW(B9&4s-Lh+HFv)&Cg|fP%dU6EJTrvg-^(0y<WcqFct~%MJ%Ie0m4$0q}YXq%Z*0k
zF2Gn0De}`KT7t0BOk#m`w%Tg7)&RyTgCXLixdLH5kueU+tc`ZNeGg!4SPX}ZWwH)o
zQ-7u%pEAqb>UO*L0mhbTG3s|xxd~xg?kE9u?Dl$lpx1j~tDE*aJ8~PsLv@Bw^|gP{
z?;jra`v?1~sSxK#A3=Dm5;7qOj*g!^Jw6J8OF=$^@ccy-;~SNL%F%<mXKWEt{_@pp
z2yaSnoBVg3s?Xd&0)5wf{{h0sPoKZ|*+P2Och<HtOeVg5`wrpc^vBux#m_&vI6pf%
rH8g$T+7%4wT0u9iKrj63pGxryht60dn&gzj00000NkvXXu0mjfJka|W

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/kk.png b/addons/skin.estuary/media/windows/subtitles/flags/kk.png
index 7f463981496b04c155a1d5d2856836bb76355ada..a0829fb5ca8ce05c1b247f8f0d0848676238e6fc 100644
GIT binary patch
delta 1317
zcmV+=1={-53b+c8B!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wiu#Ysd#R9M69mrai(M-hgf$f~aCnd$cIvNOH5menGG
z3|KxG76}QN3s~a758wdYx$tZF1zeCoTo4};h=ci%3^KN58GkIKg~PI5d)%I3cBW^x
zx+*i{<&f1qy>kX%*idC>R;!f}@kYcO(ePBB%Ky6<W;H+faolSf&iW1!0R2yu?lmJ$
z`v~9v)~E)?c*T#tcAKdm@vl7NLmgn|Y*m3#s2EiSKxF|ls6trVU!)kE-H{;60f<>d
z&ve<51S-GVt$!=N_nX%M#x+nQ=okNFlHcYizQmhp2MY-cp@0+um|+Ix0}NZAk<bb?
zspyfAJ5cs=F5llAkD$EQH9&)SoHK0>bTX2J32<S-z#X$ep;69gK)}Flz#$herQ$Il
z7nEl>J8g0rgC3|?Rz2(*Cbq*--XY2{sd%ZC!a=7rIDa0fEb?6SZzk1amTEZ6*J!l^
zB)|sPLDHbS>}N5-5T+Wy6d6fGoGrDaL7CZrf?YamRy>}DbG}&LV`42+E_lqCJ7LT_
z@eYT1ACxaqSVhMRGSPh%f&l?{uG=X$IAO{uF@seaLa@p)8@xAaGA~s3nAx1KH-BMf
zk638TtAG7nQb?TS9nLid{0Yyca%VDI8&J~OGw-JfALd==J|W8K9il|<n+y7EOgLd%
z=X|w(gPA=9WhOf1mHIWtEZDa>z1zke5Vd*V6$F%x^EML01&^|`^d*GL#M6-R!60Cy
zut52YZRWI=5$%wZE%ovdiVNC!K}}Cqg;W&E9e?*sRR!?;Bm&p%n3)~1XD4(DbP}DQ
zQ_0q-nmgek-x>dsmcW^hc#yAQwjij(Y{6;X=0w{ZYnyL2zvFKGH#$`tcZnqETvtLM
zQ7Sf(2gs6)UeHSee8xeT^UCN?JZFd8&o_9rf01|lPqR?X{WRle-IsYkKZ6wc?)X>S
z4u22nW$U|=D0|7s%_PixkfzMSln?TBU50D6lQ2uX)qjd#*j+k@Q?_^~ev)~fuxA&X
z`<N3=c;E+2Y58OSIbM&SA-W0~Z4gxB_GAv2M~ui4qtcRIj=45UuaL}pX`erY&vVVr
zx$x`MR<rN}U`9=%r^4L{q2u@c3%uSvkALXb#Iz!%UV@xAdBC}8N6eUWgJYtvhyWC9
zWd{)XbN^YMukUm0J6u@Jt!mCL9mksTQT_ymbHhI3*Zo~0DvoThqg*7r5(4ECf@i8J
z^E{!Gh7eq#VGJzu*La6OqOmQ$Qoq6de3Qps^X>7^c`qIC!{s*y225-Alow+p(SOUH
zL_itNd<!gb>^r0(ZUn7;U-dmCutK$w5kKu-<_pz5_UxFSv@i3IbejmJ^akauQD7jV
zD<L37_VW?@9CDyJ(O)b|+)F21_nmSOm(6IYU4EOsRE$&xiv?b3-3iyqhYlH)A;n7r
zMybcTmS(G`QKB(H2xY;r+hBxk%zrXN7qoae#K_8GsP(EUyHrp?SnL_~-DNl2@yLUA
zpSO95ZhVVdTQxSShxS{RVaPV-0J}1f=yEPFQRV|(St*c~PTzL4x#wbKz;09V*55Pl
zZaquAdqLB@xgJ9PYcjxZ%a(M$V0Sd)Xuxp-JPS-d=6UoSI4nacjMoYI@g7M6mQVi|
bJeB_dhu=Adiat=c00000NkvXXu0mjf`Dt_7

delta 1327
zcmV+~1<?Aq3e*aaBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~2?0{hYc00hcOL_t(o!|j&AZzM+*#(%H6XFRrN;$7DE
zCR$dD1PT!45LhH66fO{n1AhPq;Le4=hQELd5)qdufCS<YNTh&55=DUsY2mPJHgP64
zUVH5A>8`5xaj2g5tWO+5gv35|O;xu>^}YAKSKogtcx;dD|J@9;nxFhU?u^Hrb}b?R
z`mciSj7OYw5q|u=Q4LJ+il2S!CNn?epLw5;w1=6qQ3Xb!VpJIbl?BY83SscSSaCSJ
zBSDq}5VMG$X|p2<RQ|VJSN!O=uLDeKphnOw{=qcA!(n`mx6&3C5*9)sDFiUX49X7}
zHmrY<(26yw;7G_FD05kt@7E_IDDQO*Fh)GgnI;EX8A-wfxUgX0j#&?Alr`!ZFmUU6
z$R$dtL=4CU<>}W>lbo?Z2h=OC?zdy6w#8xIBFZtTM5z^Ek16$m2P%s^RsD-;^^m2;
z9ONrB+5!?_J?$W=2QTw!OwgyP1~5fN5)prALk+11GwWHfi(t)4#Itb5SL-`WtzpJF
z51DW)On5im;vnyW@&ya4?08`&y022uGvLluJK-9~%s3%tuu6RjRyAgQ^hQnQnd%Pv
zHs{;pKeKNSSZKm4-EC4x9Oo_0Gy(jP$fdGpG8-Hy<?NXc(v*+#Hglg6<#Y~FqVs?C
z0bMqx9J8r2zFEJ?zTF39raIw;`gJBO*tI#G+u9xwwZ7ja29%AnCKAIr53;lLC4`H@
zQ(y7HAYi1hK>3tS<}{WOO<$7@_3{CV3z~RNO-ELRQ~>3Ud#0)acz%?Dt9Hb`9kOG`
zv<kEmt)Nw@)~K3W;XXf@{ECLasgHlSm#<*9AgIM`!AaiaSeqPalkbjy&+YoJw5rzj
z5=qdyE~P-CoY+L}DN8asK_~U}8GB*Q3!^{slpSz4U*nbTS>EeD&q6hK(>^b?U+07T
z1XAROlV5W)+^3TbdnHlkQjzOLnE5cx*bg&4%(LMb4r(W1mUz4S9KW>Nv<`nKZ18UU
zEb}~N$IdzP3CEgp&-a+o@LKmJ-iTiyx{4UB3Dnr_(Hbz17?CALr6rvlbFCe{A~Nr%
zU0w}e=8Bzh?pLX;X5o9lJ~fGs3U?=jmOpgQ@J9PIq8o&1B}$zHIj`%0bKMTvXU;W_
zh`tg6P_UIBK;%!|7kRqA%aMO?ac(s?syW-V9BIbK`7;>KHT#&~bhnA91hS@%a*^y(
z3Y1F<o~UNb^ORQVQ*cR!F|f>E;w=J+v2E~;`c3ZU>pb+D?@wOl{j|qVm*43XFb(P{
zFV0A!lRe6SGMxGbSmMaHNPXT28e(7dJtVLqwUH6OXrJdR)g5;1h!=mG=lOfONrZCr
zdT<67=!NJ~3P_RNe8?^b>}gK)XA6jX>4ZbyDGPDYjF#Hwcj;@zNoBBD=#_>}IDq#Z
zGAcug7Y>Y4hqVpkjgGMrV-ti>2K2M_POP}Fp-IW&a3?@k2K`yDsxnK36@<l(QP*B{
z!!3{8Yj$~u=V&K4xUqXtW23rnzhxMPZ0#Okmo6l$2q~>xTom6hQXnmzu4!p<$N9>E
z?QzB1f6KhL@g(*3IpgtL!zJVsvz~riHl(u!+oKVOJ&#l1NnrZPq5Vg81{{=2DNKff
l{PZjV%TF2evHcI)zX6BeIfha!TU!7C002ovPDHLkV1he<d;<Ug

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/ko.png b/addons/skin.estuary/media/windows/subtitles/flags/ko.png
index a38397fd7b7e1b22371f1bc19d7a23a25f727b0a..f637d7f441fec21107681ae458a6862a235e245c 100644
GIT binary patch
delta 1382
zcmV-s1)2Jd3+@V#8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn000F0Nkl<ZSi|j>O=whC6vuz}y*Dq;
z<g=zRu_m!(uq7YGLP(=&1WQ9LjfkNwrJ)LO)lEP|3hly$kbhNoBF0T!wM4=|tF(xU
zL=D;04wGt!xDi9skWWLJWIo>4y<H^lWuD2Zi*A|&m;2`M-aWtjzvtXDuwy&+e>VXz
zF)^VuO+!lgp9J+|H8wU113)Q7eSJMjsdXwLf&rlG`X+IK-=F>Olv2SnfaiH3f8qMi
zpFdxR0gzJSIDZa~<KVh3uIu7?9t#T#3=R(R?Af!>!iCS<`IJ&jPEK<5>Q$zurtmy3
zSl5r^s~rHmOeln4cz77k^GGBT+`fIATrL;ddFU)Re3oT#_wHSWhlg<-hdX!fgjDn6
zYzt6mBO@cMt*zlW4zXB_bUIBW5(&K{a~3jZg?xr#@PG8_Q%uvuvMj2rt9khF;TE-g
z0HYAVr<|FY;oiM_)YQ}<gkWxNj{g3BB9RC}2-bc}vwU|H`>#0wB73W-=z5pZLkBSo
zgWld=?%%)9ix)4Ln3!O3agqA^dTMKHw+HZ(rEnJ=9UY`nDWsGfIdX)Wni>EWhi@_e
z{Y?Z4VSgCwvQN#h`s?q!`sqhheQ|=Ssw(R0>PV$hL?RImA3ls}nxPne%q;*y2&${A
z>F(|(9*;9NHpa1I#{gJ)^apd-5(qPb&~?~2Hbc`;QnK*Fj}-0SN7<29+S}WC^5hAv
zt*taQH6eru#n}Ro&*y`Z({&w9(`aaDARdpC&3|T*n#TA~Bb4ScKn$^QiA1Di!7y=z
z#_n96*~Bjxt&J$9=<V%ADTQs@NGb6=F9^J?0-B~Fgb3!s@wcNGo6T_2mDrZO9vsQd
z@;dI7@5M#qZF8PelQW35ETXhHR8{`v<If=gDP@p=nx=(d{86Ml9`357I95exehDcA
zw|`3ak|?VKsQ|@jteQGU(j+}pL8)q*hUa-fa3RFjB;4+XD+DOn6=Bbw3cj1(&(Ed%
z@HD}q5d+%+6ez%UnQnL;QC<cG0EHFi&w=VM0~C&QI?bg^mjVetd%qdWa`;o3Oe+)1
zwy|s%%l5D=7b|Pg`C%KvFc3m;<;oSt$A8DSY^E?FLpk8n&Cbp;Ha5n{$OtPdE8Mto
zgPxuqJ~;FSr#@-t+Rzy28bsF15Z438<MWT-q5EhH0(kJ?0i&a%JbwI`&d$!Dl!Xu|
zrM4<iNSVoGxPJXQ#l^+6x3@DiG{p4uG(rfz?t71Kzv<y%Q!TNWNi=Hm)|;;}@PE|_
zE`Ip|nh?y-&y!B4>FVl2*L4z!1k20IAq8C5-BiH;;osBoc%0+MkCRL$F-?=o%1SO?
zyvXItmoZI~lSi95d9<13)f`H}D`nB(d)IXt7#JX%&C=M|NJmEpuItj=+#DpH|6ZVg
zZQIzkjpH~$!u0j^k<aIO^ym>wOMgo=H8qjT<wCpIU0zIOMRCYySr!Kl9AI^Il~gK4
zGMVJ`>C-_~c~auIF1BrN0_5{~GMNndd_HKELI^HgxPY$foI7`pvuDpzQBkpNg%tWq
zN=oSO@8|sa^O&Z|nKNfLo0n2Z&%?^+$!4>gM_^eNtE;O-qfrdQAR3JZH(%l4;2_ax
zG}M9%gKqc7L<m7!TN^DcEkO^EQX)3;EtAQF0d!p_nM_htR76Qh3DIa2UDvnm`~TMb
o%+KX=tgNhHY&5bR+p!({2Y17<#d^nqLI3~&07*qoM6N<$g62w}vH$=8

delta 1413
zcmV;01$z4K3XKbp8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0*g>gR7C&)00032009920RaF30RRC3*VotC+1b|C*7x`K
z_V)Jp`1twx`TYF+{r&y^{{H{}|J2mf^78WW@$vKX^Y!)h<bUMkkdTo3`}^G7+>w!y
z($doK@bL8X^p1{>jg5_kg@v@Vw6?akhK7cWjEt6+meA19wY9Z^f`W*Mh>wqtiHV8*
z_V}%>t+=?j&d$#7@9*2&+j4Spii(Phi;H-8c;)5g^2*cVg_hiDf8m0Z@y5^S=;)}Z
zsFjtKgoK1}aDQ;i%gf*2->j^xdwY9%d3oxnwbV>!)l6pAP-@gnW$2-=#l^*UcXxbz
ze5t9a$jHdg&(D;Ul<&yV(?(&`OlH<kY1vL_*i2^AMqcm0%9xm#=jZ3@>gw(7?eO&U
zzj%<$Jyy&{V9iEg&PHI<L|(y2WV}gc&OKJwY=6SS!hh-M>Few3<L~o?V1?8<RL(zI
z&p%q!KUjuNbwgc_KV6V-PkPKuX7uOjz`(%j?(s%wn2$qg%R5)eJXnTFaWY(zGFy={
zTaYqYk&IM$_T}ciy}ew1s4Pv0Lr{c3QiUv5k1SS=ELMyxRg5f8h;eb4_w@9-y1MS}
z?#ao?hku8Mv%%9PMuR0!iX~BtB~XbaPKYH%fvvgC#Kgq6x3}!<?4F*UU0q#IPfvoH
zx*$P+AVh&6NrfOqf*?SDd6TvH`T4oIxlT?_nVFeJMn-68Xx`r5`uh5-yU<T=ohnm{
zDN>6~Y@DUG&Ew<al9G~OU|>Z>MaIU)v$M0Xuz#>$UteNkV(aem>h1DgUS67-ny;^~
zs;a72S65I_P*G7)R#sMLXJ_i`>*eO=qN1YJ)zw;BT3lRQ?(grPpP!qXo6OA2)6>(S
zpr9G30u=xN00wkYPE!B`3=kwR8s}`200001VoOIv5S6kGEC2ui2XskIMF-yr1ppiY
zgnt72(f|MgUr9tkR5;7s)Av)<Koke?Tn@QQF4=<=%t=C#gR>w+K@>gE0}JRW*svwB
zH!k*y4J-D>f#obT6$_paD`2nKvHR!v;*38z@~bm`f7;pinYZ(1cQNe0h$Ye%`PbMY
zEf{VmNRn_+6iw5}>5PhUIuR@>%3<!?aevGj&9Dr|$8@&|G(sjoh!$KuTs#MbXe(xo
zWkp6J<Khz%x!)c5o=NUxQes3l7C?#!z|*UDpS}(Nsi^>{ICnz7Gyq}>fOJ`8`VYv+
z9GHcig9c}34;ku2-kjWF!|jYHrvvZ-$jcuw(u2^b(FKKt1!Kk{<R3S_$OXU$pnq5v
zIg*$#kw%jyPbn!WnL2Iy3`EcL@gyh8#Q^+@qG~eBFtcXQnLBU(f`y9~FX0%5l{HmS
z`~XUofDWf{($ZziSFBvMdd=E(>o-Uo^w$GQDS$F>K$D@)Z``zb%hvL3+js2TwVMYa
zYXNT=fQo>s!Js@z?%BI<|AB*t4u2mxdW_^@NKFk?0H{>;Aj?%%6OQ92PM!*dLZ{E1
zbr6~77&fS@l>lng+Munjz9EOA&R@9L*m&vkm8(?Kwfe9<SgY0mNQ4>EuQw+(v>3vT
zo40P?xhoj0ac%AQ?#r6~0Kh}&z_vYdKW>){L3r|15Dc>US@rW|bI=z6UVg?X8pCyT
zyvoo8xN*2^L5_d@=B>nu@7@;y_+ZQPic;stQbYLlB1~cUKUGQGXK%|F0AIg#wz4F_
zLVvSv3OI!&2wu+mo(rHZ{3G9!*7Rr6Jo$BDD~3mO>mm_2X2Gpp1h@R_Pi5vOMG>i|
T&Fu1}00000NkvXXu0mjfcg5WY

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/lb.png b/addons/skin.estuary/media/windows/subtitles/flags/lb.png
index 6c9716ed93df01717f7c6ccb9a14ea0ce63b90ca..c764d0c8127a19531d00c62ab766b397f3d9787b 100644
GIT binary patch
delta 859
zcmV-h1El<y3+D!q8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0008?Nkl<ZSi|j>!EO{e5Qe|1_GA(u
zd*Ka0C^rtA@({et-d5ThueC3b(;nDUKmv&qNN^zuX}ayIJ%8A4yJr%#TA{t{SnBC&
zPs{&TzwL6vp&i=)y$QgdPoBG;o?=&5|A}bTdhzbH1ONw~{`M<=J2om2^k{>G4H`o3
z4?`Yc815X{QUbtZzFUlVoUv&Jcf4kOa?G3GUjYyR%wc-}0sHa=5Cl*WRBEh<fRyJ%
zi)#YzzKY$!+<$Pu+_43~(Z`RmLX!bD0UJkbjzv@u&BKc*U?9@wt;QXJbP&1EOP?Wt
znB!y+#u3|u4gm1$8;G$838<7TZOK*|!5%;_x`yx!W}aVk$FFZNdI#LG7?Bu3Gz%sW
z)wN)sJ>WY8_qiaJUBDgOuo$xw6(He|62t^zxJbT|Eq_z7$P@rs=gKm}JpkavdUr1X
zSu1tWTwGlE+1VK)!Y~XB!+@%yTHGjC??CTFFWlejWoDQeDJ4=$xI34Zmz<xU=WUo$
zVjS}pybAzW#Xkb5v6-#n9-wNrDJTzBWH<9&7w!VsD>kYNR2|dImir38%vPE9F#i@{
z7bc~&h<}U7;?Uy2ee?V?0Nj0V?7b<t&+>n|2=5Z>VRy$_0lfU<BhNm4;%m&6PgFq_
zMDeZ+ud2^3z_JMYT>#<+ZeWI+;comA;O*;=4FF3_=FBFD=CQ<zmXwUdbB8p+T8M<c
z_>><nJEIjqB-bG(11$Cck!Vgduk|dyEe<OAQGcYCy3U22Qd|R<wk@qIK>4I1I*@vR
zI5W>Pa|D6_3fgLUWvaIOp8ds%D(YR`w+4k7o{ZTO#JK@%(u92fMj#-AA~NL6Rg3M?
z4k>ACpstIh%%W{A6b4kmY?%fyWS-c>k*NYa@R^hNjnkuJ!gh<E1Z3D0VJ*6X*At)z
zs#IzP!poXy^Kb3{2yvX4u5P(a-?^y(503)+{x8CI%jUr&hV5}V3FRk#h&gVCjJL$=
luRJ^od_H^<AKIY-e*=#n?I02sWLW?J002ovPDHLkV1mq>h_(O#

delta 1424
zcmV;B1#kN22A2zv8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0+&!sR7C&)00032009920RaF30RRC3&LS?*FFVa5F7v0X
z@}8vgo}}}irS+w%_NlM<t+V;Dw)?cX%ONi9hK}oVd+T$2?0<87?sR?db$;=6e)D#K
z^ml;uc!BnKf%kcW_<4fKCNk@OhUsp1>u-4NZ+Y)=dhl_2@^XCha(wi2ef4vF_H%vr
zbbk1Ce#a&<>T-MOYIEyrbnR<(?`?MRZg=x;c=T_1^>2ChZ+Z7{diZgA#U(N5Zg=Ts
zZ|i4q?r3uGXn%6@YIO5zbo6U=^=ozZYjyW*cK2*|!X+^1Yjo*iZ0lof?PPB6WpD9i
zaPwzz^k;GPXL0sua`$L+$jHd=@9*&N@bmNY_V)Jp`1tzz`uqF){QUg={r&#_{{R2~
z#l^+v=jZC`>h10A@$vEU^78cb^!4@i!otGo>FMk1>wow6_rSow=;-LZy}kMQ`MSEg
z?(Xgeb)qYy(;c7F9-!49qSqg!*&n6b9;V$Nr`;f^-XN&oAgSO6bDt%l(iol78K2b{
zq1PFr*%_nT8Km4ArQI5)-5RFe8mHeGr{E=_(*|>%263AqpV1VX(G;E36ra`<px6|l
z+7zSQ6n~@L6{Ox3rQQ{#-xa3d6rR--oYEnn(gtvv25pucn#>QD%nzE<51rNzpV$wd
z*$|=I5Te`=qTLXq-VdbU52fG_p4ShY)DD@@9GlGsY?TXYkR6l46O+aina&lS)fJ)H
z6{Fh~qudpw-4&<d7O3JCpx7Oj#|vnU6={nmkAJu-mB22b%`mCiF|6J(t=}=O;W4k_
zGO*$?u;VhY<1(@2GP30|vgR?Z-Z8A*F{s!rpw1_gz7%DKAa9Q-Zi_B;k~4pvHio7*
zh^RM+sWN_@DRPe=Yl@A58TkMJ00wkYPE!B`3=kwR8s}`200001VoOIvUvtq>EdT%j
z2Y+-)O+^Ra2?YQg0v!vgXaE2LT}ebiR5;6HU>FvFk&T@VCtzn|WMJap<l^Gy;pOA!
z7Z4Bx0|5bkem-6vZZ0lP4kiX>Az=|wF>wh=DQOv5Svh%mIayg5X(>qwaWPR5VIgJ)
zW(7qhWffI5bq!4|Z5<t5T^${5Elmw|HGfqVWhF%gpaMO814AQY6H_yD3kyq2D=SM&
z3k!2IQxjt&Lj!$1paN?fTRVFPM<-_&S2s5|cXuG+>f-F==wNSWYhw*m;Nj`z?c?j`
z9}pNA6ch{uK|z6m0selzKHgrQ9zX>lp<&?>kx|hxv9WP+@jwt47aJQB9Tgc79)A`Z
z0#uNYn3$9tnv$BDmY$v-0R%uQEj2YIG&w0TF#)I`BQY~8G%Phd4J4Zl1RynO;i+Mv
zS(%9$Km|FunaQDGd7xw@5P;NxRD>pH=H>tu<Ygu$hoyq#fs*+^08#@~ks6kql$i%q
zP>_^Wm=X?_&(Dtn0+14*itv=etbe2epn{^}lG3vBipr|$>YAEbAgHOSuCA)AC@(85
zDJ}vksH<;iY-(<4ZENr7?Ck970umkVZLKZMO^prRJwOG$ef<+APMSPr>a^+8XUv#6
zbH<G6)2B_HGI`R(S+nQN1uB>~f5E~<i<c~2wtU5kl`B`RTDfw?isj3eE`M3Pdd=E(
z>wyY3Y}~YY%hqk%cT5Lr-??koPM{&vcWmFbb@znLd-ehq?Aw3f;Gx4ujvhOH;^e8*
zXU?2Hb@IgVV@HpiJ$L@X#Y;d1m#<vCcKyapOmO4+t=o5)8JJjD@c<Sk21X`kJb;OD
epfeQ+004Vt?pgnhhQR;;00{s|MNUMnLSTaHQmf$r

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/lt.png b/addons/skin.estuary/media/windows/subtitles/flags/lt.png
index 53e97c795c4444648351643724c7ad23ed710f37..fa71f98fe4429b0cebe2c17af96f26913df666c5 100644
GIT binary patch
delta 895
zcmV-_1AzSF3yTMk8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A)%`RRa0009RNkl<ZSi|j>J&q(r6okK*)m_c>
zNC*oFYpu0#@DVO2;Q~lp0Ebg>5)6!WaM!_DV>tjIE!xp;cYjq@zQD+z%Icnx#=@af
zDrHqEt0P{-%gBb?xQ+k&Fo55G{!C%~6rbP!C!iJU%kTcN9e@NczWxy{AM*kO%&;&L
zhCLScnQa&VBZQ%&4=7LW2@vv>Uwgz;L_ULrmvy!~^2e{=1F!>dL45xfO@C6b3Bd><
zAVdfOtE3DZFn{uWEkK2Z1d@=z-4TYn<F2v}?C^OblL@d#>4ZFDX8DqVCoC8!t>p@=
zBC{%BWZ<TVl;629fuTZ7kWM)JtpbV<;7itDSzj~DiV(2!gIn!830Ohv_uwnBTD}X#
zhYJNf`(=utT)i2XLebkAmYFrr+uYGn1*$3t49C>`L4Ur(y(5sEEVI%I=msGbJJv$0
z{Jjgd5h34L|LkRfS8^$1Rs!F=ddau(3qH;h7DD#D^g=^w)AqUVgFI=gPW4?vF67Q}
zJn+kJFM+=@0bESyiPL<}9iR7MA+TC%J?d2>s^g;8n5e3f3Aj6hm&U6KATceGB_&il
z-wX?(!+*2us-GI_b_5{zrho~iB{ssl`oSV+_60LTGD0w<RKP>Vwr4VsN)LML2X|q`
zj=grxqNYGh3-gk<p@otI4KQ8r{U>^0<)AI0q5v+&VYyU5%*(>;3plwEFSefS(PQLE
z2BvK=Wdd1|dAT6))9ZJ9b^06s@BuSpC;=1-On*(s$6$GaMom3Yb|H|;yKsNc>o@QC
zVU1$&7*UL++6<$%1ubXz^ZIW~qMMr)F_P$mNJ44BQ)<44mZ;s9yb#(Rx4#3wRzVU<
ziPT#VCFY{Q-V7tF;6UiIz`E-(U|lHy-dB%E5-CRFhQKgzRz7w^2n=PeDG<60?1Qle
zlXy!08S9w?!hxYyFX1H-XT&^&&Vs{%X&gBmj|}6;C&P|iuy*F#)fuoQ(}VVBf^7Y-
zprW*5WImsX<G2#oAMbcGojB;geJ~D);P&j`duBM|66ZMcFrC@o-QE5W-^OhK@Gqrm
VDzi(q$Ugu8002ovPDHLkV1f$1o)7>4

delta 1500
zcmV<21ta>42jdHn8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0_9LlR7C&)00032009920RaF30RRC3)tnI5q8`+n5cb`l
z_1Ts8+Lia)miXPA`rx7a;->uMsr=-s{^qUz=dIG35b@7^@PEi=@yKTK$!7G+XZFo$
z_swYe&uaS6YWvY^{L*Xv(ro_IY|xq&@XT}X#$oZtV)Myk^~z-S%VhY?W%<r!`p;(j
z&}RJ5X8qA;{?cd8nHBHHX79vZ@y1^B$X@lyU-!#k`ORSZ&SLw{Vf@cw{m^3m(PPY)
z74F4h@55N}#eZ4!$6EHuTKLLb`O94T%w7A<UHr~n{m)+h&tA!u74F1d@4{8_!&UUg
zR`$nN_{mrL%UJu%So_Ra{moha&RGUmI!usvLW*!hjB-Sdb3~7HMUZtxk#<Frc1DtS
zMw532RXIh7a5;i#JA`UHhHE^AY(0l<J&0{Qh;2NHZGSz9Zas=`22?mcgljc_Wi)_g
zHG*a}gJ(8{X*Y&yH-~BlQ#d+<X)k?YFn(e$e`7I$WH5qcF@t6@gJv>>X9iL?HGpL)
zd0i=cUMhWGD}G=re_<?uVl07T22nOId|@MZStNN|C3;*Xdt4@bT_t^8C4F9uAtk&>
zO}afoyMI1IzCT32KSaSlM8ZEr!$3vEK}N+vMv5UNx<g30I6b>LKD|0WzB)g^J3zrZ
zK*Bsh!#qL6JVCodNQogOhae=mKt#7SI=MDGyEZ$$HaovIJHR(Q!8bj^I6lKTKEyaa
zx;8twH9ERLMTQ_Gf*&KZJ3q28HMcP~x-mDrGJiO|GC038IlweI!8AF-G&#dGIlD18
zxiL1iFg3M1K!G14eIh2SIzFv3H?%Z4zBoO=I6cBRJ;XUa#W_C4IX}HOJhe4CuRA|`
zA|-k$Eu=t1t3*h*N>0K}QpQhH$4^wqP*llJRLW3Q%TZO!QC7@RR?SjY#ZObfPExo@
zO@FCDMRq7Fe=|0HIXi?uLXSpCmP$>SOHP?fPL4!JfjT{VF*N`G|CK<@y8r+H26R$R
zQvd`E5F{`f=WLSz0004EOGiZZ+}lcF00007bV*G`2j2+=02~4x3#w=U00LV{L_t(I
z%VS^|7J!kBoed{oXJcew;^5@s;^yJy<A3KD5EK#;78Vi`6yWFQ<K^Mz;^O3BVqg{#
z6%&_`l#-T_m6MlOP*hZqmzR^3k(QE_5El~_VP;@fQdUt_Q`gYc($>+{)6>`2)6><_
z*3#5aS5s9{Rst$8Ff=kYF*P%{u(YzWwzjdcwzjgev@ka_H8D0aGyp2FwX=6{bboSo
zadmU|@bK{T1QPCUt}f0_jt=&Awm=15-afv5{sDnO!NDORp+FE45*!>97~t>c>*MVO
zR1g*(5g8R76B`>B7ayMh1o824aj~&6(NU2R;bA}piAl*RscGpMnOWJ{**QP}q_Q$I
z($i8?l9LjF3Uc%E3kr*hi;GK2;eVh6$So=?$j{3KDkv+jsI024sj022hl9G>nwsjW
z%8K$bpn`_RrskH`wzjr*Am{)B5DnzEwlp_2HUJfLc6E36^!D}jPXL06Kmelq`}%r&
zy1TnNfeI!~o-%dX^cgc}&7M663TDrqHFL)FX;Y_6o&;1dci#L33l}Y3vVU~xvgJ^)
zZ0XV^ix(|iFn`5Lpn_Ga*Q{N)e#6F1o3{YL)~z6N^QMg(*00;PeaB9qf?d1!?A^Ej
zz`;X@4j(xR21gDbI&|>B{$s~aoIC|oaQe*IbKA~exNvdvmP?l|U%7Jm(xok%FJ8EC
z{_5Im*KYt7+`M)B&fR<WA5}bj^yu-Er_Y`}ee(FxqlXXf-+TVz<*U~~1#jNId;j6%
zCrt41!{;wwnHiW^Sn&WBCI&_(W;}q2aiB952mk;hi50_ZR1~-X0000<MNUMnLSTX-
CD7ohV

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/lv.png b/addons/skin.estuary/media/windows/subtitles/flags/lv.png
index cc77a3ea21b72963aef7b03fcd670cebd7e6b7fa..d1024ed7eef2a716b95b0a96f5ba0103caf87d6d 100644
GIT binary patch
delta 878
zcmV-!1CjiJ3;G6-8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0009ANkl<ZSi|j>y^do=5QV?0d&ibX
zkiZ*EgqDB@n3$&_K}d*<fQ<JcB%KF9Xc5t92?>B;cJbJ^tA7r`?QY-encV=bNN`J5
zms@t9Q>XqKF6*-X@5=zb|Ku}mKm35h!|VS9v|)Yo>rXbe!_U9|ifO;EtPC?4HXDX<
z#K-w(J`9){J`B%ZoDoPOBj)d=5Ty{uBN7M!aJAd<!?)i7Faikp>(y`U|M;`Z;_kTF
z3~Yu~d%0T$7JnekmoN9Mc1mPsg@@h8A9Z_nZ5%0w15pZYGX+Ux1!}vQp=zteuM#*1
zm(+;~P$oj8pd1cRRjmq$<Lfu56w(YgBQvW42Gwg-#IC|y2p|^Vvl2}asbbZC^$=t!
zWGU5C2LqWQtjle7@_q@tT(kGfu&AG<5=mGo>ky=bB7evT97uEAoAiFV95A<cX1G$P
zya1#*_L)LT67YzgAC&;aaU!P)%rQ&Sz|9fSy<f_I3IHoTPI+)rX!g7&qmuA}%5%Qu
z?(R-EH#Yzb!@w{Ma}~IEz@@z=au)wq0hud1Gl>YImgxQcJ-4^Fb027j4W#YQecndk
ze7Sok)qn2H%)U3wIRu$2PnTr=ErD|~5z)b|R#_(y5i5XIvw05$Bt5x%rNED0e97-G
zJ|*^h9K+o(tT!dIrzvM=Cps%i)kLH=A0aYDB8J_LpMQC|t^!4nQ)$JH83@B?+NUPO
z^PcORi0Iu^Xi){iH_@wLCV<FkLS-Ur-M2Xq&3~@VNav&UnTDiVhppDt=0WQVQz6m1
z5oH8f0=Fa=t=7%R8ips(Mz8r*FIdSxYm$orl@Y|U5fzDPnuuv)G-EI$ZO((10M_yB
z-JaJVRQyUnU4@X)G*NOvAlx}9!5tq4Mt25V%z#DWEtO~)y>3FMJZKa1G@9o`EQm7L
zVrLj_H%wPoY<D}h+bz3cWOQEvHoun@aZW&saC8!tkgC#;$0HAqkHltkB5-wm&8z(z
zwwo>2h|M_8kC6BH3~M1cOh+Cb|7Nq>T^_`jby)!X10m27`^_R3#Q*>R07*qoM6N<$
Eg0oDCs{jB1

delta 1401
zcmV-<1%~?i27wEZ8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0*+8jR7C&)00032009920RaF30RRC3i6}3SH9OU+t<a&Q
z(V?Z%qNUZStJtis+OV_Sv$ox|x8JwAh$t__ijKQ?e7tvjzJGasz<Phedw|1yfy8}+
z#eRdveuIcCGr)s~xN~^Aba=aTdA)XfzIJ=RcYMHie8G5q!g+qfdVj=ve}^nGx_5lH
zZ*;hDb-HnOyK;BEb9laUdB1dez;t@Rb$Y>ed%|{mhAc9*YjCz~ak*`Cx^8p4Z*;tG
zb-i$QzHoNGaesEea(9F)F}HAavuJI#Xl=J?Z@Fu5x@&N|Y;wG8a=mPFzHW1ZDlxQb
zaIs@(vt(+vWox%)Yq@7_x@T>>Xl=Y{ZoFx4#l^+v=jZC`>h10A@9*#N@$vHV^7Qod
z_4W1k_V&WU!s+Sh>+9?A@bL5V^Y{1nz`(%h=;-+P_<y~<z4`h1c_=NWQdpx&Po+sv
zr%O?&OH!&#QmRZ-t4&j^O;fE+RCgyWrB79%L`$PZOr=ImrbkVuM^33nPO3;xs!30)
zNl>gwP<1CPqe@VqKt`cKNTWeWr9w%jLP@AYN~lCjsYFYvL`$SfQFA6Mp+`-gJVT&8
zM4>)Kqkld{q&`KaKSriMN2fqXs6a=kKuD=UNTNqhawaQpB`TakNSQZ2oj5<BIY6O0
zL83ZBq&q{TJVT{CL#8}KraVNaJVc;6L7q84n>at6LP>5UDr_e#l|e?8IY65{L!>`O
zr9elfKu4-VNuoYQpgu&LJVTj6NNOi5Yc4X7Mt@6}N>8FuR;yH6uU1^JR$Z}IU9wkR
zvshlVSYEYRU#?bMs#RN}PgRviO=m4Ja5y}0JwSIuM}bOChfY$7Pg9CdQ-DcKb3a0D
zHah?R|8o2Mga7~l26R$RQvd`E5F{`f=WLSz0004EOGiZ6cM5kn00007bV*G`2j2+=
z0Dl|;9Sf>x0006|Nkl<ZILl*T7#4t$jhziAU}s}wU}EFo<mBS!;pOAw7Z3yk0e(I{
zULI~PPEHOsCI)69VG$8gF>!GTNl7UwX&D)5DJe-w32|{TQ4tYgA!Y_<Svh$HMI~hw
zRW)^W4Gm3A4Gnd5HB}X5B}D~!Ia#0rEq`qtT|IpRLnC7o6H`+&GgDI&6JsMo1ARSR
z9c?Y30&{r_ODk&|TRVFPM<{Txx3jgewz9O4HwP+ka&~cbbNBG{^7i(D0&j0GPY-uD
zR~Kg|paNe%|A4@t;NXzZ(6F#@AP5T!4Gjqn4hjtL_wxlRh=`1gijIkmi;GW4NPkEK
z0w5J17Z)279TgcF0aTC_nVb@n8kZIil1&E!kec|kxYU@G<j5qTf{e`M=oqj(P%;Y$
zKx#lLVxp5XGk^-RlcS<j<3RF2$s8a6sR62pOO1|7&IT&T&C4$+EGjN3EdzpbAOO*&
zCB;RB1^IcoKm`?*Rn;}Mb@dI6jeku|%|Ou9)Y#ZiUsqdGT~%2DRM67e*51+C)z#h8
z3j}?AAhM^stE;o4y{*3ms9?gxNt35coi=^O%vrN$&z>`9_Uu`+X3m&CZR(WCljhC?
zDww}u;iAP$mM&YqV&$sUV6bZCisj3eE?Kj7-TDnc1sgYQ-ZEwDw(T=#0&=y_*|7si
z%$_-O`?jq+ckSM@7pP$0{sRXO9X@jO=&@tRPn<Y;^2CYb$BrF6dgSn_(`U|}11dOw
z;o_ysSFU1$E0?cbzroDF#KMXPurM(&GBM);OpF7asXzb#SJ3SfZveA100000NkvXX
Hu0mjfgu`c0

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/mk.png b/addons/skin.estuary/media/windows/subtitles/flags/mk.png
index e9e38b720c8545846eabe0856c0cdd473f31c0cb..a860e3aee963e569f251e1162be0038ff2a48e64 100644
GIT binary patch
delta 1491
zcmV;^1uXiZ42cYoB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wivmPtfGR9M69mrIOXM-_&@Q}@>Gd31YbZ1s#CC${6n
zMj$0%6oC|xU>*`=5wftOJQT4)$S?s3WRO@8i5*H%gm_2+8GrE<A`dU{CKlu&;zbli
z%F9_Kc9^j}W}KPvWZd0$ci&re>ts>4$L@Ha4L+^Xy<LxU{yO!azq;X?U9<mp6GYPE
zht*{>6NIugG`R9xSbOs7MLYfm*|y<6_dl3_;Oe<k_d#=ZxX&aL6iY2`*(X*IsUI29
z&K)m4LG7kXAb%hNB7#Vb-YXV&&Q=Q(5Mk_=gxYS9%Ao@J3Fsa#L6uOJ0N5>#(a$?n
zb5s@8I6r@HoMT@)z&HBRNP)EM!TG07An6iQ`ysmyj1i0xYPUl7RUtoFfdbqdOn*;?
z5VZcO<Z}^>s#4np^{*)*hY*wylwuLqo&ohUls!O54S#@U8KKuBKjm0{+|fGXq40pi
zB%Y1mbl5E(bq;lo;yq93Iv}>tjeUc0I}_KKB>JH6w2pX|A9v)Z9HG}kvkZU~AOK~%
z9UX|!c@Fxo37hT{#y<^aOlTf}<;TFUK=4BEZK!`PCZP8=ggov%Z9?<AV8-J2{#&s6
zq~bo%^?&S??KYuGUOG6#P@z{5j0oj2od1o`-2<B*6w)b}ei)X1E`$zTcnVq-K~>^L
zlLkybtR!{tYq0uvrTaPrRfPCd)fnqa040F;sP_?NWFZRlUKJLP!_+=#d<Dk#2%YD_
zFJI00u|1GBmG-}3?J$IX-0@)NgLm;h#vA~cen<ow(*^Fo1?5>GELH5PK!gH5_#<?V
zf?E>AL_qZ~#%UM-69cx6LicsWovX+=KvvP;&M3+CioGdi`m?}KD*&}yA={OceW8>8
z0v3P$Q2TnMAjJ2P9M=8;{dv$tvD+crE~MMQZd20hAtXv!29Si>$t#Z_0GeaOBPdBt
zNN<L*-BM{nEWy(cf%c)X_i_aetg#o?{sJ-rJO0Xg-K)kjR0Z{l5g}+EW3E?001*!q
z7!g1*Vh|#Er261NT?{VrQAw@F%mCcwLoiDslp11i6cJ0f5<ppk;1G(~>xKTj;7>s@
z7n_?Cv>NUlg^l+Q1L*t<C?a3x?*Y40$#z1v6Ve@EZ&VPiz-3fo839~;6I$~H?%k8$
z0~dd<Mknp(VD<M=P|_{&Ug*Ci^xllD4^<T;Hz;-|*iRH(Y+t^NCZDi&?K8V}LA#BJ
zkW`Xu0HYd(=v%_%y|D5txN!Jt4k$3W51QYH3s1w!AtiK`AQAxpWmSr7*uWbnPjbMy
zsdXLDq5$U*5mXha4te|zm^mn9Tfm)#&a;0p)yXtaR)v-bemRa!?T<I$_?@uy3#D^x
zP>CALS`{gZVI3$Tijen_OhDR%%|C_>Uyg(;*Mx=HD8)il#fiJ3lh(7a_>(xcFbmuN
z1a`Bs^)YC_0PjBv`O4)?;XQtEH8Z$UoWnUsC>>M#9XCGhsPA>4p3wI!%sPrW7qfp<
z7Bp@z5Q(jEdx4ZOgT<U<Vb&2Yc~DP%Z}hcszk|{doWps)t|11Xu$G<(vODFvLzd<b
zGt78~NQRb{#UEJmcPz$Q#9Bsg%Sa|OL~4lCNG3BzZ_5xH=j88L77tpqw1`AsGe64M
z_U8=yNlO9b)?RT0lVj8#8fDX64U&J!6iE#xiIThWODGn>-ViGR5hm^iNryFH;%;!~
zqwJ~(#iDZl*U&r&i9%2q`4nvZo#)Im1?~?$=yoH3neU8qV$^W@cuKu)868PTjBx1~
zTzUn_h8e#ph4iK2KA*y>{YYuN4C9YN{m!U}Wl(xOq22UMe|sE$wu&H92R1JQ^^f`Y
t=tbatK_mr62FLL+ng{yV{uf-c4*`b?y8iyR-tqtd002ovPDHLkV1f)gw6*{M

delta 1534
zcmV<a1p)er4518=Bq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~2?0{hYc00oyxL_t(o!|jz#j2uT5$A7Q7t7kuEyt}q$
z*Nzk0abib7N{FKfq=*FbAwdp-gN+hU#0f=CHXwlv5(kjDMG1-!A5uU@d<u~dAMhm>
z1Q7UuqDX|qIRrb|wY|<dyX(z*X6%{iuIhR@RL_6f6W=W){6?+rsaN&hzh3>{zu>xE
zxBqt&MAGAj)nzjigt9f{T=^NSJ$Ln@9lwWc+whos7v{fw_1vk4pgB7{W|9etr51PW
z6Dx?+kBn&NzP~?9?UqX*AOa$SNR8er7I)583lk7w?2d%mZjdUV0{IE(9xp+aP?iAL
zEslTDk2_RzR29`YKYx3iW1l*}7y8mjfwb(w`R7j{=@L`>A-e&L5sVRPcS847AwOAx
z0^A%-e_e(UwEm>za}kWHQriXf&nY2?5R?#<ViDF}1obnNJwQkefMyw?*CRjWSboOQ
zI^v=5fWsu7jbC-xEgp3ab&ld~Pv|-zKB0db#|C~o6W5p|#-Q-Dj(C=zapb2Qq1QvR
z41g3M0A;%!1BlRh8T$VgHa#Sae-zA^&^!RkPlI29;Dz3sQ2$sgK<`ZmdE9y0gy!R5
z#^V3}8?gGE;@;Qw>Xhv^p(<WFIKxn(R}qW|<uaWAsnFd6o4z8XQ!xDmEIlcN4qShD
z9$FPaRpLgI224MpBz5p>u=)q3`x*pQg!op~nCnUaC4l#+_Yq}eAqw<f6&8=f)IMl@
z2FCUXoxg%#zMAo4dmwEp?Z3d<VF>-W<H61c-{O7DIRG&IeP~P<xOWQ5vqD&^*j0fD
z1-$<&=o|&NB#4QC>Yt3$F8(7XY#o1v?rVxWSCMgmtfIf2QIZ=KdrQjn-N5%M0JS?I
z+m(}jqDPV#Oey%Y;LZsC3>2pocN+Th5!lqjQ2TtOAjI#H9M=8_{dv$tvD+crE~MMQ
zZd1}5AtXv!29Si>$t#Z_0GeaOBPdBtNN<I)-BM{nY{AoyfcBxW_i_ggtg(L=)_w~z
z0y}=kdf%(YHdF=miV-1b9&@gDK>!gC6c`aeF=7xRd8GQ`L0wEPA3`8hJ~IG!`4Ef<
zrG}UsMZ^-W1W=YBID{gOdZ9lr_)}2K#mCJFTDdz%VdKNY06KpLipZDwFM{2vWIG|-
z3F!{7H!Fx%;4&()i~uga4y}Lr0{7nnHwWc{AR-tByA?zgyA}L7SUm*Bz=qGpAnli7
z^%qf4(k<~`=)WQKUXQE~RTm^TDRw8=+X^nW2bB|<eAe2vyLRn@b{i2PsU+6`Ml}l2
z*M!M0!OD-}!r`kqpuprlXnq4OyZ|eQl+aazNCW_sRV%V#1OGXBk^_IvO|9#I76mwm
zh@h%Sb;#rQ!OTG++XC(^bY6<3PNspfYP3Y~%h5NrKi+`j_ruZ;mCmt2Cu(eKRir3}
zb)bYOLf%I*0cjI9e+M>vIufp26BcHp6bn%mCmx7FS}(!kccX7%7PkKy>}F-_)6o7K
zy!RC3E0-&U_xK8cf$D!saSrDkp>#~`cijAfqrTUHdP3i`FzYDhT&z-A(73liBtDIM
z3#5z{Ean^wvyO1dgL>+FW2}w)9h8pX9M1c74KV<Pwe&=g-6=O5vNXSyVa78=GPJZT
ze$$e_Wii$w)-rleMlzWpQbVLhGMO=YPlnhyCx6Sbc+jGyMI?X5n)!Cdw%=sf+bso<
zTYJS3OpZ}|WRy)0G)N{>BsG{MO76;!pjZTZQ|tspn0OE*9oB$}2f>|>va2E#i^}<*
zK=U9Z3PEAyBe3=7o-;2NxL@|5+l>Hb9vkPxsNwYSlzQDVI+BnW;nFd<^a_v-Gk#MF
z=|6|Zd<v`fL#;~jFBpFc>i0)QEQ8YP3GJq5`q6Rt!774C9oP)ixwdu@cux>Xfsw&+
kTto9f{~G7KZvTV!0f!2@{=EnrVgLXD07*qoM6N<$g2ive-2eap

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/ms.png b/addons/skin.estuary/media/windows/subtitles/flags/ms.png
index aa2727ec65066e4224b2d8ef598d2a21dde46ed2..667a3d4a709fb3906e1528c2fc5c147fcbcc6958 100644
GIT binary patch
delta 1264
zcmV<M1P}X~3WN%fB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wiukx4{BR9M69mtTlfRUF4Z=iWPic4yXgH(hsEB2ikw
z^+6FqjX(nvMC>J{x2T6GiXtK~il7G}U##Aue=j{GLH{EWC4Yk@Gs7O%(Dh%Nxsx-I
z?##HeGduU(^XuW<d*{xq5f%8-{@~u<x#ym_=X<{2-|u(Mz=AE<|J@Wyd8~cI@6D&F
z%ryViM~+N?_K(JUJvsEv8aoPKr#v8w2nU|qO0BLFxD=VROUiRdc`g91Yx`Z-vBSi=
z?e{-rA4L$6cz+@h!59<wNAHwUOioV1=xEjhJP<BisZhG!0AO)$mc1KKGP0~hv9g##
zWq_k+*HNzL02O~EYTtM46C^|<VsC<A#P%97wk;qC-qJp<ym<(~^8nHw)EgRK2MqRB
zd2!drRO&q(IJ}EewI6`x{nOmlUuC+MM=6Ci4wZV&E`L>P6kx&?O1OFp$b=o%3xa9P
zAt}qM7japw`S@CRVBHD2QZ-)r{6T)d*$YZgN^z~+!}c}f+_Px{r4)zHtmpg5)ikxo
zz`<u@%9Bz=5_Dbw!+Y+9_3K*zd~NWxVRYy+Q#bmUy3vbL0?MG2;*Q)+)(lOuYH0z0
zO)E2;`+seSYmLPepE%H_drOXl1V9kR16^sZesw&-fEaWj=s-X;VtjO900-qnEE~l5
zAb$80jUQOhXx#>&Wf2pR6c(Hc3_&<92GH~an!e%8)G(V@U1H^uDbAPfgg^jAv6AC#
zVHy3oG62UXMktoMY5Ky@J1@1-|5q{uK|l}$h<^x!k8Fp{n<EJfbBzY|hT+|BHgflp
zi#)yc1716}o1Y3R5P{W8uW;hRFkk*SVi^&Sa!mu8pZD&IX^+#d#X+16frK&8o#pDc
zr`j2q^98MiOQn7ufB#XQ+;)V0J3eIA&v3rDoVUkz@W;%ej*=2i<Lg#Yh$=}qsRERQ
z+JD;|g{I#j0S0Y^rVb;1I?v0W?m-ecZ}VPmS=p8!+CQ%VbzVUbV2nX)jfha5n1F5D
zEP(eaM_GHl1hWlXrErvkqm)HY=)>n$4R2Xt_ZPH>UMmBloG>C734^aY%hdRIi-ADI
z(&%fuYR5rPsAv|Y!Xg6gFy>nv3o0s$k$)4!7z@wW?Gg;U^#a2iHsCl8j^p6EZrpYp
zCm{jzd}sP~W<jz5MKTy;xOVz9>>RTI3Xkn)aODWhG;ox%GDOtJ^jk*M-|TeZR$!@*
zWdMT^h|LI<&oXuSLc0W_0|+#NgDBOaJ6dVzrA>cDa$A&kN@Aa=jrLg^f-r+TfPcP&
z&oHoM3$E*uPNzwwQZe;O36fV*hFcY%qy))KX!<_B@6$In1`mB_0bG6lbuJEkgxB!N
zx*i$j;wc9wTwqd;<UI*MI>Iob9l(g)4+4ay80OM0zZQRKG0^?+PO_tG$!0Pv%J;A+
zm&5Z?I7;C-Dn6jt`C9ELBdp#L6KU;jV<e7;rtdRbuQOdKlm6ipyn50C$gCJ<yj&ua
z$&lAIy5_oYU3Xrj{}+oSsMqUMt5vcqhU2qW9vB4jxA{Ce0~GC{6tb<deA`R|jfMXO
a3-%}BQtpvy_Pq=M0000<MNUMnLSTYxYEohV

delta 1269
zcmV<R1Pc3v3YrR#Bq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~2?0{hYc00fXpL_t(o!|j$`XdG1-hMzMt`;+XZX=0lu
zDPn0cg{BuRrO;M{R;Yzi>WwYliC&1JC?Y~d5xgkao2qx>-;Ea*!GE!o7Apj6t<;ND
zYWioa$=Y49&F&_f-Rzt>pBHClb~dTvA4RYq%$$ESXV1=gzxVy#Zx?RH&G^5ELMe~6
zulU{hG?kg=-+IZBsgM5Bey=Nsp02T@@OjDuvWRftsjbxNI)O`(NxP&xhm_|6;JS9*
zbsf7+?6Cdr$LymBA`%}YA{b-h_2@ID6yxLLFg%>~01t%omn)R6HUL<hn`Q6DlMF2@
zQLKL~rcmkQ=-G9Y>p4KhFNx-N9s2+Y(TLcaAQ-W$MvR>c2!gk?hs&=X0`NS5v<LNu
z#@7M;-Bq65^*)t)7Y7dSqEzh#V0rHpxAj(;s^w8ip^ZbOp0lZHjRH)Vp@i96Kqg$U
zqac{Z9FnrEdJ&h^nvbuAd)A$xBUR&tkMDowm+5X$f>Mer<u10b8Rd>mV<@FKd}cjg
zkFTbwJ^Btl8B?B=B9dVK1u(ehPFTOb1;Ez^UmJ!8E-`tnhskT*C?%i_N-1v1O|xcT
zoK;H;0Bl;B;rpKlxYAfm@sR^<y0_#=NB{(3J<yS6;<Muk2E?EPK?ee&5#yr+12}&u
zCt}$k#s~4kuW0<hf=25$0Ii6ah@`OKRA30geKCNhAJFs-XC?>Pyy_w=mrQc5bSne`
zD2kOFXA8^d&6NQ-J~l+L+)2|H2HtqCjsD-0AqWD3AV5Uue_%Uo-W*9_m}@ksHw<rn
zv60)CT;TDo@9@&G-F#PAfe5T#dYOL{=Lh-p+ab${c$8}z(EPA>Urc*!zZM6v8v+Sy
zpfk(Fm#5kpnDYg#g^Q(L9)9~l9^H0?eLLP|*3WRRxSZEVcJS-WqIoSPJjU0prVw?K
z@K6OP3AMK#g{D7G0u0&+O&wPJRG#NQ+=C=MZ+$OZFP0zLzn}rlzk(pZ7=wS-8WEv9
zHU`_aSpaWUj<WV@31%C(O5rF6M=6V*a15X03={Lh?oVhhy_N$aPZ$x5gvHmHWpZ@1
z#XulpY4o+t+HnvRDmq1}u!%rBjD-=`f+D0m8U!)M!t-^z1bweP!{CMuIF5tkIJmAG
z&mG4}NWg+|zWwIAAlZN-8H|51TseIjc8*v8g@^Xjzj6p>8aPT>86xUq`Yj`WoPR`r
zNPR2=7=%EqBUC=i<fZfN5{M2U&<GBqREzE?({PL`yS)-5agQm9$3$<m&)N`#4)Oqc
z4n9HOmMyrhOFEq<l}g3bCnZQ;Ng1x!e3B9*ozV1seBY;MWCZT}$^w6wc=}~7^u34I
z@X5L!8Rg<B2PaH0DM#|21duRc8|?r_?C(K<&=kX5+U2L>k1Yl|@83ywcrDpXhDG@<
z7UgnyUJ6Gk949oRid@l}M~<+1M@+QOjghz>n!e9$z0OpnO!}Ks@Zw1eAhTkS(Q=7Q
zCPQA==$Pxkb=?J({!c+7lAvC%Q>|9Xt{5arClB-k`G4)SKNmAV(f%ogEOA@DVWEM>
f4L<W`{0HMV;Zp9A+J(ej00000NkvXXu0mjf$<bA?

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/nl.png b/addons/skin.estuary/media/windows/subtitles/flags/nl.png
index a1c839ac83a0f2a7e2d7865c7b7f72cefbaa1af6..85d1f0cd205481269800650ad94865020eb4b415 100644
GIT binary patch
delta 820
zcmV-41Izr{3cv=C8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0008bNkl<ZSi|j>Pl_x>5Qo2rtgh}E
zos|f#-3;Dfmfpp+OF@u#3eVvIyulnmkls8uE(8&TZr+rgnST*3Dl;pqyXPVDaAOA)
znOU9W?~6Yb*>JO){ohRhzW?lVA0Hk#9S;AAXw~}qx3@9?xWkukz9qf9EL0+daU=`_
zx)}h_Fo1xDu<Qf8jFvMvSWfdgCUQ#T(+S+$zTxhUAHVr-p3et3f4=>N>GwYnnGY5b
zRHV%XDPswp$bZT!cW*H6j^kwn^JVT1yH7u%;>@mXHsoo-Qbd^vL=>OZt6~!nk$I%P
z^H(6sI|p~e9SkQ=6Kpnp1Rx%cSWKXT0w#){i7%B?gzJ010?<Ls5ikrebK>E+q@#L}
zQ^HfiMasb$S8amMk{a(TxT^s=(SGh`3y>GBJ_Q-@lz;J*FcB#Ex13SY<#0e%R_k*!
z^VRR>)}qjAA!Ty!#PjpBKR!MpB7_hKA)u<L>Rfo`>5K2xBJ9Tcm>Fh9&Y7Gu?#_O{
z=jrKb{tR=@Ow$B#6#!Vx-v?0VX11F509A8IL0MFhbI;GCa1G$xRJB3XGtI1xD*!WF
zdD_GLTYrFan4EJH7m*gB7J=9D{2>6`{o?G46ucJle_Djs#Cq8Cb5;Ofz4?L1FZLYY
z#j;6Dvzb51+J>(+qfYq(#OD@BX@#X5Iv?L}*#G=f*NWYUF%y#&0M-E2YvkHxdeIS9
zt@#Q-jD~v`0e2(iQkkN~xn8`E{$AmJ?M3(+M1L}az6jkCF-A@?B03=Aa~hyaM}_JE
zxCHPHqzEq2m_3h?bp!@6+#*2?RnVY_h9%@R9Sxu)WOWyL7lg%Q&~`Or;O1b7ARWMV
z6t*Gr(Zk5NyCZCNGe8r*yn<_Sww$+{(2-SV^rbypCY>gxmm}MuyNvF4TTX{xk#S4T
ycP+>;o`wDcSk3?GFXFo+_q*}-hxleU1K@AdOZ^LC1CNOS0000<MNUMnLSTZ|lzzMb

delta 1362
zcmV-Y1+DtP2HFac8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0&P%CR7C&)00032009920RaF30RRC3lNchIB`=Z}BH5y+
z)tR2wnV!~~pV^?L+@z`Asjc9wvEZ$-;;^*iu(XjEA<2M-!GCLW!fbQHY;(kIbjEIV
z$8L4VZ+6LVcgk>h%W!ziae0v(CdPPvzh`d2XK%u2Z^UVF#cFZJYjVeHa>#6R$!v4V
zZFI|Rb&wn;!E188Vrsu+Yr$k|!ewp5W^To1ZpLSC$7gTIXK%@9aLH+Lj~pewXKuV+
zX1-r%z+h;>V1H=CVrs-<YQ<w~#$#*8WNgS}Y>XTwy<=;;T4KCgW4>Huz+Gj*U1h^w
zXT)A-#$ag3$jI;S@9^;O^Yioe_V)Pr`1<<#`}_O+{QUj>{r>*`|NsBR#l`36=j!U}
z?d|RH@$vHV^7Qod_4W0_!oun4>Few3_xJa}z`*F}=zqPvz4`h1y1KgV?(Q8oXGCC=
zI9851SC2YakvdtDI$4uCT9i9ll{{OPJY1I@Hf29skTX(@G*gW=RF5@PkTq42HCB=~
zSCcnals8wEKU<L;He?(%V>?)mFi(jvP>V59jWJP<F;b5*Q;;%Kkuy}1GgOl?P>e87
ziaS}49Dg)o8#7-vQ;8}{gey#lEKQ0nPK+*3jxJD-E>MszQIIZCkt|J%EKG?jONKU7
ziXSvxHBp2uOM)*>h%r%&GE<K;Q;;)Mkuz13GgXu{R+KSPjxkV+FiwazQidKhTqZhR
zJXC=|ScgVnkx6BlN@tu)Xq`)Fo=j<<OKG1>X@8(hYN1VPqD5bkJywM!I9o76Wj04;
zJxy#wRdq*Mdq`S+NLzkEQ*<~<XfHrvSG|@K00006bW%=J00ayWBrqE1Y?A;000Cl4
zM?_re*Z`LR000McNliru-w6c(90DB+s%QWJ0!m3lK~y-)V_+B-fRT-z4JTk{V`O0B
z;D6-e;^yJy<L4I;6cQ2^77`K^;OFP#<>BVy;^bgrU=|S-6PJ*bl9rK`lb2Tj0(p5k
zSs7_5NeOW=Q4wYaW<@1s6;(BL4NWa=Z5<t5T^${5Z7od=bv0ELWhF(R0zG{LLnC7o
zQ!{f53rkBYD@#iY3v)A56JsMo1ART90)J~8TRVFPM<-`z7gtwTH#Z>R;_U3?=wNSW
zYhw*m;O^n+<?Z9^=kM<y00ls%pRbR%m#2q2P(ff&a7buactm7WRCII<5JX2uMMXx0
zhlPd&2L%EZ#Ky(NCj=!XB_*e%q=W(ikV;NUN(@SfkBf^1DoBk>OAiW83P}dZW`6(y
zNKJA`QgBduT3jknL1tE3LJ(LUC>aI>AT=NrK?!MDnLq{EY4HicNg#QkWDXF3)Bsf^
z1t-L(WdjxD#;4~chJfXBa>9WCqy(rUBrz{NJ{PDUzo4+FxTLhKyaEU+fdE98mz9<j
z7Zn!d0~J(N*VNY4H#9aiH3LCQ3x9}gYHDn#udA(TZ38N3@96C6?&<C8pD<y<L@)p{
z`ulo&x+hJZG8L#`+VmMSXU(2HXYSm2^A~`@{CRWd&Y3-X;iAP$rU4Z!UABD1%2lgZ
zubD7$?b>zg*RNZ<cH)FJt5>huuyNDoEkFfZw{73CbJy-Yd-m?zzyH9&gG&eY@87p~
z&z{}8cI`ZL_y|zJ(PPI?oIG_J6P!AE=Il9U1|}9(Jb;CXfsu(B4`5;(=u8Cy0DX|=
U100R5hX4Qo07*qoM6N<$g8#2j)Bpeg

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/no.png b/addons/skin.estuary/media/windows/subtitles/flags/no.png
index 6c4c2e08d934d8b7d23da2c7447a4a9c3712c984..4501d95caadbcfe21f58004d5c81172667ec8684 100644
GIT binary patch
delta 1013
zcmV<R0}A}@2+RnOBtr&bOGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wit*-1n}R9M69myv!&e|a<a-g7MOeSdZ`8xSFld*Sl#
zym@oacfNDJ@7;luaWekzLlCKcKKE>Jr%s{!`zs%seET)ey!<`@zkc@-v#W3Xr=V@D
z=l6c8D`0HE)9=26&6<J=5W$UVq^cQRxWE^mUB`RJ=H@1P<I|NJYf1oE%vX&Oive8(
zFvHrce<x#pfA2$paRpRru-N+(y>~B@0yq(z<aPDxRd#;(4MBM8+9ksGw~_K4fB|N9
zWNij&iUDedb^r`_<_wxYR26{M71}gth$W~XE^ja50EjWQ+#n^xAp#kI$oH(=Qv?t-
zj0}XPLF+0b08qdV4k1Pm$vZnKSt=qzh}v%+f8zrHhCz>lunbHsKWK&>9MbNV0hpmN
zA~Axv95{hE*X<Qb)*{jYuq6b?u^^gRzzj^$7&8+sfP_Ix5EF=EB6%i73KJoue%~08
zqq)*mcnAQnLcN(406A8|h716U03i;j&(}82B18ss9IvqsKw-r|N-1bd;X~Vm89@Ez
zf9Kfw^B5rBW8P!VVa|aF)9I91(;&cXHiH|VlwKLewIgd)?bfE6XG)z^>pxzH%a;*E
zPLIyLa{tl`&oOHPCLrX%nE~l*zvN*{sjmiPJ^h9v29t5k?H}*3*t_{y)&4jpWf2o1
zf?+sum=uY%V1_{-8sCZ+WPM8UgjNxCfAWLI6*;|q>(>3Ptt~_Z?>*jooO3wmy5KLq
z_AvlIee=OeMwUx3oT`edl2Rh2gqg9syUR;gu4D!d-@eZL;zeZE-~eA-(3M_azxfsO
z(s&}m?An{h5@1X2Xn+<2N@m$}CSwlo-d!QX5IPfTb?!>gR)#|#c<3-gO27_Qe``jg
zdW8%_L_+MlyLf$@(PF@Wgz$h7$}$_)+prDfDP|BNX=p?d!(v2Z#1A@uSnJk`%`6+%
zs-y=ivA!AmzAZ1Mln6rr3sV*$;9@{<1w<}^bpZMjNGXA=1Yw;Y^>4`@keU%gI0~Tg
zo+(D{9L{;Xb9iyMVuT_>UHP7of2!*4cUnIJsL$G!61R4&s?5!pc{gBSZNx!cF`kU6
z*VdT$D$B5_Kty=z?Bkuwy0cFpOFhtLD@zKnLcKs%K?qEn8M9H{1Muq;?#!pGF=E5P
z#8P({0T}J<P%r)lV0(L;#r*JJAH&*%$uun3pHHdQC!G;(08auNkN7-#Cjk5<h*ZG1
jW#bW!2s9`E3r@yA<3w1P6BO*^00000NkvXXu0mjf7I@3&

delta 1029
zcmV+g1p52T2<-@vBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr%}4bV*G`2j2+=02~4x3#w=U00ZMmL_t(o!|j%lXGMQEGxy$eEbe`OW}QSN
z5Cr$Yn|J5!%=y0aopZifIF94^zlR`F{dnf-;7*)C_xD$RX!7-!JoVzc0Q~&T2Q-&o
zdmzvj>)E}Z>IxVe@Z{TXVa=?t0z`158mVeV=g#rjCs*;_vAMa4Ui)}uVoeDEi}|iG
zVlkkL0A^TQ^<;m{ukXAMFs^_~4HkR9qj&CPQ2-}`lYFjTzRb>dzaR*2T)9B__9jyP
z24H}hEuGCkO))^t(2juNPMt#Yo2mlPx<Y3&G{gcbh|B3k8~`z<RvV;LIAkCL68V{x
zXNmx#hLMRdo1t};82~6?2Zs<Nh~&&pN|lO;5Tf?UWBh*`fg$KJ3CqOP@(0bZgG1VE
znSdD@BN8Ks%fJc5xh_{IRf|YRz>YAumkOd;1<b${jWH|H5=a=N1TldqCX%nDNKqn$
z)aQ*6S+13?!$Sgq73s~a5Xe}G0Rc5&5g^2Y^!eW6EJEzF4$nuUBT!T^kkSg;R`}2k
zVJ1+2{waTU_ACa7_n7yXbC`1=!gM;NnavQOX&SipQJIw?t}UHawL6<?zEbK|wf^l@
zxOfpk<mBkgOLs3k_YBP}U;;u0&I+{KAV*3)`rcL(vR-~e5rfIN=H~aeSnOSYq-wt$
zld^~j5y3E=I81V0X~_&h?~8B63-W$S@q~6G>g0b1gDY}!`^JsCTU%R*2;O_V_c-Tp
z&UN6=zw#jfKYaDxN=1&gV0fu2s!B?UloDpf?(QxxT)LDMIDGRe^YiDCW`+ZNaY0vR
zef|0u%*)`32+ft(?<v6WZpHny7*I0Ho--M9c>8uggxwm3Kx;xdiQo!oyM{v_xNn#t
z1+agk)tb?$Ua^KDA|dwEUA(@nXfaSgLRcCDJ2DbhURoQrLJ0Co5+Z46L=nScL}SDc
zCV$xL){4z68`i3#2Pd(982h;`KT0VPh6EO-EJDD=fZz&=+yd(e^evFm0$E9-b;RMX
zWKT%Vh#@Q!n0e0>qjnDGJl;9HI9xG85utyse6L7Vb<bP0<u>$HyVBy;j#ZVp8I5-X
z1=dC!)D`2&n0jrEiLde+mMstwo;dwz=d$kfV+>uv22(FAZ-5o)1@abzz;xEojOw0%
zU!QPmK4py&8xAIxx_?FhMmsyyi$4L_-ri<0Km6w{STP@J#xyM0pHHdQC#8)d8^AH+
zz{bDM`e1PY{2_=`z_?Z8Aw~pd4;k|~{)6!s<3w1P!=6c600000NkvXXu0mjffv?}L

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/pb.png b/addons/skin.estuary/media/windows/subtitles/flags/pb.png
index 4104550801abbdef92cd9f590b014fb3b8eea244..78686443126077acd63e1f3aff4a2cbd6e40c92c 100644
GIT binary patch
delta 1595
zcmV-B2E_U149pCWB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wiv*-1n}R9M69mtBZmR~5&9YoBw^ojZ5Fov(aMOp_FY
zNl4R7i#{lVLXh-Dg|xL0>j$L|Mf9Z<DMF|e`lNy{A}UyowSQ8Ov7#+%=$DZYXiE&%
zNis2$iF0S}%$?qw`?>eod--tg+zh3Uk{7cc&OUHB=l@^-_1}A~19#$1{J)1F67!u|
zH{3TswOzk0pgpW-&*x&G58%1u-=yK%U0Q+&<fDXK6qAc$03s71lC2*WK6q5K6~Orv
z=Tkb~q6*msihsF29)IasfW8=r3CjHXbyk{{O<fRU5RvR&q)SRb1%OWs)_8EN48V((
z3C`Xe>b|R}D(L14s)~jH89r0}V-OS|jsX%A(@HxypMnttL4x*(pj{FgF_pA<czl)F
zkvfub;j!(D9IX~PU7lja_JQ~e9D2aINhm0-v_oQIEPs$`t5EASa3Mvwm8}?o5D+3n
z0>_5SJTzIN;Dw9-oS?Kehyv5&H#xey%z<4Sys$dOE7dWA8Wf)?5w@rjlv=0JQ=>~j
zaUsP8kEkG#Wc~~W)UdZu<K%dWL!(U=u6%?SUOB||(g;47t~UZZr>Z=7>;hlex5Uvx
zh3D6&xqsB`2MMT#4BTf#Tu6I<$Or^TgC`AXmOX+HlaC!=94qsM(KQNr<>Ehv`Qh_N
z>DZVgX%a<(i3}iIT^iu~zqp?#9(j|4`_?&?)cD=TI4@NuXr~4xMMI`S8e#}r6$py;
z4jWQL45BfIixs{xxx&6eD|5C_I9K`{d+whk$$vRQTe!K_WM#RAtvkd(-6s5U?f_3e
zeulj9oEW{qy@hptwmQYz^&wOPs-D=pO%vWC&}nyQS<6V0^5yX|pC74^Q=!&?C{mVJ
zw_)=$<ojy`0+W-&eEi;N8rq~?O?mhAMXt}U^WLR|w=Whsynh8}h3(SjsnHGoC}W&n
zn}1-##zYApAfTB7pBh}{(TNh<`ci^I8nW{sPT-w)l|Rf~B$6hP2my#9VRXF6-Xl}Y
zKCqjQZA|mm(~DeL=;z1*ivVfJzJGjVnb|^_pRZ2y_vX}xct8WHj#w;^A{ams1yMmm
zic3BDVuUe*3E6qEQEBql@8>!HYL3I7oqyr@6Zf#I`W{$^bU{FXKtuo>sfL~hOiuxI
zyj&UPt5^3jR~g1&NpPSJ36`13GD%{HB7^Isv|1J;LL3>y2(6Cg?A&GE`1QZov$F!h
zf;ti$kyu{d7~*SJ_cFIWj8*qR1r!@ntXN9c@XXQ<{!$y@Tice{UudCLIC%FG6MsWD
zxK<ixbU3EnZqsTyM8G)@DEZ<Lran(!`y8eSd85p?`uIU<CvR3qPy&d>2GjF^xm5y>
z4GtG94$EuR0Uo)$j~}m$;ew^V(B`o(y+LqI%4LU7m1d(uqtPLk#F%&h*KTt1fisMZ
zTAa81WMzzpFW=3X_XlxUT(H>SNPpG$N)RE^7tKyTH8?R!%XbJUDS;rKc7V5PBmAvC
zz@E6yeRr*KaQA<>Fh9!jYCo+`OsgX_8=f5#D?EAfRqi{o#QF6C-@dko->y&4)_^A^
zRZj>3uYp)1sw?aG^QGsq5_lyIDXI5hq}z?U-Vx8adOs&F@8|2)Wu83nZ-0Ju>P23^
zu!}28qkwSNjtZYXw1_Pz&n$eDpO&{{y?|KIZWG$<hCwq0eAwavuQ=y$&Ot0$WqO@3
zfIu1yKU$vVPt`$A%`9;2lb85RRzNhspUWeB_tIYGn?*1_t81Xw5jVj#C=LgHiwSdH
z5Ua#0h(?G+5ScA1bhlCr*MHm)k1pK9iT77{ddDIHeDB6Cep8tOAeRKtC`+Q3c}74p
zMo6mUyxi)B{gO~fBL<UU;zAzN7bB7BmV@3*pjnFofwSp2#}^N>xs7LrG9X0}wq)LY
zj&@7kw%B@`R>;xVBv4EWnCo@oe4bptCrWZzEB+sc21VMIw9%lLFEp^$oe2kkX<*<s
t&!csqlntfXTo~VG0x8hG^Ivc${tHKwAZ=PoT`K?p002ovPDHLkV1kqL@Bjb+

delta 1584
zcmV-02G9A-4CV}wBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00rDhL_t(o!|j$`h+S71hM#ZkefBwL&ip%n
z`8Ca?7)(N%W?J+@5fp-?H!7soLaaZOUKG)rQlto>Qs|Wm-iWARHP%W&#)`J6!TuNt
zfm&j)PLhe4Oq?@wX3q3X&hJ`#t<Q^n=42?vs}g?%^Ihz<VYB!9e((3L{Vupuck2JW
z1d*6;&bXmMKecxKwt)7qo;jb3fdas@$G=9ywY#(g5y(dgxhN(V#Q;PmLL^(?t9<aN
zW-Ea6DbA;KyhRnV3zTvN9((Z_fI<w!1Z8gRI?K)KrY?vvh)8xX(j_IJ0>DQGHh6Hf
z0>Bpw)p5?=9PGZUs4D2@3aW~R02w}$eWR0M0T_Row0LN2g_+?xl5yeD?F$^Ol{j6Q
zWZ4!#d<G6ZVBI7XlvdgyF)<d%v{l&XG;kqBxYex~fe;WPL;}Z#DtvyTOwkJ$|1nN^
zbpQpX#%^+SPlW@!*Li+rl9y|v1T`o=QzC3pB`6!6Mo*0{0mX$B7d)bZM3VV47*NA>
zaf5%8V`UDFG?~Bh0iJ*P5ZBAY_+Yx;2<)7!@!+uwd~x3*M~hXSTbtrivkxSo8ZvO7
z5pf~y`5_|^APt^0q*?a}LQFn(e0H?LXGT^j=9P<oAL4t@9i?MqlB7u#2_`ataCNbt
z@BH+B9)I|C4(?myRI<UZ*T;CVI!-$^C@Fs$G8NJgL)fZ7P^@>@kRoCbjX7MZ^3{oD
z_7z*1vwgz3@~7B){{%_S5!%Ad)h5eJ8`!!-4AgDH&t?zs)MIDJ8_$W68{Au5<HswL
zyjdSaHK6K=z1uY5Edrf(hnBSrCn;YTtMKXJDmfK48W2Uw(#ke$ei!+^4FZ9Qi6MVJ
zeD4$uZPKo#y!Gk=*XP!F`%=Q27fT%8zl^iOc4_nE$U481QBJRpvu<Oegm)3pOo5LL
ztnkQqnQeuXppb^_e-J0|x3`qv&R!&vCXomMh$3NRti<$@NoF3{!-v+V_|xeHuFUsw
z<bXwhG-TgDKD@+CvBFPQrub`f@;!e%paE4!EEY%+44{aDsGuRmrJj5#!WhAX?0>Od
zZSux%<~aXKj>Dha#qr1QVR!9quny^hfB=Dr060<&Jr9_k0_u3FI>eW*PBU8_!eB{o
zpbiO^T@w|O#1KUW*GXx$EJlPlGKdjc9n0C-%e?lBf3kOH6@mqIBse0mytIEl$d|89
zGrKl~RrhWM6dO{kSjyJ$^x_WwxY5tow=J^2*g~yv@a{#%2XAn#JjTdSOuOBt)pUq}
za~@Fgr9n)6jzaq!rUZGT%(V)9x4e_rYr`l3#A1W#dBEHnfyV}i3l@jv&$WIYzPyhg
zERW)XrLWlL(a*g`a7`)|hfjZ%W}`!+(IJ<_n7AL;ZgTR0GYpSdoVWaNd6b7P-_4nK
z25?whu-M>8)%QjaAySBDrk)%aAED(t1eBCO5KlY68ymy?rQXlpxXyidt#WYBzqv3s
z!qQ3~txim<BQzVH9plS9aq<=JJF>|6wIbiRwwGV6jnmeECnZ%+2mybufmkAH%WL@a
z<!7@IcqI)fsrO){n?_yli053rj}w>o^Of2XPaOCcKR@*XuU^>AmBkT2xNAq1j~`mV
z7L}*xKgf?N+p%6iENC}`Hq$U@rhpGyJm3}Q9L_n2C7Vny2?GeE!SMa1DSlrY;MA^p
zj(zkJpU4J?2KYl|m~Vewnr5z90^_r}26~CO39dnLIPhCcnDc^IC00Q+LL`F7Y*C@R
zm14N&26<%u9!|Wo%u_oS5a8Q4cJs^XBmlW2fJRvpz0NZNnlVCBCFkW<8um#-F^w2V
zhKP%KOd&=h(;WxBGl6Ci1p;T&F^(@BWOEzu8q9zcMcC4L_c>tN9d+Ac>up*gM`M#f
zDJf#E*NO9aa($jC$z@UeK9>eX+LpA@pp-ANnl&W-z!cE`z9atkssrWhP@0_!<J(Li
i1=_b6^G^K_)_(v;lOSzcNR?#(0000<MNUMnLSTYaBkunI

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/pl.png b/addons/skin.estuary/media/windows/subtitles/flags/pl.png
index 4feccc8a7d9b98efc532bbe15a6c137b81c337f9..667445a0944f9e97b942b3f243a77a09fb934225 100644
GIT binary patch
delta 826
zcmV-A1I7IQ3dRPI8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0008hNkl<ZSi|j>L2}$S5Jg{u9BC{c
z#97B%=SaCkt`={TRdfz7T(QOi(LalBfS^Z?Dpjd$GN|GJ<bROt-@ku<5N_i({_n#8
zK7RaF>$0%5_MZgpu|9nG$yNX)-o5()mj@~{48uyHltM8Z*D)LC^jQMHC6Lf`?(WDP
zv0pD%czpaLzyP>Am#-Jv)*`rB1TF<L0!Rk82~1yW3aSL*QUq4K-`&T3%evqm$(94s
zWB`jpD6&*0sej1U;?Kho*L1wsEZ@<K4N`#d1iS*MBP4>FB7j*wI~MWY{@aJ<tGzl2
z$k+iX@9bsS8E{9gJ;RRJY=G(!UdsN+!VXGZCzf*Q47rXaXswM$#7y_jo{b#ii1J^r
zLC0r$_C3G+ZP{^a0Pqx%^~8^q>-E->u4hep>Q(HeXn)P;E@)gX7X&P2VOdHlzhEUn
zm6GtX#>I{RTnA04Ys!TyYTlaDykQx0VxTedx5)>_%+Ad0U{{tl5RC4@2vK(}V9CG)
z;M32)@cI3Z=*xx0i~`{UU3g^&@;w0hrX0aSh{#ju4m1gSIP>YZ-zNqD>ISu<a2{md
z6Ua2am4AZ0*osF)8qy4h^gvfvy6Laoh*WEUz@XR^G#ya?%<pCCifC7|XCKshG@^!}
zIjS2n!?O%d%$Nl;FV+5grRbKNJoseU);wYk24H7k^oylncJ<8~&?_ye3}|y9y2;c^
zn;F<7v^CVC1eOlyT<?5(K?V97V{lCdmwN%5vwzJDR5{PJLam&Lov%|avn%5575aBi
z49dlBuT8?YN}U;~YvD=GQVL~RSS?K`t5Nn|7{R+wjP00C_YTq#C1ZO6ken*#>tYjt
z`#YZQSI%$G*xi}avL*=Iecg^b<oH18-vIk=9o?gu_E=Y(tyV6VC!X(5JAl)}8y=tk
z<TGq{ylu|eP9ylgHI#aI+MfAbzpy^MxqT4d#%%!b7k>5|T1R{PsQ>@~07*qoM6N<$
Ef<fMkI{*Lx

delta 1398
zcmV-+1&R8`2L1|=8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0)kLXR7C&)00032009920RaF30RRC3#KgnM$Hv6N!td_x
z?d|OD?(OjK@bdEV^z-xe^z`-h_4oGn_xJb0!NBL|=H%n!<$vVl=H=z+=jZC_>Fet0
z?Ck6A?d<RG?(p#M@$vA$z`y0?<m2Mu=H}(-=;!I_=<Dn1?Cb08?CkFC?eFgG@bB;O
z@bJIBz2oEJ;^N`t<m2k;=<Mt2y}Y~P;o;=t;^*e&>gwsbxwzut;Njum?d<FD@9wv@
zw&CF4;o#u4w12bN*w@(D*W23K-rd~a-`=vZu-Vwy+uPdT-reBe-{a!q<>ce$<>a9r
zGRsk9%12zyNL|lJUC~Nk(@I~{Nng}UVAV@u)=Xj7OktiLGRsV0%0gGnLs-v5TF^yX
z(nVX-MO)NGT-8Qg)<#{N9WlyBTgp9C%so`kKUL5_R)5k!R?<LM(?M9(Kv>p5SeYF#
z%0yYoI8VztP|Z3~&pJ`iI#SX)QqwzA)I3zxJXF>^RF@qv$v;%dGfT@fOwBb+&oxca
zHBQntPt!I})HhGnH&4nxRF)hslN>L|J5k3lN69cq%rQyMF-gxcO3^Y)(lSfaGfdPo
zOw}_?%6~CQ$S_CAJ5rJyE{+>5!Zu98D?-OBM9VBi%`HaGEk@8TN6{`w(k@8TE=bfa
zNYyS#%q&I9EJVdCL&G;sjT<eAA1}EzO1v#Z#4tz8F-gxdOVBe*(KAcdGfmetPR%h&
zzBWsS9xj9?HLyHRxIj|HMq1EGUerop)=Od6OMhY5OJUheV%bY#+Du~GOk&(kW7SGv
z&q`j#MOn5zP=F;fi7-BeHbad)Nti=Wphs1rNLHgrR+m9fia14tFFgPM|Kdf&_W%F@
z26R$RQvd`E5F{`f=WLSz0004EOGiZ2e!M#q00007bV*G`2j2+=02~4x3#w=U00LP_
zM1Mh4ILl*T7#4t$jhziAU}s}wVB+B9;^OAy;pOAw7Z4N_5)u>?;OFDx<>BP!;^O3B
zVqg{)5fu}ckd%^^;g*$^lb4s1mF1R^mXeeZ7ZVi`W@cbkP*f6AR#8<`*U;3`*4EL{
z*4EP0P*+n`Q5I8DQ~)Z_)zdc+moPNa;D6!<838hYn@hvUP(s{5Ur!gPz}UpZ)J(-(
zO`1!Slao_h8%St!NvoNwn3<ZG7y}hpSX$`;-C$%bBcr8d0|Z)HGBVaiKsV@FSy})U
z*xK2HO;Fd+&;*&msi~;}bOXo)dpld80tZJYXBSs{eI)}iF)?Kz08$1@`u46a&VNph
z4nPHNPVOF_UMAkAKEA%bW<UU>d`!JfygWVJo!o#5{QLs~gMvds!@?sXA|inRNQH-m
zh6D!%2Kf5{6+}hH#Ky%ZBqk*TK?)Fn=%mDi__)}Z=qR9q)U@=B%&hF3+&m!22LceC
zo0FZDnUS8B3RF-~SX5k6T2@|BS$|noRSg7HRh5+$<z=NM#YKe$Km|3mb@dI6O-;=$
zt!+@y+S1(A)Ywp8*WLkC(Am}9)7#fSVdA98Krm$rh@3QWLVsWH)M?Xa02R!fHG9t7
zdGi-6T(o%ck|j%*E?Kg8@uGzb=FeNUe8tLDKn1JUtX;Q$!^TaMCIPi?-fyyHGtiJp
zlQwPKuyyLXZQFqgcI@1>d(Yl|`wtvEboj`TqeqV%Ieh5gf&KfA?LB_t<SC$n(`U|}
zJAdIKCb)3^(&a163`{JncmN9%10xeN9>Byn(3uJZ01M&J7(c36R{#J207*qoM6N<$
Ef<5Q9YybcN

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/pt.png b/addons/skin.estuary/media/windows/subtitles/flags/pt.png
index 3a5ba8d5a48005cedfe653d2b6164e3b14408081..1cd738dfb11010c3559d2cc00889966c7119e382 100644
GIT binary patch
delta 1340
zcmV-C1;hI33eO6VB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wiu+(|@1R9M69m&=PBRTRd5=hm&B?s+)QOfq=~lV}1V
zipEF;6@v=8GmC(N3jPIRAa2El8}}k8xKX06vJ(U$ViH6bfqyYbf_X?LgPBJ%lX-Ne
zyX!uVi+W7Yn1v!_;~co0TUCAQeD$60oO>JAZQcIwCWu&GKja1*{VcSa|7g+AKP>*I
zpvgc#VX4W})0a~V)KU28t#`QFX&0~r5$LfsQfo;Qn=dp8BJlWYp+KLTmOcbja}S`-
z5xqyVEWcm;Qhyo^F1`0YK-~fsRW46WFugdpLX9zq2ndCj+yk$UEt5Zz0)V1Q*E|mu
zyL{A$0;-T~93j8LT7X(&X=NRp_jw>ANYo;@DM*o(PY%BPmMSQKmMDt3l)e}huyzMc
zQvhtq;bQA9E_lQUX#TZ%(1;kphQK3zZ8rCNuD_7ccYo7hZY2y(r&yITYL~c5KzZQm
zSyXhXSu%hr7rNkaG2lYL7e2rCY+#vV+m{KZ!TH4@Lc77p?|t;vYs@{Dk);`UkAwi;
zuNvY5;yn0(I*)o!^qyD%tr+kz;6srDm7IEo(YojOzGZG)8{mzxCF)VRwXa23?B#A<
zncLP!JbyaJ$Tume6ExnN1+;7UKqwfnB?FmvWWndus{siZ5l$SOW=MLGt8<JzbO5ts
zC#{Xk)JFR08~>GXeH!fv%sts+^i1!nG*mN<R0`CH+JvC22GD7DXk{&oF^DlBFl-z*
zW;5!kkd8rm;wd_Z5Ax&bE4+PlFZRnO$@k;PwSR=LzeB4fl>ik`5mc3k5;d=epb<nW
z4cJl`o#5~>pc;^9K!k^fmY7=dOw2df{meX*i#M6Sw3X3;gtHf?80ep&^TZNck{V%a
zn*nF(DuapxQN^ed%gV5huu22u8Yoks5-~=wWEgQQy2$QJDYv&NvqK$hh}>Sz*fy2W
zbAQ$1c6pRsh^wkWBZ44BC5YyUkq{`QVoC;F@MOW$2_6^o`PiM5pQdY^yOWYk1@<h@
z^YY={Otu2Y4)0=k;ufg^yRl7rT_MXL%Mj;~%;oBL4x9()5$7Ot;M_e#SO7pkqCt!>
z9t>{|-(hC3&FMn}?3wtQy<gOMadbPkKY#m}3-&BKk8EMn^9#&=Ymm&Y2(Md)3W7q^
zoQ=$`1yH2GySxjEftc6P$t%6Q``8@k_rrn9LzvIMVk?$rL)rYwDEh!8e~z~qJT<tI
zf+FvzR`s42LCn(-;@Uo-WZvhUPz9~JAY52T`SiB|j_g?A!v}|0cxjjqSYr1thJOuz
z%+Rd0Nj|C5HyfdNtyTdG(V+zyMIUeuuWPEnM~{yIG~alTqLYZ>+-#kTv%<5R7I<{m
zZF<u-O`p)2Gz_1t)8`CSq?UoY0(Lc~sEUU0cK|MPIOo6!7*l}|i6Ah8<<#T@Fa^iI
zoA26+A|=r(tk!_8bV4bZjws$avVU$3q$)^ItO_Ctk|YI)F6eaahPAXHXyrtpMM-t<
z`{lh@HK%-A&Qxh7$qInpq(*~;fyN-V(Sxa3Bq>-ZF^HgrH(TmC09n)d0MVQYRIA{o
z5MxA9=UDEvY4_At0QA)xm|IP3PY-E5kkr!Z<@d5Pq5ZFqVG0CQTG6rS+BMkTMs+6a
y2Q~x!_xU{91g7#sDb%~$@_jN7wAcR^tlMAYW9XM21;~{E0000<MNUMnLSTZA(ta`k

delta 1349
zcmV-L1-kmr3h4@vBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00iGjL_t(o!|j&KiyT!H#((G5t)A|AIL=Hm
zc?UDm1VR*zkq9aV6?A770R<KO3&cR&iVHXHMNn{~L|tVk2tvdph%N$SkOcFPOa?QL
z%uMFdneMLpI4-KHyJyV85OAS6a5=Xg_nxo5^PPWl3+~%}`@fqYVtM_b8?5!S)TsZX
zML++rd{04>fqueDou_9mr5327@X=fEaJ$tkU<o47V=JWAk|s7^Xc9!=@z+9uJ~u6W
z2&m>BK%FCck7ikZzj#w>H7>sQK0wt17F8}yPcpN-(4oc{L<EGwOYVVJ$5+W8NdZ7n
zrE7nlhl*W3YD585NH&g;UtujkC9yQJ7S8)TkP#$m5!@7{NavG-FTbT76hKQ9#av2X
zj5e@l3r$l1Y{}tr<2EjM#0Y5qwRzBp7{P|XBYjOa_j|6rkkNO;U~VQ1&ZJnCGHRE&
zN<eww_OqzyO1)$NQ!aGD<6^*tfG>Q0?b(08Do3}k5=@PA%R_`_jgjB`=&e>*crGJL
zGw>b>0lZ%`#0SKA@Bwum^`7WGu>jg;z{h|OMG91M>J>(-o@0AgxqfwkH^x_}M&;(-
z24T6E+f`*@TOaYr0wdp~q)yOyXBN<|;RB&yz?KYT-jM~LQ?CXjU_>~6V1^;-MXrA=
zF!IoT%#NKjHm*_`>8EevSHiU!v?s9eWP{Puy=&6Yo@u15K#izP2+CRjt!9fx*1#Bp
z7y|;s#&LZ<qnZloIHbp)qIKv1Kc2eG+eh|bzpRsdKY?6L2>V(z8qyY^0xE*45>cY&
z)etm-NLvH86h<pJd<>`tBpMLm;h}#OrdK?Zi#5icS!8PY28$QBGCGiO=E5`s{j;>5
zSYb<2A#80j;B2Scl+**Ficuw&m0=xWjRwdyP^Lg7VvJzPFydHtk+F*@bK8{pp%yko
z=2kPdO(*nRvAA6xB^TnFYS4%vNKpx*d1534N~xHV0T(=3@U()*#e6<~E9HNunF?ob
zr6kjV-K&edd}xfRM&Rh7T?|j&BsE|+Hc783WEo@`;vAB>T>Z|0^WZ$<9AplhyMqV|
z00>Alh!G}&;mzS&%nmj=b#Q>)lV7vviz+XUZfEYZk2!D8u=DU1Ha)+@{I>?lY)5$A
zGE@*0qULO5c0GV11>WUdPz-;>ypB#>?&aOb7C5&L_Fo#peEt<%vD9nI=2u412d4OQ
zqRHUN!A=T_yrbH#_q+&Vo`w+D_W>pIKJSDoXuAu-`K6Rke;eTNjwL>PaEPUshWUUM
z#(ptu_+yrOrAhKhmA?51#kSfGScncS$SC@Nb9h}>1wMLw450bJgA{+AL=0!=t6Z2D
zp53&>qr2wlO`FtxLTkz}e4<L9Gtefr4Ad2{t1(4YG=#qcaGAq72S&h{HVBaj0<&07
zPCWqAaO}IquA?YY60O2o4QQtmO2KqQ@y?NTYamrYf?`z=NsuHdKy*Q;>olyS1woxZ
z0xe3a``j<@#ddSbkL7<%l}3_u0Q4pmY9tKQ2C=msOvNHe!9s~a1TDPTQq2L#y3PlP
z=1id44sHrDMih09)mD>cPo)E(uUf<0tYdq6NUMRQlD0R$lbsGt?$#6tsx+cw*)_4f
zwSruceqb}uf7iR-o7I8o{HGMEbhYJw$vklPRNlA$oc#slW9Si=o*VJu00000NkvXX
Hu0mjfL3MGX

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/ro.png b/addons/skin.estuary/media/windows/subtitles/flags/ro.png
index 33bed99fa5b3789749375286c9472556e9701d4b..b910c0212cde0a156fc8f3a81c0003629b4f250a 100644
GIT binary patch
delta 975
zcmV;=12Fu92;~QmB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wita!Eu%R9M69mobmzL=c6)YTG+I%dH4bCtXfJPJs9o
zB!v6{#2+9aBSYl;9O4rqgXjn#0|W`o-j2uJUGIW!x9!=z)qh2ouq|2Bw%V>&uU@_G
zfyePU{_n#u>-pfz`2O{te-Fn87yt78PjB_n>5GTI6RxlE!-0=}`+4YrOMq{``ixh{
zX@$$!UGxln$1rpNeE9LFm>Cwjx~dG#zn+mq{;qt-Q$i`?Qv|84v;8G6zy1c`vIlw)
zFMt1=zy7(YD}M?AvrumX7<~T8uV5vhnSm7ul8{vAkbXQNfy)u#65ara@boEOZu%bJ
zq7NL$NKCn9Zy^A=g2*MHQUz2|%p6Eq1%iN-SI-;+%!MdG7)N~Q3xb)%|87QNngbeU
zsvx`sM407Pq7C<L2s5yhR=_GduJVF}ZeHQ_jRqj5On*#X0?!}<OU4uimhA6}ps}z4
z0Oo}SB#`4N6($-0IVn3Sd98m9>N6NM0CUtekQTU!AT69!>Pva*l`|P_8JMQb6f+h=
z)s|tw*ruC6c7JbaHHoP`FoD%lFqfi>vj`UkPN$LM7zq|??X6K?KgD<)7Xt}r@qL+}
zjw7|=ReyNki0s1UVBBTk6f-F~LYS$RB5ZuYY@yb4$I_N*N+sL2R)pG$hER;;jR+-D
z7E^MJfXoRNP}Qo<zQ78Aot0u8Fr}Kl7w}aBroxHkd?rGi7@aBRvLJ-Q0(K_4^k#ou
zGZNPf6mPH!z$DbCvl2*5F*8N40E96+UCF+{iGPi1;|(Pc*c3Oc*s2Q*AV%^=gp@X%
zVy<-8?9C`pW<jPF#~vc0YQQuXu|}KC=wi5^fnr3qc>S7wiU#cdq_==#tfp5CNNYA!
z+BBbQpcqlE{k1T#E`yQpiMCDODg&iUmQ89dg-a-B;?@Z>F-BsHU|qdz;{_#&gc-Ev
zw0~^__&iUEd0*13{0hh=QjA*wLvT!yJ_zgTPH5dibd6-8Z<H2XOA(}o8SDGy@KH-Y
z+p)WIk~nr@0dTbo><8z1e?h;yB6PcQ=veCj!@6e`k8u{ioeNA5o{!~>(27~qpCvp-
zZpS0Xi(vuq-qnt9`h#9OhOnp8(00W2_(<W!;jNBjX>P-_?r@3QIB_`L(qHYH$36j`
x15e)ZdGrSOvm8pxxv+o701_}h{x5hOuK`-RHLtdQ=F0#8002ovPDHLkV1h9{#jXGV

delta 988
zcmV<210($92ZIQZBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~2?0{hYc00VhRL_t(o!|j&6jwD48gukrm-q~4hg>gbU
z9|Io)@f0|iya3__F!1mYK97Tq5FS{E0UjW5VD@%;x_$zqvZ{M#_fCrr2eB!&rh8Of
z5g8eo)$kaP@qZ7)Y~bxr;+xky{@fp4x%h{#zI%Vrrt`<I-X~mNQ}%n_{ptI004@Q(
z`1C_w9Oe}-V|y_$4jaaC1He1)eSn!^VdJZ6sQs3VB=VPapOO+vkupb+`a0WP^8B;U
z0WJq%0P+0i-}&v28(&cgm<4|fVDQoVKY~?2GXtv>Bq7P~A$@y9f}(<eB2hX45uQG!
z)Q5jz0Js<ehba<M?%7)iKz0(j0xCHnXVEl}Feie5lvn>146q_ZCBigO#-TE3BK~zV
z5mN&+%;Y3W1w@$TUZNB2dk8bIlvc!Couc}Jgl=9?{Ebc^rc6ww0yh$YC1a`rOZIn7
z&{a4g09L9BNT5PVsVdP4sE~3YrQ-E>(9(a%s1s<YYa$)En;<Qkxb(F=e&tL?rwYt-
zW{w#P!M$ZzFiz7=AmiT9>L#ZChY8F}K`X^3HWMxi9FG%+DH1Gr?X64iTQMD`j@Qbw
zWV+lR4-;N-Hy#v3E~2P_aaVz3%%oHh!c1O@hSJ({k=D))xDv)vs@e9nB6uqrLNR~R
z>^!u(r7Y%DFaokduz=jF*5(2$0(Mr4HDF4feyQZ$1E#8p<$PvB3NaSunCpTNstVYd
z=@KuEwIXq?K%EWd1WZChIxB(195Zt)PCyuK($(xMo!F(mW5rcV+8j?*u~iosK#b%Q
z6H?o7j@jk*?9HfDnjuric}XwSyxe~SrdC8pYs2VbykCJjh-{hlYx$`jSOc%;&<UX!
zedyHzq_rBVZJN(LPzO=={#q1Rm%+&Qpq-{~u0ZXQ<&bKnC=$w<csdC)F-BsHU>m;{
z;D#tA%%C^tau#_SexDNUTvBts6DkrZ#!~`gD3~Hc5VrA?&^C+Ej$~ozl2(6SOA(~b
z85@S4b@0-+aa>B_C~???g}~J|up0~4y9<Wx6=AcjA02BSVA$p@=VP4VyAn0i@NBBz
z2)&rq{aK>K$nA9Ca4{|f-niNlj=wNy%NTZSH1-p59bbR5=OK|=8=iGXk+_XB`{OOc
z)vhIGPk?8@lLzho@5K%9YyBuFt>1;iYi{^YBLUNE@A4S``S=@Jx;3wwRtjSP0000<
KMNUMnLSTXmQo-N=

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/ru.png b/addons/skin.estuary/media/windows/subtitles/flags/ru.png
index 157fe4a6e26a2da6b79a6c60f57033cc7e95da83..cff16cfe318000115d18ddd821dc780a05b6d9ea 100644
GIT binary patch
delta 727
zcmV;|0x12$3giWl8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn0007UNkl<ZSi|j>y>8nu5XXOal3dtn
z`Uu%NWbT+fK!Lt&*StgK3?1?UnOfM6DeA6+NSUHP+O$BInty;mi4yPs<9*q18JF?D
z4*__3dU938%>IdJ*1EmDl@`F=xw*N)-A5{s=~7ihWKW#d^L^f*=X{@^&1_mP?LR+1
z1JDAP8GYa5?lWOk#oZ@}Qm}+7Axe-eZe}wO5t+QL8K5StPdSU*8`o<13^nsWd4k&A
z<@L*?s=g7C1Ap5kfF1)lCwLCx)c3Wm1At)|&Kf-iQzz!{>?udqYys}>2JY`+vnk_s
z$^+*^a2QF!U8dO`Rx5aTC;(t!w|ix~1=R+T22eyaZ6rNQ-9k#~sv<1GI_?G-?gM56
zO*3j%01%_%E|YNf#QgpgK<x>gphgcU?uLl6+gS}@#D6G+03wPzsR!)E-wv=3hlpY}
zB-=*U31D*%^t}*5S+`85|1%HF!;|9=!eVhG1R-RA`oxlISt{XE0G{@g5IF%ydm&T+
zU-`nP_z?}?Q4tyuG}WjU?fIO%*K_W8B3N?x;EuUt@dJ;1<8uZW075|eeiX{0RqfS5
zD1tm&_kZI3v?tqiM?xT`Pg-Dnh!KwwKi!cE2hY9W2ZeaFA?#npI0pzo=zE&JXHgkG
z=yHJMAFU&hevphlwOmi$?qejB0IyxgT7*U0B1I0ACzUD$Qo^~<JTp(ny=M$CcXq(0
z>mY;?V7FTFW4UB`eNEf8ELG7IS1rZdr+6PLNKh|gjXRn|n=}hB#K<}XHrp+%*CRl4
zb;YA9@7k94UB|L%XsX2e+u^ASwjz9wk@o5eUS2MLiZA0b_z9bhcnBA?v2p+a002ov
JPDHLkV1lHeM+pD`

literal 1346
zcmYk4drVUY6vi(gmzQ|2dN0zB(#zu(`Ve}r&<eIruth*%6&abCE)@h(L3|V)j+siP
ziJB$oVuHZb5Oe|torpMOQE>_xjvxwzC{xR$^!<JpSp9Fwch1Ro^8NMYcV1GkEj*MO
z3IITOPPVAfcd^eC9N^ocwhJ#mo6_vUd;mDb008+<0O0n$<O={$!vz4f6adm20bt#c
zmcAVV0PwGp<Q0j10l?4i|C*efoSK@Nn3!-l9Co|i>2$hWE|16K^?DZ<7nhcnmY0{`
zzI|&pn@uK@#bUA9Y;L!EY;4SEG+M3J(b3V7kr9KzFg!dAf<t+EhRjUk)~yzi$Sx8&
z#bUQu>=BE-V)0^D)>2m1G6=p9i<N0<%1xWp0)b8-FbIVvq0lT4_+%9dZ9<_P1P3;6
zR;H$^Qc^UjsfN^4Badh1@hm)^mCv{F`F1|v0fJA{(-)GHRa~wvIoUuEW-iyl<yr~C
zMv``tbdaPI1pj0*)l8<2#WJ$lW;WZ(X4}|oJBQ=oaGV^D3k3U;lhtu?nz%T9e7p(A
zEjVt&aXW+Iz;P#zyKvmy3xaAkTT7$qqoYl9x`j@+(dmxpXeXWS!Z0_6c`)pOFN5Q{
z$VdZ)Vv3BkQYdx`#X+GssZ<x0>ZVdXK2azd9Pb9fd%kc?j21!k2x3AID}vY&#DO4A
z1aYCL8$~@R>P1llg6I(BE(msj;A~Ws5`uIPWQHIs1lb_S0mDuhcEPY4hCMLsg`h<U
zvOtg#g47T+N29faU~5>|6pi*_?b-zdF`}pyMeQi+K+#1MU5bdXpr{^2|E1BchlMqx
z=qm<eoW+_+N-}Y|c7kvago_~D1mPh`4?%cIa*-sLNYX|SzOLuiuYZ$}a0NlGVc6Bg
z#2ZOTcQ$P3;qe~v`G4^FcS!OYlX;a+zf|_F)5jYqD=gRvtXK)hbE(S8Up^C9vVEIq
zwW3GZ=QBaFoP2T6hmb%Z%AXe2QQ<?C%n@Z2Z5%F@Mn=dl{rqcqf^>iBKB?m4tU@t6
z|7mV!W@a4>BMAI4h^(!Bl%a^qTlp$;Aa<a&q~*P$zs~E$0=?e4e#QHilGZIDG38)+
z$m*QE%%p<o2LHy8eubcAcj3V0*fm=M$1Y=mk^n69X_g$x&J93^hH^tMK3fT}<<uAk
zhsh2o!h&`H8-Vf^qBBvFGyV0gm+xQbXzDw6?$)gcxZ>c!irby-9f@ovYbXG%&@8A`
zUqn(V&5cb>O@4k2B*7z7Mkn8lzXn;{-g^)3Km5I?`{WUsOy=*8%}J~GA1bXXJFs_E
z(MPR9J+J?yn$yi_G@76lTmBw=H~i-L^grV-D7T+}ATe&@#`qMDAT~C3O|ZP^`)?|;
zk4U8Qn_o&Yie!0}yX!Jb3XdJj&1J!DZSe^SIODIu7cWKI{Lr?W`}dWXDQD;Bl<N@0
zKO-aK^y%*o7n~?A&pJhwWb8Pab6{7kxa{ki{Hm&|J+y|~?Oh#r5|i2M+p7UqMdiW6
z2dWMk7PM-;UZv9MR4Tn*t*xj&q|;P40Y%)SW3$YizvW*ij!$UQjw?r+`6u-)Q{Ckw
zjhm~M>d#(`2tYZz`YK%)u5=cktO@A3yX*0Z@X-c+*LY`f*SAmVo@d>t&u{LnoPPM@
z;K-iG4()U=J=m_B?*3tNgtlo_ltAVTmOOi1I`~zKpoY4(CB1fDn^q1oB8mm_v**uT
iI!}S5B~c4`f&Ks+>yvGFKY8Q>3dj)`h`KVR_5T5s6F+SL

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/sk.png b/addons/skin.estuary/media/windows/subtitles/flags/sk.png
index 70cca6e169d00afbf14488c342177a3d468b0fb8..b9422dc758f8178fcaceacfc5f8403ef944e8931 100644
GIT binary patch
delta 1052
zcmV+%1mpY52(bu|B!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9nCIY9{>OYzDYzuR9M69mrZCLRTRg6=g#E4mzSp^DaHy$L_{oz
z8r@W_8!PRm;zAcn-D;t36sZew;l_msy3mCSQ4wO&jffb8;(x-Ag`lQgMZ}hXL29xn
zfxKkin>%xki}`#n6GVh;%z@#}+?l!m-}$)r%!30vu>ZRWBH^zqE8aPWs_u(up>_9>
zBNHLeF*9aoXEC#kN~AoTbBIVqoR1ghK>41TmFLB^s+QyR`Bzt00XiWNsw&=l%xpy1
zIft2*5Ou*iRDT_!4pNA#>IjI46wwYHFmiJ*FGuqBFUQ8=3n+lF4$w5g`0<ZLHTH~%
z?3#N|fN^5|{W4Yupn?eQy0cMyT&xLx7eJb(jow6Wy@ShNy#AvP=%0NF8AJf|-hUUm
z-A3VYu_h}tLx9K5E%ErVIijH=&LQG>>h>0=l7xv9$A6i4;C=umUwnad`4aKh7nuL#
zTh6by>Tw+tv~t``%U@GvvhBF={c;6>DZ{~lXqe^|@7TGvMHEG7G+=vvk*U{SWiWpp
zciXMRQA89)L{Yj6pn@<2Ff6-gidnWAoCRRD6o4{J6rUQTia0@2MZ9NX?mpbHhY=Av
zr=P)gwtw+oE|I26oHTD-VuqR_nS2!iRlpb~3e*A2NELjN7osXmA40rm=k+%b5pMW=
zk^al)Dla=-lGHax03&nU@>JyF`B*Ego-b42lguL#5a;+|T{(GZhA;e0Y)o9oH?J&l
zeEKLezR#2KDi@O}Vt;K^wA|lo;+93&@(7qIt$#$uQec_5PqRUBu=2+y3y+>=@t2Kk
z!bJIM>JC7N9z4O1KX2@@6IhuBD*>tk1SK8^`0&aCbHPQV-^Ym%h~R)=V}|tPS>}IQ
zr&w7}+;bymzWbQxFJEbpt^F1|US0_bq<L*vugCJ0-*~#*2h6~G#3z(W0=D)iXFhwA
zdw)+o$3lFVXQ#J$XyI*iYpbEH?uNnYE1@b-yw5aC0Kk$2O%ei;5pQgBlcS%$$0N5K
z#;#t)vK~GnY7KQzh2F|bfh+=PimwC2X2jm(yw5seeLoim0=l+Vii$ORZvr-+mps=+
zVJb%AJ)RoCFbs$=!XUsoM^Loint<e<*MBlpMj|gaT)w)BNLUT7C`vVBXhswSwFq?D
z^xG{u-7c+Gn;-}XitmDYQ^{v6f$A-`5VSlJX1IL289Dc!XgFZdZdU+7x636T(-!Di
zz@&jgc7^)CnC1E3QO}l-3A>Z!H(?LB8R+fv_h=vZOArZxPSqFo%@Sa6@W0@|{uKst
WwQV8wVB@U-0000<MNUMnLSTZqKkRw{

delta 1060
zcmV+<1l#+u2+IhNBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~2?0{hYc00Y5EL_t(o!|j$$XdP7)$A9O}ypOy*6-hBx
zFd`yiLDcA`YTa0AHx(DUQ0i6-?M9Kh5EpJ-h@cByxDXW~Cf$gLK`1W#SO{v`RYYtE
z7^EhP639#Dy}2{@xR|f|CR0?DAeaNg%$%9I|KET4xc3h1+rItZO%MrxT3)us7@Tu^
zB3fwOdFW6p1iGrq%*+g`no)_AhcN~bsfcrbaSfE;scLy$+&kw=zd!!!>MB4t1VZN=
z)>>3`OxPHMs+JJGpbzCk_#lP2b8ZYoM2c*O1{iyIwJ68x_BVZX_yP(b^Z}X%s2_i3
z^>=?nWY^eN1*j9dUoN3O02M@V$L)>cb+IP+T>xpCHbxV@{w5~>@Y?s^WpMg=WEcU^
zf9Eae^%{liVog?Ph5(P8UF6XtvqU3@7=wu6iCf#8ND^Adj?%jCUH~S}JV&~8k@$=A
z%zgM3=hoYPUTcC{`c++dR_B=L7|wsQQ~`gWj?r*PG)nW1H|$*5B8nnhG-P{jfytL&
zVmNmWbIZ-dQA89)L{Yj6pn^~YP&9j{4%KWn7!5$Z5`bfrIBcqrI>ZPrb%?dJX79lq
zc@Pnyd-5rCXB+$3B5CS~ljem>RB@_ECSPU1IY1dD4)6g~NgdcEZ$#%{>HuObJFkDd
ziimLCCkqT-I9o;8?UAImIRhwJ;F^~r7tej|uzJ5NflacAL_mz;+jYnB1JitJZ(yT!
z4PU;v$kD08OxppE$E#dOCW-BpanT|JUKuiXzRtL;4DCc}CD2UVrkPU=EdRR6{KF?%
z_;Di}FmZf7c^e=^_aEcCA2w(<Ez5tPB|z1H;E3x0@2$);8(csJ1B?iP2nGl?rb&;V
zX72lSikbD;UDtE!>koML(n^D@cP>`Eyb~Od=Dnf)K1(Y<^JD>#s)DtMO(>NFbnQ1z
zef%1CpLmA(_#jVDZS%nV8@R2l-Hq1(gZeX}YEZ1rG)n+LlLVI}1R`V6=;nVWhd+9o
zhi*EEUcQV1lFLa=(C>pP^;+HvWEn_PtPc>Y5?hP0HromP^;`@HxV5!XRBDS`2_i7|
zNGWSwG^RsIti|F1jKY8jB@6<LF$Bf->j_96xmTew6M4H~^4V2nLOr;mDV-`KRiYs9
zGSKZX=(OqfdbHaef*>F${tIx50YtLM#RKxU*g{bAOsHbWmYcC_Yl%ifhMi6Y5cGOn
zv@solz6MMv7-Uzf|A}c{{~c%9vN2(ABG05qAGi_d|9f(O$p*mhf=CE-DffjvvjiCK
evF5)02kj4XwQV7m_i&T|0000<MNUMnLSTX}2;|ZL

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/sl.png b/addons/skin.estuary/media/windows/subtitles/flags/sl.png
index 6c69727efedde013b1f3aa0a7ec950e733082216..fbdc6b8658a1c0420a7005b630d339f3c84b33cb 100644
GIT binary patch
delta 956
zcmV;t14I1A3&#hL8Gi-<0047(dh`GQ00v@9M??Vs0RI60puMM)00009a7bBm000XU
z000XU0RWnu7ytkO2XskIMF-#t1q&A(x+!jn000A2Nkl<ZSi|j>KZ_(q7{-5Z)$GhT
z?s|)f9>N}IARCD%h$o0f27(y*1@t?ZU1TB{nwwo_a)<_+D1RIVx4Lkbtaqpz9o&I|
z9P92*SM~cCbXQML&x|05iTlDZ)kSwbf8M968!qai{_kY~M@L5rA>i)+324FE-`}?p
zfF$<z_K?)DGV6XJ1k7x~xScQK@_hL(<8tlp-F$!j<KtrhMgZ<kN(o6zz##-AbtL+L
zeNufAeIf<i-G7&em|5p`C<KNKhbou)_7CTV<O``K2l@(1)m7rBho{_s@QB)B|H`wx
za(RczY`QsA10rU&vi3#-L&nG7|H!BJjNRE|%;2j#e{lWznwQ^uYa{p&te>ZK1Oh-^
z*J~Htd3uMOGUxsjnM<T9b7}X<6{YJ`4?$PlZ7~gC{D1Dpdi(XOoTeJHfQ0}Sc**{R
zy(@h9<_nBs<nvp<5r6%K1KTZ+_KjT$BNEVNOOD);oY_|7n;#CTzP#RSL*&fo=bX(m
zA;g9N#?NWaC$B!k?nIb5A6$Emj}DJGo1DQ=-C!4h8j4-Gh1_wki9Q1LGJu?Uc5>a^
zWC5_i?|<<LzPNdtH{N*-3xV6;9`G>EP^~qlt_H1{T6VxB=Glh?M0Qct!h(>C5QGfA
ze&k&K?ttl5;O2vhDr~i2+I-YWh~BoAa2H0i_Li%2taBjMqRI}T4Urr$k_A3HcFY`z
z&>h$IHx8&>UyB^LkR03@kHTsTs_ay?z=Z|J+<)3WH)(D<s(#crW}u<B=zYn7TIJQS
z1vl>A;OhB{*vScIMl>T}Sfjb+VN1Gg;DE|5=(j;ow{woD3z6+@4)5RN{X(D?C?zcA
zg)*~+=5}mrjAu<lN<yTbZ^a=AQX;pPBY=z`XFO-((Au^Q4T7O17nZxPK82+WEbey+
z)qgd)AHqtaN(oD;YXR*}HnR??fSWeN&<1-$t7n1(IVCE31m>g2DKLtW5CSoTHU|r!
zHjax9E#;s|KxiHA=OF-I-hv31s3gu}>^U%<axxh+oy{1J$HW+k<-4FLHEWbxk5K;=
zTO3m31X2ecTIEiYwbS`I=acb*z-Tt(PBoe{G1yjQDu`HT^}kU9YKb$?JWds(+3ezj
e_@XWffWH7g95NbJ;p?ja0000<MNUMnLSTX~`^AU=

delta 1471
zcmV;w1wi`82gVDK8Gi!+002a!ipBr{03c&XQcVB=dL{q>fP?@5`Tzg`fam}Kbua(`
z>R<o>I+y?e7jT@qQ9J+u0^d+fR7C&)00032009920RaF30RRC3*VotC+1b|C*7x`K
z_V)Jp`1twx`TP6({QUg={r&#_{{R2~)YR1S^78TV@$>WZ^?&vC`uh6P($eto@bvWb
z(9qEI@$$sk=$^jOo4nD)+v)f8_Rh}E@9*!^vc6A?zh9NHV3x5^jls>YzRSzY;Ka*I
zhPzjjzg(8UONYJOzsUwogG`6DLV~hGgS142wnT=wbBC>SrOejk@7m|`c&pHRh^$75
zyhe$=MTomahkv?7hq(q!fkl9=IeDo&d#pTtt~`COOL(T!+vDcz?&s|A+T`m{d8a*q
zvps>dJb$u0f3ZD(u|0mU21|cFe5*Bfs5Ez~HF>NxdagHnuYZiKyw>Ht*yo3nvN(LP
zH+`}<eX}-vur_<JHhZrIN`5+esxNb=Fm<Ufb*nLVt$#3ht~GV5n3k}ho3c1~tTKAB
zGI_8ud9MaZd^LBeDQ~4Iai=PBsw;G>D|D<Yb*(FPt}J%0EOxIfcCZFWdLwM4BW<Q6
zZ>S}3sU>l$C2^}Ja;znCttE4=s~R8OKt|p)I^Q)r;x;_wHa+DwJ?J()={G&;I6mq)
zKI=F?sDBwB+&e+uFE-yWH{vii<S{trF*xTjIOsAt=`uO$GCAuqIo&%!rx_ol86Mm>
zJ=`lY-z+oYEHmURGv+Ka=PfkoEj8&bHR>)l>n=9zE;isSGu<mP+&Dg?7#^M&9o8~9
z*Cs99CobYBFXSjM<tQ-cDKY3OG3hEX>MAkpDSt8TDKX<HFW@IG+b1s9GdZ0Y9hV#+
z%rZF8DKOb9GT<#V<t{bnE;Z^dHS8}o?JqX&FE`^YG~X>V*(@^AGB}hQAdw^}z&Sq1
zJVMq&NaICI=tfNGM@{QTP3%Wa>_|@SM^5cXPVPuf??_JYNl)oUOy@>S;YLi@K}W|r
zKYxrOCY3HSku*1$IzFU9MXW?fuSH3)MM<MSLzOi-kSs97!qtKR000JbQchC<1Pl-)
zFdFA<lK=n!0b)x>L=ob(J-Pq@00(qQO+^Ra2?YQg0v!vgXaE2LL`g(JR5;6HU>FvF
zk&T@VCtzn|WMJap<l^Gw=Hcbz<Kq_)5PuXD5a0(gd3m@&;v7s2%tFE<!lGiF+~T}^
z{QMvV{QP{p;@q5KqCg2DW(H;n5lLYwE>0eh0+<QB;yj#OQo@oV5<msgk{|^#vU2hY
zicke$BR~oyrGW~RlqH45I8{{D)HO6A3ZO=a2}>#~0TpP06=>_|>ggK*<zYrZ6n|&|
z6&M;Bo0yuJTUc6I+t}Ixfvv5*y}g5@nW>4fks(llle3Gfo4bdnm$#3vpFa@z`S}F|
z1_isjxw<$z0TqOVhJ{B&Mn%WO#>FQj0zm>0BqgUrMudljh5!|$rln_OW@YE(=H(Z_
zKw(jKc2;IadRi(_L2*fGS$RceReyC&ZEbBG5CEx~>Z;0$^0LyBVxWTh^oGW!=9bpB
zb|B~g0ubHS+S1(A*pOZiRM6Sg-P7CGKVjmeNs}i}0fNbsCrz3-p}()Ur@N~Ys9@@}
z=`&`|nmuRky!i{DVE(+hb7s$)Ib-_5ML-3Mmn>bje8tLDtJkbuyKde3^?&QutzElj
z^{SOCmT%a&X){p4maW^i@7TF(_ny6b_wC<*;K2U<`}XeLvwPRhgNF_uISN#8?D&b3
zr%s<av*zr&bLY-qxN!d5xpimPoH=v);-$-1t^yTYyME*5t=o6*-n;+c;iJb-o;-f^
z@WK6ickeuX_WZ@mS3m`?-#EN|_x{62Oz`3Tr_W!Q8JJjD@c<Sk21X`kJb;ODpfeQ+
Z0038x?{Ih*pAP^4002ovPDHLkV1h)~$lCw_

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/sq.png b/addons/skin.estuary/media/windows/subtitles/flags/sq.png
index 648c156b3754b401e2170f555fdb2f5e2779d28d..803f4a0b97de267528e0ed874ee58c969da513a5 100644
GIT binary patch
delta 1168
zcmV;B1aJHE3EByeBtr&bOGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wiuXGugsR9M69myv!sf8@=)*Ijk1u8XSfd82~6Y)n0x
zYMSmkr_Vj-c0G7F9*+O}5Jdb(`{$xRwU6FkJrK|d>(c7y)&mOzE`0DFX}zheKtynT
zhw~oSw&i-$AX4V(J^-8MlrSqZK#q~DN*)7dHs9AQcli9>_W>3j@EJJ#={oWD?*$ye
zi69~ff6$2FMM!`b!6P7o)+IdxW+;Z5(Ew^js-R{@HlzHYJ^L8Bis1q1Jb5#aqvE6x
zD6d*b3})OV^Gwt7TT;GC0}Bx@_$2~-p=&l~yx1%_XgoJk<TQ>>1T%wr7)Cb8n*lms
z$phIySBID?CQ?{W1P~g5FT;x4uB8{@Fh@Soe+_+?5#Zx+kC*+DTgkX-#xFVYMz@a`
z<*m);5||mfIwaS6_^E~#6^juQ2bF|~kP#3#li&{>`ApaByM{~c9v>dv1>jQu2$#o0
zzRrnP{E{=`AZi6E;8bw4jCnu%!2=|$7)KLE!o(pWSaBl)+zUe?s>+Wx&}rh14gh?b
zf8m-AoE6W;0viLNok6i<@X4%c_79MO90J6MROyXU|B2~t%nW3PI1(&zC4@Ov)A>dc
z-aI`HBp#>3jLM=A3C(1}V+Dp`#5Nn8b2K721QBpGY<I#D5ePc4$@;JPj?QyW9UfSx
z@?^#^D|0d<=ZuK_QvpH%Rj^WXs|l!?e_)}BbxvfBXpZw69CtKG&ImcM=NcT70=AU|
zKny}SsX#U$C5Sq=mkHc3M1)=wDMy|#;VF8)PXo8B5|2C2`DQ`NMv9Tn0T!$DQdTiL
zZd+|SnSzX!6ognnr5w{}L}*oMv+`=w^J|X$5F*dH1~WL)$kW||Ctb%i9ci7=f0!OO
zqS=hK6}2sSy95a!M2J;3adQj-6k&{k-jvQad^@hV=vr=Sz<}pn$2aR0&-SP2RT;(5
z?B^zZ9K$Mnhz0Y60x4l3Vj^S_T=hm{l}L)*Pm$}Ic(d8zI~}+@{0YE2{b}B6cepVe
zaX%+cH7#NR%*aw`<hc(R^y#Dme;KeEL#wr~Mj%%LFX6c;ExS0@DRX5EJQ~X~K}OEG
z9nQ1Ekz_O*IV;($EM>DD%lY3GP%}&urU^H-;>q12WT35SSOcvHuQdy<a)be|H#@YN
zSexR2wyHXJzwIxk86-t*O92H!EFNePoPbpoCPPlT2%rWB;&@wjG2lRjf59S1RdWK|
z`UXr2BrArG+a(CTVGyJ74kry>1SjqUXzj{X2N;1D+WmTN2u)GDHlB%uWAcC@l~BMK
zeY2&&PS2+ASnMuYv>jd3;Kh}F!B#1XE;4UKrj&GZjcc8e+4*@Q1w;&ukui*fMR!b~
zT`swrM|xn_H7p!BGFz?SLccb4|9Nd{#~V>rX{22)=RM&bZ~*K*;Qi<!a7z&Jz+zJ4
i0S*O*hyM#6j=uniQOj6^pUQOr0000<MNUMnLSTYe4*<&m

delta 1176
zcmV;J1ZVr&3G)e%Bq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr%}4bV*G`2j2+=02~4x3#w=U00e1CL_t(o!|j%lXE}dlX5Q<rx>eUjRrkD6
zQ5O;fb01ALO?REs=bm$4!~MEn|MwC^{Cm4+qCc^V-rc_^pcB@G{qI{3EDSjJ&Re9_
zy0QWh!Sx-^dtBR=>rI15S*QB|Y+6&otgHYzMzSh-44Bz`U$fle<2T<1Sa`r^;NZKf
z#G5}Ca0DlUh#-GJBZ3zp0bT@;fCyT*^az-t7-~iXs2Qn(ni<)Q@`LvDL*y!k2cYxh
z^+1k_lR}`pY9TS0ahuE&P0LS7`78}AL^$V{2=IxnSex-|vtY0BTuYIYI64u`4C-MR
z*&we6=zJv)WCPtlz*I4j!g?Zr&<K1Q_POa=dJztC<O6?Q({~vG-Vb+p-Y>b4jO%9n
zkRz{jyNFTV+H7utnW6g!<k}BE_0XbXF=FDNk`NIx0s^NJ{GuZt>55&~aG~Ad-NV}e
zT<9O*;&{O4Iq`yDa!MRTtsn)Q3T~D$?`J=FfP@v}Xu?RCI79?1ZbX1PVJJjZ`PK$H
zP2AD}fDeB&T+xBk;#pf@Z6LHWD0T!snKjM+0Wy$7fEbY~y;1r<G2M=tfy@v`f+a46
zFvn^-UrWN9r^kWBqjZ>2Srj6nnM`=3z%Y#1dX00AMg)f-0<MPbRyZUAK?l}Z|1{sx
zdG4sg1FKY?%ot{6O=jer5s^PCKnS1;R(ftV0X2UUEHtsoiL4RLaejlT1W3*ZIk4jz
z9FqdJkpw^tLO8BKHXtR4I**qL+%QChUK1%t9x>rDdcIBrH>(m4JI~o>LCQvok<I}Y
ztMpQKvAH48rsFBdSV=*M1yss0RU<;HN}H7zo1PzY<eLzA$~Bn5p++9>7Ch=YuINbX
zgvNjLXb{b2tfQ!H$(t=m03kxGvWc5x2%rdK4D_aSzTwMppYyKex&{n*+I4)f+ULps
z1idPw7@GY&q>o})g%7b{9#bGCEJRF%EP|`vXsi-Rk-I5!RTHl^TYRMh7l&T~c%whb
zYwZ@-hC}Y=#EGUwEPxqV3XMF^0fRmrS0H}_R%2+j_tgmGO5iy>=cQ#E$0}tmje!Sa
z*(S)y8Mnn*wm6iGW+P`Mo0Y9>wqrT}y#i{6X~Hz&rcpe(TZ9a>H4Q7E72&03!DS9H
z;N@nERud~z9MD!(=jpexpP4~Y)HW1QAjIN<7QqQvRbevZq>BJ*uqTe!Wg7$bR2Y9O
zf>bppz>WWaNr7a=@Nu&R!8Z(IG~VH)!HeL;9RsaXx#|ET@Jzc~&kdm|YS+Otk#I~N
zFr*R+7^81C6xixn_Z^GvC5yJBYZ|<`@?EgeilU3mA0ksqy1B=-&&cfjJdpw-hQ`Pk
zM#7>yBG4|ET+Smsu<aTa4jh?{QSe09C4YZy8pmr<_R~naT-Mt}c7Q!#=O4oTTXg{3
q5JWt%nAEt3rND5HG4I!ZuzmxGQOj5X^*iPO0000<MNUMnLSTZc!V{GM

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/sr.png b/addons/skin.estuary/media/windows/subtitles/flags/sr.png
index cbef24c06094fe7c39ff6e925b642d5458808741..de53a72ac6579708369100310abdbd8f7393ad14 100644
GIT binary patch
delta 1256
zcmV<E1Q+|33j7I>B!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wiuiAh93R9M69mrIOQMG%I+?$hT!V20s2a~VZh8kM*Z
z1`u2rjm8*JqlSfviF*@Q#-J<X)`X2lRvHt--ULlR;!YVBNPmn`Bnqf7G9$`kX71~B
zca@9tn0sM}#swRx+)kZ7r@QK}`nxK9;kMkC|GOBBafdhF?cJ(T!u-N5aa#I%;^MEV
z0~!EZ-r9$By9Fx17;LSEbq<@R`Ob#H28&6OrFDRoI!07;4IthlAs|@>s?|E%Y;y9A
zHvt+BZ~}DBoqr=-`V*6<1#1n~7{nN4ay@okN^M;v`?-Ocy-a<+gDD^=iYnD}{!^rI
zDyoQRz7B93)+0qSEP$pC>GjYMAOwiHRv$1s@1wbOHR;R@wktHQT%ft<e!}<~G<Y<4
z2mupA^{g@9ONfOYuo*(`D|I;n00CrS5%mEz24ivxFn@;Z$CJ2;4({O$N$0S;QvAiE
z#JL78<Z)=lfew?cniHh?$dw`si)99K0IDD%K=7!sxpP2kb<&y0;&+xbX(C!9t@X)f
z94k8k6&X4MxveFxQN^IBX!Q*hB)AHz19+|VB#)2npx5yE39uGpEU$)BjJDR2NuMmX
zh^NouwtwG)YyQO5yVkLPeqz9L=~D*b<bYIBl>)HRsHYrh0q5VtmdLyhcrSz~gdq4J
ztl7Mg^$%@h)wyqJZQaDg?gtnjkBrWpr}g|(cpsNWC`Z0Gf4^iagxt3Gg7+cMMwtOr
z==J+_dmdXv4~FhUi^ljk{R=7CUp<mt+Xx>Yq<`in38O3M7G-<AXvuv+LpfI!L<C5o
z$doHn<$WXs0i(tFGuYK*aK|L+%X^Wtzfez8VwzBU<t4m=4|0=Mv&8!_4G}c=RRVM+
z;wVap0>)y97;CZ4ks3oB9VK)+)UM9sMM+nU5loT;z8Qcj@)D2~Jwk}0H&Wn(ka@uv
z#eW!!F`$cW<jPgzsnawk#&NB2(z#iB$Btum?8JvSTya%@U!p-P8l)JCb23bUA_WBz
zu;i7f#MwVsJaiblW`y<+XOL?P^d#ag{Z9YbNir`ii(nuNLm3eP1n(`%;29_=$bw){
zj8zPV3*Q`P^ThY)^lEB%PGPq_2p@bzwtw~v-SG{CuzS$mjR$d{5$OO8HPH&N19<<P
z=a`zBB1sagwODIOl7xlhUvl;HL!@IXX*}{e&8e+qUmqb{`-0}R%N#xU$+8u2{SXmi
zjEG1zrl+TQde4V>9|$1~Z7yYO`=hLE>?Qkc1!movJZT#y>3<cOc<fz_F&Ja6D}TR#
z7FDf$I)E(8$g+$iNvPFol~FaYVc**{Kiy9IzyW&o8fjW%)Bew>Z@G8K`OQF-b8Br;
zZGsPhEX$Sv^m;wo?RMq7q{0{j*0Sn_XBd0&*`bJ+i~f2*<+~Dus3I}a@Ac?(Iyo?a
ze!tJc!UCO62k(8}gbDzq9yI=M=V9gEDj*=nNW0yx062goNjP!h1oe8Ik&zLa%_d2b
zESuv0DymA1k#4uk{QNx5x#~_h0<?gUTYMi~1ZEA!l=nh+iva|ncl&?AZTTC#X8)zm
S3LoVF0000<MNUMnLSTYS2T2P6

delta 1265
zcmV<N1P=TB36=_wBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00fLlL_t(o!|j$!h+RbxhQI35=RT5|Oky%K
z*J#wG_`rq9Br&=WMG-M7Dp?4Ed%=~6x)Qg78^x>?LEH;bNDS`OWD$diFVsX$Vlu`@
zGBfvey1UB7Ip@xuF+vatf+=oOr_brG|F8PHnhSrI?XvyfO%U<>ue>(+b(6$}#Y+NO
zW8HiD$J_%gfSX@<4(<0VR)7eu(ZG3+%ky$)OK{O4S+=|mu-d1DS?K{Z1T;ppD8OvA
z&b8YdefD{PmIu57z2nD;XMaV?vf!NHL{JfQ^CsNJoW{mP@m&i!^E=Ij9#T;-3^PX0
z<<Ec63RKNdwQ?Qcr#GQhF&u#99vuv@7$HVTrMD1~oj20nx}N;hDO_J^{c)1^?wg1+
z8?YF#7$8O@#nH2+axXDeek^8;C06cB1^^1^;u01jCW1&Q0U{J%AH~o1@OKnwK9Ad#
z6HXr_&A0He%)>?+)DPoxE4^9e3|(BRD^PzDFawPdV!*_e;D9xn<fjr#pF8rbjaq}e
zF{C)<S=)=4>WVW^##+`IGX%rbM&B?+qaShg08e-B<DRJ<3|gT)0nQ=fcq)FyWakPB
z9a5wY>6>Ht?bqYm-*WDnjl8ljJBD0i>NuT}kQruL5jI-QoC6);#H+ZPSqPC3l$d{%
z7?lu}4cA@CrrWl$?)YbPwr*ke_FI^lNleb4p!3N6gpig;tVg-Ge7_tk#xiyYN(iy6
zMqL3+84QQ?2LV@Q4?=&oLu+P+;mMrhw*lF%ZN#_Uq2V_ZC)d!g+IF>Bt$ig!JvUQS
z7098gl&?z_LLx>5vFiK@Zv7NowV8kXi9P7CA86(|DbHv;`8dHKMCHP^touqC5?F~<
z6ZAFXq()2%;t&$z9L{@k5z^!&vDc$<Zh@dizHW*rSxNZs2#hkX32AjlC`s+F5`?G}
zK@l-T93o&#UG$H0q_4iAJv)Q%%#hEYVerXeWXDcIOe;ICG8vP>MlxtM4DWw+r38jn
z5+uM;cA}Ba{KC?{{kRPibie!_J-^666aMVa3_m$a5ymR8`VL@K1<a~0P(pAR<7c3f
zpoofKh%*G?<fn(ZZuSf8(0UqI&*8S+3a`IOamDxaXQqkq_Hnqs9>lSW$i`%7sEr7F
zfY)Ann7O$*vMj?nhjWfB%UFLr{2}Mw-$y>Rme!rm(4N~$@$muT`44EH|DA*HynVqA
zSUpsgloF~s8ix)Y;(^_7l=nc4amD7^rncY3+SVS5pVlB7H<U%2-puf$#O&QKBO-{%
z%B(NK%xr||0g9raC<?MHqtR%Lf||heb1%|<cRSs^dl@tv<avWFue^Up^X3~?fd3td
zdhVR7x=jf&QWV89fx%!vx7!_o*HVZGILEq2A7tvWhgM{Kq3l-^s^8Tl)C^6D;b1_o
z*DHwu42MG&7Z>UEdV~<lOQ<4H`|;oxJFoYS5&}|6bi3UV0S}O68ApyBq1kLQF)=~A
z-6qSj3zqnwnwgPOqTfC5v#_v$_hkbLA`?IdnE2PwF3y&KGlEF{ztCS|0udNoV$93-
bAGALKyk`HU18Qsi00000NkvXXu0mjfimzS3

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/sv.png b/addons/skin.estuary/media/windows/subtitles/flags/sv.png
index 72ff4173ec0f4d7b40fbc2be292f71e33287cda9..35e5c06284763eca142709d55837112c94db9497 100644
GIT binary patch
delta 1010
zcmV<O0}cG52#5%fB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2witl}SWFR9M69mp!W_MHGggx2Ah$uJ<mkAnXPjs0e<7
zk&$3xB>o2jW!c}Lh8k>SV5XRgfqy^{7Qu88!7mg{L{RW!U4QR~(^YkjK~>ju-!Bkh
z6K^Fw-P2R&Iqx~=?H;&T7wiANgw*lE>+#;*6@MOVPQB^tYj4iZpLq9;{}i;v`sA&?
z1J>Z&xb_kUn>gWuRo~Hf3m$#uk#bcFB=N!3XHVTYXT#meW&p%w#FW{@ggbx(u)FHH
z{`N-z>kjB}=YPAOe&d(h2Ow1dp%4Ig`JtNxflDCx`132M-dC36B?7pYFz&b)5I3ve
zJGgV@@-CIA>j0Kr;An`%WS~iKvl7T7j#{{s>t<35S`OZ_boUBTt~CgEj)usx3k*P4
z5xH|X5OWPEAp->gfk3K-Df`E4r<S0pFhZCEhFevm0)O2(9H6SxjTyw08$glXke8!-
zY}rdX6JVP8R1r6usSs0c_cR5PIVsyD`&xn^L~PlEYN?J#9sz82v8XTxFDfJpClwfC
zW=I)@P|7gY-vmBP_7p?PoJDZF46P4pQ@R;lP*Xrimp^;I|Ks7uo=3J%2!X{y1VIR8
z9EGF6q<;;!{kN5VmN#zT2zM}Z%pqsT%<!<s58r;ubFakvI)H3|ZxD%q6A%FiHDrO%
zF$X)(-N5CzH(j=12=@(R8+8C?5J<=egpfN@K$IOS#w_de0Ng=U`ua=c*7gqSu_-`N
zAOZubjfQJB>hie;Cjfl@x#U_)Q(aKatd?^HUVr@XI*&j36#JXfT&)pRobZcRZy<RC
zdiuTB&TPUh;M5(<_>JSZw_5PcS6>3}%*Sv@)dy_sGRGyv2Dw`1#Rtv@@Ua9F3-$_<
z`V(Vl4AF=cz(sRJ5Lg6_%?LxP9*<hKr;UWqf;*}JL$Z?qDH|zg>bz}(ONgOm><%&e
zsef5d&zmDoAi!WWJj)XR%fvVkV}j5@@LK=!U~*5*2_+bs6>AoFoSG9RGy=HcmWk2l
z0KGD@NGC_Z(IP-tY#+^`-}-@Ixd`p4dEEaeV^Bf1O1PJilO=kk?bGm{4t7G~((aOO
zXNS<Q(G+0$Kn>=Ac<}y9b32^aulqOwQ)__w*%E2kFdY8H(ZV?x0e06b!tEdFRxA2p
zhef|c3N66RTgzFc``^F+_wQkK3N&m;2m9=<m;73bya!wb_U`ig=sxgsc`1c;YskB|
g67cuM|ALG4540a)xMqyWr~m)}07*qoM6N<$f}>j8qyPW_

delta 1019
zcmV<X0|fkt2%-p(Bq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00WpwL_t(o!|j$kt0YAjhM%{lduER3EUqBz
z1{$acUctynFfkJUgMqT_Z%{)GHZm|%OvS)IAP9?KDk6A8!9)ZFFY9_PPFL0U8B}#m
z_qi-A3ya{Xq-VN&>V3ZVyVSt>I$!_yC8UlQUXOqG?ymUjU~}qA-&}cf_Wg->-?$^u
zruE5NeFv<;xpw6x4mNSZ1*^WJ?-o4z%p>Kl7D(cQ%g>&=an6Rjlg$8#$%rYli3xWA
z2Vi&AbM@_y0M;GQ;m-Fz|IV*B4nV2^LLmU~@<Z1N0+&GW@fVj+eXlIXivqY88F$<Z
zh?{@a=ML^%y0}Xv>N<dB7dRRsF&StgZdQam;;6}`TsM=NXt{Wc(%maWxz`}vIT|9%
zE-(OHMdaq;K+IK8LIw%~0)bQ$Q}&P9PEA2`VT3RT47ch=1-f}SKy{}ZBZw(CfMUHN
zFIV^2qL*|gz%=ryBW^ZxA*S5kX$~ZFQnr6d^fd)Rh}fbB)l?l<9sz82v$!yd7Z;L+
zlMW0qGo*|{C}|k;Zvr1Cdx{}t&LTLThE@l)DBX-Ms5u~{i=VyU|M~D^&m-F>gur4U
zf*^#_j>1u3Qij|5+gd-18#i!-JD54<kh5cEc-Z5|?>^<ZSK@sgKsLZPh(y2%hyZ_t
zDp?@ripS$W{><gLH($132=@(R8Fc_=5J<=egpfN@K$IOS#w_Yv0l0&z_4Sv?t?eDu
zV^e_QKm-O<3k}z-)#Y;!P5}7)bBVR4rcOb%VYQq)@ZyJ8dHl(z*x!`mYK5pW3BP>x
z8j?4lr{8<+%p%+ZPN!pOzp)+nRttZ={rW55op~D$sm=i#tITl;u|cjDd6@&Z2JkTj
zlM(C{B=slS&={f-D}akO5kX)PG!`Qasm^%RqCKr8d?xOw0u0Gc0;FuDoT>e`6_*f0
zi`X4v_EV#tes2?T0s#i&z_UC7uuO~tF(wEd1h4ro2a|hhlTd=8jbhD&$F6@lF@#0{
zH{3EY`W&EFMi%MhC^%XK2#f8}9Qy4%5G)s=otm>~=WS3ywobU0mXjrVrR`~WPX{|8
zabb5!x3fd&*Jui`e4vUsARfH`LN#E19GCwEV+TwD>Ss%&VZ(6vH%ANSU<BA*uLw7O
zqFb%#haDFE5-Bu+>z^-YneIpb_<`GAwF@+CNC*4uu9y5)le`C92KH`$*E?GKz%S)b
pDXd#T-o2H8f9|s8`T7s8e*v@~VYpsitf2q^002ovPDHLkV1iK0%|HME

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/tr.png b/addons/skin.estuary/media/windows/subtitles/flags/tr.png
index 98c273185d4d75f6dd01a84ae536cc6afebda0d3..f8b62cfde562442ef07740bf34a01a36bead9fa2 100644
GIT binary patch
delta 1210
zcmV;r1V#Jd3C;<SB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wiuTS-JgR9M69mrbZuRTRg6YoBvJ-n&mt!3zAwEQF{?
zqKRN%649haQ4%FlPO^fqsgpjSNztHzLTC^=&`CBhBqaI<Nq<n9<j2S~jNW_t-t*kM
z_da_y*!!G&?o(^#q_<&n_T6Wnwf<}E|N8HJVWBOw|9cZe^5dOlE?=@3f92{eaa#F$
zbTHY<fiA$t_jaRmMMNbLo9VPMd5&qd;(VTifXT9GN$W5G2xSQh>V5p}9Kn0SzygY<
z_0k*T^y_Z}bboUo4?zFSdCJRw)%J`CMx-7KAnD1xu>zW`S7QZ2<5`UXvfGyvQZjM?
zZMO(TL2wRJ85gNM#Sca5P^Fq<G!d0!MQcE)M(`Tv0w6_!wp%cO93TK;W(IW*6+sa+
zfe-=H%IQ3^na)F-$nRQ@h~Uqj!=3n*!SU}PrMz;6CV#9N)2_*R1uV?WR2gUha2}io
z5yT9mm!(Ttyz5Q!wW|>k%CqNjr+*_%PLtiSoQWOVncaVoFg5j`Ss*B=5}Y3eP(qBN
z^zma6L=2K=EP3ZG@-?dv5#~NWz~HN+qh*xmbf0>H;>gh&K!cY<ZfF<+@;>?;W<XJE
z!8(jcReuI_w?0X>dL;n;ufL%<{3SItk_)wt;_wj^rS-sl*psIcFNUP6=r4(kWEmm7
ztuxRc4A7z=GlncNy!+t&6h#3cFtz71==U1}GTIavd*wxnk3S__zmCDTKTu9jk5ogc
zN*MxTWHbY%f?A7sp9mDm*S>oLB0{)u5uKX8&VOmuvK1@nY}t%iwv^l6-_6{CLxjth
zhb5cHh$<q{SE&sE3WzVkxjMDfRUnX=NYI<fsRj^5Nb5sDoFDFalZYtNYSr6g;ua`4
z2iAhMh;!f^{`WJ82(48sG2>(P`}y6UImg_dedy#A(>r&;)fvo^#nEQ!(y)(n(dQ5V
zV1Hfewtfzd9gkVaG8VnM9R?Qpmp=3EhuB|EaBbfggo~Hv0d3lLH3v+k1C$=DL!FO;
zWF6NI9-=&Z9uZ;unWvd}c^iZ<5*eAH_tFdC9QOO4hVugpgJ?&si#A>KL3slmP@B?}
z>P%8rCSQAlWqUrMea{9K?c724u`Spie}AUDaFKl78nU&kxw89%Xt;ScBn^lHKCdLL
z!#4qV6ud{hPf{G$DNz1#iNBwHp5C_S7~A?d?T0tfzIP+`#7PE6k1_k<M+ECf&V**|
z*UC6lCe)XBZRmhgu!$%wge)D$S{*#zGrM;`b9?tA4Gp+aS?W9>LuHH+l_;fixPPV)
z4O%&cK$d41G2~(pkw}o_sM+hev|Uw{(oBEqCUGnRiTY>-`mMZ?fw3-g-45Mek50Qy
zCWbs|fEgabF^cML(3E3z7`ZB%plEWQsS+x5-ceXfzuO%G$a~|Q(vptJm@rB=i`yXA
zC3pT#>rJFdue<pvN~ur;m{CvO8#Ax(gcHD>z{D-SkIn*r3L@3LFu%nBJkVeGU$D^r
Y0gif~0QfSJq5uE@07*qoM6N<$g2JUb>;M1&

delta 1212
zcmV;t1Vj7I3E>HlBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00dV_L_t(o!|j$!s8&@J$A4>|^F8iEO~DF$
zQx-y0B+*2$mqawFQIteUl#{F=Z0e*3I4K%5PzVh|2Rg|HhJ-|KkOZYkK1QZtbnn%B
zujl*r-e<1{d!NU>nhgRWa=~Wrv(Gu}|6gnW*E)X(ZrV-zzndVEAMGu1`J#pROP6m5
zXodC2aH5j~eSmfE?m%aY$VwtN)9YgL9MkE<{X7Q&lV#D9)?ok;$`TaR`*`gf!F$5c
z0*a>RWo(3#ue}A(&w)GugHvZIFaA;cGa?v~dM$vYnR#mkG<mPq3WU~NtpT!Iml9Gk
zasYqrb_hj5a1K*B7paiqiz0QXQth<}&;nMpCWLAvuW>H`QWR*n14GCG0uZLBQRh$*
z6hRXS5ip&c-oqQ{J-D9y&N~nh{OL2eV?Q%I`VFL%S72!3sxj@Fz$;>5db-L$i-7as
zJcuBsiCz{jX5scX$XBmKL?}<6#hv_xFfo5ccH2_Mw{Br(?|#DM<UeMCprA@{elCF$
zVicv1FN+{zkUV42+i#MuT7if#`{_Q0UmTuWMtM&E$;T-U9j*zqblGS_Lqo{>h}mR7
zQES0Ej7U`m^fx_0wsJWDgD=0LIQTiWG!lebM{)2Fiqg6NUhMG`Nf(XiD)~ziBUyh&
zNO$WD42DCrD9DT<OA7Bla34icKnP6k`UD1pCh~c;t-#33FHn5=G1(n!7=Ha7<<!)i
zYA97HLqLqo%|NN3)*{{~0Y&k3?^=t95YC-PC#S9gtt?x%jNZl#m?ew3<-Hxu?mIxZ
zc(EzjBt}#biCCq!2q+-F1n271QdfV0KxU#q|HecEh$5utLqMEw&b%!|6zO#8<1z6F
z6r2NV!CJ&Qa1Q_LDMW<MishKmk^27p;ZL1mcGn(sVv?zC+u`ywX3@gvGYx6^$GM2v
z5CE)8!`Acg$kCXEEMvhdTVQCB>x}7lc4B`z#+5yv5zb$jN3`wR)fzBWAE1BqU>)jw
zY)IB|W&Z)n(`OM8MxTC)@s~D32y-GMGmO3XJUEB__J?MFXki%rsCCh&ix`yG=mTm~
zno^xf%F4v6ud`&=M|AIA%YtoN=|8#=`~8oU=gyO_Sw*&bC6{)*A04+UqWUJp20pJO
zt;4qocoe)xy-%$;KBqwW+Xa9AeC9dEHb2YArpM?$w4Uxg>#)a;Gdz5RnVlaHtgnIF
zqN^HFY;MiI`Vz0LKHwB=5=sXlOP}Ldk%D^9%<jF+?%qrDN#dGisq=_5oiRpKqLj|z
z+Kp(~$teV~Ji~|~7lVjIfh3^zsQ1!wRZ&Vi{b`t_u}CELM=LPs<gI@UjP#l9_vnv}
z(d%}}#E_>RU}{i_QB?m1wAwM+M6QY^Dw@DERYJwiI|^$V^!p8gd~B2xTGBHa<3{Oc
z@fhZ&Sm(`Go%(h5qYO)hBEYnI^0Cn>EExxG2gbRvHUs=Fh*bZD`3)xEfx*A_a?}3v
a_7{$Np8)^r3%CFP000O{MNUMnLSTX;ghS*2

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/uk.png b/addons/skin.estuary/media/windows/subtitles/flags/uk.png
index f33768312b45098bd584b0105fb91ecce2baed19..5ff28902edfbb08f46f17e3938dae6eee4d06760 100644
GIT binary patch
delta 832
zcmV-G1Hb&02m1z)B!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wit2uVaiR9M69mrbtRL==U;TeiDRIw&weVF`$7w!jh?
zv4U(R8)3u}SO624AR&|$5HUdM@SfW)R~-gbWtaWBqm15!cUL8=e&num?zunZh9`Tn
z|GODxE&9p7c+v9y{ro7P3zmJ~wLlNz&6`);-NlL*9FLB!Yv?)$K+~lCrg6)A$pk<M
z5eY&_Ywsi82gWh&m-kL5$LrU>0Fx2{D1YGq!w~R30uD1UONS*O<uw(!DpAwC0M>-o
zk*q>w7y^d_Odi^FK;(Q5crVP9K?*p_Sim;R2L#sis!7zUoX?>sPzWf;OFLjb!Fx9A
zRfVnhHIbyWY65|I7W1qOSd^&2?dtlr3VM(aWj@advmy|gCNWI~oQ(pTy0u%yb$^|}
zH3d@U#Vvtxyf6$A=bD`TZpn11t^#%?csmS5#k5Y95M#(?9Je7D$0UtZD_|e-Tpw*V
zYd&t1(G12>O9%|JFMj^<tAD=v_7%oGjWe1CoHJZ5N6U4&O~zY*d9D(7h=LeJ2oRzW
z&-n9?U-|BbzrSn&LIlHO@?^1h5`X6%-44KB5bZV%rAL5yLT<W=KoH<Dt2&{Q=Y^1=
zjpz38R$08aU6q)$5HbVdmv&t#5P%6}>B$b56#{!;+u`eKWmL_v#0KNIR{*35hu?HR
zTViWh<8C+7v9w)DNx^)O6*X+iy&w~qXFxNN8IwUd0C1Zytg2isMAdtVR)18bLec~j
za?{HMCNHMR<IH27(YTy;Vhu+=BZXvF394GpM)Jz@LMXr-J(I5#xJ)hg19WYRb4JrT
zno@QK=2&jX8r;k_v35Cq3JJyZTPc;05K%CWaDQoQ1$sW*_w@aV?s(v{*5O)*tATSU
zsE8~Cs!L}nRSBnc&ji7XFkQ{uT}FoSxDsgE6TkgFbL<;FKSAH8X0%N@-R%FLV(Ci>
zhC!S^1lsP|(g~jfUjxq{`Fr$V;IH&i3jKO7JetkG<>`OHll=#`x9jTV;q4m$0000<
KMNUMnLSTYR(Ry_N

delta 840
zcmV-O1GoJ929*bpBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00Rq2L_t(o!|j$$uH`fkg}-u=dqdww4Fl9H
z0Ws|@umnb|ptsT+VZ;(x027!XA=E3N#Q^nf-pfrK`!KMbIQQqN2j~fjS5joVlK7lD
zRjve{?8*M`W|+0;2mj(l%lr59qkt}0_HEY!J%}+kZ(ebC7b{+{-#falq3av~O_Tgh
z<Cf==34jnH5`>V}-bcI-jAQbb=MD$Q>(@U4k@_fqZU@5<@IC?#GcZe=B_QQB6}VPM
zo)^HH&^nS;hzvtuw}Z(;n>L6Xj{)z6nKDQLXBi9FW_dwiEw7qHt;+EjiUNgza=vs1
zd<l3NJ)8Ba!Z!MvNK#rgfxtYAc~%B2O4Q(Xb$wff^Ez1P^PDg%0+DGF(^SAqv~V8n
zrTh<n6S$^8s=T-*FpejNA>v$<tKTh^F4d=?R^Z_@6cy7torD-eKE@jYfpJXINVNhh
z$gRS=smF4ATa0Efj#^S+n0@x+_h0<=)z_~u?rEISG~k@!@^Q3$F1N*a3oy@B@(xiD
zqX+>)6yh1b|MoNAeD~+)EkKB1cubxw_L;<g*`wO?upl~f8cLS{^Mu@V6M-PWV^(!S
zrN|2*qx6Rx1Z<7o7Ds+ZS_qke@JqX{6bQfsvUKGD%nE^XU^~OVRuiIXjwLr3`*Q_A
znsE3{_p>Fpbz{0r!$n(Cxs(*l8(C4qrrZlMfq4cr6PYm?lnns4NyDnjwKS~que73n
zDix9@ppcthCNOz1O&(_+>x{<bvJ-1M@*XKAY!%TuY$dNEFN6Zj(KGo<fz#A-KS0;E
zIA=7iqbbMEz#PjLvIe(`fdnp>Pa&b0-jx6oLPWth!u_eO73leJ-_!R8y8Vt%T8C>L
zt_IGjpdzvms6IN&QI&97eI^KAglXnq?ldxt`;|b`9{A<gnSI~z=>hsaHKT3OU9a+w
zwe+V1!yt|y0&Vv!*OA$C;7j27NALFU*x$e(>8BKWmhZx&*$kW>8S}~hgZ2-%x9jR`
S^@I!n0000<MNUMnLSTaW!-W(8

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/vi.png b/addons/skin.estuary/media/windows/subtitles/flags/vi.png
index 28e0b248af32e04847bb86cceabdc980a0be932e..f7b82da7f40e4e2e06db1d01b29669ca78d70201 100644
GIT binary patch
delta 1057
zcmV++1m6452(}22B!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wit!%0LzR9M69m%WZ0MHGd<TV35VJ3D5z^1?!ZkdR0S
zEFqo%9>F98@D4;s5b^>%0ii=2kRc>U$&d&j;>SXGvAwJfyMOEHslQ85RsF*lIdj66
z)YCnso;v5Ad+x0oxEfdE|2_l}d;8ie-adDY@b~#M0j*d!&+oJrSSs-5Cm#_XZwf0A
z5zL~)Sc_@fJl`~k<a>P&K<hn5RP!Amc~1&~v~{TJ@Lsdp<J%8D23T6aCg9?yU-0)&
zGdO|~K|~OkJ%5YHC|`M2)nTpzsVZsbIe%|oI3g7>EC8J)ZF-Uq7|8^3sQJ>2whR0(
zX$SBrDb?Xpl%$Y0J#-n`0wjfSeu0L77C<fF1DUDZ<$HIW<8b%PjuI7I(M)WjMmWD9
zl~-+DRDD3bN5u?LiwHWXF-Biu_Fi)UY=7^bkb+7`2Y+IjNJ6b0*02B(&Bh54C8A<7
zkj!(Qqc?*ASFdjYc=VMSji_lSE$9ed%^J%uateUt9C)7rOXSmNCk6nZeJRl$_j!@)
zf;*X~L8sMGl%S@<HPwWp0)4+lHyeyGG$I(JD4zirM~S0%9A;UV@55%3mpOQMOSsGn
zrd~MxynkbRS_q-2LPCkEq?8bmT?KFsLLlp&O_=4+6#R+s;FjU|{VmH^W2RL?Y!AU6
zLjQBagIf#2!-QysC>|)OKop#tE07e35quchO9fZ7_(2Hw;qIrF>o+5ZZ~0kf9(~jD
z=WUCo?4v4o4nQXrqR_^96(lrQf%6%(09Lc9)PH4i5b-PkZbl%U38^;|!xr;R`$8#8
z+Lkm;K?HCfydRvdvyu~J0=B-fK{RmrU2Z1(Zv@si5@%n`E2cKzu?&mw&S%V-0x_b_
zqaq{`O!0=vOa?{Tqr~Fno_n7y`RnVvM;yEj&%f7W4;p+iU+sQLGMO~=0fj}JE06#!
zWq+t8_qF6y=WW=oBfoyw;Z8s_`{3c1aQS_QT|3;}W>i46<WMJR(Om_CDjFghB1U9Z
z!(-piX?Xkth?JPL5>?!96(^vRonpE_4C#o0pc4fG;C%K#i(n)JQuYLu(F5|NU1&UA
zjHau5!DJiO(hJlF{4@p5HuR!2)?lQ;ihp3lP?IrSlg2dv%pfvpJe7o@dO(pv$f0a)
zGf`k~!Di91++VS5JG!R9ipl4KSt@cO<Uh^>qw{5$OO+JhQG)ku-4?g(Mgr|>#gA#r
z0@ybVO9O^9_1@DCc2AwF?RX=B^SGs5t%ft<8h8;{KjZW01@MO;Vu58<;~9<s^cq+H
b3$DgLw(wuRQk2{#00000NkvXXu0mjfU{l`D

delta 1065
zcmV+^1lIeu2+#<SBq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00YKJL_t(o!|j&6ZX`t%g}+-}-7_A0v8**1
z0)&J_La-9z3E&ZygaF=w2nj-7fF~f_kPXNX5~O5E1Q7AFLaf<c<6W@5GhKg|psM=E
zgMa|7knojyx~EiA=iGD8y*+RhSMh%jLB!s^_JV)6PhBJYe)dE_E7r}kJFNwl3cUKk
zd&I}<!U{wLv*<9^V%j#ZHw_~BUiSfLy~l`Zz5^uhNg<GWhpG<yn$-?pzVkl7(gHRC
z=imK+zkia!5sU~Tg23!qM21Z2v#Jhj6-ZS{ThIA>`^+J!h+zTfENQ(V`GAp3Ag7uy
z&1iqyz?Y;Qz^9~Chf7hCLRxR2%g`1eDTK3gGz7E&Y5^a}Oyw@$yQ7?kyJxnPsNjlb
zViPsO**U3fwe?W-0reggGh{6y=%B`!eTCV1$pO&+-2F)jDj^++Wg-c+b~wWVL^K;G
zM3jh%$v`r%dCuMp23)<|1MuiGGa6CTR#|`05xkl;mS5x&0LeM<J_DA_r`b*n06_a(
zqC48;L#_+%cwUC;g>kL;KoxaOHQ}hhX49kVHO3ek5e!n4&wz`=#Nitbvn<SaVZF}B
z?7!I)F7knCBb<EP(VrATD5{W9qADpRL}Xh5oP!X^x@Qw+`7;H7EIhbnIC{Hh`C@;}
zv`UKY0oViBeBbck)`IXbAzC4d2TCar1?T1pBn4swAE<7t;EEPM2;n~5{m^p#X5`>C
zKda26FIs-RZPAo{ROQYI=%hmw+Bolmgyt@AK7$s(YBrU6Oim)62Efe-#8V+{%*3$8
zd`#v-X-nFcG%Y~{a2~uLoIbW8j81>Zv3FyQXyD?jJWO_93GCfSoPILzm^ysNHY~zB
zpD||&#E3eNijYJw#TzCw85C&`6N~3J-1}(BZ=dIP#Qy8>^jjP3euFROtJ5z@CX<Fa
zps<K@1rng84Ykz1wwx-nNoe;XKfc@HjzKj0;Nhom@pXsYbGW<BsDNsz;b4Eq{Crt~
zpo)fwhKLcF_3$|Na~U3g10p3Stwa^~Q^g64lVJXS7|Ia?K_?0X!1?Tf7Qsjc1O`J^
z4W{k46*4hhDZ}(NtYsFc5BO;boNd^M(pZC$1}lOQLoLQ|O$O8aGlK}@;He}G)dPwY
zLJp<3%|wBn1?xq}a(BhD?dWxy1}i52FPN1g7eZ!hm&b3WQrA)?1$dO;J-zF3%Wfpl
zu2y`TdKSR0X;>OCq^bA*I^^%y>Ns9Y;4JpEt5w-1vIjg1?EOQye=E*`Ujz{gEUOw%
jFaof7!kAa_AB;Z$w(wuRhefO+00000NkvXXu0mjfabxX(

diff --git a/addons/skin.estuary/media/windows/subtitles/flags/zh.png b/addons/skin.estuary/media/windows/subtitles/flags/zh.png
index b7e1eeb549f650beeaf9637200640a938bbaf023..87f90c7e44b90be2bee34c402a7f66671485c126 100644
GIT binary patch
delta 1098
zcmV-Q1hxD42;T^hB!32COGiWi{{a60|De66lK=n!32;bRa{vGf6951U69E94oEQKA
z00(qQO+^Rb3Iz)n9J(oPi2wit>`6pHR9M69mP@N0MHGd<U0vPh+((Q=@d2462tsfm
zhzJ=9{t$nGI1`-tC!9Lexn!VYK~z)_gQx@vf>CcI_vGZB?tiYwa!}oU`rI25bdX6>
z(C^1yd+oJ$6+9VF#^XK=GynPJ!{86k6W7NN{XhZC1NQ%ej<Mdlv93L^l;D;3J|J&S
z22^G577fnVxVi>`H5H4OGWm`t9l0|ga!w$jl*)Ao<QT|(U+xd@xxIb9d;cAPr3bu#
zliz+N9sM-{Sbts?-A^6^oEavt2K;`YzfsZu>@hQ_#vc!RfremtcFZ|X0IFx78_&H5
zP~DK*mefXEG~79HaJ6Ig`;vU8f(Bd-w6OZrFej>WJ=LLzM-E~^Jq8x#e2WN7LJ}FU
zwncSQ5CCK#-(9h|)Z#BdeO~zIBL{B?-F4(+NB>JzsDBX<9L=kNgVzK9e6)vxfdeVe
z#Z_o8lx)FC<n@a2%>qD>LnQv4*ncgs_j1M}>|c$98x`wo3lxMo3hhdCKZ<y>BDVpO
zK_2jFTM!M|qk)%Pz+_*OH3N_k<Vg4<bNq>8`ECyvKx<fi+>nnmZjn$1tSB$thIq?x
z3zh6gmw!yupS~8#g$0YT#GEsr(4#)ExRTJl!0KAVQ*Q>EOB*&{*T~J~4)w)MeKFI1
zTcZwSb1821FlS|CKvi{`0cg9995%S)%=*KM{AXfy9hw(Ax)^bJpg)&haPV}Xxf0lX
zxrbWY0jQbf@>q948r)#!NT)TRzQ+{ku0v%B*MAuKw$UAds}q(D49p9>(S9Sk?<>@Y
zl6IPRHzwa3pezhwV>SAImw^meiYNrkD4vfF0}MfMNZ=Om%-f|TCtrBv0XGZE)_LV5
zkA6ToPuehF@46sK5Ceq1h|COG`EdNRsd#YnmFRCqlvMPXPKj-TvlXMZ9ja_~U1H7|
zP=DwP2$(=j8JS@S1-SQ_K^-v{p?|=fG4z2QT1Jb8{uBcMDM8<(A$yFehGtv)QH`DJ
zA+wys)COiP8VQ=kSrIZaU{(ST{EKby87ULEx%GCE-6@M^x)6jwnu{<B6eGkqWj_TO
zquPI*e@D7^$}n7~NStdRNc16MAyAv)41Y8-Fe=fu@)~$Kvn0^)WTG5R$5D(~B85Ph
zGtgC@ji9PL=8Vc&nSuxLx!D9`Go4TD%sfAnAQ^Dj)QCVRLoaA6KP$mvkCSG}V*h~U
zqM@!F-Ubju#$&Mi0ho8b-BxVd8E|+QLZIz>x@Nfr;P(&sq021fIdsNSZVJwQ$wNN7
zvU~77o9N#JW7TH--u|>EJOo|<4j=J)bPe1x%sj9h*?5E_mNnLs@wktF0UKn2syNwp
Qr~m)}07*qoM6N<$f)<qb@c;k-

delta 1106
zcmV-Y1g-nu2>1w)Bq<<cNK#Dz0D2|>0Dy!50Qvv`0D$NK0Cg|`0P0`>06Lfe02gqa
zx=}olAr*fIbV*G`2j2+=02~4x3#w=U00ZtxL_t(o!|j$$iyT!HhM#lmR#i{W#7GoB
zAe#h12rdK>Axps@;x7<)f;<0&TbH_*EOaf1iV9*7l|h1F)QMy|o$0E&_nzb8)~&9d
zF@`7v!5rxN>aIHPea?GMH9U$(@qZ6N#D9GGAozcS^ThS>eQ&S;;sN>RNlUKR4%f8@
z7H06mTkoKolTlUPy0*dj8duj~AWcR4oT9fq>ByZCp_;%9ODUg+fX09hL%u%#&h0Jv
z>g_iG79Q{hoc#17>FBpfz~Zvef9Davi692jfL{iN!;0a1kBC539z1RhY)q!Jy{b+E
zswaP+D#zXfSlysqN9rOj3htb-f3;`z^8&qHK?AM^I#_)uh%>5l1J!{Mj~v9Tx+FI8
z@m3Lt8D@q8(sfwfWCZ{U=$#eqr4D}q>hp$wI<o(YVRsyQ>==HiG8zMdqj@o~|8n4u
z_x7+L;J{4h=E~SJlC3y1biJbdG7B)!5Q%@kCzdY-_MTTH!t!b)99FEawOBC3k+EB%
z|JH~%Dzpob1a#DA+k)7*dTivPS&aG`wV8l~fkwhF%JBz|#hU|M09(WA{RTZ&T$?Zj
zBs(wNf_PJKt>x91E}77uJ~vD=1&J}|oD;AxU_+q2lCZmh)wPDlUJW#tHf%nxF*kp=
zJJc7I`l8Z(Sz|qz%&oZf!<<SXU{!UR0Catih7ImmS-)GMzb01Kp?S8aj}fOMe$BIB
z|M5U`C9wH)59?${pv_uNOWh69*bO3%blL+p42T8#>rhF;HG<v}`Xg|4LR3INynz?G
zFO2@{3L8RRcG?P%g1it=LolRNV;FyS2`C^bVj&<x?)m5tKrjdnGjJ_D@p>-F$tNE3
zfSV<q2$TaY{eY=X-Vk5!c0n?O7$6MUWFna48_Sc$au04kGlm-xOP2kZPMK|zvo)h_
zCsh8_b<Q~_U}4B2U=lH{NCd&K0CztUs3YPc4BRtpoC7;pN{fc!6aj#gU>JX}arFpO
z4Q1K@)u>qc+sKoT*<@rIN;K_R6H*9><isO?W1D;iWfC`Uy`9DGl*MMgFbIJ(H(@le
z7$L@K^;43PRUYvDTX64`VLVTfIQKv>V+aumfm#G7V1+<&V$reXa^^3Ajo(bjv1wn-
zsAi-P2y+5`<=Gfil}DUVImv&o;L&_##>m)GlaNAX*7Gw9qJTrDK?H^=3<h20XC-L&
zIB6EN%Y7DYLtQz%j3UMrmt=n>U_SYFN3m?*fa8}T1iF5pZx&kte!0&#z0#WJzzGX;
zQ*w6F-Yeuj*JQ%K3BsyV{NA!ql>^`z;NZbr_OD|N+!RDSuqZShVniOGd&oH-#eXpV
Y1RG?5s$>BrcmMzZ07*qoM6N<$f+?K%KmY&$

-- 
2.7.4


From fd5079c1cd5eda79e4c2a39bb33e97361e6610a6 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Wed, 5 Oct 2016 22:07:44 +0200
Subject: [PATCH 030/175] fix bug when opening playlists to smartplaylisteditor
 several times

---
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
index 5f0f75f..1d45f6f 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
@@ -183,6 +183,11 @@ bool CGUIDialogSmartPlaylistEditor::OnMessage(CGUIMessage& message)
       }
     }
     break;
+    case GUI_MSG_WINDOW_DEINIT:
+    {
+      m_playlist.Reset();
+    }
+    break;
   }
   return CGUIDialog::OnMessage(message);
 }
-- 
2.7.4


From 9ba7da03d4500ad2e86f7eae869719df6ef9f88e Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Wed, 5 Oct 2016 22:47:07 +0200
Subject: [PATCH 031/175] Fix: PVR windows never must list removable media.

---
 xbmc/pvr/windows/GUIWindowPVRBase.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/pvr/windows/GUIWindowPVRBase.cpp b/xbmc/pvr/windows/GUIWindowPVRBase.cpp
index 34fe5b2..6a4544c 100644
--- a/xbmc/pvr/windows/GUIWindowPVRBase.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRBase.cpp
@@ -69,6 +69,9 @@ CGUIWindowPVRBase::CGUIWindowPVRBase(bool bRadio, int id, const std::string &xml
   m_bRadio(bRadio),
   m_progressHandle(nullptr)
 {
+  // prevent removable drives to appear in directory listing (base class default behavior).
+  m_rootDir.AllowNonLocalSources(false);
+
   m_selectedItemPaths[false] = "";
   m_selectedItemPaths[true] = "";
 
-- 
2.7.4


From 8318e17f9e55545f448bbff2c7b7905cae2e1b35 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <afedchin@users.noreply.github.com>
Date: Thu, 6 Oct 2016 17:14:27 +0300
Subject: [PATCH 032/175] Added workaround for AMD/ATI cards to fix
 interlacing. (#10633)

* [dxva] Added workaround for AMD/ATI cards to fix interlacing.
---
 xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/DXVAHD.cpp | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/DXVAHD.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/DXVAHD.cpp
index bb336c3..0383e0a 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/DXVAHD.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/DXVAHD.cpp
@@ -610,6 +610,13 @@ bool CProcessorHD::Render(CRect src, CRect dst, ID3D11Resource* target, ID3D11Vi
   stream_data.OutputIndex = flags & RENDER_FLAG_FIELD1 && !frameProgressive ? 1 : 0;
 
   // input format
+  if (!frameProgressive && PCIV_ATI == g_Windowing.GetAIdentifier().VendorId)
+  {
+    // workaround for AMD/ATI cards which may disable deinterlacing for 
+    // not full set of past/future frames and enable it only when format is changed. 
+    // here we just reset frag to progressive and later change it back to interlaced
+    m_pVideoContext->VideoProcessorSetStreamFrameFormat(m_pVideoProcessor, DEFAULT_STREAM_INDEX, D3D11_VIDEO_FRAME_FORMAT_PROGRESSIVE);
+  }
   m_pVideoContext->VideoProcessorSetStreamFrameFormat(m_pVideoProcessor, DEFAULT_STREAM_INDEX, dxvaFrameFormat);
   // Source rect
   m_pVideoContext->VideoProcessorSetStreamSourceRect(m_pVideoProcessor, DEFAULT_STREAM_INDEX, TRUE, &sourceRECT);
-- 
2.7.4


From ccecd3cd0d1a9f303eba7e8177ceea29cea0af68 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 6 Oct 2016 16:54:47 +0200
Subject: [PATCH 033/175] guilib: fix initial focus when opening GUiMediaWindow
 with plugin content after 5220b49d4159f5ee62fd34409f5b811a16185b80

---
 xbmc/windows/GUIMediaWindow.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/windows/GUIMediaWindow.cpp b/xbmc/windows/GUIMediaWindow.cpp
index 89f1c6a..97ebd67 100644
--- a/xbmc/windows/GUIMediaWindow.cpp
+++ b/xbmc/windows/GUIMediaWindow.cpp
@@ -512,6 +512,9 @@ bool CGUIMediaWindow::OnMessage(CGUIMessage& message)
       if (message.GetParam2() == PLUGIN_REFRESH_DELAY)
       {
         Refresh();
+        SetInitialVisibility();
+        RestoreControlStates();
+        SetInitialVisibility();
         return true;
       }
     }
-- 
2.7.4


From 7dfc65e968e7e5e4277a6178b1e25b7be4ef21c1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?P=C3=A4r=20Bj=C3=B6rklund?= <per@ohmy.nu>
Date: Thu, 6 Oct 2016 19:50:09 +0200
Subject: [PATCH 034/175] Remove hardcoded bitness

---
 xbmc/utils/SystemInfo.cpp | 11 +----------
 1 file changed, 1 insertion(+), 10 deletions(-)

diff --git a/xbmc/utils/SystemInfo.cpp b/xbmc/utils/SystemInfo.cpp
index aaf6f0a..45b6f1a 100644
--- a/xbmc/utils/SystemInfo.cpp
+++ b/xbmc/utils/SystemInfo.cpp
@@ -1017,16 +1017,7 @@ const std::string& CSysInfo::GetKernelCpuFamily(void)
 
 int CSysInfo::GetXbmcBitness(void)
 {
-#if defined (__aarch64__) || defined(__amd64__) || defined(__amd64) || defined(__x86_64__) || defined(__x86_64) || defined(_M_X64) || \
-  defined(_M_AMD64) || defined(__ppc64__) || defined(__mips64) || defined(__s390x__)
-  return 64;
-#elif defined(__thumb__) || defined(_M_ARMT) || defined(__arm__) || defined(_M_ARM) || defined(__mips__) || defined(mips) || defined(__mips) || defined(i386) || \
-  defined(__i386) || defined(__i386__) || defined(__i486__) || defined(__i586__) || defined(__i686__) || defined(_M_IX86) || defined(_X86_) || defined(__powerpc) || \
-  defined(__powerpc__) || defined(__ppc__) || defined(_M_PPC)
-  return 32;
-#else
-  return 0; // Unknown
-#endif
+  return static_cast<int>(sizeof(void*) * 8);
 }
 
 bool CSysInfo::HasInternet()
-- 
2.7.4


From 6492569d058304c7c730b7b362420f3a4e570191 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 6 Oct 2016 20:21:08 +0200
Subject: [PATCH 035/175] allow http header icy-metadata

---
 xbmc/filesystem/CurlFile.cpp | 23 +++++++++++++++--------
 1 file changed, 15 insertions(+), 8 deletions(-)

diff --git a/xbmc/filesystem/CurlFile.cpp b/xbmc/filesystem/CurlFile.cpp
index a6d7fe0..a0b2ef2 100644
--- a/xbmc/filesystem/CurlFile.cpp
+++ b/xbmc/filesystem/CurlFile.cpp
@@ -791,7 +791,8 @@ void CCurlFile::ParseAndCorrectUrl(CURL &url2)
       // set xbmc headers
       for (std::map<std::string,std::string>::const_iterator it = options.begin(); it != options.end(); ++it)
       {
-        std::string name = it->first; StringUtils::ToLower(name);
+        std::string name = it->first;
+        StringUtils::ToLower(name);
         const std::string &value = it->second;
 
         if (name == "auth")
@@ -826,13 +827,19 @@ void CCurlFile::ParseAndCorrectUrl(CURL &url2)
         }
         // other standard headers (see https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)
         else if (name == "accept" || name == "accept-language" || name == "accept-datetime" ||
-          name == "authorization" || name == "cache-control" || name == "connection" || name == "content-md5" || name == "content-type" || 
-          name == "date" || name == "expect" || name == "forwarded" || name == "from" || name == "if-match" || 
-          name == "if-modified-since" || name == "if-none-match" || name == "if-range" || name == "if-unmodified-since" || name == "max-forwards" || 
-          name == "origin" || name == "pragma" || name == "range" || name == "te" || name == "upgrade" || 
-          name == "via" || name == "warning" || name == "x-requested-with" || name == "dnt" || name == "x-forwarded-for" || name == "x-forwarded-host" || 
-          name == "x-forwarded-proto" || name == "front-end-https" || name == "x-http-method-override" || name == "x-att-deviceid" ||
-          name == "x-wap-profile" || name == "x-uidh" || name == "x-csrf-token" || name == "x-request-id" || name == "x-correlation-id")
+                 name == "authorization" || name == "cache-control" || name == "connection" ||
+                 name == "content-md5" || name == "content-type" || name == "date" ||
+                 name == "expect" || name == "forwarded" || name == "from" ||
+                 name == "if-match" || name == "if-modified-since" || name == "if-none-match" ||
+                 name == "if-range" || name == "if-unmodified-since" || name == "max-forwards" ||
+                 name == "origin" || name == "pragma" || name == "range" || name == "te" ||
+                 name == "upgrade" || name == "via" || name == "warning" ||
+                 name == "x-requested-with" || name == "dnt" || name == "x-forwarded-for" ||
+                 name == "x-forwarded-host" || name == "x-forwarded-proto" ||
+                 name == "front-end-https" || name == "x-http-method-override" ||
+                 name == "x-att-deviceid" || name == "x-wap-profile" || name == "x-uidh" ||
+                 name == "x-csrf-token" || name == "x-request-id" || name == "x-correlation-id" ||
+                 name == "icy-metadata")
         {
           SetRequestHeader(it->first, value);
           if (name == "authorization")
-- 
2.7.4


From 1562ffcc605799ae87696ddc90958e5aa154b548 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?P=C3=A4r=20Bj=C3=B6rklund?= <per@ohmy.nu>
Date: Thu, 6 Oct 2016 20:52:16 +0200
Subject: [PATCH 036/175] Fix tests on win32. CPUInfo is initialized before
 CCharsetConverter causing us to blow up.

Added Windows specific conversion methods to avoid these kinds of issues as the string conversion is a bit special for Windows as API calls expect UTF-16 strings.

These methods are not meant for general usage, just for Windows specific scenarios.
---
 xbmc/platform/win32/CMakeLists.txt       |  6 ++-
 xbmc/platform/win32/CharsetConverter.cpp | 71 ++++++++++++++++++++++++++++++
 xbmc/platform/win32/CharsetConverter.h   | 74 ++++++++++++++++++++++++++++++++
 xbmc/utils/CPUInfo.cpp                   |  8 ++--
 4 files changed, 154 insertions(+), 5 deletions(-)
 create mode 100644 xbmc/platform/win32/CharsetConverter.cpp
 create mode 100644 xbmc/platform/win32/CharsetConverter.h

diff --git a/xbmc/platform/win32/CMakeLists.txt b/xbmc/platform/win32/CMakeLists.txt
index 19f20c4..2436fa1 100644
--- a/xbmc/platform/win32/CMakeLists.txt
+++ b/xbmc/platform/win32/CMakeLists.txt
@@ -1,4 +1,5 @@
-set(SOURCES MessagePrinter.cpp
+set(SOURCES CharsetConverter.cpp
+            MessagePrinter.cpp
             WinMain.cpp
             crts_caller.cpp
             dxerr.cpp
@@ -9,7 +10,8 @@ set(SOURCES MessagePrinter.cpp
             WIN32Util.cpp
             WindowHelper.cpp)
 
-set(HEADERS crts_caller.h
+set(HEADERS CharsetConverter.h
+            crts_caller.h
             dirent.h
             dxerr.h
             IMMNotificationClient.h
diff --git a/xbmc/platform/win32/CharsetConverter.cpp b/xbmc/platform/win32/CharsetConverter.cpp
new file mode 100644
index 0000000..d8cc7f9
--- /dev/null
+++ b/xbmc/platform/win32/CharsetConverter.cpp
@@ -0,0 +1,71 @@
+/*
+ *      Copyright (C) 2005-2016 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <memory>
+
+#include "CharsetConverter.h"
+namespace KODI
+{
+namespace PLATFORM
+{
+namespace WINDOWS
+{
+std::string FromW(const wchar_t* str, size_t length)
+{
+  int result = WideCharToMultiByte(CP_UTF8, 0, str, length, nullptr, 0, nullptr, nullptr);
+  if (result == 0)
+    return std::string();
+
+  auto newStr = std::make_unique<char[]>(result);
+  result = WideCharToMultiByte(CP_UTF8, 0, str, length, newStr.get(), result, nullptr, nullptr);
+  if (result == 0)
+    return std::string();
+
+  return std::string(newStr.get());
+}
+
+std::string FromW(const std::wstring& str)
+{
+  return FromW(str.c_str(), str.length());
+}
+
+std::wstring ToW(const char* str, size_t length)
+{
+  int result = MultiByteToWideChar(CP_UTF8, 0, str, length, nullptr, 0);
+  if (result == 0)
+    return std::wstring();
+
+  auto newStr = std::make_unique<wchar_t[]>(result);
+  result = MultiByteToWideChar(CP_UTF8, 0, str, length, newStr.get(), result);
+
+  if (result == 0)
+    return std::wstring();
+
+  return std::wstring(newStr.get());
+}
+
+std::wstring ToW(const std::string& str)
+{
+  return ToW(str.c_str(), str.length());
+}
+
+}
+}
+}
diff --git a/xbmc/platform/win32/CharsetConverter.h b/xbmc/platform/win32/CharsetConverter.h
new file mode 100644
index 0000000..cbee84c
--- /dev/null
+++ b/xbmc/platform/win32/CharsetConverter.h
@@ -0,0 +1,74 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2016 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <string>
+
+namespace KODI
+{
+namespace PLATFORM
+{
+namespace WINDOWS
+{
+/**
+ * Convert UTF-16 to UTF-8 strings
+ * Windows specific method to avoid initialization issues
+ * and locking issues that are unique to Windows as API calls
+ * expect UTF-16 strings
+ * \param str[in] string to be converted
+ * \param length[in] length in characters of the string
+ * \returns utf8 string, empty string on failure
+ */
+std::string FromW(const wchar_t* str, size_t length);
+
+/**
+ * Convert UTF-16 to UTF-8 strings
+ * Windows specific method to avoid initialization issues
+ * and locking issues that are unique to Windows as API calls
+ * expect UTF-16 strings
+ * \param str[in] string to be converted
+ * \returns utf8 string, empty string on failure
+ */
+std::string FromW(const std::wstring& str);
+
+/**
+ * Convert UTF-8 to UTF-16 strings
+ * Windows specific method to avoid initialization issues
+ * and locking issues that are unique to Windows as API calls
+ * expect UTF-16 strings
+ * \param str[in] string to be converted
+ * \param length[in] length in characters of the string
+ * \returns UTF-16 string, empty string on failure
+ */
+std::wstring ToW(const char* str, size_t length);
+
+/**
+ * Convert UTF-8 to UTF-16 strings
+ * Windows specific method to avoid initialization issues
+ * and locking issues that are unique to Windows as API calls
+ * expect UTF-16 strings
+ * \param str[in] string to be converted
+ * \returns UTF-16 string, empty string on failure
+ */
+std::wstring ToW(const std::string& str);
+}
+}
+}
diff --git a/xbmc/utils/CPUInfo.cpp b/xbmc/utils/CPUInfo.cpp
index e6fef0e..dc551ed 100644
--- a/xbmc/utils/CPUInfo.cpp
+++ b/xbmc/utils/CPUInfo.cpp
@@ -56,7 +56,7 @@
 #endif
 
 #ifdef TARGET_WINDOWS
-#include "utils/CharsetConverter.h"
+#include "platform/win32/CharsetConverter.h"
 #include <algorithm>
 #include <intrin.h>
 #include <Pdh.h>
@@ -154,6 +154,8 @@ CCPUInfo::CCPUInfo(void)
   }
 
 #elif defined(TARGET_WINDOWS)
+  using KODI::PLATFORM::WINDOWS::FromW;
+
   HKEY hKeyCpuRoot;
 
   if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor", 0, KEY_READ, &hKeyCpuRoot) == ERROR_SUCCESS)
@@ -176,7 +178,7 @@ CCPUInfo::CCPUInfo(void)
         if (RegQueryValueExW(hCpuKey, L"ProcessorNameString", nullptr, &valType, LPBYTE(buf), &bufSize) == ERROR_SUCCESS &&
             valType == REG_SZ)
         {
-          g_charsetConverter.wToUTF8(std::wstring(buf, bufSize / sizeof(wchar_t)), cpuCore.m_strModel);
+          cpuCore.m_strModel = FromW(buf, bufSize / sizeof(wchar_t));
           cpuCore.m_strModel = cpuCore.m_strModel.substr(0, cpuCore.m_strModel.find(char(0))); // remove extra null terminations
           StringUtils::RemoveDuplicatedSpacesAndTabs(cpuCore.m_strModel);
           StringUtils::Trim(cpuCore.m_strModel);
@@ -185,7 +187,7 @@ CCPUInfo::CCPUInfo(void)
         if (RegQueryValueExW(hCpuKey, L"VendorIdentifier", nullptr, &valType, LPBYTE(buf), &bufSize) == ERROR_SUCCESS &&
             valType == REG_SZ)
         {
-          g_charsetConverter.wToUTF8(std::wstring(buf, bufSize / sizeof(wchar_t)), cpuCore.m_strVendor);
+          cpuCore.m_strVendor = FromW(buf, bufSize / sizeof(wchar_t));
           cpuCore.m_strVendor = cpuCore.m_strVendor.substr(0, cpuCore.m_strVendor.find(char(0))); // remove extra null terminations
         }
         DWORD mhzVal;
-- 
2.7.4


From d4adcc2022f55e63b3418024c54330790e80d419 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Sun, 2 Oct 2016 23:11:53 +0200
Subject: [PATCH 037/175] SmartPlaylistEditor: some refactoring and code
 improvements

---
 .../resource.language.en_gb/resources/strings.po   |  3 +-
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp      | 42 ++++++-----
 xbmc/dialogs/GUIDialogSmartPlaylistEditor.h        |  2 +-
 xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp        | 88 +++++++++++++---------
 xbmc/dialogs/GUIDialogSmartPlaylistRule.h          |  2 +-
 5 files changed, 77 insertions(+), 60 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 22572e2..15b3712 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -12425,6 +12425,7 @@ msgctxt "#20426"
 msgid "Export to a single file or separate files per entry?"
 msgstr ""
 
+#: xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
 msgctxt "#20427"
 msgid "Choose rule type"
 msgstr ""
@@ -13048,7 +13049,7 @@ msgstr ""
 
 #: addons/skin.estuary/1080i/SmartPlaylistEditor.xml
 msgctxt "#21433"
-msgid "Name of the playlist"
+msgid "Playlist name"
 msgstr ""
 
 msgctxt "#21434"
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
index 1d45f6f..81eabd1 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.cpp
@@ -213,14 +213,14 @@ void CGUIDialogSmartPlaylistEditor::OnPopupMenu(int item)
 
 void CGUIDialogSmartPlaylistEditor::OnRuleList(int item)
 { 
+  if (item < 0 || item > static_cast<int>(m_playlist.m_ruleCombination.m_rules.size()))
+    return;
   if (item == static_cast<int>(m_playlist.m_ruleCombination.m_rules.size()))
     OnRuleAdd();
-  else if (item < 0 || item > static_cast<int>(m_playlist.m_ruleCombination.m_rules.size()))
-    return;
   else
   {
     CSmartPlaylistRule rule = *std::static_pointer_cast<CSmartPlaylistRule>(m_playlist.m_ruleCombination.m_rules[item]);
-    if (CGUIDialogSmartPlaylistRule::EditRule(rule,m_playlist.GetType()))
+    if (CGUIDialogSmartPlaylistRule::EditRule(rule, m_playlist.GetType()))
       *m_playlist.m_ruleCombination.m_rules[item] = rule;
   }
   UpdateButtons();
@@ -288,7 +288,7 @@ void CGUIDialogSmartPlaylistEditor::OnMatch()
 void CGUIDialogSmartPlaylistEditor::OnName()
 {
   std::string name = m_playlist.m_playlistName;
-  if (CGUIKeyboardFactory::ShowAndGetInput(name, CVariant{g_localizeStrings.Get(16012)}, false))
+  if (CGUIKeyboardFactory::ShowAndGetInput(name, CVariant{16012}, false))
   {
     m_playlist.m_playlistName = name;
     UpdateButtons();
@@ -297,23 +297,24 @@ void CGUIDialogSmartPlaylistEditor::OnName()
 
 void CGUIDialogSmartPlaylistEditor::OnLimit()
 {
-  const int limits[] = {0, 10, 25, 50, 100, 250, 500, 1000, -1 };
-  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  std::vector<int> limits = {0, 10, 25, 50, 100, 250, 500, 1000};
+  CGUIDialogSelect* dialog = static_cast<CGUIDialogSelect*>(g_windowManager.GetWindow(WINDOW_DIALOG_SELECT));
   dialog->Reset();
   int selected = -1;
-  for (unsigned int i = 0; limits[i] > -1; i++) {
-    if (limits[i] == m_playlist.m_limit)
-      selected = i;
-    if (limits[i] == 0)
+  for (auto limit = limits.begin(); limit != limits.end(); limit++)
+  {
+    if (*limit == static_cast<int>(m_playlist.m_limit))
+      selected = std::distance(limits.begin(), limit);
+    if (*limit == 0)
       dialog->Add(g_localizeStrings.Get(21428));
     else
-      dialog->Add(StringUtils::Format(g_localizeStrings.Get(21436).c_str(), limits[i]));
+      dialog->Add(StringUtils::Format(g_localizeStrings.Get(21436).c_str(), *limit));
   }
   dialog->SetHeading(CVariant{ 21427 });
   dialog->SetSelected(selected);
   dialog->Open();
   int newSelected = dialog->GetSelectedItem();
-  if (!dialog->IsConfirmed() || newSelected < 0 || limits[newSelected] == m_playlist.m_limit)
+  if (!dialog->IsConfirmed() || newSelected < 0 || limits[newSelected] == static_cast<int>(m_playlist.m_limit))
     return;
   m_playlist.m_limit = limits[newSelected];
   UpdateButtons();
@@ -322,7 +323,7 @@ void CGUIDialogSmartPlaylistEditor::OnLimit()
 void CGUIDialogSmartPlaylistEditor::OnType()
 {
   std::vector<PLAYLIST_TYPE> allowedTypes = GetAllowedTypes(m_mode);
-  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  CGUIDialogSelect* dialog = static_cast<CGUIDialogSelect*>(g_windowManager.GetWindow(WINDOW_DIALOG_SELECT));
   dialog->Reset();
   for (auto allowedType: allowedTypes)
     dialog->Add(GetLocalizedType(allowedType));
@@ -340,7 +341,7 @@ void CGUIDialogSmartPlaylistEditor::OnType()
 void CGUIDialogSmartPlaylistEditor::OnOrder()
 {
   std::vector<SortBy> orders = CSmartPlaylistRule::GetOrders(m_playlist.GetType());
-  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  CGUIDialogSelect* dialog = static_cast<CGUIDialogSelect*>(g_windowManager.GetWindow(WINDOW_DIALOG_SELECT));
   dialog->Reset();
   for (auto order: orders)
     dialog->Add(g_localizeStrings.Get(SortUtils::GetSortLabel(order)));
@@ -367,7 +368,7 @@ void CGUIDialogSmartPlaylistEditor::OnGroupBy()
 {
   std::vector<Field> groups = CSmartPlaylistRule::GetGroups(m_playlist.GetType());
   Field currentGroup = CSmartPlaylistRule::TranslateGroup(m_playlist.GetGroup().c_str());
-  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  CGUIDialogSelect* dialog = static_cast<CGUIDialogSelect*>(g_windowManager.GetWindow(WINDOW_DIALOG_SELECT));
   dialog->Reset();
   for (auto group : groups)
     dialog->Add(CSmartPlaylistRule::GetLocalizedGroup(group));
@@ -405,15 +406,14 @@ void CGUIDialogSmartPlaylistEditor::UpdateButtons()
     SET_CONTROL_LABEL2(CONTROL_NAME, m_playlist.m_playlistName);
   
   UpdateRuleControlButtons();
-  
 
   if (m_playlist.m_ruleCombination.GetType() == CSmartPlaylistRuleCombination::CombinationOr)
-    SET_CONTROL_LABEL2(CONTROL_MATCH, g_localizeStrings.Get(21426));
+    SET_CONTROL_LABEL2(CONTROL_MATCH, g_localizeStrings.Get(21426)); // one or more of the rules
   else
-    SET_CONTROL_LABEL2(CONTROL_MATCH, g_localizeStrings.Get(21425));
+    SET_CONTROL_LABEL2(CONTROL_MATCH, g_localizeStrings.Get(21425)); // all of the rules
   CONTROL_ENABLE_ON_CONDITION(CONTROL_MATCH, m_playlist.m_ruleCombination.m_rules.size() > 1);
   if (m_playlist.m_limit == 0)
-    SET_CONTROL_LABEL2(CONTROL_LIMIT, g_localizeStrings.Get(21428));
+    SET_CONTROL_LABEL2(CONTROL_LIMIT, g_localizeStrings.Get(21428)); // no limit
   else
     SET_CONTROL_LABEL2(CONTROL_LIMIT, StringUtils::Format(g_localizeStrings.Get(21436).c_str(), m_playlist.m_limit));
   int currentItem = GetSelectedItem();
@@ -489,8 +489,10 @@ void CGUIDialogSmartPlaylistEditor::OnInitWindow()
   PLAYLIST_TYPE type = ConvertType(m_playlist.GetType());
   bool allowed = false;
   for (auto allowedType: allowedTypes)
+  {
     if (type == allowedType)
       allowed = true;
+  }
   if (!allowed && allowedTypes.size())
     m_playlist.SetType(ConvertType(allowedTypes[0]));
 
@@ -553,7 +555,7 @@ void CGUIDialogSmartPlaylistEditor::HighlightItem(int item)
   OnMessage(msg);
 }
 
-std::vector<CGUIDialogSmartPlaylistEditor::PLAYLIST_TYPE> CGUIDialogSmartPlaylistEditor::GetAllowedTypes(std::string mode)
+std::vector<CGUIDialogSmartPlaylistEditor::PLAYLIST_TYPE> CGUIDialogSmartPlaylistEditor::GetAllowedTypes(const std::string& mode)
 {
   std::vector<PLAYLIST_TYPE> allowedTypes;
   if (mode == "partymusic")
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h
index 7aa19d5..ffa7271 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistEditor.h
@@ -60,7 +60,7 @@ protected:
   void UpdateRuleControlButtons();
   int GetSelectedItem();
   void HighlightItem(int item);
-  std::vector<PLAYLIST_TYPE> GetAllowedTypes(std::string mode);
+  std::vector<PLAYLIST_TYPE> GetAllowedTypes(const std::string& mode);
   PLAYLIST_TYPE ConvertType(const std::string &type);
   std::string ConvertType(PLAYLIST_TYPE type);
   std::string GetLocalizedType(PLAYLIST_TYPE type);
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
index 3e34c99..4de8063 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
@@ -371,48 +371,15 @@ void CGUIDialogSmartPlaylistRule::OnBrowse()
   pDialog->Reset();
 }
 
-void CGUIDialogSmartPlaylistRule::OnCancel()
-{
-  m_cancelled = true;
-  Close();
-}
-
-void CGUIDialogSmartPlaylistRule::OnField()
-{
-
-  std::vector<Field> fields = CSmartPlaylistRule::GetFields(m_type);
-  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
-  dialog->Reset();
-  dialog->SetHeading(CVariant{20427});
-  int selected = -1;
-  for (unsigned int i = 0; i < fields.size(); i++)
-  {
-    dialog->Add(CSmartPlaylistRule::GetLocalizedField(fields[i]));
-    if (fields[i] == m_rule.m_field)
-      selected = i;
-  }
-  if (selected > -1)
-    dialog->SetSelected(selected);
-  dialog->Open();
-  int newSelected = dialog->GetSelectedItem();
-  // check if selection has changed
-  if (!dialog->IsConfirmed() || newSelected < 0 || newSelected == selected)
-    return;
-  m_rule.m_field = fields[newSelected];
-
-  UpdateButtons();
-}
-
 std::pair<std::string, int> OperatorLabel(CDatabaseQueryRule::SEARCH_OPERATOR op)
 {
   return std::make_pair(CSmartPlaylistRule::GetLocalizedOperator(op), op);
 }
 
-void CGUIDialogSmartPlaylistRule::OnOperator()
+std::vector<std::pair<std::string, int>> CGUIDialogSmartPlaylistRule::GetValidOperators(const CSmartPlaylistRule& rule)
 {
-
   std::vector< std::pair<std::string, int> > labels;
-  switch (m_rule.GetFieldType(m_rule.m_field))
+  switch (rule.GetFieldType(rule.m_field))
   {
   case CDatabaseQueryRule::TEXT_FIELD:
     // text fields - add the usual comparisons
@@ -459,7 +426,54 @@ void CGUIDialogSmartPlaylistRule::OnOperator()
     labels.push_back(OperatorLabel(CDatabaseQueryRule::OPERATOR_DOES_NOT_EQUAL));
     break;
   }
-  CGUIDialogSelect* dialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  return labels;
+}
+
+void CGUIDialogSmartPlaylistRule::OnCancel()
+{
+  m_cancelled = true;
+  Close();
+}
+
+void CGUIDialogSmartPlaylistRule::OnField()
+{
+  const auto fields = CSmartPlaylistRule::GetFields(m_type);
+  CGUIDialogSelect* dialog = static_cast<CGUIDialogSelect*>(g_windowManager.GetWindow(WINDOW_DIALOG_SELECT));
+  dialog->Reset();
+  dialog->SetHeading(CVariant{20427});
+  int selected = -1;
+  for (auto field = fields.begin(); field != fields.end(); field++)
+  {
+    dialog->Add(CSmartPlaylistRule::GetLocalizedField(*field));
+    if (*field == m_rule.m_field)
+      selected = std::distance(fields.begin(), field);
+  }
+  if (selected > -1)
+    dialog->SetSelected(selected);
+  dialog->Open();
+  int newSelected = dialog->GetSelectedItem();
+  // check if selection has changed
+  if (!dialog->IsConfirmed() || newSelected < 0 || newSelected == selected)
+    return;
+
+  m_rule.m_field = fields[newSelected];
+  // check if operator is still valid. if not, reset to first valid one
+  std::vector< std::pair<std::string, int> > validOperators = GetValidOperators(m_rule);
+  bool isValid = false;
+  for (auto op : validOperators)
+    if (std::get<0>(op) == std::get<0>(OperatorLabel(m_rule.m_operator)))
+      isValid = true;
+  if (!isValid)
+    m_rule.m_operator = (CDatabaseQueryRule::SEARCH_OPERATOR)std::get<1>(validOperators[0]);
+
+  m_rule.SetParameter("");
+  UpdateButtons();
+}
+
+void CGUIDialogSmartPlaylistRule::OnOperator()
+{
+  const auto labels = GetValidOperators(m_rule);
+  CGUIDialogSelect* dialog = static_cast<CGUIDialogSelect*>(g_windowManager.GetWindow(WINDOW_DIALOG_SELECT));
   dialog->Reset();
   dialog->SetHeading(CVariant{ 16023 });
   for (auto label : labels)
@@ -488,7 +502,7 @@ void CGUIDialogSmartPlaylistRule::UpdateButtons()
     CONTROL_DISABLE(CONTROL_BROWSE);
   SET_CONTROL_LABEL2(CONTROL_OPERATOR, std::get<0>(OperatorLabel(m_rule.m_operator)));
 
-  // update the parameter edit control appropriately
+  // update label2 appropriately
   SET_CONTROL_LABEL2(CONTROL_VALUE, m_rule.GetParameter());
   CGUIEditControl::INPUT_TYPE type = CGUIEditControl::INPUT_TYPE_TEXT;
   CDatabaseQueryRule::FIELD_TYPE fieldType = m_rule.GetFieldType(m_rule.m_field);
diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistRule.h b/xbmc/dialogs/GUIDialogSmartPlaylistRule.h
index b3b9356..d61c442 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistRule.h
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistRule.h
@@ -43,7 +43,7 @@ protected:
   void OnCancel();
   void UpdateButtons();
   void OnBrowse();
-
+  std::vector< std::pair<std::string, int> > GetValidOperators(const CSmartPlaylistRule& rule);
   CSmartPlaylistRule m_rule;
   bool m_cancelled;
   std::string m_type;
-- 
2.7.4


From 7f68e6732f63491b4ecdcc8b7854fac6b72a7f8b Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 6 Oct 2016 22:50:46 +0200
Subject: [PATCH 038/175] CUtil::MakeShortenPath() should return true if the
 given path is already short enough (fixes #16783)

---
 xbmc/Util.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/xbmc/Util.cpp b/xbmc/Util.cpp
index 161304a..86a0f50 100644
--- a/xbmc/Util.cpp
+++ b/xbmc/Util.cpp
@@ -1433,7 +1433,10 @@ bool CUtil::MakeShortenPath(std::string StrInput, std::string& StrOutput, size_t
 {
   size_t iStrInputSize = StrInput.size();
   if(iStrInputSize <= 0 || iTextMaxLength >= iStrInputSize)
-    return false;
+  {
+    StrOutput = StrInput;
+    return true;
+  }
 
   char cDelim = '\0';
   size_t nGreaterDelim, nPos;
-- 
2.7.4


From db56d51971d788a427c043ddf6804f1e1875f767 Mon Sep 17 00:00:00 2001
From: Balint Reczey <balint@balintreczey.hu>
Date: Fri, 7 Oct 2016 09:40:37 +0200
Subject: [PATCH 039/175] drop AsyncFileCopy from Makefile, too

---
 xbmc/utils/test/Makefile | 1 -
 1 file changed, 1 deletion(-)

diff --git a/xbmc/utils/test/Makefile b/xbmc/utils/test/Makefile
index a5e0a5f..496a8fb 100644
--- a/xbmc/utils/test/Makefile
+++ b/xbmc/utils/test/Makefile
@@ -2,7 +2,6 @@ SRCS=	\
 	TestAlarmClock.cpp \
 	TestAliasShortcutUtils.cpp \
 	TestArchive.cpp \
-	TestAsyncFileCopy.cpp \
 	TestBase64.cpp \
 	TestBitstreamStats.cpp \
 	TestCharsetConverter.cpp \
-- 
2.7.4


From 295c9da92447af5831f0d6a6367f5e1185cf6aaa Mon Sep 17 00:00:00 2001
From: Rechi <Rechi@users.noreply.github.com>
Date: Fri, 7 Oct 2016 14:07:39 +0200
Subject: [PATCH 040/175] add method
 CHTTPFileHandler::SetLastModifiedDate(const struct __stat64 *statBuffer)

---
 .../network/httprequesthandler/HTTPFileHandler.cpp | 26 ++++++++++++----------
 xbmc/network/httprequesthandler/HTTPFileHandler.h  |  3 ++-
 2 files changed, 16 insertions(+), 13 deletions(-)

diff --git a/xbmc/network/httprequesthandler/HTTPFileHandler.cpp b/xbmc/network/httprequesthandler/HTTPFileHandler.cpp
index 228e332..f35cc1d 100644
--- a/xbmc/network/httprequesthandler/HTTPFileHandler.cpp
+++ b/xbmc/network/httprequesthandler/HTTPFileHandler.cpp
@@ -20,7 +20,6 @@
 
 #include "system.h"
 #include "HTTPFileHandler.h"
-#include "filesystem/File.h"
 #include "utils/Mime.h"
 #include "utils/StringUtils.h"
 #include "utils/URIUtils.h"
@@ -89,17 +88,7 @@ void CHTTPFileHandler::SetFile(const std::string& file, int responseStatus)
     {
       struct __stat64 statBuffer;
       if (fileObj.Stat(&statBuffer) == 0)
-      {
-        struct tm *time;
-#ifdef HAVE_LOCALTIME_R
-        struct tm result = { };
-        time = localtime_r((time_t*)&statBuffer.st_mtime, &result);
-#else
-        time = localtime((time_t *)&statBuffer.st_mtime);
-#endif
-        if (time != NULL)
-          m_lastModified = *time;
-      }
+        SetLastModifiedDate(&statBuffer);
     }
   }
 
@@ -114,3 +103,16 @@ void CHTTPFileHandler::SetFile(const std::string& file, int responseStatus)
   if (!m_lastModified.IsValid())
     m_canBeCached = false;
 }
+
+void CHTTPFileHandler::SetLastModifiedDate(const struct __stat64 *statBuffer)
+{
+  struct tm *time;
+#ifdef HAVE_LOCALTIME_R
+  struct tm result = { };
+  time = localtime_r((time_t*)&statBuffer->st_mtime, &result);
+#else
+  time = localtime((time_t *)&statBuffer->st_mtime);
+#endif
+  if (time != NULL)
+    m_lastModified = *time;
+}
diff --git a/xbmc/network/httprequesthandler/HTTPFileHandler.h b/xbmc/network/httprequesthandler/HTTPFileHandler.h
index 9d7e8de..3b3840e 100644
--- a/xbmc/network/httprequesthandler/HTTPFileHandler.h
+++ b/xbmc/network/httprequesthandler/HTTPFileHandler.h
@@ -22,6 +22,7 @@
 #include <string>
 
 #include "XBDateTime.h"
+#include "filesystem/File.h"
 #include "network/httprequesthandler/IHTTPRequestHandler.h"
 
 class CHTTPFileHandler : public IHTTPRequestHandler
@@ -46,7 +47,7 @@ protected:
 
   void SetCanHandleRanges(bool canHandleRanges) { m_canHandleRanges = canHandleRanges; }
   void SetCanBeCached(bool canBeCached) { m_canBeCached = canBeCached; }
-  void SetLastModifiedDate(CDateTime lastModified) { m_lastModified = lastModified; }
+  void SetLastModifiedDate(const struct __stat64 *buffer);
 
 private:
   std::string m_url;
-- 
2.7.4


From 94dbb9dd64f72995f41e53f2e5aae0b6e771007e Mon Sep 17 00:00:00 2001
From: Rechi <Rechi@users.noreply.github.com>
Date: Fri, 7 Oct 2016 14:07:43 +0200
Subject: [PATCH 041/175] CHTTPImageHandler: add GetLastModifiedDate
 implementation

---
 xbmc/network/httprequesthandler/HTTPImageHandler.cpp | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/xbmc/network/httprequesthandler/HTTPImageHandler.cpp b/xbmc/network/httprequesthandler/HTTPImageHandler.cpp
index 6d0ac87..c5e572d 100644
--- a/xbmc/network/httprequesthandler/HTTPImageHandler.cpp
+++ b/xbmc/network/httprequesthandler/HTTPImageHandler.cpp
@@ -37,7 +37,15 @@ CHTTPImageHandler::CHTTPImageHandler(const HTTPRequest &request)
     XFILE::CImageFile imageFile;
     const CURL pathToUrl(file);
     if (imageFile.Exists(pathToUrl))
+    {
       responseStatus = MHD_HTTP_OK;
+      struct __stat64 statBuffer;
+      if (imageFile.Stat(pathToUrl, &statBuffer) == 0)
+      {
+        SetLastModifiedDate(&statBuffer);
+        SetCanBeCached(true);
+      }
+    }
     else
       responseStatus = MHD_HTTP_NOT_FOUND;
   }
-- 
2.7.4


From f8c9d54bc5722964a06cb2dff977428bd98e91f7 Mon Sep 17 00:00:00 2001
From: Rechi <Rechi@users.noreply.github.com>
Date: Fri, 7 Oct 2016 14:07:47 +0200
Subject: [PATCH 042/175] CHTTPImageHandler: add GetMaximumAgeForCaching (one
 week)

---
 xbmc/network/httprequesthandler/HTTPImageHandler.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/network/httprequesthandler/HTTPImageHandler.h b/xbmc/network/httprequesthandler/HTTPImageHandler.h
index ca36299..e14b642 100644
--- a/xbmc/network/httprequesthandler/HTTPImageHandler.h
+++ b/xbmc/network/httprequesthandler/HTTPImageHandler.h
@@ -33,6 +33,7 @@ public:
   virtual bool CanHandleRequest(const HTTPRequest &request);
 
   virtual int GetPriority() const { return 5; }
+  virtual int GetMaximumAgeForCaching() const { return 60 * 60 * 24 * 7; }
 
 protected:
   explicit CHTTPImageHandler(const HTTPRequest &request);
-- 
2.7.4


From 6ee9a6bc3b1ce864e788dd115ba0c7ba21d49f40 Mon Sep 17 00:00:00 2001
From: BigNoid <big.noid@kodi.tv>
Date: Fri, 7 Oct 2016 15:27:58 +0200
Subject: [PATCH 043/175] field and operator buttons from label2 to label

---
 xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp b/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
index 4de8063..04a4571 100644
--- a/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
+++ b/xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
@@ -493,14 +493,14 @@ void CGUIDialogSmartPlaylistRule::UpdateButtons()
 {
   if (m_rule.m_field == 0)
     m_rule.m_field = CSmartPlaylistRule::GetFields(m_type)[0];
-  SET_CONTROL_LABEL2(CONTROL_FIELD, CSmartPlaylistRule::GetLocalizedField(m_rule.m_field));
+  SET_CONTROL_LABEL(CONTROL_FIELD, CSmartPlaylistRule::GetLocalizedField(m_rule.m_field));
 
   CONTROL_ENABLE(CONTROL_VALUE);
   if (CSmartPlaylistRule::IsFieldBrowseable(m_rule.m_field))
     CONTROL_ENABLE(CONTROL_BROWSE);
   else
     CONTROL_DISABLE(CONTROL_BROWSE);
-  SET_CONTROL_LABEL2(CONTROL_OPERATOR, std::get<0>(OperatorLabel(m_rule.m_operator)));
+  SET_CONTROL_LABEL(CONTROL_OPERATOR, std::get<0>(OperatorLabel(m_rule.m_operator)));
 
   // update label2 appropriately
   SET_CONTROL_LABEL2(CONTROL_VALUE, m_rule.GetParameter());
-- 
2.7.4


From 8acfa1333b7ca86be3bde663bb4714b777071bc6 Mon Sep 17 00:00:00 2001
From: phil65 <philipptemminghoff@gmx.de>
Date: Fri, 7 Oct 2016 16:37:28 +0200
Subject: [PATCH 044/175] another sync, misc fixes / additions

---
 addons/skin.estuary/1080i/DialogAddonSettings.xml |   2 +-
 addons/skin.estuary/1080i/DialogContextMenu.xml   |  11 +-
 addons/skin.estuary/1080i/DialogNotification.xml  |   1 +
 addons/skin.estuary/1080i/DialogSelect.xml        |   1 +
 addons/skin.estuary/1080i/DialogVideoInfo.xml     |  16 +-
 addons/skin.estuary/1080i/Home.xml                | 114 ++++----
 addons/skin.estuary/1080i/MusicVisualisation.xml  |  16 +-
 addons/skin.estuary/1080i/MyVideoNav.xml          |  14 +-
 addons/skin.estuary/1080i/MyWeather.xml           |   6 +-
 addons/skin.estuary/1080i/PlayerControls.xml      |  24 +-
 addons/skin.estuary/1080i/Variables.xml           |   6 +-
 addons/skin.estuary/1080i/View_500_SmallThumb.xml | 315 ++--------------------
 addons/skin.estuary/1080i/View_501_Banner.xml     |  28 +-
 addons/skin.estuary/1080i/View_54_InfoWall.xml    |  88 +-----
 14 files changed, 178 insertions(+), 464 deletions(-)

diff --git a/addons/skin.estuary/1080i/DialogAddonSettings.xml b/addons/skin.estuary/1080i/DialogAddonSettings.xml
index a101b8e..7da9e61 100644
--- a/addons/skin.estuary/1080i/DialogAddonSettings.xml
+++ b/addons/skin.estuary/1080i/DialogAddonSettings.xml
@@ -47,7 +47,7 @@
 			<width>1060</width>
 			<height>680</height>
 			<onup>2</onup>
-			<ondown>9001</ondown>
+			<ondown>2</ondown>
 			<onleft>9</onleft>
 			<onright>9001</onright>
 		</control>
diff --git a/addons/skin.estuary/1080i/DialogContextMenu.xml b/addons/skin.estuary/1080i/DialogContextMenu.xml
index e902358..2ccf7b5 100644
--- a/addons/skin.estuary/1080i/DialogContextMenu.xml
+++ b/addons/skin.estuary/1080i/DialogContextMenu.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <window>
-	<defaultcontrol>1000</defaultcontrol>
+	<defaultcontrol>996</defaultcontrol>
 	<include>Animation_DialogPopupOpenClose</include>
 	<coordinates>
 		<left>0</left>
@@ -17,6 +17,15 @@
 			<animation effect="fade" start="100" end="0" time="200">WindowClose</animation>
 			<texture colordiffuse="B0FFFFFF">colors/black.png</texture>
 		</control>
+		<control type="button" id="22001">
+			<left>-1920</left>
+			<top>-1080</top>
+			<width>5760</width>
+			<height>3240</height>
+			<texturefocus></texturefocus>
+			<texturenofocus></texturenofocus>
+			<onclick>Action(close)</onclick>
+		</control>
 		<control type="image" id="999">
 			<description>background image</description>
 			<left>0</left>
diff --git a/addons/skin.estuary/1080i/DialogNotification.xml b/addons/skin.estuary/1080i/DialogNotification.xml
index 6c9563f..7769bf4 100644
--- a/addons/skin.estuary/1080i/DialogNotification.xml
+++ b/addons/skin.estuary/1080i/DialogNotification.xml
@@ -6,6 +6,7 @@
 			<depth>DepthMax</depth>
 			<top>945</top>
 			<left>640</left>
+			<animation effect="slide" end="600,-850" time="500" tween="sine" easing="inout" condition="Window.IsActive(fullscreenvideo)">conditional</animation>
 			<include>Animation_DialogPopupOpenClose</include>
 			<visible>String.IsEmpty(Window(Home).Property(script.cinemavision.running))</visible>
 			<control type="image">
diff --git a/addons/skin.estuary/1080i/DialogSelect.xml b/addons/skin.estuary/1080i/DialogSelect.xml
index 00a8aed..4f16919 100644
--- a/addons/skin.estuary/1080i/DialogSelect.xml
+++ b/addons/skin.estuary/1080i/DialogSelect.xml
@@ -115,6 +115,7 @@
 						<width>700</width>
 						<height>60</height>
 						<aligny>center</aligny>
+						<scroll>true</scroll>
 						<label>[B]$INFO[ListItem.Label][/B]</label>
 					</control>
 					<control type="textbox">
diff --git a/addons/skin.estuary/1080i/DialogVideoInfo.xml b/addons/skin.estuary/1080i/DialogVideoInfo.xml
index 22887aa..31234dc 100644
--- a/addons/skin.estuary/1080i/DialogVideoInfo.xml
+++ b/addons/skin.estuary/1080i/DialogVideoInfo.xml
@@ -51,7 +51,7 @@
 				</control>
 			</control>
 			<control type="group">
-				<top>184</top>
+				<top>154</top>
 				<left>70</left>
 				<visible>Stringcompare(ListItem.DBType,musicvideo)</visible>
 				<include>OpenClose_Left</include>
@@ -498,6 +498,20 @@
 				<animation effect="fade" start="100" end="0" time="200">WindowClose</animation>
 				<top>980</top>
 				<include>MediaFlags</include>
+				<control type="label">
+					<right>100</right>
+					<top>60</top>
+					<align>right</align>
+					<width>1400</width>
+					<height>44</height>
+					<font>font10_title</font>
+					<textcolor>77FFFFFF</textcolor>
+					<shadowcolor>text_shadow</shadowcolor>
+					<label>$INFO[ListItem.FileNameANdPath]</label>
+					<visible>Control.HasFocus(6)</visible>
+					<animation effect="fade" start="0" end="100" time="300">Visible</animation>
+					<animation effect="fade" start="100" end="0" time="200">Hidden</animation>
+				</control>
 				<control type="group">
 					<visible>Control.HasFocus(50)</visible>
 					<animation effect="fade" time="200">VisibleChange</animation>
diff --git a/addons/skin.estuary/1080i/Home.xml b/addons/skin.estuary/1080i/Home.xml
index 55983fa..e76aa77 100644
--- a/addons/skin.estuary/1080i/Home.xml
+++ b/addons/skin.estuary/1080i/Home.xml
@@ -587,6 +587,35 @@
 							<param name="widget_header" value="$LOCALIZE[19020]" />
 							<param name="visible" value="!System.HasPVRAddon"/>
 						</include>
+						<control type="grouplist">
+							<height>218</height>
+							<left>478</left>
+							<top>36</top>
+							<orientation>horizontal</orientation>
+							<visible>PVR.IsRecordingTV | PVR.HasNonRecordingTVTimer</visible>
+							<align>right</align>
+							<width>1360</width>
+							<control type="group">
+								<width>680</width>
+								<visible>PVR.IsRecordingTV</visible>
+								<include content="PVRWidget">
+									<param name="icon" value="$INFO[PVR.TVNowRecordingChannelIcon]" />
+									<param name="header" value="$LOCALIZE[19158]" />
+									<param name="label1" value="$INFO[PVR.TVNowRecordingDateTime,$LOCALIZE[19126] - ]" />
+									<param name="label2" value="$INFO[PVR.TVNowRecordingTitle][CR][COLOR=grey]$INFO[PVR.TVNowRecordingChannel][/COLOR]" />
+								</include>
+							</control>
+							<control type="group">
+								<visible>PVR.HasNonRecordingTVTimer</visible>
+								<width>680</width>
+								<include content="PVRWidget">
+									<param name="icon" value="$INFO[PVR.TVNextRecordingChannelIcon]" />
+									<param name="header" value="$LOCALIZE[19157]" />
+									<param name="label1" value="$INFO[PVR.TVNextRecordingDateTime,$LOCALIZE[19126] - ]" />
+									<param name="label2" value="$INFO[PVR.TVNextRecordingTitle][CR][COLOR=grey]$INFO[PVR.TVNextRecordingChannel][/COLOR]" />
+								</include>
+							</control>
+						</control>
 						<include content="ImageWidget">
 							<param name="image_path" value="special://skin/extras/home-images/tv.jpg"/>
 							<param name="text_label" value="$LOCALIZE[31143]" />
@@ -620,34 +649,6 @@
 							<param name="height" value="550"/>
 							<param name="visible" value="System.HasPVRAddon"/>
 						</include>
-						<control type="grouplist">
-							<height>218</height>
-							<left>478</left>
-							<top>36</top>
-							<orientation>horizontal</orientation>
-							<align>right</align>
-							<width>1360</width>
-							<control type="group">
-								<width>680</width>
-								<visible>PVR.IsRecordingTV</visible>
-								<include content="PVRWidget">
-									<param name="icon" value="$INFO[PVR.TVNowRecordingChannelIcon]" />
-									<param name="header" value="$LOCALIZE[19158]" />
-									<param name="label1" value="$INFO[PVR.TVNowRecordingDateTime,$LOCALIZE[19126] - ]" />
-									<param name="label2" value="$INFO[PVR.TVNowRecordingTitle][CR][COLOR=grey]$INFO[PVR.TVNowRecordingChannel][/COLOR]" />
-								</include>
-							</control>
-							<control type="group">
-								<visible>PVR.HasNonRecordingTVTimer</visible>
-								<width>680</width>
-								<include content="PVRWidget">
-									<param name="icon" value="$INFO[PVR.TVNextRecordingChannelIcon]" />
-									<param name="header" value="$LOCALIZE[19157]" />
-									<param name="label1" value="$INFO[PVR.TVNextRecordingDateTime,$LOCALIZE[19126] - ]" />
-									<param name="label2" value="$INFO[PVR.TVNextRecordingTitle][CR][COLOR=grey]$INFO[PVR.TVNextRecordingChannel][/COLOR]" />
-								</include>
-							</control>
-						</control>
 					</control>
 				</control>
 				<control type="group" id="13000">
@@ -697,6 +698,35 @@
 							<param name="widget_header" value="$LOCALIZE[19021]" />
 							<param name="visible" value="!System.HasPVRAddon"/>
 						</include>
+						<control type="grouplist">
+							<height>218</height>
+							<left>478</left>
+							<top>36</top>
+							<orientation>horizontal</orientation>
+							<align>right</align>
+							<width>1360</width>
+							<visible>PVR.IsRecordingRadio | PVR.HasNonRecordingRadioTimer</visible>
+							<control type="group">
+								<width>680</width>
+								<visible>PVR.IsRecordingRadio</visible>
+								<include content="PVRWidget">
+									<param name="icon" value="$INFO[PVR.RadioNowRecordingChannelIcon]" />
+									<param name="header" value="$LOCALIZE[19158]" />
+									<param name="label1" value="$INFO[PVR.RadioNowRecordingDateTime,$LOCALIZE[19126] - ]" />
+									<param name="label2" value="$INFO[PVR.RadioNowRecordingTitle][CR][COLOR=grey]$INFO[PVR.RadioNowRecordingChannel][/COLOR]" />
+								</include>
+							</control>
+							<control type="group">
+								<visible>PVR.HasNonRecordingRadioTimer</visible>
+								<width>680</width>
+								<include content="PVRWidget">
+									<param name="icon" value="$INFO[PVR.RadioNextRecordingChannelIcon]" />
+									<param name="header" value="$LOCALIZE[19157]" />
+									<param name="label1" value="$INFO[PVR.RadioNextRecordingDateTime,$LOCALIZE[19126] - ]" />
+									<param name="label2" value="$INFO[PVR.RadioNextRecordingTitle][CR][COLOR=grey]$INFO[PVR.RadioNextRecordingChannel][/COLOR]" />
+								</include>
+							</control>
+						</control>
 						<include content="ImageWidget">
 							<param name="image_path" value="special://skin/extras/home-images/tv.jpg"/>
 							<param name="text_label" value="$LOCALIZE[31143]" />
@@ -730,34 +760,6 @@
 							<param name="height" value="550"/>
 							<param name="visible" value="System.HasPVRAddon"/>
 						</include>
-						<control type="grouplist">
-							<height>218</height>
-							<left>478</left>
-							<top>36</top>
-							<orientation>horizontal</orientation>
-							<align>right</align>
-							<width>1360</width>
-							<control type="group">
-								<width>680</width>
-								<visible>PVR.IsRecordingRadio</visible>
-								<include content="PVRWidget">
-									<param name="icon" value="$INFO[PVR.RadioNowRecordingChannelIcon]" />
-									<param name="header" value="$LOCALIZE[19158]" />
-									<param name="label1" value="$INFO[PVR.RadioNowRecordingDateTime,$LOCALIZE[19126] - ]" />
-									<param name="label2" value="$INFO[PVR.RadioNowRecordingTitle][CR][COLOR=grey]$INFO[PVR.RadioNowRecordingChannel][/COLOR]" />
-								</include>
-							</control>
-							<control type="group">
-								<visible>PVR.HasNonRecordingRadioTimer</visible>
-								<width>680</width>
-								<include content="PVRWidget">
-									<param name="icon" value="$INFO[PVR.RadioNextRecordingChannelIcon]" />
-									<param name="header" value="$LOCALIZE[19157]" />
-									<param name="label1" value="$INFO[PVR.RadioNextRecordingDateTime,$LOCALIZE[19126] - ]" />
-									<param name="label2" value="$INFO[PVR.RadioNextRecordingTitle][CR][COLOR=grey]$INFO[PVR.RadioNextRecordingChannel][/COLOR]" />
-								</include>
-							</control>
-						</control>
 					</control>
 				</control>
 				<control type="group" id="15000">
diff --git a/addons/skin.estuary/1080i/MusicVisualisation.xml b/addons/skin.estuary/1080i/MusicVisualisation.xml
index 27254ea..9656847 100644
--- a/addons/skin.estuary/1080i/MusicVisualisation.xml
+++ b/addons/skin.estuary/1080i/MusicVisualisation.xml
@@ -95,7 +95,7 @@
 				<bordertexture colordiffuse="border_alpha">colors/black.png</bordertexture>
 				<bordersize>4</bordersize>
 				<visible>!String.IsEmpty(Player.Art(fanart))</visible>
-				<visible>![Window.IsActive(VisualisationSettings) | Window.IsActive(VisualisationPresetList)]</visible>
+				<visible>!Window.IsActive(VisualisationPresetList)</visible>
 				<animation effect="fade" start="0" end="100" delay="400" time="200">Visible</animation>
 				<animation effect="fade" end="0" time="200">Hidden</animation>
 			</control>
@@ -149,6 +149,20 @@
 				<animation effect="fade" start="0" end="100" delay="400" time="200">WindowOpen</animation>
 				<animation effect="fade" end="0" time="200">WindowClose</animation>
 			</control>
+			<control type="label">
+				<left>1450</left>
+				<top>770</top>
+				<width>400</width>
+				<height>45</height>
+				<align>right</align>
+				<aligny>bottom</aligny>
+				<label>$VAR[SeekLabel]</label>
+				<font>font30_title</font>
+				<shadowcolor>black</shadowcolor>
+				<textcolor>grey</textcolor>
+				<animation effect="fade" start="0" end="100" delay="400" time="200">WindowOpen</animation>
+				<animation effect="fade" end="0" time="200">WindowClose</animation>
+			</control>
 			<control type="progress">
 				<animation effect="fade" end="0" time="200">WindowClose</animation>
 				<left>30</left>
diff --git a/addons/skin.estuary/1080i/MyVideoNav.xml b/addons/skin.estuary/1080i/MyVideoNav.xml
index d632a53..b691503 100644
--- a/addons/skin.estuary/1080i/MyVideoNav.xml
+++ b/addons/skin.estuary/1080i/MyVideoNav.xml
@@ -50,17 +50,7 @@
 					<height>338</height>
 					<font>font13_title</font>
 					<label>$INFO[ListItem.Label]</label>
-					<visible>Control.IsVisible(54) | ListItem.IsCollection</visible>
-				</control>
-				<control type="textbox">
-					<right>130</right>
-					<top>245</top>
-					<width>429</width>
-					<height>338</height>
-					<font>font12</font>
-					<visible>Control.IsVisible(54)</visible>
-					<label>$INFO[ListItem.Plot]</label>
-					<autoscroll delay="10000" time="3000" repeat="10000">Skin.HasSetting(autoscroll)</autoscroll>
+					<visible>ListItem.IsCollection</visible>
 				</control>
 				<control type="textbox">
 					<right>130</right>
@@ -68,7 +58,7 @@
 					<width>429</width>
 					<height>398</height>
 					<font>font12</font>
-					<visible>!Control.IsVisible(54)</visible>
+					<visible>!ListItem.IsCollection</visible>
 					<label>$INFO[ListItem.Tagline,[B],[/B][CR]]$INFO[ListItem.Plot]</label>
 					<autoscroll delay="10000" time="3000" repeat="10000">Skin.HasSetting(autoscroll)</autoscroll>
 				</control>
diff --git a/addons/skin.estuary/1080i/MyWeather.xml b/addons/skin.estuary/1080i/MyWeather.xml
index 8765895..49748ab 100644
--- a/addons/skin.estuary/1080i/MyWeather.xml
+++ b/addons/skin.estuary/1080i/MyWeather.xml
@@ -115,7 +115,7 @@
 			<visible>Container(300).HasFocus(3)</visible>
 			<include>Visible_Right_Delayed</include>
 			<control type="image">
-				<left>90</left>
+				<left>80</left>
 				<top>138</top>
 				<width>1370</width>
 				<height>796</height>
@@ -306,7 +306,7 @@
 			<visible>Container(300).HasFocus(2)</visible>
 			<include>Visible_Right_Delayed</include>
 			<control type="image">
-				<left>90</left>
+				<left>80</left>
 				<top>138</top>
 				<width>1370</width>
 				<height>796</height>
@@ -562,7 +562,7 @@
 			<include>OpenClose_Right</include>
 			<visible>Container(300).HasFocus(4)</visible>
 			<include>Visible_Right_Delayed</include>
-			<left>520</left>
+			<left>480</left>
 			<top>120</top>
 			<control type="image">
 				<top>20</top>
diff --git a/addons/skin.estuary/1080i/PlayerControls.xml b/addons/skin.estuary/1080i/PlayerControls.xml
index f78ced3..f7fb457 100644
--- a/addons/skin.estuary/1080i/PlayerControls.xml
+++ b/addons/skin.estuary/1080i/PlayerControls.xml
@@ -95,31 +95,31 @@
 			</control>
 			<control type="slider">
 				<left>0</left>
-				<top>-20</top>
+				<top>-10</top>
 				<width>800</width>
-				<height>50</height>
+				<height>30</height>
 				<onup>8010</onup>
 				<ondown>650</ondown>
-				<texturesliderbar colordiffuse="00FFFFFF">osd/progress/nub_bar.png</texturesliderbar>
-				<textureslidernib>osd/progress/nub_bar.png</textureslidernib>
-				<textureslidernibfocus colordiffuse="button_focus">osd/progress/nub_bar.png</textureslidernibfocus>
+				<texturesliderbar colordiffuse="00FFFFFF">osd/progress/nub_leftright.png</texturesliderbar>
+				<textureslidernib>osd/progress/nub_leftright.png</textureslidernib>
+				<textureslidernibfocus colordiffuse="button_focus">osd/progress/nub_leftright.png</textureslidernibfocus>
 				<info>Player.Progress</info>
 				<action>seek</action>
-				<visible>!Control.HasFocus(87)</visible>
+				<visible>!Control.HasFocus(87) + Player.SeekEnabled</visible>
 			</control>
 			<control type="slider">
 				<left>0</left>
-				<top>-20</top>
+				<top>-10</top>
 				<width>800</width>
-				<height>50</height>
+				<height>30</height>
 				<onup>8010</onup>
 				<ondown>650</ondown>
-				<texturesliderbar colordiffuse="00FFFFFF">osd/progress/nub_bar.png</texturesliderbar>
-				<textureslidernib colordiffuse="button_focus">osd/progress/nub_bar.png</textureslidernib>
-				<textureslidernibfocus colordiffuse="button_focus">osd/progress/nub_bar.png</textureslidernibfocus>
+				<texturesliderbar colordiffuse="00FFFFFF">osd/progress/nub_leftright.png</texturesliderbar>
+				<textureslidernib colordiffuse="button_focus">osd/progress/nub_leftright.png</textureslidernib>
+				<textureslidernibfocus colordiffuse="button_focus">osd/progress/nub_leftright.png</textureslidernibfocus>
 				<info>Player.Progress</info>
 				<action>seek</action>
-				<visible>Control.HasFocus(87)</visible>
+				<visible>Control.HasFocus(87) + Player.SeekEnabled</visible>
 			</control>
 		</control>
 		<control type="grouplist" id="201">
diff --git a/addons/skin.estuary/1080i/Variables.xml b/addons/skin.estuary/1080i/Variables.xml
index 3d8a5b2..943ed24 100644
--- a/addons/skin.estuary/1080i/Variables.xml
+++ b/addons/skin.estuary/1080i/Variables.xml
@@ -74,6 +74,10 @@
 		<value condition="ListItem.IsFolder + String.IsEmpty(ListItem.Thumb)">DefaultFolderSquare.png</value>
 		<value>$INFO[ListItem.Thumb]</value>
 	</variable>
+	<variable name="InfoWallThumbVar">
+		<value condition="!String.IsEmpty(Listitem.Art(poster))">$INFO[Listitem.Art(poster)]</value>
+		<value>$INFO[ListItem.Icon]</value>
+	</variable>
 	<variable name="IconWallThumbVar">
 		<value condition="Container.Content(studios)">$INFO[ListItem.Label,resource://resource.images.studios.white/,.png]</value>
 		<value condition="!IsEmpty(ListItem.Thumb)">$INFO[ListItem.Thumb]</value>
@@ -298,9 +302,9 @@
 		<value condition="Skin.HasSetting(no_fanart)">$VAR[GlobalFanartVar]</value>
 		<value condition="Window.IsActive(musicinformation) | Window.IsActive(movieinformation) | Window.IsActive(addoninformation) | Window.IsActive(pvrguideinfo) | Window.IsActive(pvrrecordinginfo) | Window.IsActive(pictureinfo) | Window.IsVisible(script-script.extendedinfo-DialogVideoInfo.xml) | Window.IsVisible(script-script.extendedinfo-DialogInfo.xml) | Window.IsVisible(script-script.extendedinfo-VideoList.xml)">$INFO[Window(home).Property(infobackground)]</value>
 		<value condition="Window.IsActive(pictures) + String.IsEmpty(ListItem.Art(fanart))">$INFO[ListItem.FolderPath]</value>
+		<value condition="!String.IsEmpty(ListItem.Art(fanart))">$INFO[ListItem.Art(fanart)]</value>
 		<value condition="!String.IsEmpty(Container.Art(tvshow.fanart))">$INFO[Container.Art(tvshow.fanart)]</value>
 		<value condition="!String.IsEmpty(Container.Art(artist.fanart))">$INFO[Container.Art(artist.fanart)]</value>
-		<value condition="!String.IsEmpty(ListItem.Art(fanart))">$INFO[ListItem.Art(fanart)]</value>
 		<value>$INFO[Container.Art(fanart)]</value>
 	</variable>
 	<variable name="WeatherFanartVar">
diff --git a/addons/skin.estuary/1080i/View_500_SmallThumb.xml b/addons/skin.estuary/1080i/View_500_SmallThumb.xml
index 3ef7615..a628882 100644
--- a/addons/skin.estuary/1080i/View_500_SmallThumb.xml
+++ b/addons/skin.estuary/1080i/View_500_SmallThumb.xml
@@ -1,29 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <includes>
-	<include name="SmallThumbInfoFlag">
-		<control type="group">
-			<top>$PARAM[posy]</top>
-			<control type="image">
-				<top>0</top>
-				<right>41</right>
-				<width>70</width>
-				<height>32</height>
-				<fadetime>300</fadetime>
-				<aspectratio align="center">keep</aspectratio>
-				<texture>$PARAM[icon]</texture>
-			</control>
-			<control type="label">
-				<right>41</right>
-				<top>35</top>
-				<width>70</width>
-				<height>32</height>
-				<align>center</align>
-				<font>font10</font>
-				<selectedcolor>white</selectedcolor>
-				<label fallback="">$INFO[$PARAM[infolabel]]</label>
-			</control>
-		</control>
-	</include>
 	<include name="View_500_SmallThumb">
 		<include content="UpDownArrows">
 			<param name="container_id" value="500" />
@@ -48,281 +24,24 @@
 				<preloaditems>2</preloaditems>
 				<pagecontrol>531</pagecontrol>
 				<scrolltime tween="cubic" easing="out">500</scrolltime>
-				<visible>Container.Content(movies) | Container.Content(sets) | Container.Content(tvshows) | Container.Content(seasons) | Container.Content(episodes) | Container.Content(artists) | Container.Content(albums) | Container.Content(musicvideos) | Container.Content(addons)</visible>
-				<itemlayout height="360" width="300" condition="Container.Content(movies) | Container.Content(sets) | Container.Content(tvshows) | Container.Content(seasons)">
-					<control type="image">
-						<left>0</left>
-						<top>-1</top>
-						<width>256</width>
-						<height>362</height>
-						<texture fallback="DefaultVideo.png" background="true">$VAR[ListPosterVar]</texture>
-						<bordertexture border="20">overlays/shadow.png</bordertexture>
-						<bordersize>20</bordersize>
-						<animation effect="slide" end="-15,0" time="0" condition="true">Conditional</animation>
-					</control>
+				<visible>Container.Content(movies) | Container.Content(sets) | Container.Content(tvshows) | Container.Content(seasons) | Container.Content(episodes) | Container.Content(artists) | Container.Content(albums) | Container.Content(musicvideos) | Container.Content(addons) | Container.Content(images)</visible>
+				<itemlayout height="360" width="442" condition="Container.Content(movies) | Container.Content(sets) | Container.Content(tvshows) | Container.Content(seasons) | Container.Content(episodes) | Container.Content(images)">
 					<control type="group">
-						<left>170</left>
-						<top>20</top>
-						<include>UserRatingCircle</include>
+						<include>InfoWallPictureLayout</include>
 					</control>
 				</itemlayout>
-				<focusedlayout height="360" width="300" condition="Container.Content(movies) | Container.Content(sets) | Container.Content(tvshows) | Container.Content(seasons)">
-					<control type="group">
-						<animation effect="slide" start="0,0" end="-40,0" time="300">Focus</animation>
-						<animation effect="slide" start="-40,0" end="0,0" time="125">UnFocus</animation>
-						<control type="image">
-							<left>1</left>
-							<top>15</top>
-							<width>220</width>
-							<height>330</height>
-							<texture border="2" fallback="DefaultVideo.png" background="true">$VAR[ListPosterVar]</texture>
-							<bordertexture colordiffuse="border_alpha">colors/black.png</bordertexture>
-							<bordersize>4</bordersize>
-						</control>
+				<focusedlayout height="360" width="442" condition="Container.Content(movies) | Container.Content(sets) | Container.Content(tvshows) | Container.Content(seasons) | Container.Content(episodes) | Container.Content(images)">
 						<control type="group">
-							<left>170</left>
-							<top>20</top>
-							<include>UserRatingCircle</include>
-						</control>
-					</control>
-					<control type="group">
-						<top>15</top>
-						<animation type="Focus">
-							<effect type="slide" start="0,0" end="-40,0" time="300" />
-							<effect type="fade" start="0" end="100" time="300" />
-						</animation>
-						<animation effect="fade" start="100" end="0" time="0">UnFocus</animation>
-						<control type="image">
-							<left>1</left>
-							<width>220</width>
-							<height>330</height>
-							<texture border="8" colordiffuse="button_focus">buttons/thumbnail_focused.png</texture>
-						</control>
-						<control type="image">
-							<left>5</left>
-							<top>260</top>
-							<width>212</width>
-							<height>66</height>
-							<texture>colors/black.png</texture>
-							<animation effect="fade" start="0" end="70" time="50">Focus</animation>
-						</control>
-						<control type="textbox">
-							<left>15</left>
-							<top>260</top>
-							<width>192</width>
-							<height>65</height>
-							<font>font10</font>
-							<align>center</align>
-							<aligny>center</aligny>
-							<label>$INFO[ListItem.Label]</label>
-						</control>
-					</control>
-					<control type="image">
-						<top>15</top>
-						<right>42</right>
-						<width>70</width>
-						<height>330</height>
-						<fadetime>300</fadetime>
-						<texture colordiffuse="button_focus">colors/white.png</texture>
-						<animation effect="zoom" start="0,100" end="100,100" time="250" center="auto">Focus</animation>
-						<animation effect="zoom" start="100,100" end="0,100" time="125" center="auto" delay="50">UnFocus</animation>
-					</control>
-					<control type="group">
-						<top>15</top>
-						<animation effect="fade" start="0" end="100" time="200" delay="250">Focus</animation>
-						<animation effect="fade" start="100" end="0" time="50">UnFocus</animation>
-						<include content="SmallThumbInfoFlag">
-							<param name="icon" value="lists/rating.png" />
-							<param name="infolabel" value="ListItem.Rating" />
-							<param name="posy" value="20" />
-						</include>
-						<include content="SmallThumbInfoFlag">
-							<param name="icon" value="lists/year.png" />
-							<param name="infolabel" value="ListItem.Year" />
-							<param name="posy" value="140" />
-						</include>
-						<control type="image">
-							<right>52</right>
-							<top>260</top>
-							<width>48</width>
-							<height>48</height>
-							<texture>$VAR[ListWatchedIconVar]</texture>
-						</control>
-					</control>
-				</focusedlayout>
-				<itemlayout height="360" width="450" condition="Container.content(episodes)">
-					<control type="image">
-						<left>-10</left>
-						<top>-2</top>
-						<width>400</width>
-						<height>362</height>
-						<texture border="40">buttons/button-nofo.png</texture>
-					</control>
-					<control type="image">
-						<left>11</left>
-						<top>19</top>
-						<width>356</width>
-						<height>230</height>
-						<texture fallback="DefaultVideo.png" background="true">$VAR[ListInfoBoxImageVar]</texture>
-						<aspectratio>scale</aspectratio>
-					</control>
-					<control type="label">
-						<left>21</left>
-						<top>270</top>
-						<width>336</width>
-						<height>20</height>
-						<font>font30_title</font>
-						<selectedcolor>white</selectedcolor>
-						<align>center</align>
-						<aligny>center</aligny>
-						<label>$INFO[ListItem.Season]$INFO[ListItem.Episode,x]</label>
-					</control>
-					<control type="label">
-						<left>21</left>
-						<top>309</top>
-						<width>336</width>
-						<height>20</height>
-						<font>font12</font>
-						<selectedcolor>white</selectedcolor>
-						<align>center</align>
-						<aligny>center</aligny>
-						<label>$VAR[SongTitleVar]</label>
-					</control>
-					<control type="group">
-						<visible>!String.IsEmpty(ListItem.label2)</visible>
-						<visible>!String.IsEqual(Container.SortMethod,$LOCALIZE[38018]) + !String.IsEqual(Container.SortMethod,$LOCALIZE[20359]) + !String.IsEqual(Container.SortMethod,$LOCALIZE[551])</visible>
+						<animation effect="zoom" start="100" end="105" time="200" tween="sine" easing="inout" center="222,180">Focus</animation>
+						<animation effect="zoom" start="105" end="100" time="200" tween="sine" easing="inout" center="222,180">UnFocus</animation>
+						<include>InfoWallPictureLayout</include>
 						<control type="image">
-							<left>11</left>
-							<top>19</top>
-							<width>356</width>
-							<height>32</height>
-							<texture colordiffuse="B0FFFFFF">colors/black.png</texture>
-						</control>
-						<control type="label">
 							<left>15</left>
-							<top>20</top>
-							<width>352</width>
-							<height>25</height>
-							<font>font12</font>
-							<selectedcolor>button_focus</selectedcolor>
-							<textcolor>button_focus</textcolor>
-							<aligny>center</aligny>
-							<label fallback="">$INFO[ListItem.Label2]</label>
-						</control>
-					</control>
-					<control type="group">
-						<left>330</left>
-						<top>15</top>
-						<include>UserRatingCircle</include>
-					</control>
-				</itemlayout>
-				<focusedlayout height="360" width="450" condition="Container.content(episodes)">
-					<control type="group">
-						<animation effect="slide" start="0,0" end="-40,0" time="300">Focus</animation>
-						<animation effect="slide" start="-40,0" end="0,0" time="125">UnFocus</animation>
-						<control type="image">
-							<left>-10</left>
-							<top>-2</top>
-							<width>400</width>
-							<height>362</height>
-							<texture border="40">buttons/button-nofo.png</texture>
-						</control>
-						<control type="image">
-							<left>11</left>
-							<top>19</top>
-							<width>356</width>
-							<height>230</height>
-							<texture border="2" fallback="DefaultVideo.png" background="true">$VAR[ListInfoBoxImageVar]</texture>
-							<aspectratio>scale</aspectratio>
-						</control>
-						<control type="label">
-							<left>21</left>
-							<top>270</top>
-							<width>336</width>
-							<height>20</height>
-							<font>font30_title</font>
-							<selectedcolor>white</selectedcolor>
-							<align>center</align>
-							<aligny>center</aligny>
-							<label>$INFO[ListItem.Season]$INFO[ListItem.Episode,x]</label>
-						</control>
-						<control type="label">
-							<left>21</left>
-							<top>309</top>
-							<width>336</width>
-							<height>20</height>
-							<font>font12</font>
-							<selectedcolor>white</selectedcolor>
-							<align>center</align>
-							<aligny>center</aligny>
-							<label>$VAR[SongTitleVar]</label>
-						</control>
-						<control type="group">
-							<visible>!String.IsEmpty(ListItem.label2)</visible>
-							<visible>!String.IsEqual(Container.SortMethod,$LOCALIZE[38018]) + !String.IsEqual(Container.SortMethod,$LOCALIZE[20359]) + !String.IsEqual(Container.SortMethod,$LOCALIZE[551])</visible>
-							<control type="image">
-								<left>11</left>
-								<top>19</top>
-								<width>356</width>
-								<height>32</height>
-								<texture colordiffuse="B0FFFFFF">colors/black.png</texture>
-							</control>
-							<control type="label">
-								<left>15</left>
-								<top>20</top>
-								<width>352</width>
-								<height>25</height>
-								<font>font12</font>
-								<selectedcolor>button_focus</selectedcolor>
-								<textcolor>button_focus</textcolor>
-								<aligny>center</aligny>
-								<label fallback="">$INFO[ListItem.Label2]</label>
-							</control>
-						</control>
-						<control type="group">
-							<left>330</left>
-							<top>15</top>
-							<include>UserRatingCircle</include>
-						</control>
-						<control type="image">
-							<left>4</left>
-							<top>11</top>
-							<width>370</width>
-							<height>333</height>
+							<top>5</top>
+							<width>368</width>
+							<height>348</height>
 							<texture border="8" colordiffuse="button_focus">buttons/thumbnail_focused.png</texture>
-						</control>
-					</control>
-					<control type="image">
-						<right>32</right>
-						<top>12</top>
-						<width>70</width>
-						<height>330</height>
-						<fadetime>300</fadetime>
-						<texture colordiffuse="button_focus">colors/white.png</texture>
-						<animation effect="zoom" start="0,100" end="100,100" time="250" center="auto">Focus</animation>
-						<animation effect="zoom" start="100,100" end="0,100" time="125" center="auto" delay="50">UnFocus</animation>
-					</control>
-					<control type="group">
-						<top>12</top>
-						<right>-10</right>
-						<animation effect="fade" start="0" end="100" time="200" delay="250">Focus</animation>
-						<animation effect="fade" start="100" end="0" time="50">UnFocus</animation>
-						<include content="SmallThumbInfoFlag">
-							<param name="icon" value="lists/rating.png" />
-							<param name="infolabel" value="ListItem.Rating" />
-							<param name="posy" value="20" />
-						</include>
-						<include content="SmallThumbInfoFlag">
-							<param name="icon" value="lists/year.png" />
-							<param name="infolabel" value="ListItem.Year" />
-							<param name="posy" value="140" />
-						</include>
-						<control type="image">
-							<top>260</top>
-							<right>52</right>
-							<width>48</width>
-							<height>48</height>
-							<texture>$VAR[ListWatchedIconVar]</texture>
+							<animation effect="fade" start="100" end="0" time="200">Unfocus</animation>
 						</control>
 					</control>
 				</focusedlayout>
@@ -355,16 +74,16 @@
 				</itemlayout>
 				<focusedlayout height="360" width="350" condition="Container.Content(addons)">
 					<control type="group">
-						<animation effect="zoom" start="100" end="105" time="200" tween="sine" easing="inout" center="160,180">Focus</animation>
-						<animation effect="zoom" start="105" end="100" time="200" tween="sine" easing="inout" center="160,180">UnFocus</animation>
+						<animation effect="zoom" start="100" end="107" time="200" tween="sine" easing="inout" center="160,180">Focus</animation>
+						<animation effect="zoom" start="107" end="100" time="200" tween="sine" easing="inout" center="160,180">UnFocus</animation>
 						<include content="InfoWallMusicLayout">
 							<param name="fallback_image" value="DefaultAddon.png" />
 						</include>
 						<control type="image">
-							<left>15</left>
-							<top>5</top>
-							<width>288</width>
-							<height>348</height>
+							<left>17</left>
+							<top>8</top>
+							<width>286</width>
+							<height>344</height>
 							<texture border="8" colordiffuse="button_focus">buttons/thumbnail_focused.png</texture>
 							<animation effect="fade" start="100" end="0" time="200">Unfocus</animation>
 						</control>
diff --git a/addons/skin.estuary/1080i/View_501_Banner.xml b/addons/skin.estuary/1080i/View_501_Banner.xml
index 0393842..b242982 100644
--- a/addons/skin.estuary/1080i/View_501_Banner.xml
+++ b/addons/skin.estuary/1080i/View_501_Banner.xml
@@ -1,5 +1,29 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <includes>
+	<include name="BannerInfoFlag">
+		<control type="group">
+			<top>$PARAM[posy]</top>
+			<control type="image">
+				<top>0</top>
+				<right>41</right>
+				<width>70</width>
+				<height>32</height>
+				<fadetime>300</fadetime>
+				<aspectratio align="center">keep</aspectratio>
+				<texture>$PARAM[icon]</texture>
+			</control>
+			<control type="label">
+				<right>41</right>
+				<top>35</top>
+				<width>70</width>
+				<height>32</height>
+				<align>center</align>
+				<font>font10</font>
+				<selectedcolor>white</selectedcolor>
+				<label fallback="">$INFO[$PARAM[infolabel]]</label>
+			</control>
+		</control>
+	</include>
 	<include name="View_501_Banner">
 		<include content="UpDownArrows">
 			<param name="container_id" value="501" />
@@ -156,12 +180,12 @@
 						<animation effect="fade" start="100" end="0" time="50">UnFocus</animation>
 						<top>13</top>
 						<right>0</right>
-						<include content="SmallThumbInfoFlag">
+						<include content="BannerInfoFlag">
 							<param name="icon" value="lists/rating.png" />
 							<param name="infolabel" value="ListItem.Rating" />
 							<param name="posy" value="5" />
 						</include>
-						<include content="SmallThumbInfoFlag">
+						<include content="BannerInfoFlag">
 							<param name="icon" value="lists/year.png" />
 							<param name="infolabel" value="ListItem.Year" />
 							<param name="posy" value="84" />
diff --git a/addons/skin.estuary/1080i/View_54_InfoWall.xml b/addons/skin.estuary/1080i/View_54_InfoWall.xml
index d41cf0e..17b3775 100644
--- a/addons/skin.estuary/1080i/View_54_InfoWall.xml
+++ b/addons/skin.estuary/1080i/View_54_InfoWall.xml
@@ -12,7 +12,7 @@
 			<top>18</top>
 			<width>350</width>
 			<height>280</height>
-			<texture border="2" fallback="DefaultFolderSquare.png" background="true">$VAR[ShiftThumbVar]</texture>
+			<texture border="2" background="true">$VAR[InfoWallThumbVar]</texture>
 			<aspectratio>keep</aspectratio>
 			<bordertexture colordiffuse="border_alpha">colors/black.png</bordertexture>
 			<bordersize>4</bordersize>
@@ -35,6 +35,11 @@
 			<aligny>center</aligny>
 			<label>$INFO[ListItem.Label]</label>
 		</control>
+		<control type="group">
+			<left>320</left>
+			<top>20</top>
+			<include>UserRatingCircle</include>
+		</control>
 	</include>
 	<include name="InfoWallMusicLayout">
 		<param name="fallback_image">DefaultFolder.png</param>
@@ -50,7 +55,7 @@
 				<top>21</top>
 				<width>250</width>
 				<height>250</height>
-				<texture border="2" fallback="$PARAM[fallback_image]" background="true">$VAR[ShiftThumbVar]</texture>
+				<texture border="2" fallback="$PARAM[fallback_image]" background="true">$VAR[InfoWallThumbVar]</texture>
 				<aspectratio>keep</aspectratio>
 				<bordertexture colordiffuse="border_alpha">colors/black.png</bordertexture>
 				<bordersize>4</bordersize>
@@ -112,80 +117,11 @@
 				<preloaditems>2</preloaditems>
 				<pagecontrol>533</pagecontrol>
 				<scrolltime tween="cubic" easing="out">500</scrolltime>
-				<visible>Container.Content(artists) | Container.Content(albums) | Container.Content(sets) | Container.Content(movies) | Container.Content(tvshows) | Container.Content(seasons) | Container.Content(musicvideos) | Container.Content(images)</visible>
-				<itemlayout height="360" width="240" condition="Container.Content(sets) | Container.Content(movies) | Container.Content(tvshows) | Container.Content(seasons)">
-					<control type="image">
-						<left>-5</left>
-						<top>0</top>
-						<width>259</width>
-						<height>364</height>
-						<texture fallback="DefaultVideo.png" background="true">$VAR[ListPosterVar]</texture>
-						<bordertexture border="20">overlays/shadow.png</bordertexture>
-						<bordersize>20</bordersize>
-					</control>
-					<control type="textbox">
-						<left>20</left>
-						<top>220</top>
-						<width>209</width>
-						<height>100</height>
-						<label>$INFO[ListItem.Label]</label>
-						<font>font12_title</font>
-						<shadowcolor>text_shadow</shadowcolor>
-						<align>center</align>
-						<aligny>center</aligny>
-						<visible>String.IsEmpty(ListItem.Art(poster)) + !Listitem.IsParentFolder</visible>
-					</control>
-					<control type="group">
-						<left>179</left>
-						<top>30</top>
-						<include>UserRatingCircle</include>
-					</control>
-				</itemlayout>
-				<focusedlayout height="360" width="240" condition="Container.Content(sets) | Container.Content(movies) | Container.Content(tvshows) | Container.Content(seasons)">
-					<control type="group">
-						<animation effect="zoom" start="100" end="105" time="200" tween="sine" easing="inout" center="124,179">Focus</animation>
-						<animation effect="zoom" start="105" end="100" time="200" tween="sine" easing="inout" center="124,179">UnFocus</animation>
-						<control type="image">
-							<left>-5</left>
-							<top>0</top>
-							<width>259</width>
-							<height>364</height>
-							<texture fallback="DefaultVideo.png" background="true">$VAR[ListPosterVar]</texture>
-							<bordertexture border="20">overlays/shadow.png</bordertexture>
-							<bordersize>20</bordersize>
-						</control>
-						<control type="textbox">
-							<left>20</left>
-							<top>220</top>
-							<width>209</width>
-							<height>100</height>
-							<label>$INFO[ListItem.Label]</label>
-							<font>font12_title</font>
-							<shadowcolor>text_shadow</shadowcolor>
-							<align>center</align>
-							<aligny>center</aligny>
-							<visible>String.IsEmpty(ListItem.Art(poster)) + !Listitem.IsParentFolder</visible>
-						</control>
-						<control type="group">
-							<left>179</left>
-							<top>30</top>
-							<include>UserRatingCircle</include>
-						</control>
-						<control type="image">
-							<left>15</left>
-							<top>20</top>
-							<width>219</width>
-							<height>325</height>
-							<texture border="8" colordiffuse="button_focus">buttons/thumbnail_focused.png</texture>
-							<animation effect="fade" start="0" end="100" time="200" tween="sine">Focus</animation>
-							<animation effect="fade" start="100" end="0" time="200" tween="sine">UnFocus</animation>
-						</control>
-					</control>
-				</focusedlayout>
-				<itemlayout height="360" width="300" condition="Container.Content(artists) | Container.Content(albums) | Container.Content(musicvideos)">
+				<visible>Container.Content(artists) | Container.Content(albums) | Container.Content(sets) | Container.Content(movies) | Container.Content(tvshows) | Container.Content(seasons) | Container.Content(episodes) | Container.Content(musicvideos) | Container.Content(images)</visible>
+				<itemlayout height="360" width="300" condition="Container.Content(artists) | Container.Content(albums) | Container.Content(musicvideos) | Container.Content(sets) | Container.Content(movies) | Container.Content(tvshows) | Container.Content(seasons)">
 					<include>InfoWallMusicLayout</include>
 				</itemlayout>
-				<focusedlayout height="360" width="300" condition="Container.Content(artists) | Container.Content(albums) | Container.Content(musicvideos)">
+				<focusedlayout height="360" width="300" condition="Container.Content(artists) | Container.Content(albums) | Container.Content(musicvideos) | Container.Content(sets) | Container.Content(movies) | Container.Content(tvshows) | Container.Content(seasons)">
 					<control type="group">
 						<animation effect="zoom" start="100" end="105" time="200" tween="sine" easing="inout" center="160,180">Focus</animation>
 						<animation effect="zoom" start="105" end="100" time="200" tween="sine" easing="inout" center="160,180">UnFocus</animation>
@@ -200,10 +136,10 @@
 						</control>
 					</control>
 				</focusedlayout>
-				<itemlayout height="360" width="401" condition="Container.Content(images)">
+				<itemlayout height="360" width="401" condition="Container.Content(images) | Container.Content(episodes)">
 					<include>InfoWallPictureLayout</include>
 				</itemlayout>
-				<focusedlayout height="360" width="401" condition="Container.Content(images)">
+				<focusedlayout height="360" width="401" condition="Container.Content(images) | Container.Content(episodes)">
 					<control type="group">
 						<animation effect="zoom" start="100" end="105" time="200" tween="sine" easing="inout" center="190,180">Focus</animation>
 						<animation effect="zoom" start="105" end="100" time="200" tween="sine" easing="inout" center="190,180">UnFocus</animation>
-- 
2.7.4


From 26fc8f2de3caa32938141d9ddc64ee5b443dd44e Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Fri, 7 Oct 2016 17:56:59 +0100
Subject: [PATCH 045/175] Fix remixers node to use string constant

---
 addons/resource.language.en_gb/resources/strings.po | 6 ++++++
 system/library/music/musicroles/Remixers.xml        | 2 +-
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 15b3712..31ac537 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -15277,6 +15277,12 @@ msgid "If traffic advisory is send from RDS, volume is increased"
 msgstr ""
 
 #. Music role category
+#: system/library/music/musicroles/Remixers.xml
+msgctxt "#29987"
+msgid "Remixers"
+msgstr ""
+
+#. Music role category
 #: system/library/music/musicroles/Arrangers.xml
 msgctxt "#29988"
 msgid "Arrangers"
diff --git a/system/library/music/musicroles/Remixers.xml b/system/library/music/musicroles/Remixers.xml
index 1dd4f6c..2e6efb4 100644
--- a/system/library/music/musicroles/Remixers.xml
+++ b/system/library/music/musicroles/Remixers.xml
@@ -1,6 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <node order="7" type="folder" visible="Library.HasContent(Role, Remixer)">
-	<label>Remixers</label>
+	<label>29987</label>
         <icon>DefaultMusicGenres.png</icon>
 	<path>musicdb://artists/?role=Remixer</path>
 </node>
-- 
2.7.4


From ee14f323a8d164692011399da6a6a90d60727fa7 Mon Sep 17 00:00:00 2001
From: Christian Fetzer <fetzer.ch@gmail.com>
Date: Fri, 7 Oct 2016 19:49:51 +0200
Subject: [PATCH 046/175] Build with CMake

Removes the possibility to build with legacy build systems on jenkins.
---
 tools/buildsteps/android/configure-xbmc        |  6 +-----
 tools/buildsteps/android/make-binary-addons    |  8 ++------
 tools/buildsteps/android/make-xbmc             |  6 +-----
 tools/buildsteps/android/package               |  6 +-----
 tools/buildsteps/androidx86/configure-xbmc     |  6 +-----
 tools/buildsteps/androidx86/make-binary-addons |  8 ++------
 tools/buildsteps/androidx86/make-xbmc          |  6 +-----
 tools/buildsteps/androidx86/package            |  6 +-----
 tools/buildsteps/ios/configure-xbmc            |  6 +-----
 tools/buildsteps/ios/make-binary-addons        |  6 +-----
 tools/buildsteps/ios/make-xbmc                 |  9 +--------
 tools/buildsteps/ios/package                   | 11 ++---------
 tools/buildsteps/linux64/configure-xbmc        |  6 +-----
 tools/buildsteps/linux64/make-xbmc             |  6 +-----
 tools/buildsteps/linux64/run-tests             | 13 ++++---------
 tools/buildsteps/osx64/configure-xbmc          |  6 +-----
 tools/buildsteps/osx64/make-binary-addons      |  6 +-----
 tools/buildsteps/osx64/make-xbmc               |  9 +--------
 tools/buildsteps/osx64/package                 |  8 ++------
 tools/buildsteps/osx64/run-tests               |  9 ++-------
 tools/buildsteps/rbpi/configure-xbmc           |  7 +------
 tools/buildsteps/rbpi/make-xbmc                |  6 +-----
 22 files changed, 30 insertions(+), 130 deletions(-)

diff --git a/tools/buildsteps/android/configure-xbmc b/tools/buildsteps/android/configure-xbmc
index 50c015b..81c0d3c 100644
--- a/tools/buildsteps/android/configure-xbmc
+++ b/tools/buildsteps/android/configure-xbmc
@@ -2,8 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=android
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  make -C $WORKSPACE/tools/depends/target/cmakebuildsys
-else
-  make -C $WORKSPACE/tools/depends/target/xbmc
-fi
+make -C $WORKSPACE/tools/depends/target/cmakebuildsys
diff --git a/tools/buildsteps/android/make-binary-addons b/tools/buildsteps/android/make-binary-addons
index 1c07b4c..123f55d 100644
--- a/tools/buildsteps/android/make-binary-addons
+++ b/tools/buildsteps/android/make-binary-addons
@@ -16,12 +16,8 @@ then
     echo "building $addon"
     git clean -xffd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon
 
-    if [ "$CMAKE_BUILD" = true ]; then
-      # Must match prefix in android/PathSetup.cmake
-      INSTALL_PREFIX="../../../../../build/install"
-    else
-      INSTALL_PREFIX="\$(PREFIX)"
-    fi
+    # Must match prefix in android/PathSetup.cmake
+    INSTALL_PREFIX="../../../../../build/install"
     cd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon;make -j $BUILDTHREADS V=99 VERBOSE=1 INSTALL_PREFIX="$INSTALL_PREFIX"  || ALL_BINARY_ADDONS_BUILT="0"
   done
 fi
diff --git a/tools/buildsteps/android/make-xbmc b/tools/buildsteps/android/make-xbmc
index 3cff087..11d8d70 100644
--- a/tools/buildsteps/android/make-xbmc
+++ b/tools/buildsteps/android/make-xbmc
@@ -2,8 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=android
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS || make
-else
-  cd $WORKSPACE;make -j$BUILDTHREADS || make
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS || make
diff --git a/tools/buildsteps/android/package b/tools/buildsteps/android/package
index 833a2d9..bb535a4 100644
--- a/tools/buildsteps/android/package
+++ b/tools/buildsteps/android/package
@@ -8,11 +8,7 @@ else
   TARGET=apk-unsigned
 fi
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS $TARGET
-else
-  cd $WORKSPACE;make -j$BUILDTHREADS $TARGET
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS $TARGET
 $RUN_SIGNSTEP
 
 cd $WORKSPACE
diff --git a/tools/buildsteps/androidx86/configure-xbmc b/tools/buildsteps/androidx86/configure-xbmc
index 50c015b..81c0d3c 100644
--- a/tools/buildsteps/androidx86/configure-xbmc
+++ b/tools/buildsteps/androidx86/configure-xbmc
@@ -2,8 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=android
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  make -C $WORKSPACE/tools/depends/target/cmakebuildsys
-else
-  make -C $WORKSPACE/tools/depends/target/xbmc
-fi
+make -C $WORKSPACE/tools/depends/target/cmakebuildsys
diff --git a/tools/buildsteps/androidx86/make-binary-addons b/tools/buildsteps/androidx86/make-binary-addons
index 0ef6c3d..19a9d85 100644
--- a/tools/buildsteps/androidx86/make-binary-addons
+++ b/tools/buildsteps/androidx86/make-binary-addons
@@ -16,12 +16,8 @@ then
     echo "building $addon"
     git clean -xffd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon
 
-    if [ "$CMAKE_BUILD" = true ]; then
-      # Must match prefix in android/PathSetup.cmake
-      INSTALL_PREFIX="../../../../../build/install"
-    else
-      INSTALL_PREFIX="\$(PREFIX)"
-    fi
+    # Must match prefix in android/PathSetup.cmake
+    INSTALL_PREFIX="../../../../../build/install"
     cd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon;make -j $BUILDTHREADS V=99 VERBOSE=1 INSTALL_PREFIX="$INSTALL_PREFIX"  || ALL_BINARY_ADDONS_BUILT="0"
   done
 fi
diff --git a/tools/buildsteps/androidx86/make-xbmc b/tools/buildsteps/androidx86/make-xbmc
index 3cff087..11d8d70 100644
--- a/tools/buildsteps/androidx86/make-xbmc
+++ b/tools/buildsteps/androidx86/make-xbmc
@@ -2,8 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=android
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS || make
-else
-  cd $WORKSPACE;make -j$BUILDTHREADS || make
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS || make
diff --git a/tools/buildsteps/androidx86/package b/tools/buildsteps/androidx86/package
index d1ca55f..70c9b69 100644
--- a/tools/buildsteps/androidx86/package
+++ b/tools/buildsteps/androidx86/package
@@ -8,11 +8,7 @@ else
   TARGET=apk-unsigned
 fi
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS $TARGET
-else
-  cd $WORKSPACE;make -j$BUILDTHREADS $TARGET
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS $TARGET
 $RUN_SIGNSTEP
 
 cd $WORKSPACE
diff --git a/tools/buildsteps/ios/configure-xbmc b/tools/buildsteps/ios/configure-xbmc
index 3470f69..dbe8a74 100755
--- a/tools/buildsteps/ios/configure-xbmc
+++ b/tools/buildsteps/ios/configure-xbmc
@@ -2,8 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=ios
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  make -C $WORKSPACE/tools/depends/target/cmakebuildsys
-else
-  make -C $WORKSPACE/tools/depends/target/xbmc
-fi
+make -C $WORKSPACE/tools/depends/target/cmakebuildsys
diff --git a/tools/buildsteps/ios/make-binary-addons b/tools/buildsteps/ios/make-binary-addons
index ec7564f..c0651fc 100755
--- a/tools/buildsteps/ios/make-binary-addons
+++ b/tools/buildsteps/ios/make-binary-addons
@@ -16,11 +16,7 @@ then
     echo "building $addon"
     git clean -xffd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon
 
-    if [ "$CMAKE_BUILD" = true ]; then
-      INSTALL_PREFIX="../../../../../build/addons/"
-    else
-      INSTALL_PREFIX="../../../../../addons/"
-    fi
+    INSTALL_PREFIX="../../../../../build/addons/"
     cd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon;make -j $BUILDTHREADS V=99 VERBOSE=1 INSTALL_PREFIX="$INSTALL_PREFIX"  || ALL_BINARY_ADDONS_BUILT="0"
   done
 fi
diff --git a/tools/buildsteps/ios/make-xbmc b/tools/buildsteps/ios/make-xbmc
index 862d4e5..b70e3ee 100755
--- a/tools/buildsteps/ios/make-xbmc
+++ b/tools/buildsteps/ios/make-xbmc
@@ -2,11 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=ios
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS || make
-else
-  cd $WORKSPACE;make -j$BUILDTHREADS xcode_depends
-  cd $WORKSPACE;xcodebuild -project Kodi.xcodeproj -target Kodi-iOS -configuration $Configuration build \
-    ONLY_ACTIVE_ARCH=YES ARCHS=$DARWIN_ARM_CPU VALID_ARCHS=$DARWIN_ARM_CPU \
-    SDKROOT=iphoneos$SDK_VERSION XBMC_DEPENDS_ROOT=$XBMC_DEPENDS_ROOT CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS || make
diff --git a/tools/buildsteps/ios/package b/tools/buildsteps/ios/package
index c07b5ca..08458ca 100755
--- a/tools/buildsteps/ios/package
+++ b/tools/buildsteps/ios/package
@@ -2,15 +2,8 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=ios
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS deb
-  cd $WORKSPACE/build/tools/darwin/packaging/ios/
-else
-  #ensure that dpkg tools are used from our toolchain
-  export PATH=$XBMC_DEPENDS_ROOT/buildtools-native/bin/:$PATH
-
-  cd $WORKSPACE/tools/darwin/packaging/ios/;sh mkdeb-ios.sh $Configuration
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS deb
+cd $WORKSPACE/build/tools/darwin/packaging/ios/
 
 #rename for upload
 #e.x. kodi-20130314-8c2fb31-Frodo-ios.deb
diff --git a/tools/buildsteps/linux64/configure-xbmc b/tools/buildsteps/linux64/configure-xbmc
index 79a2878..12271d5 100755
--- a/tools/buildsteps/linux64/configure-xbmc
+++ b/tools/buildsteps/linux64/configure-xbmc
@@ -2,8 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=linux64
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  make -C $WORKSPACE/tools/depends/target/cmakebuildsys
-else
-  make -C $WORKSPACE/tools/depends/target/xbmc
-fi
+make -C $WORKSPACE/tools/depends/target/cmakebuildsys
diff --git a/tools/buildsteps/linux64/make-xbmc b/tools/buildsteps/linux64/make-xbmc
index 836a619..c9a4d46 100755
--- a/tools/buildsteps/linux64/make-xbmc
+++ b/tools/buildsteps/linux64/make-xbmc
@@ -2,8 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=linux64
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS || make
-else
-  cd $WORKSPACE;make -j$BUILDTHREADS || make
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS || make
diff --git a/tools/buildsteps/linux64/run-tests b/tools/buildsteps/linux64/run-tests
index abcaea4..d5580c8 100755
--- a/tools/buildsteps/linux64/run-tests
+++ b/tools/buildsteps/linux64/run-tests
@@ -2,16 +2,11 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=linux64
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS kodi-test
-  if [ "$Configuration" != "Coverage" ]; then
-    cd $WORKSPACE;build/kodi-test --gtest_output=xml:gtestresults.xml
-  else
-    cd $WORKSPACE/build;GTEST_OUTPUT="xml:$WORKSPACE/gtestresults.xml" make coverage
-  fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS kodi-test
+if [ "$Configuration" != "Coverage" ]; then
+  cd $WORKSPACE;build/kodi-test --gtest_output=xml:gtestresults.xml
 else
-  cd $WORKSPACE;make -j$BUILDTHREADS testsuite
-  cd $WORKSPACE;./kodi-test --gtest_output=xml:gtestresults.xml
+  cd $WORKSPACE/build;GTEST_OUTPUT="xml:$WORKSPACE/gtestresults.xml" make coverage
 fi
 
 awk '{ if ($1 == "<testcase" && match($0, "notrun")) print substr($0,0,length($0)-2) "><skipped/></testcase>"; else print $0;}' gtestresults.xml > gtestresults-skipped.xml
diff --git a/tools/buildsteps/osx64/configure-xbmc b/tools/buildsteps/osx64/configure-xbmc
index f3edbff..2613074 100755
--- a/tools/buildsteps/osx64/configure-xbmc
+++ b/tools/buildsteps/osx64/configure-xbmc
@@ -2,8 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=osx64
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  make -C $WORKSPACE/tools/depends/target/cmakebuildsys
-else
-  make -C $WORKSPACE/tools/depends/target/xbmc
-fi
+make -C $WORKSPACE/tools/depends/target/cmakebuildsys
diff --git a/tools/buildsteps/osx64/make-binary-addons b/tools/buildsteps/osx64/make-binary-addons
index 1625f93..c12a42a 100755
--- a/tools/buildsteps/osx64/make-binary-addons
+++ b/tools/buildsteps/osx64/make-binary-addons
@@ -16,11 +16,7 @@ then
     echo "building $addon"
     git clean -xffd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon
 
-    if [ "$CMAKE_BUILD" = true ]; then
-      INSTALL_PREFIX="../../../../../build/addons/"
-    else
-      INSTALL_PREFIX="../../../../../addons/"
-    fi
+    INSTALL_PREFIX="../../../../../build/addons/"
     cd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon;make -j $BUILDTHREADS V=99 VERBOSE=1 INSTALL_PREFIX="$INSTALL_PREFIX"  || ALL_BINARY_ADDONS_BUILT="0"
   done
 fi
diff --git a/tools/buildsteps/osx64/make-xbmc b/tools/buildsteps/osx64/make-xbmc
index c3cc31a..cc1184b 100755
--- a/tools/buildsteps/osx64/make-xbmc
+++ b/tools/buildsteps/osx64/make-xbmc
@@ -2,11 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=osx64
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS || make
-else
-  cd $WORKSPACE;make -j$BUILDTHREADS xcode_depends
-
-  cd $WORKSPACE;xcodebuild -sdk macosx$SDK_VERSION -project Kodi.xcodeproj -target Kodi.app ONLY_ACTIVE_ARCH=YES \
-     ARCHS=x86_64 VALID_ARCHS=x86_64 XBMC_DEPENDS_ROOT=$XBMC_DEPENDS_ROOT -configuration $Configuration build
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS || make
diff --git a/tools/buildsteps/osx64/package b/tools/buildsteps/osx64/package
index fded79d..66db6d3 100755
--- a/tools/buildsteps/osx64/package
+++ b/tools/buildsteps/osx64/package
@@ -2,12 +2,8 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=osx64
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS dmg
-  cd $WORKSPACE/build/tools/darwin/packaging/osx/
-else
-  cd $WORKSPACE/tools/darwin/packaging/osx/; sh ./mkdmg-osx.sh $Configuration
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS dmg
+cd $WORKSPACE/build/tools/darwin/packaging/osx/
 
 #rename for upload
 #e.x. kodi-20130314-8c2fb31-Frodo-x86_64.dmg
diff --git a/tools/buildsteps/osx64/run-tests b/tools/buildsteps/osx64/run-tests
index 5aa20e7..38ae333 100755
--- a/tools/buildsteps/osx64/run-tests
+++ b/tools/buildsteps/osx64/run-tests
@@ -2,13 +2,8 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=osx64
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS kodi-test
-  cd $WORKSPACE;build/kodi-test --gtest_output=xml:gtestresults.xml
-else
-  cd $WORKSPACE;make -j$BUILDTHREADS testsuite
-  cd $WORKSPACE;./kodi-test --gtest_output=xml:gtestresults.xml
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS kodi-test
+cd $WORKSPACE;build/kodi-test --gtest_output=xml:gtestresults.xml
 
 awk '{ if ($1 == "<testcase" && match($0, "notrun")) print substr($0,0,length($0)-2) "><skipped/></testcase>"; else print $0;}' gtestresults.xml > gtestresults-skipped.xml
 rm gtestresults.xml
diff --git a/tools/buildsteps/rbpi/configure-xbmc b/tools/buildsteps/rbpi/configure-xbmc
index 506fc61..6dd54bf 100755
--- a/tools/buildsteps/rbpi/configure-xbmc
+++ b/tools/buildsteps/rbpi/configure-xbmc
@@ -2,9 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=rbpi
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  make -C $WORKSPACE/tools/depends/target/cmakebuildsys
-else
-  cd $WORKSPACE
-  make -C tools/buildsteps/rbpi -f config-xbmc-makefile
-fi
+make -C $WORKSPACE/tools/depends/target/cmakebuildsys
diff --git a/tools/buildsteps/rbpi/make-xbmc b/tools/buildsteps/rbpi/make-xbmc
index e01df1a..07cfae2 100755
--- a/tools/buildsteps/rbpi/make-xbmc
+++ b/tools/buildsteps/rbpi/make-xbmc
@@ -2,8 +2,4 @@ WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
 XBMC_PLATFORM_DIR=rbpi
 . $WORKSPACE/tools/buildsteps/defaultenv
 
-if [ "$CMAKE_BUILD" = true ]; then
-  cd $WORKSPACE/build;make -j$BUILDTHREADS || make
-else
-  cd $WORKSPACE;make -j$BUILDTHREADS || make
-fi
+cd $WORKSPACE/build;make -j$BUILDTHREADS || make
-- 
2.7.4


From 7c20463706b547202e61e5dbd11bc26f8f95f67d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 7 Oct 2016 21:19:59 +0200
Subject: [PATCH 047/175] VideoPlayer: drop some outdated pullup correction
 code that does more harm than any good now

---
 xbmc/cores/VideoPlayer/DVDTSCorrection.cpp  | 30 -----------------------------
 xbmc/cores/VideoPlayer/DVDTSCorrection.h    |  3 ---
 xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp |  8 +-------
 3 files changed, 1 insertion(+), 40 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDTSCorrection.cpp b/xbmc/cores/VideoPlayer/DVDTSCorrection.cpp
index 43c052c..4a9a3cf 100644
--- a/xbmc/cores/VideoPlayer/DVDTSCorrection.cpp
+++ b/xbmc/cores/VideoPlayer/DVDTSCorrection.cpp
@@ -45,14 +45,12 @@ void CPullupCorrection::Flush()
 {
   m_pattern.clear();
   m_ringpos       = 0;
-  m_ptscorrection = 0.0;
   m_prevpts       = DVD_NOPTS_VALUE;
   m_patternpos    = 0;
   m_ringfill      = 0;
   m_haspattern    = false;
   m_patternlength = 0;
   m_frameduration = DVD_NOPTS_VALUE;
-  m_trackingpts   = DVD_NOPTS_VALUE;
   memset(m_diffring, 0, sizeof(m_diffring));
 }
 
@@ -126,35 +124,7 @@ void CPullupCorrection::Add(double pts)
     }
   }
 
-  //calculate where we are in the pattern
-  double ptsinpattern = 0.0;
-  for (int i = 0; i < m_patternpos; i++)
-    ptsinpattern += m_pattern[m_pattern.size() - i - 1];
-
   m_frameduration = CalcFrameDuration();
-
-  //correct the last pts based on where we should be according to the frame duration
-  m_ptscorrection = (m_frameduration * m_patternpos) - ptsinpattern;
-
-  double corrpts = pts + m_ptscorrection;
-  if (m_trackingpts != DVD_NOPTS_VALUE)
-  {
-    //set the tracked pts a frame duration forward
-    m_trackingpts += m_frameduration;
-
-    //if the tracked pts differs too much from the corrected one,
-    //move the tracked pts slowly towards the corrected one
-    //this allows the timestamps to wobble slightly
-    if (fabs(m_trackingpts - corrpts) > MAXERR)
-      m_trackingpts += (corrpts - m_trackingpts) * 0.005;
-
-    //set m_ptscorrection so that pts + m_ptscorrection = m_trackingpts
-    m_ptscorrection = m_trackingpts - pts;
-  }
-  else
-  {
-    m_trackingpts = corrpts;
-  }
 }
 
 //gets a diff diffnr into the past
diff --git a/xbmc/cores/VideoPlayer/DVDTSCorrection.h b/xbmc/cores/VideoPlayer/DVDTSCorrection.h
index 0ff555b..3e42a03 100644
--- a/xbmc/cores/VideoPlayer/DVDTSCorrection.h
+++ b/xbmc/cores/VideoPlayer/DVDTSCorrection.h
@@ -35,7 +35,6 @@ class CPullupCorrection
     void   Flush(); //flush the saved pattern and the ringbuffer
     void   ResetVFRDetection(void);
 
-    double GetCorrection()    { return m_ptscorrection;            }
     int    GetPatternLength() { return m_patternlength;            }
     double GetFrameDuration() { return m_frameduration;            }
     double GetMaxFrameDuration(void) { return m_maxframeduration;  }
@@ -66,8 +65,6 @@ class CPullupCorrection
 
     std::vector<double> m_pattern, m_lastPattern; //the last saved pattern
     int m_patternpos;              //the position of the pattern in the ringbuffer, moves one to the past each time a pts is added
-    double m_ptscorrection;        //the correction needed for the last added pts
-    double m_trackingpts;          //tracked pts for smoothing the timestamps
     double m_frameduration;        //frameduration exposed to VideoPlayer, used for calculating the fps
     double m_maxframeduration;     //Max value detected for frame duration (for VFR files case)
     double m_minframeduration;     //Min value detected for frame duration (for VFR files case)
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
index 8651327..9184826 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
@@ -799,14 +799,8 @@ int CVideoPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
 
   int result = 0;
 
-  //correct any pattern in the timestamps
-  if (picture.format != RENDER_FMT_BYPASS)
-  {
-    m_pullupCorrection.Add(pts);
-    pts += m_pullupCorrection.GetCorrection();
-  }
-
   //try to calculate the framerate
+  m_pullupCorrection.Add(pts);
   if (!m_stalled)
     CalcFrameRate();
 
-- 
2.7.4


From aaf7e42202ca744fb0d3ce0ea307173779412b0c Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Fri, 7 Oct 2016 22:52:20 +0200
Subject: [PATCH 048/175] - release CVBuffer after it actually has been
 rendered

---
 .../VideoRenderers/HwDecRender/RendererVTBGLES.cpp | 41 +++++++++++++++++++---
 .../VideoRenderers/HwDecRender/RendererVTBGLES.h   |  7 ++--
 .../VideoRenderers/LinuxRendererGLES.cpp           |  2 ++
 .../VideoPlayer/VideoRenderers/LinuxRendererGLES.h |  1 +
 4 files changed, 44 insertions(+), 7 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVTBGLES.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVTBGLES.cpp
index ca3a957..46c8a61 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVTBGLES.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVTBGLES.cpp
@@ -48,6 +48,7 @@ CRendererVTB::CRendererVTB()
     buf.m_textureY = nullptr;
     buf.m_textureUV = nullptr;
     buf.m_videoBuffer = nullptr;
+    buf.m_fence = nullptr;
   }
 }
 
@@ -55,6 +56,11 @@ CRendererVTB::~CRendererVTB()
 {
   if (m_textureCache)
     CFRelease(m_textureCache);
+
+  for (int i = 0; i < NUM_BUFFERS; ++i)
+  {
+    DeleteTexture(i);
+  }
 }
 
 void CRendererVTB::AddVideoPictureHW(DVDVideoPicture &picture, int index)
@@ -73,6 +79,12 @@ void CRendererVTB::ReleaseBuffer(int idx)
   if (buf.m_videoBuffer)
     CVBufferRelease(buf.m_videoBuffer);
   buf.m_videoBuffer = nullptr;
+  
+  if (buf.m_fence && glIsSyncAPPLE(buf.m_fence))
+  {
+    glDeleteSyncAPPLE(buf.m_fence);
+    buf.m_fence = nullptr;
+  }
 }
 
 int CRendererVTB::GetImageHook(YV12Image *image, int source, bool readonly)
@@ -154,10 +166,6 @@ void CRendererVTB::DeleteTexture(int index)
 {
   CRenderBuffer &buf = m_vtbBuffers[index];
   
-  if (buf.m_videoBuffer)
-    CVBufferRelease(buf.m_videoBuffer);
-  buf.m_videoBuffer = nullptr;
-
   if (buf.m_textureY)
     CFRelease(buf.m_textureY);
   buf.m_textureY = nullptr;
@@ -166,6 +174,8 @@ void CRendererVTB::DeleteTexture(int index)
     CFRelease(buf.m_textureUV);
   buf.m_textureUV = nullptr;
 
+  ReleaseBuffer(index);
+
   YUVFIELDS &fields = m_buffers[index].fields;
   fields[FIELD_FULL][0].id = 0;
   fields[FIELD_FULL][1].id = 0;
@@ -243,4 +253,27 @@ bool CRendererVTB::UploadTexture(int index)
   return true;
 }
 
+void CRendererVTB::AfterRenderHook(int idx)
+{
+  CRenderBuffer &buf = m_vtbBuffers[idx];
+  if (buf.m_fence && glIsSyncAPPLE(buf.m_fence))
+  {
+    glDeleteSyncAPPLE(buf.m_fence);
+  }
+  buf.m_fence = glFenceSyncAPPLE(GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE, 0);
+}
+
+bool CRendererVTB::NeedBuffer(int idx)
+{
+  CRenderBuffer &buf = m_vtbBuffers[idx];
+  if (buf.m_fence && glIsSyncAPPLE(buf.m_fence))
+  {
+    int syncState = GL_UNSIGNALED_APPLE;
+    glGetSyncivAPPLE(buf.m_fence, GL_SYNC_STATUS_APPLE, 1, nullptr, &syncState);
+    if (syncState == GL_SIGNALED_APPLE)
+      return false;
+  }
+  
+  return true;
+}
 #endif
\ No newline at end of file
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVTBGLES.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVTBGLES.h
index 4147db7..b045db1 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVTBGLES.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererVTBGLES.h
@@ -33,17 +33,17 @@ public:
   CRendererVTB();
   virtual ~CRendererVTB();
 
-  // Player functions
+  // Feature support
   virtual void AddVideoPictureHW(DVDVideoPicture &picture, int index) override;
   virtual void ReleaseBuffer(int idx) override;
-
-  // Feature support
+  virtual bool NeedBuffer(int idx) override;
   virtual CRenderInfo GetRenderInfo() override;
 
 protected:
   // hooks for hw dec renderer
   virtual bool LoadShadersHook() override;
   virtual int  GetImageHook(YV12Image *image, int source = AUTOSOURCE, bool readonly = false) override;
+  virtual void AfterRenderHook(int idx) override;
 
   // textures
   virtual bool UploadTexture(int index) override;
@@ -56,6 +56,7 @@ protected:
     CVOpenGLESTextureRef m_textureY;
     CVOpenGLESTextureRef m_textureUV;
     CVBufferRef m_videoBuffer;
+    GLsync m_fence;
   };
   CRenderBuffer m_vtbBuffers[NUM_BUFFERS];
 };
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp
index 275e165..f478fb0 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp
@@ -811,6 +811,8 @@ void CLinuxRendererGLES::Render(DWORD flags, int index)
       break;
     }
   }
+  
+  AfterRenderHook(index);
 }
 
 void CLinuxRendererGLES::RenderSinglePass(int index, int field)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h
index c060b0d..d54041d 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h
@@ -187,6 +187,7 @@ protected:
   // hooks for HwDec Renderered
   virtual bool LoadShadersHook() { return false; }
   virtual bool RenderHook(int idx) { return false; }
+  virtual void AfterRenderHook(int idx) {};
   virtual bool RenderUpdateVideoHook(bool clear, DWORD flags, DWORD alpha) { return false; }
   virtual int  GetImageHook(YV12Image *image, int source = AUTOSOURCE, bool readonly = false) { return NOSOURCE; }
   virtual bool RenderUpdateCheckForEmptyField() { return true; }
-- 
2.7.4


From cce636c43c7be61dfc811ac5fa1660e25f3a810b Mon Sep 17 00:00:00 2001
From: Martijn Kaijser <mcm.kaijser@gmail.com>
Date: Fri, 7 Oct 2016 18:23:56 +0200
Subject: [PATCH 049/175] Add revision when Python API was changed, expanded or
 deprecated

---
 .codedocs                                          |  8 ++++-
 doxygen_resources/Doxyfile.doxy                    |  8 ++++-
 xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile    |  8 ++++-
 .../kodi-addon-dev-kit/doxygen/General/General.dox | 11 +++++++
 .../doxygen/Modules/modules_python.dox             | 34 +++++++++++++++++++++-
 xbmc/interfaces/legacy/Control.h                   |  2 ++
 xbmc/interfaces/legacy/Dialog.h                    |  4 +++
 xbmc/interfaces/legacy/InfoTagVideo.h              | 10 +++----
 xbmc/interfaces/legacy/ListItem.h                  | 22 +++++++++-----
 xbmc/interfaces/legacy/ModuleXbmc.h                |  1 +
 xbmc/interfaces/legacy/Monitor.h                   | 12 ++++++--
 xbmc/interfaces/legacy/Player.h                    | 10 +++++++
 xbmc/interfaces/legacy/RenderCapture.h             | 24 +++++++++++++++
 xbmc/interfaces/legacy/Stat.h                      |  1 +
 xbmc/interfaces/legacy/WindowXML.h                 | 30 +++++++++++++------
 15 files changed, 157 insertions(+), 28 deletions(-)

diff --git a/.codedocs b/.codedocs
index 14a6f44..0b85796 100644
--- a/.codedocs
+++ b/.codedocs
@@ -12,7 +12,13 @@ ALIASES                = "table_start=<table width= 100% style= border bgcolor=
                          "python_func_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
                          "python_class{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
                          "python_class_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
-                         "doc_header{1}=\htmlonly <h3><span style=\"text-decoration: underline;\"><span  style=\"font-style: italic;\"><span style=\"color: rgb(102, 102, 102);\">\1</span></span></span></h3> \endhtmlonly"
+                         "doc_header{1}=\htmlonly <h3><span style=\"text-decoration: underline;\"><span  style=\"font-style: italic;\"><span style=\"color: rgb(102, 102, 102);\">\1</span></span></span></h3> \endhtmlonly" \
+                         "python_v12=\xrefitem python_v12 \"v12 Python API changes\" \"\"" \
+                         "python_v13=\xrefitem python_v13 \"v13 Python API changes\" \"\"" \
+                         "python_v14=\xrefitem python_v14 \"v14 Python API changes\" \"\"" \
+                         "python_v15=\xrefitem python_v15 \"v15 Python API changes\" \"\"" \
+                         "python_v16=\xrefitem python_v16 \"v16 Python API changes\" \"\"" \
+                         "python_v17=\xrefitem python_v17 \"v17 Python API changes\" \"\""
 
 # Hide undocumented class members.
 HIDE_UNDOC_MEMBERS =
diff --git a/doxygen_resources/Doxyfile.doxy b/doxygen_resources/Doxyfile.doxy
index 5a2b7ef..beeac82 100644
--- a/doxygen_resources/Doxyfile.doxy
+++ b/doxygen_resources/Doxyfile.doxy
@@ -248,7 +248,13 @@ ALIASES                = "table_start=<table width= 100% style= border bgcolor=
                          "python_func_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
                          "python_class{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
                          "python_class_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
-                         "doc_header{1}=\htmlonly <h3><span style=\"text-decoration: underline;\"><span  style=\"font-style: italic;\"><span style=\"color: rgb(102, 102, 102);\">\1</span></span></span></h3> \endhtmlonly"
+                         "doc_header{1}=\htmlonly <h3><span style=\"text-decoration: underline;\"><span  style=\"font-style: italic;\"><span style=\"color: rgb(102, 102, 102);\">\1</span></span></span></h3> \endhtmlonly" \
+                         "python_v12=\xrefitem python_v12 \"v12 Python API changes\" \"\"" \
+                         "python_v13=\xrefitem python_v13 \"v13 Python API changes\" \"\"" \
+                         "python_v14=\xrefitem python_v14 \"v14 Python API changes\" \"\"" \
+                         "python_v15=\xrefitem python_v15 \"v15 Python API changes\" \"\"" \
+                         "python_v16=\xrefitem python_v16 \"v16 Python API changes\" \"\"" \
+                         "python_v17=\xrefitem python_v17 \"v17 Python API changes\" \"\""
 
 # This tag can be used to specify a number of word-keyword mappings (TCL only).
 # A mapping has the form "name=value". For example adding "class=itcl::class"
diff --git a/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile b/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile
index ae71b16..609be06 100644
--- a/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile
+++ b/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile
@@ -248,7 +248,13 @@ ALIASES                = "table_start=<table width= 100% style= border bgcolor=
                          "python_func_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
                          "python_class{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
                          "python_class_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
-                         "doc_header{1}=\htmlonly <h3><span style=\"text-decoration: underline;\"><span  style=\"font-style: italic;\"><span style=\"color: rgb(102, 102, 102);\">\1</span></span></span></h3> \endhtmlonly"
+                         "doc_header{1}=\htmlonly <h3><span style=\"text-decoration: underline;\"><span  style=\"font-style: italic;\"><span style=\"color: rgb(102, 102, 102);\">\1</span></span></span></h3> \endhtmlonly" \
+                         "python_v12=\xrefitem python_v12 \"v12 Python API changes\" \"\"" \
+                         "python_v13=\xrefitem python_v13 \"v13 Python API changes\" \"\"" \
+                         "python_v14=\xrefitem python_v14 \"v14 Python API changes\" \"\"" \
+                         "python_v15=\xrefitem python_v15 \"v15 Python API changes\" \"\"" \
+                         "python_v16=\xrefitem python_v16 \"v16 Python API changes\" \"\"" \
+                         "python_v17=\xrefitem python_v17 \"v17 Python API changes\" \"\""
 
 # This tag can be used to specify a number of word-keyword mappings (TCL only).
 # A mapping has the form "name=value". For example adding "class=itcl::class"
diff --git a/xbmc/addons/kodi-addon-dev-kit/doxygen/General/General.dox b/xbmc/addons/kodi-addon-dev-kit/doxygen/General/General.dox
index 278e11a..ef7ccf0 100644
--- a/xbmc/addons/kodi-addon-dev-kit/doxygen/General/General.dox
+++ b/xbmc/addons/kodi-addon-dev-kit/doxygen/General/General.dox
@@ -16,3 +16,14 @@ Guideline for Kodi's developers to create documentation
 \subpage Doxygen_On_Addon
 
 */
+
+---------------------------------------------------------------------------------
+
+@subpage revisions "Revisions against older versions"
+*/
+
+/*!
+\page revisions Revisions
+
+\subpage python_revisions
+*/
\ No newline at end of file
diff --git a/xbmc/addons/kodi-addon-dev-kit/doxygen/Modules/modules_python.dox b/xbmc/addons/kodi-addon-dev-kit/doxygen/Modules/modules_python.dox
index 7911f93..e5dedf6 100644
--- a/xbmc/addons/kodi-addon-dev-kit/doxygen/Modules/modules_python.dox
+++ b/xbmc/addons/kodi-addon-dev-kit/doxygen/Modules/modules_python.dox
@@ -37,7 +37,7 @@ uses a handful of custom modules to expose Kodi functionality to Python.
 |------------------------------------:|:-----------------------------------------------------------|
 | \ref python_xbmc       "xbmc"       | Offers classes and functions that provide information about the media currently playing and that allow manipulation of the media player (such as starting a new song). You can also find system information using the functions available in this library.
 | \ref python_xbmcgui    "xbmcgui"    | Offers classes and functions that manipulate the Graphical User Interface through windows, dialogs, and various control widgets.
-| \ref python_xbmcplugin "xbmcplugin" |  Offers classes and functions that allow a developer to present information through Kodi's standard menu structure. While plugins don't have the same flexibility as scripts, they boast significantly quicker development time and a more consistent user experience.
+| \ref python_xbmcplugin "xbmcplugin" | Offers classes and functions that allow a developer to present information through Kodi's standard menu structure. While plugins don't have the same flexibility as scripts, they boast significantly quicker development time and a more consistent user experience.
 | \ref python_xbmcaddon  "xbmcaddon"  | Offers classes and functions that manipulate the add-on settings, information and localization.
 | \ref python_xbmcvfs    "xbmcvfs"    | Offers classes and functions offers access to the Virtual File Server (VFS) which you can use to manipulate files and folders.
 | \ref python_xbmcwsgi   "xbmcwsgi"   | The [<b>Web Server Gateway Interface (WSGI)</b>](https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface) is a specification for simple and universal interface between web servers and web applications or frameworks for the Python programming language.
@@ -141,3 +141,35 @@ web applications or frameworks for the Python programming language.
 @}
 
 */
+
+/*!
+@page python_v12 Python API v12
+*/
+/*!
+@page python_v13 Python API v13
+*/
+/*!
+@page python_v14 Python API v14
+*/
+/*!
+@page python_v15 Python API v15
+*/
+/*!
+@page python_v16 Python API v16
+*/
+/*!
+@page python_v17 Python API v17
+*/
+
+/*!
+@page python_revisions Python API Changes
+@brief Overview of changes on Python API for Kodi
+
+- @subpage python_v12
+- @subpage python_v13
+- @subpage python_v14
+- @subpage python_v15
+- @subpage python_v16
+- @subpage python_v17
++*/
+  
\ No newline at end of file
diff --git a/xbmc/interfaces/legacy/Control.h b/xbmc/interfaces/legacy/Control.h
index ac7b848..f59e3c2 100644
--- a/xbmc/interfaces/legacy/Control.h
+++ b/xbmc/interfaces/legacy/Control.h
@@ -2538,6 +2538,7 @@ namespace XBMCAddon
     ///
     ///
     ///--------------------------------------------------------------------------
+    /// @python_v16 Deprecated **focusTexture** and **noFocusTexture**. Use **focusOnTexture** and **noFocusOnTexture**.
     ///
     /// **Example:**
     /// ~~~~~~~~~~~~~{.py}
@@ -2763,6 +2764,7 @@ namespace XBMCAddon
     ///
     ///
     ///--------------------------------------------------------------------------
+    /// @python_v17 **orientation** option added.
     ///
     /// **Example:**
     /// ~~~~~~~~~~~~~{.py}
diff --git a/xbmc/interfaces/legacy/Dialog.h b/xbmc/interfaces/legacy/Dialog.h
index 33c5bf7..5b59e93 100644
--- a/xbmc/interfaces/legacy/Dialog.h
+++ b/xbmc/interfaces/legacy/Dialog.h
@@ -120,6 +120,7 @@ namespace XBMCAddon
       ///
       ///
       ///------------------------------------------------------------------------
+      /// @python_v17 **preselect** option added.
       ///
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
@@ -148,6 +149,7 @@ namespace XBMCAddon
       ///
       ///
       ///--------------------------------------------------------------------------
+      /// @python_v17 New function added
       ///
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
@@ -181,6 +183,8 @@ namespace XBMCAddon
       ///
       ///
       ///------------------------------------------------------------------------
+      /// @python_v16 New function added.
+      /// @python_v17 Added new option **preselect**.
       ///
       /// **Example:**
       /// @code{.py}
diff --git a/xbmc/interfaces/legacy/InfoTagVideo.h b/xbmc/interfaces/legacy/InfoTagVideo.h
index fc90001..8f20faa 100644
--- a/xbmc/interfaces/legacy/InfoTagVideo.h
+++ b/xbmc/interfaces/legacy/InfoTagVideo.h
@@ -76,7 +76,7 @@ namespace XBMCAddon
       ///
       ///
       ///-----------------------------------------------------------------------
-      ///
+      /// @python_v17 New function added.
       ///
       getDbId();
 #else
@@ -240,7 +240,7 @@ namespace XBMCAddon
       ///
       ///
       ///-----------------------------------------------------------------------
-      ///
+      /// @python_v17 New function added.
       ///
       getTVShowTitle();
 #else
@@ -268,7 +268,7 @@ namespace XBMCAddon
       /// | episode        | The type is used as a series episode
       ///
       ///-----------------------------------------------------------------------
-      ///
+      /// @python_v17 New function added.
       ///
       getMediaType();
 #else
@@ -377,7 +377,7 @@ namespace XBMCAddon
       ///
       ///
       ///-----------------------------------------------------------------------
-      ///
+      /// @python_v17 New function added.
       ///
       getSeason();
 #else
@@ -395,7 +395,7 @@ namespace XBMCAddon
       ///
       ///
       ///-----------------------------------------------------------------------
-      ///
+      /// @python_v17 New function added.
       ///
       getEpisode();
 #else
diff --git a/xbmc/interfaces/legacy/ListItem.h b/xbmc/interfaces/legacy/ListItem.h
index e3e974d..87ea93b 100644
--- a/xbmc/interfaces/legacy/ListItem.h
+++ b/xbmc/interfaces/legacy/ListItem.h
@@ -199,7 +199,7 @@ namespace XBMCAddon
       /// \ingroup python_xbmcgui_listitem
       /// @brief \python_func{ setIconImage(iconImage) }
       ///-----------------------------------------------------------------------
-      /// @warning Deprecated. Use setArt
+      /// @python_v16 Deprecated. Use **setArt()**.
       ///
       setIconImage(...);
 #else
@@ -211,7 +211,7 @@ namespace XBMCAddon
       /// \ingroup python_xbmcgui_listitem
       /// @brief \python_func{ setThumbnailImage(thumbFilename) }
       ///-----------------------------------------------------------------------
-      /// @warning Deprecated. Use setArt
+      /// @python_v16 Deprecated. Use **setArt()**.
       ///
       setThumbnailImage(...);
 #else
@@ -345,8 +345,8 @@ namespace XBMCAddon
       ///  | icon          | string - image path
       ///
       ///
-      ///
       ///-----------------------------------------------------------------------
+      /// @python_v17 New function added.
       ///
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
@@ -613,6 +613,9 @@ namespace XBMCAddon
       ///
       ///
       ///-----------------------------------------------------------------------
+      /// @python_v17
+      /// Added labels **setid**, **set**, **imdbnumber**, **code** and **dbid**.
+      /// Expanded the possible infoLabels for the option **mediatype**.
       ///
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
@@ -683,7 +686,6 @@ namespace XBMCAddon
       /// @param items               list - [(label, action,)*] A list of tuples consisting of label and action pairs.
       ///   - label           string or unicode - item's label.
       ///   - action          string or unicode - any built-in function to perform.
-      /// @param replaceItems        [opt] bool - Deprecated!
       ///
       ///
       /// List of functions - http://kodi.wiki/view/List_of_Built_In_Functions
@@ -693,6 +695,7 @@ namespace XBMCAddon
       ///
       ///
       ///-----------------------------------------------------------------------
+      /// @python_v17 Completely removed option **replaceItems**.
       ///
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
@@ -845,6 +848,8 @@ namespace XBMCAddon
       /// listitem.setSubtitles(['special://temp/example.srt', 'http://example.com/example.srt'])
       /// ...
       /// ~~~~~~~~~~~~~
+      ///-----------------------------------------------------------------------
+      /// @python_v14 New function added.
       ///
       setSubtitles(...);
 #else
@@ -856,7 +861,7 @@ namespace XBMCAddon
       /// \ingroup python_xbmcgui_listitem
       /// @brief \python_func{ getdescription() }
       ///-----------------------------------------------------------------------
-      /// @warning Deprecated.
+      /// @python_v17 Deprecated.
       ///
       ///
       getdescription();
@@ -869,7 +874,7 @@ namespace XBMCAddon
       /// \ingroup python_xbmcgui_listitem
       /// @brief \python_func{ getduration() }
       ///-----------------------------------------------------------------------
-      /// @warning Deprecated.
+      /// @python_v17 Deprecated. Use **InfoTagMusic**.
       ///
       ///
       getduration();
@@ -882,7 +887,7 @@ namespace XBMCAddon
       /// \ingroup python_xbmcgui_listitem
       /// @brief \python_func{ getfilename() }
       ///-----------------------------------------------------------------------
-      /// @warning Deprecated.
+      /// @python_v17 Deprecated.
       ///
       ///
       getfilename();
@@ -898,6 +903,9 @@ namespace XBMCAddon
       /// Returns the path of this listitem.
       ///
       /// @return [string] filename
+      ///-----------------------------------------------------------------------
+      /// @python_v17 New function added.
+      ///
       ///
       getPath();
 #else
diff --git a/xbmc/interfaces/legacy/ModuleXbmc.h b/xbmc/interfaces/legacy/ModuleXbmc.h
index ee9c171..f327238 100644
--- a/xbmc/interfaces/legacy/ModuleXbmc.h
+++ b/xbmc/interfaces/legacy/ModuleXbmc.h
@@ -80,6 +80,7 @@ namespace XBMCAddon
     ///
     ///
     /// ------------------------------------------------------------------------
+    /// @python_v17 Default level changed from LOGNOTICE to LOGDEBUG
     ///
     /// **Example:**
     /// ~~~~~~~~~~~~~{.py}
diff --git a/xbmc/interfaces/legacy/Monitor.h b/xbmc/interfaces/legacy/Monitor.h
index f551486..22ac999 100644
--- a/xbmc/interfaces/legacy/Monitor.h
+++ b/xbmc/interfaces/legacy/Monitor.h
@@ -154,6 +154,8 @@ namespace XBMCAddon
       ///
       /// @note Will be called when library clean has ended and return video or
       /// music to indicate which library is being scanned
+      ///-----------------------------------------------------------------------
+      /// @python_v14 New function added.
       ///
       onScanStarted(...);
 #else
@@ -172,6 +174,8 @@ namespace XBMCAddon
       ///
       /// @note Will be called when library clean has ended and return video or
       /// music to indicate which library has been scanned
+      ///-----------------------------------------------------------------------
+      /// @python_v14 New function added.
       ///
       onScanFinished(...);
 #else
@@ -183,7 +187,7 @@ namespace XBMCAddon
       /// \ingroup python_monitor
       /// @brief \python_func{ onDatabaseScanStarted(database) }
       ///-----------------------------------------------------------------------
-      /// @warning Deprecated, use onScanStarted().
+      /// @python_v14 Deprecated. Use **onScanStarted()**.
       ///
       onDatabaseScanStarted(...);
 #else
@@ -195,7 +199,7 @@ namespace XBMCAddon
       /// \ingroup python_monitor
       /// @brief \python_func{ onDatabaseUpdated(database) }
       ///-----------------------------------------------------------------------
-      /// @warning Deprecated, use onScanFinished().
+      /// @python_v14 Deprecated. Use **onScanFinished()**.
       ///
       onDatabaseUpdated(...);
 #else
@@ -243,7 +247,7 @@ namespace XBMCAddon
       /// \ingroup python_monitor
       /// @brief \python_func{ onAbortRequested() }
       ///-----------------------------------------------------------------------
-      /// @warning Deprecated, use waitForAbort() to be notified about this event.
+      /// @python_v14 Deprecated. Use **waitForAbort()** to be notified about this event.
       ///
       onAbortRequested();
 #else
@@ -285,6 +289,8 @@ namespace XBMCAddon
       /// @return                        True when abort have been requested,
       ///                                False if a timeout is given and the
       ///                                operation times out.
+      ///-----------------------------------------------------------------------
+      /// @python_v14 New function added.
       ///
       waitForAbort(...);
 #else
diff --git a/xbmc/interfaces/legacy/Player.h b/xbmc/interfaces/legacy/Player.h
index 29ee6fc..4d97d76 100644
--- a/xbmc/interfaces/legacy/Player.h
+++ b/xbmc/interfaces/legacy/Player.h
@@ -501,6 +501,16 @@ namespace XBMCAddon
 #ifdef DOXYGEN_SHOULD_USE_THIS
       ///
       /// \ingroup python_Player
+      /// @brief \python_func{ DisableSubtitles() }
+      ///-----------------------------------------------------------------------
+      /// @python_v12 Deprecated. Use **showSubtitles** instead.
+      /// @python_v17 Completely removed function.
+      ///
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_Player
       /// @brief \python_func{ getSubtitles() }
       ///-----------------------------------------------------------------------
       /// Get subtitle stream name.
diff --git a/xbmc/interfaces/legacy/RenderCapture.h b/xbmc/interfaces/legacy/RenderCapture.h
index 6c7aa45..1f85539 100644
--- a/xbmc/interfaces/legacy/RenderCapture.h
+++ b/xbmc/interfaces/legacy/RenderCapture.h
@@ -121,6 +121,8 @@ namespace XBMCAddon
       /// Get image format
       ///
       /// @return                        Format of captured image: 'BGRA'
+      ///-----------------------------------------------------------------------
+      /// @python_v17 Image will now always be returned in BGRA 
       ///
       getImageFormat()
 #else
@@ -142,6 +144,8 @@ namespace XBMCAddon
       /// @return                    Captured image as a bytearray
       ///
       /// @note The size of the image is m_width * m_height * 4
+      ///-----------------------------------------------------------------------
+      /// @python_v17 Added the option to specify wait time in msec.
       ///
       getImage(...)
 #else
@@ -164,6 +168,8 @@ namespace XBMCAddon
       ///
       /// @param width               Width capture image should be rendered to
       /// @param height              Height capture image should should be rendered to
+      ///-----------------------------------------------------------------------
+      /// @python_v17 Removed the option to pass **flags**
       ///
       capture(...)
 #else
@@ -182,6 +188,24 @@ namespace XBMCAddon
         g_application.m_pPlayer->RenderCapture(m_captureId, m_width, m_height, CAPTUREFLAG_CONTINUOUS);
       }
 
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmc_RenderCapture
+      /// @brief \python_func{ getCaptureState() }
+      ///-----------------------------------------------------------------------
+      /// @python_v17 Removed function completely.
+      ///
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmc_RenderCapture
+      /// @brief \python_func{ waitForCaptureStateChangeEvent() }
+      ///-----------------------------------------------------------------------
+      /// @python_v17 Removed function completely.
+      ///
+#endif
+
 // hide these from swig
 #ifndef SWIG
       inline bool GetPixels(unsigned int msec)
diff --git a/xbmc/interfaces/legacy/Stat.h b/xbmc/interfaces/legacy/Stat.h
index 99c3abe..bdc643e 100644
--- a/xbmc/interfaces/legacy/Stat.h
+++ b/xbmc/interfaces/legacy/Stat.h
@@ -43,6 +43,7 @@ namespace XBMCAddon
     ///
     ///
     /// ------------------------------------------------------------------------
+    /// @python_v12 New function added
     ///
     /// **Example:**
     /// ~~~~~~~~~~~~~{.py}
diff --git a/xbmc/interfaces/legacy/WindowXML.h b/xbmc/interfaces/legacy/WindowXML.h
index d2fa2c7..48124c0 100644
--- a/xbmc/interfaces/legacy/WindowXML.h
+++ b/xbmc/interfaces/legacy/WindowXML.h
@@ -335,6 +335,7 @@ namespace XBMCAddon
       ///
       ///
       /// ------------------------------------------------------------------------
+      /// @python_v17 Changed function from **setProperty** to **setContainerProperty**.
       ///
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
@@ -348,16 +349,27 @@ namespace XBMCAddon
       SWIGHIDDENVIRTUAL void setContainerProperty(const String &strProperty, const String &strValue);
 #endif
 
-      /**
-       * getCurrentContainerId() -- Get the id of the currently visible container
-       * 
-       * 
-       * example:\n
-       *   - container_id = self.getCurrentContainerId()
-       */
-
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmcgui_window_xml
+      /// @brief \python_func{ getCurrentContainerId() }
+      ///-----------------------------------------------------------------------
+      /// Get the id of the currently visible container.
+      ///
+      /// ------------------------------------------------------------------------
+      /// @python_v17 Added new function.
+      ///
+      /// **Example:**
+      /// ~~~~~~~~~~~~~{.py}
+      /// ..
+      /// container_id = self.getCurrentContainerId()
+      /// ..
+      /// ~~~~~~~~~~~~~
+      ///
+      getCurrentContainerId(...);
+#else
       SWIGHIDDENVIRTUAL int getCurrentContainerId();
-
+#endif
 
 #ifndef SWIG
       // CGUIWindow
-- 
2.7.4


From 762e0526396e190cd39042ffc7bc4914e88a6a58 Mon Sep 17 00:00:00 2001
From: "Chris \\\"Koying\\\" Browet" <cbro@semperpax.com>
Date: Sat, 8 Oct 2016 10:57:47 +0200
Subject: [PATCH 050/175] FIX: [gles;oes] confusion between field and index

---
 .../VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodec.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodec.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodec.cpp
index 8a12340..4afed03 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodec.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodec.cpp
@@ -143,16 +143,16 @@ bool CRendererMediaCodec::RenderHook(int index)
   glActiveTexture(GL_TEXTURE0);
   glBindTexture(GL_TEXTURE_EXTERNAL_OES, plane.id);
 
-  if (index != FIELD_FULL)
+  if (m_currentField != FIELD_FULL)
   {
     g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA_BOB_OES);
     GLint   fieldLoc = g_Windowing.GUIShaderGetField();
     GLint   stepLoc = g_Windowing.GUIShaderGetStep();
 
     // Y is inverted, so invert fields
-    if     (index == FIELD_TOP)
+    if     (m_currentField == FIELD_TOP)
       glUniform1i(fieldLoc, 0);
-    else if(index == FIELD_BOT)
+    else if(m_currentField == FIELD_BOT)
       glUniform1i(fieldLoc, 1);
     glUniform1f(stepLoc, 1.0f / (float)plane.texheight);
   }
@@ -190,7 +190,7 @@ bool CRendererMediaCodec::RenderHook(int index)
   }
 
   // Set texture coordinates (MediaCodec is flipped in y)
-  if (index == FIELD_FULL)
+  if (m_currentField == FIELD_FULL)
   {
     tex[0][0] = tex[3][0] = plane.rect.x1;
     tex[0][1] = tex[1][1] = plane.rect.y2;
-- 
2.7.4


From 95a9e5ee4349d11600c57c51bc802bd89c60da12 Mon Sep 17 00:00:00 2001
From: Martijn Kaijser <mcm.kaijser@gmail.com>
Date: Sat, 8 Oct 2016 12:15:40 +0200
Subject: [PATCH 051/175] AMC: align allowed ref with player

---
 .../VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp      | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp
index 6f9ee78..a4cae0a 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp
@@ -885,7 +885,7 @@ double CDVDVideoCodecAndroidMediaCodec::GetTimeSize(void)
 
 unsigned CDVDVideoCodecAndroidMediaCodec::GetAllowedReferences()
 {
-  return 3;
+  return 4;
 }
 
 void CDVDVideoCodecAndroidMediaCodec::FlushInternal()
-- 
2.7.4


From c927e654ee5aac2b89e56bb28955030d22fa2ec4 Mon Sep 17 00:00:00 2001
From: Martijn Kaijser <martijn@xbmc.org>
Date: Sat, 8 Oct 2016 15:14:07 +0200
Subject: [PATCH 052/175] clarify checkbox uasge in PR template

---
 PULL_REQUEST_TEMPLATE.md | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/PULL_REQUEST_TEMPLATE.md b/PULL_REQUEST_TEMPLATE.md
index 85b7ee8..5738daf 100644
--- a/PULL_REQUEST_TEMPLATE.md
+++ b/PULL_REQUEST_TEMPLATE.md
@@ -15,17 +15,17 @@
 ## Screenshots (if appropriate):
 
 ## Types of change
-<!--- What type of change does your code introduce? Put an `x` in all the boxes that apply: -->
+<!--- What type of change does your code introduce? Put an `x` in all the boxes that apply like this: [X] -->
 - [ ] Bug fix (non-breaking change which fixes an issue)
 - [ ] New feature (non-breaking change which adds functionality)
 - [ ] Breaking change (fix or feature that would cause existing functionality to change)
 
 ## Checklist:
-<!--- Go over all the following points, and put an `x` in all the boxes that apply -->
+<!--- Go over all the following points, and put an `x` in all the boxes that apply like this: [X] -->
 <!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->
 - [ ] My code follows the [Code guidelines](https://codedocs.xyz/xbmc/xbmc/code_guidelines.html) of this project 
 - [ ] My change requires a change to the documentation, either Doxygen or wiki
 - [ ] I have updated the documentation accordingly
 - [ ] I have read the [CONTRIBUTING](https://github.com/xbmc/xbmc/blob/master/CONTRIBUTING.md) document
 - [ ] I have added tests to cover my change
-- [ ] All new and existing tests passed
\ No newline at end of file
+- [ ] All new and existing tests passed
-- 
2.7.4


From 887da7699223b30105a0bb4280c10ccbfe18ac24 Mon Sep 17 00:00:00 2001
From: peak3d <pfau@peak3d.de>
Date: Sat, 8 Oct 2016 21:00:45 +0200
Subject: [PATCH 053/175] support reusing of CFile::m_pFile

---
 xbmc/filesystem/CurlFile.cpp |  6 ++++++
 xbmc/filesystem/CurlFile.h   |  1 +
 xbmc/filesystem/File.cpp     | 17 +++++++++++++++++
 xbmc/filesystem/File.h       | 17 +++++++++++++++--
 xbmc/filesystem/IFile.h      |  1 +
 xbmc/filesystem/IFileTypes.h |  3 +++
 6 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/xbmc/filesystem/CurlFile.cpp b/xbmc/filesystem/CurlFile.cpp
index a0b2ef2..aac70bf 100644
--- a/xbmc/filesystem/CurlFile.cpp
+++ b/xbmc/filesystem/CurlFile.cpp
@@ -1196,6 +1196,12 @@ bool CCurlFile::CReadState::ReadString(char *szLine, int iLineLength)
   return (bool)((pLine - szLine) > 0);
 }
 
+bool CCurlFile::ReOpen(const CURL& url)
+{
+  Close();
+  return Open(url);
+}
+
 bool CCurlFile::Exists(const CURL& url)
 {
   // if file is already running, get info from it
diff --git a/xbmc/filesystem/CurlFile.h b/xbmc/filesystem/CurlFile.h
index 9fedd55..d65b843 100644
--- a/xbmc/filesystem/CurlFile.h
+++ b/xbmc/filesystem/CurlFile.h
@@ -51,6 +51,7 @@ namespace XFILE
       virtual ~CCurlFile();
       virtual bool Open(const CURL& url);
       virtual bool OpenForWrite(const CURL& url, bool bOverWrite = false);
+      virtual bool ReOpen(const CURL& url);
       virtual bool Exists(const CURL& url);
       virtual int64_t  Seek(int64_t iFilePosition, int iWhence=SEEK_SET);
       virtual int64_t GetPosition();
diff --git a/xbmc/filesystem/File.cpp b/xbmc/filesystem/File.cpp
index 27fcd55..c41db03 100644
--- a/xbmc/filesystem/File.cpp
+++ b/xbmc/filesystem/File.cpp
@@ -254,6 +254,19 @@ bool CFile::Open(const std::string& strFileName, const unsigned int flags)
 
 bool CFile::Open(const CURL& file, const unsigned int flags)
 {
+  if (m_pFile)
+  {
+    if ((flags & READ_REOPEN) == 0)
+    {
+      CLog::Log(LOGERROR, "File::Open - already open: %s", file.GetRedacted().c_str());
+      return false;      
+    }
+    else
+    {
+      return m_pFile->ReOpen(URIUtils::SubstitutePath(file));
+    }
+  }
+
   m_flags = flags;
   try
   {
@@ -280,6 +293,10 @@ bool CFile::Open(const CURL& file, const unsigned int flags)
       {
         // for internet stream, if it contains multiple stream, file cache need handle it specially.
         m_pFile = new CFileCache(m_flags);
+
+        if (!m_pFile)
+          return false;
+
         return m_pFile->Open(url);
       }
     }
diff --git a/xbmc/filesystem/File.h b/xbmc/filesystem/File.h
index 272ec25..30f3896 100644
--- a/xbmc/filesystem/File.h
+++ b/xbmc/filesystem/File.h
@@ -64,12 +64,25 @@ public:
   bool CURLAddOption(XFILE::CURLOPTIONTYPE type, const char* name, const char * value);
   bool CURLOpen(unsigned int flags);
 
+  /**
+  * Attempt to open an IFile instance.
+  * @param file reference to CCurl file description
+  * @param flags see IFileTypes.h
+  * @return true on success, false otherwise
+  *
+  * Remarks: Open can only be called once. Calling
+  * Open() on an already opened file will fail
+  * exept flag READ_REOPEN is set and the underlying
+  * file has an implementation of ReOpen().
+  */
   bool Open(const CURL& file, const unsigned int flags = 0);
+  bool Open(const std::string& strFileName, const unsigned int flags = 0);
+
   bool OpenForWrite(const CURL& file, bool bOverWrite = false);
+  bool OpenForWrite(const std::string& strFileName, bool bOverWrite = false);
+
   ssize_t LoadFile(const CURL &file, auto_buffer& outputBuffer);
 
-  bool Open(const std::string& strFileName, const unsigned int flags = 0);
-  bool OpenForWrite(const std::string& strFileName, bool bOverWrite = false);
   /**
    * Attempt to read bufSize bytes from currently opened file into buffer bufPtr.
    * @param bufPtr  pointer to buffer
diff --git a/xbmc/filesystem/IFile.h b/xbmc/filesystem/IFile.h
index 36bb37c..49307d1 100644
--- a/xbmc/filesystem/IFile.h
+++ b/xbmc/filesystem/IFile.h
@@ -61,6 +61,7 @@ public:
 
   virtual bool Open(const CURL& url) = 0;
   virtual bool OpenForWrite(const CURL& url, bool bOverWrite = false) { return false; };
+  virtual bool ReOpen(const CURL& url) { return false; };
   virtual bool Exists(const CURL& url) = 0;
   /**
    * Fills struct __stat64 with information about file specified by url.
diff --git a/xbmc/filesystem/IFileTypes.h b/xbmc/filesystem/IFileTypes.h
index 4c6dd98..7cafa2c 100644
--- a/xbmc/filesystem/IFileTypes.h
+++ b/xbmc/filesystem/IFileTypes.h
@@ -49,6 +49,9 @@ namespace XFILE
 /* indicate that caller will do write operations before reading  */
   static const unsigned int READ_AFTER_WRITE = 0x80;
 
+/* indicate that caller want to reopen a file if its already open  */
+  static const unsigned int READ_REOPEN = 0x100;
+
 struct SNativeIoControl
 {
   unsigned long int   request;
-- 
2.7.4


From cf7b4d2570f518ea89f1b89ba69805689269fee6 Mon Sep 17 00:00:00 2001
From: "h.udo" <hudokkow@gmail.com>
Date: Sat, 8 Oct 2016 21:17:50 +0100
Subject: [PATCH 054/175] get_filename_component(... PATH) is deprecated. Use
 DIRECTORY instead

---
 project/cmake/addons/CMakeLists.txt                 | 2 +-
 project/cmake/addons/bootstrap/Bootstrap.cmake      | 2 +-
 project/cmake/addons/depends/windows/CMakeLists.txt | 2 +-
 project/cmake/modules/FindCpluff.cmake              | 2 +-
 project/cmake/scripts/common/HandleDepends.cmake    | 2 +-
 project/cmake/scripts/common/Macros.cmake           | 2 +-
 project/cmake/scripts/common/ProjectMacros.cmake    | 2 +-
 project/cmake/scripts/linux/Install.cmake           | 8 ++++----
 project/cmake/scripts/linux/Macros.cmake            | 2 +-
 project/cmake/scripts/osx/Macros.cmake              | 2 +-
 10 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/project/cmake/addons/CMakeLists.txt b/project/cmake/addons/CMakeLists.txt
index 8058576..60fe35a 100644
--- a/project/cmake/addons/CMakeLists.txt
+++ b/project/cmake/addons/CMakeLists.txt
@@ -245,7 +245,7 @@ foreach(addon ${addons})
       message(STATUS "\n-- ---- Configuring addon ${addon} ----")
       set(SUPPORTED_ADDON_FOUND TRUE)
 
-      get_filename_component(dir ${addon} PATH)
+      get_filename_component(dir ${addon} DIRECTORY)
 
       # check if the addon has a platforms.txt
       set(platform_found FALSE)
diff --git a/project/cmake/addons/bootstrap/Bootstrap.cmake b/project/cmake/addons/bootstrap/Bootstrap.cmake
index 25e8aa2..617b04e 100644
--- a/project/cmake/addons/bootstrap/Bootstrap.cmake
+++ b/project/cmake/addons/bootstrap/Bootstrap.cmake
@@ -30,7 +30,7 @@ foreach(ADDON_DEFINITION_FILE ${ADDON_DEFINITIONS})
     list(FIND ADDONS_TO_BUILD ${ADDON_ID} ADDONS_TO_BUILD_IDX)
     if(ADDONS_TO_BUILD_IDX GREATER -1 OR "${ADDONS_TO_BUILD}" STREQUAL "all")
       # get the path to the addon definition directory
-      get_filename_component(ADDON_DEFINITION_DIR ${ADDON_DEFINITION_FILE} PATH)
+      get_filename_component(ADDON_DEFINITION_DIR ${ADDON_DEFINITION_FILE} DIRECTORY)
 
       # install the addon definition
       message(STATUS "Bootstrapping ${ADDON_ID} addon...")
diff --git a/project/cmake/addons/depends/windows/CMakeLists.txt b/project/cmake/addons/depends/windows/CMakeLists.txt
index e4411dc..537cd66 100644
--- a/project/cmake/addons/depends/windows/CMakeLists.txt
+++ b/project/cmake/addons/depends/windows/CMakeLists.txt
@@ -39,7 +39,7 @@ file(GLOB_RECURSE download_input_files prebuilt/*.txt)
 foreach(file ${download_input_files})
   if(NOT file MATCHES install.txt)
     file(STRINGS ${file} def)
-    get_filename_component(dir ${file} PATH)
+    get_filename_component(dir ${file} DIRECTORY)
     separate_arguments(def)
     list(GET def 0 id)
 
diff --git a/project/cmake/modules/FindCpluff.cmake b/project/cmake/modules/FindCpluff.cmake
index 0e58869..fb2bb25 100644
--- a/project/cmake/modules/FindCpluff.cmake
+++ b/project/cmake/modules/FindCpluff.cmake
@@ -8,7 +8,7 @@
 
 if(NOT WIN32)
   string(REPLACE ";" " " defines "${CMAKE_C_FLAGS} ${SYSTEM_DEFINES} -I${EXPAT_INCLUDE_DIR}")
-  get_filename_component(expat_dir ${EXPAT_LIBRARY} PATH)
+  get_filename_component(expat_dir ${EXPAT_LIBRARY} DIRECTORY)
   set(ldflags "-L${expat_dir}")
   ExternalProject_Add(libcpluff SOURCE_DIR ${CORE_SOURCE_DIR}/lib/cpluff
                       BUILD_IN_SOURCE 1
diff --git a/project/cmake/scripts/common/HandleDepends.cmake b/project/cmake/scripts/common/HandleDepends.cmake
index 4aca6ba..2398705 100644
--- a/project/cmake/scripts/common/HandleDepends.cmake
+++ b/project/cmake/scripts/common/HandleDepends.cmake
@@ -21,7 +21,7 @@ function(add_addon_depends addon searchpath)
       file(STRINGS ${file} def)
       separate_arguments(def)
       list(LENGTH def deflength)
-      get_filename_component(dir ${file} PATH)
+      get_filename_component(dir ${file} DIRECTORY)
 
       # get the id of the dependency
       if(NOT "${def}" STREQUAL "")
diff --git a/project/cmake/scripts/common/Macros.cmake b/project/cmake/scripts/common/Macros.cmake
index b30dfab..71c39ef 100644
--- a/project/cmake/scripts/common/Macros.cmake
+++ b/project/cmake/scripts/common/Macros.cmake
@@ -36,7 +36,7 @@ function(source_group_by_folder target)
       set(file ${CMAKE_CURRENT_SOURCE_DIR}/${file})
     endif()
     file(RELATIVE_PATH relative_file ${relative_dir} ${file})
-    get_filename_component(dir "${relative_file}" PATH)
+    get_filename_component(dir "${relative_file}" DIRECTORY)
     if(NOT dir STREQUAL "${last_dir}")
       if(files)
         source_group("${last_dir}" FILES ${files})
diff --git a/project/cmake/scripts/common/ProjectMacros.cmake b/project/cmake/scripts/common/ProjectMacros.cmake
index 653382c..e73ef90 100644
--- a/project/cmake/scripts/common/ProjectMacros.cmake
+++ b/project/cmake/scripts/common/ProjectMacros.cmake
@@ -8,7 +8,7 @@
 #   xbt is added to ${XBT_FILES}
 function(pack_xbt input output)
   file(GLOB_RECURSE MEDIA_FILES ${input}/*)
-  get_filename_component(dir ${output} PATH)
+  get_filename_component(dir ${output} DIRECTORY)
   add_custom_command(OUTPUT  ${output}
                      COMMAND ${CMAKE_COMMAND} -E make_directory ${dir}
                      COMMAND TexturePacker::TexturePacker
diff --git a/project/cmake/scripts/linux/Install.cmake b/project/cmake/scripts/linux/Install.cmake
index fac75ed..5b2e3df 100644
--- a/project/cmake/scripts/linux/Install.cmake
+++ b/project/cmake/scripts/linux/Install.cmake
@@ -61,7 +61,7 @@ install(PROGRAMS ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/scripts/${APP_NAME_LC}
 
 # Install libraries
 foreach(library ${LIBRARY_FILES})
-  get_filename_component(dir ${library} PATH)
+  get_filename_component(dir ${library} DIRECTORY)
   string(REPLACE "${CMAKE_BINARY_DIR}/" "" dir ${dir})
   install(PROGRAMS ${library}
           DESTINATION ${libdir}/${APP_NAME_LC}/${dir}
@@ -71,7 +71,7 @@ endforeach()
 # Install add-ons, fonts, icons, keyboard maps, keymaps, etc
 # (addons, media, system, userdata folders in share/kodi/)
 foreach(file ${install_data})
-  get_filename_component(dir ${file} PATH)
+  get_filename_component(dir ${file} DIRECTORY)
   install(FILES ${CMAKE_BINARY_DIR}/${file}
           DESTINATION ${datarootdir}/${APP_NAME_LC}/${dir}
           COMPONENT kodi)
@@ -309,7 +309,7 @@ install(FILES ${CORE_SOURCE_DIR}/xbmc/addons/kodi-addon-dev-kit/include/kodi/kod
 # Install XBT skin files
 foreach(texture ${XBT_FILES})
   string(REPLACE "${CMAKE_BINARY_DIR}/" "" dir ${texture})
-  get_filename_component(dir ${dir} PATH)
+  get_filename_component(dir ${dir} DIRECTORY)
   install(FILES ${texture}
           DESTINATION ${datarootdir}/${APP_NAME_LC}/${dir}
           COMPONENT kodi)
@@ -321,7 +321,7 @@ if(EXISTS ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/extra-installs)
               foreach(dir \${dirs})
                 file(GLOB_RECURSE FILES RELATIVE ${CMAKE_BINARY_DIR} \${dir}/*)
                 foreach(file \${FILES})
-                  get_filename_component(dir \${file} PATH)
+                  get_filename_component(dir \${file} DIRECTORY)
                   file(INSTALL \${file} DESTINATION ${datarootdir}/${APP_NAME_LC}/\${dir})
                 endforeach()
               endforeach()")
diff --git a/project/cmake/scripts/linux/Macros.cmake b/project/cmake/scripts/linux/Macros.cmake
index 2c89eab..0bd7657 100644
--- a/project/cmake/scripts/linux/Macros.cmake
+++ b/project/cmake/scripts/linux/Macros.cmake
@@ -31,7 +31,7 @@ function(core_link_library lib wraplib)
     set(extra_libs ${data_arg})
   endif()
 
-  get_filename_component(dir ${wraplib} PATH)
+  get_filename_component(dir ${wraplib} DIRECTORY)
   add_custom_command(OUTPUT ${CMAKE_BINARY_DIR}/${wraplib}-${ARCH}${CMAKE_SHARED_MODULE_SUFFIX}
                      COMMAND cmake -E make_directory ${dir}
                      COMMAND ${CMAKE_C_COMPILER}
diff --git a/project/cmake/scripts/osx/Macros.cmake b/project/cmake/scripts/osx/Macros.cmake
index 7aed2ac..54580cd 100644
--- a/project/cmake/scripts/osx/Macros.cmake
+++ b/project/cmake/scripts/osx/Macros.cmake
@@ -33,7 +33,7 @@ function(core_link_library lib wraplib)
   elseif(check_arg STREQUAL archives)
     set(extra_libs ${data_arg})
   endif()
-  get_filename_component(dir ${wraplib} PATH)
+  get_filename_component(dir ${wraplib} DIRECTORY)
 
   # We can't simply pass the linker flags to the args section of the custom command
   # because cmake will add quotes around it (and the linker will fail due to those).
-- 
2.7.4


From 6aa24df5261820419bb800660195745af4145b1e Mon Sep 17 00:00:00 2001
From: peak3d <pfau@peak3d.de>
Date: Sat, 8 Oct 2016 23:33:28 +0200
Subject: [PATCH 055/175] DynamicDlls are not system-dll's

---
 xbmc/cores/DllLoader/DllLoaderContainer.cpp | 2 +-
 xbmc/cores/DllLoader/Win32DllLoader.cpp     | 7 +++----
 xbmc/cores/DllLoader/Win32DllLoader.h       | 2 +-
 3 files changed, 5 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/DllLoader/DllLoaderContainer.cpp b/xbmc/cores/DllLoader/DllLoaderContainer.cpp
index 2d11a70..aa4e55c 100644
--- a/xbmc/cores/DllLoader/DllLoaderContainer.cpp
+++ b/xbmc/cores/DllLoader/DllLoaderContainer.cpp
@@ -251,7 +251,7 @@ LibraryLoader* DllLoaderContainer::LoadDll(const char* sName, bool bLoadSymbols)
 #ifdef TARGET_POSIX
   pLoader = new SoLoader(sName, bLoadSymbols);
 #elif defined(TARGET_WINDOWS)
-  pLoader = new Win32DllLoader(sName);
+  pLoader = new Win32DllLoader(sName, false);
 #else
   pLoader = new DllLoader(sName, m_bTrack, false, bLoadSymbols);
 #endif
diff --git a/xbmc/cores/DllLoader/Win32DllLoader.cpp b/xbmc/cores/DllLoader/Win32DllLoader.cpp
index 9db3216..6be805d 100644
--- a/xbmc/cores/DllLoader/Win32DllLoader.cpp
+++ b/xbmc/cores/DllLoader/Win32DllLoader.cpp
@@ -132,10 +132,11 @@ Export win32_exports[] =
   { NULL,                          -1, NULL,                                NULL }
 };
 
-Win32DllLoader::Win32DllLoader(const std::string& dll) : LibraryLoader(dll)
+Win32DllLoader::Win32DllLoader(const std::string& dll, bool isSystemDll)
+  : LibraryLoader(dll)
+  , bIsSystemDll(isSystemDll)
 {
   m_dllHandle = NULL;
-  bIsSystemDll = false;
   DllLoaderContainer::RegisterDll(this);
 }
 
@@ -180,8 +181,6 @@ bool Win32DllLoader::Load()
   // handle functions that the dll imports
   if (NeedsHooking(strFileName.c_str()))
     OverrideImports(strFileName);
-  else
-    bIsSystemDll = true;
 
   return true;
 }
diff --git a/xbmc/cores/DllLoader/Win32DllLoader.h b/xbmc/cores/DllLoader/Win32DllLoader.h
index e421293..6dd210d 100644
--- a/xbmc/cores/DllLoader/Win32DllLoader.h
+++ b/xbmc/cores/DllLoader/Win32DllLoader.h
@@ -34,7 +34,7 @@ public:
     DWORD function;
   };
 
-  Win32DllLoader(const std::string& dll);
+  Win32DllLoader(const std::string& dll, bool isSystemDll);
   ~Win32DllLoader();
 
   virtual bool Load();
-- 
2.7.4


From 73c531c003ba3bc8ca5cb7740f1241474e314315 Mon Sep 17 00:00:00 2001
From: ronie <ronie@users.noreply.github.com>
Date: Sun, 9 Oct 2016 01:01:37 +0200
Subject: [PATCH 056/175] update python listitem documentation

---
 xbmc/interfaces/legacy/ListItem.h | 47 +++++++++++++++++++++++----------------
 1 file changed, 28 insertions(+), 19 deletions(-)

diff --git a/xbmc/interfaces/legacy/ListItem.h b/xbmc/interfaces/legacy/ListItem.h
index 87ea93b..3b0bc4c 100644
--- a/xbmc/interfaces/legacy/ListItem.h
+++ b/xbmc/interfaces/legacy/ListItem.h
@@ -68,6 +68,15 @@ namespace XBMCAddon
     /// @param thumbnailImage       __Deprecated. Use setArt__
     /// @param path                 [opt] string
     ///
+    ///
+    ///-----------------------------------------------------------------------
+    ///
+    /// **Example:**
+    /// ~~~~~~~~~~~~~{.py}
+    /// ...
+    /// listitem = xbmcgui.ListItem('Casino Royale')
+    /// ...
+    /// ~~~~~~~~~~~~~
     class ListItem : public AddonClass
     {
     public:
@@ -110,7 +119,7 @@ namespace XBMCAddon
       /// ~~~~~~~~~~~~~{.py}
       /// ...
       /// # getLabel()
-      /// label = self.list.getSelectedItem().getLabel()
+      /// label = listitem.getLabel()
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -135,7 +144,7 @@ namespace XBMCAddon
       /// ~~~~~~~~~~~~~{.py}
       /// ...
       /// # getLabel2()
-      /// label = self.list.getSelectedItem().getLabel2()
+      /// label = listitem.getLabel2()
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -160,7 +169,7 @@ namespace XBMCAddon
       /// ~~~~~~~~~~~~~{.py}
       /// ...
       /// # setLabel(label)
-      /// self.list.getSelectedItem().setLabel('Casino Royale')
+      /// listitem.setLabel('Casino Royale')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -185,7 +194,7 @@ namespace XBMCAddon
       /// ~~~~~~~~~~~~~{.py}
       /// ...
       /// # setLabel2(label)
-      /// self.list.getSelectedItem().setLabel2('Casino Royale')
+      /// listitem.setLabel2('Casino Royale')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -246,7 +255,7 @@ namespace XBMCAddon
       /// ~~~~~~~~~~~~~{.py}
       /// ...
       /// # setArt(values)
-      /// self.list.getSelectedItem().setArt({ 'poster': 'poster.png', 'banner' : 'banner.png' })
+      /// listitem.setArt({ 'poster': 'poster.png', 'banner' : 'banner.png' })
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -279,7 +288,7 @@ namespace XBMCAddon
       /// ~~~~~~~~~~~~~{.py}
       /// ...
       /// # setUniqueIDs(values)
-      /// self.list.getSelectedItem().setUniqueIDs({ 'imdb': 'tt8938399', 'tmdb' : '9837493' })
+      /// listitem.setUniqueIDs({ 'imdb': 'tt8938399', 'tmdb' : '9837493' })
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -315,7 +324,7 @@ namespace XBMCAddon
       /// ~~~~~~~~~~~~~{.py}
       /// ...
       /// # setRating(type, rating, votes, defaultt))
-      /// self.list.getSelectedItem().setRating("imdb", 4.6, 8940, True)
+      /// listitem.setRating("imdb", 4.6, 8940, True)
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -351,7 +360,7 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// poster = self.list.getSelectedItem().getArt('poster')
+      /// poster = listitem.getArt('poster')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -383,7 +392,7 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// uniqueID = self.list.getSelectedItem().getUniqueID('imdb')
+      /// uniqueID = listitem.getUniqueID('imdb')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -415,7 +424,7 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// rating = self.list.getSelectedItem().getRating('imdb')
+      /// rating = listitem.getRating('imdb')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -447,7 +456,7 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// votes = self.list.getSelectedItem().getVotes('imdb')
+      /// votes = listitem.getVotes('imdb')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -473,7 +482,7 @@ namespace XBMCAddon
       /// ~~~~~~~~~~~~~{.py}
       /// ...
       /// # select(selected)
-      /// self.list.getSelectedItem().select(True)
+      /// listitem.select(True)
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -499,7 +508,7 @@ namespace XBMCAddon
       /// ~~~~~~~~~~~~~{.py}
       /// ...
       /// # isSelected()
-      /// is = self.list.getSelectedItem().isSelected()
+      /// selected = listitem.isSelected()
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -620,7 +629,7 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// self.list.getSelectedItem().setInfo('video', { 'genre': 'Comedy' })
+      /// listitem.setInfo('video', { 'genre': 'Comedy' })
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -667,7 +676,7 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// self.list.getSelectedItem().addStreamInfo('video', { 'codec': 'h264', 'width' : 1280 })
+      /// listitem.addStreamInfo('video', { 'codec': 'h264', 'width' : 1280 })
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -733,8 +742,8 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// self.list.getSelectedItem().setProperty('AspectRatio', '1.85 : 1')
-      /// self.list.getSelectedItem().setProperty('StartOffset', '256.4')
+      /// listitem.setProperty('AspectRatio', '1.85 : 1')
+      /// listitem.setProperty('StartOffset', '256.4')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -762,7 +771,7 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// AspectRatio = self.list.getSelectedItem().getProperty('AspectRatio')
+      /// AspectRatio = listitem.getProperty('AspectRatio')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
@@ -788,7 +797,7 @@ namespace XBMCAddon
       /// **Example:**
       /// ~~~~~~~~~~~~~{.py}
       /// ...
-      /// self.list.getSelectedItem().setPath(path='/path/to/some/file.ext')
+      /// listitem.setPath(path='/path/to/some/file.ext')
       /// ...
       /// ~~~~~~~~~~~~~
       ///
-- 
2.7.4


From 6a2721881c95732156edad60b00275bc83391179 Mon Sep 17 00:00:00 2001
From: BigNoid <big.noid@kodi.tv>
Date: Sun, 9 Oct 2016 08:59:04 +0200
Subject: [PATCH 057/175] make onclick override conditional. Fallback to
 default action if no condition is met.

---
 xbmc/guilib/GUIBaseContainer.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/guilib/GUIBaseContainer.cpp b/xbmc/guilib/GUIBaseContainer.cpp
index fd4b096..7b833d7 100644
--- a/xbmc/guilib/GUIBaseContainer.cpp
+++ b/xbmc/guilib/GUIBaseContainer.cpp
@@ -762,7 +762,7 @@ bool CGUIBaseContainer::OnClick(int actionID)
       int selected = GetSelectedItem();
       if (selected >= 0 && selected < (int)m_items.size())
       {
-        if (m_clickActions.HasAnyActions())
+        if (m_clickActions.HasActionsMeetingCondition())
           m_clickActions.ExecuteActions(0, GetParentID(), m_items[selected]);
         else
           m_listProvider->OnClick(m_items[selected]);
-- 
2.7.4


From 1271ee6e74b23a3f409df48b97c44e9a6c221310 Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Sat, 8 Oct 2016 15:32:25 +0100
Subject: [PATCH 058/175] Add explicit ordering on song join songartist queries

---
 xbmc/interfaces/json-rpc/schema/version.txt | 2 +-
 xbmc/music/MusicDatabase.cpp                | 9 ++++++---
 2 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/xbmc/interfaces/json-rpc/schema/version.txt b/xbmc/interfaces/json-rpc/schema/version.txt
index 7ffe909..7725c34 100644
--- a/xbmc/interfaces/json-rpc/schema/version.txt
+++ b/xbmc/interfaces/json-rpc/schema/version.txt
@@ -1 +1 @@
-7.22.1
\ No newline at end of file
+7.22.2
\ No newline at end of file
diff --git a/xbmc/music/MusicDatabase.cpp b/xbmc/music/MusicDatabase.cpp
index ad5afcb..9410245 100644
--- a/xbmc/music/MusicDatabase.cpp
+++ b/xbmc/music/MusicDatabase.cpp
@@ -2485,10 +2485,11 @@ bool CMusicDatabase::GetRecentlyPlayedAlbumSongs(const std::string& strBaseDir,
       return false;
 
     std::string strSQL = PrepareSQL("SELECT songview.*, songartistview.* FROM "
-      "(SELECT idAlbum FROM albumview WHERE albumview.lastplayed IS NOT NULL "
+      "(SELECT idAlbum, lastPlayed FROM albumview WHERE albumview.lastplayed IS NOT NULL "
       "ORDER BY albumview.lastplayed DESC LIMIT %u) as playedalbums "
       "JOIN songview ON songview.idAlbum = playedalbums.idAlbum "
-      "JOIN songartistview ON songview.idSong = songartistview.idSong ", 
+      "JOIN songartistview ON songview.idSong = songartistview.idSong "
+      "ORDER BY playedalbums.lastplayed DESC,songartistview.idsong, songartistview.idRole, songartistview.iOrder",
       g_advancedSettings.m_iMusicLibraryRecentlyAddedItems);
     CLog::Log(LOGDEBUG,"GetRecentlyPlayedAlbumSongs() query: %s", strSQL.c_str());
     if (!m_pDS->query(strSQL)) return false;
@@ -2623,7 +2624,7 @@ bool CMusicDatabase::GetRecentlyAddedAlbumSongs(const std::string& strBaseDir, C
         "(SELECT idAlbum FROM album ORDER BY idAlbum DESC LIMIT %u) AS recentalbums " 
         "JOIN songview ON songview.idAlbum = recentalbums.idAlbum "
         "JOIN songartistview ON songview.idSong = songartistview.idSong "
-        "ORDER BY songview.idAlbum desc, songview.itrack, songartistview.iOrder ",
+        "ORDER BY songview.idAlbum DESC, songview.idSong, songartistview.idRole, songartistview.iOrder ",
         limit ? limit : g_advancedSettings.m_iMusicLibraryRecentlyAddedItems);
     CLog::Log(LOGDEBUG,"GetRecentlyAddedAlbumSongs() query: %s", strSQL.c_str());
     if (!m_pDS->query(strSQL)) return false;
@@ -4258,6 +4259,7 @@ bool CMusicDatabase::GetSongsFullByWhere(const std::string &baseDir, const Filte
     if (artistData)
     { // Get data from song and song_artist tables to fully populate songs with artists
       // All songs now have at least one artist so inner join sufficient
+      // Need guaranteed ordering for dataset processing to extract songs
       if (limited)
         //Apply where clause and limits to songview, then join as mutiple records in result set per song
         strSQL = "SELECT sv.*, songartistview.* "
@@ -4266,6 +4268,7 @@ bool CMusicDatabase::GetSongsFullByWhere(const std::string &baseDir, const Filte
       else
         strSQL = "SELECT songview.*, songartistview.* "
           "FROM songview JOIN songartistview ON songartistview.idsong = songview.idsong " + strSQLExtra;
+      strSQL += " ORDER BY songartistview.idsong, songartistview.idRole, songartistview.iOrder";
     }
     else
       strSQL = "SELECT songview.* FROM songview " + strSQLExtra;
-- 
2.7.4


From f1b442affd6b7443e5483fb6b7d5fb72b47aebc0 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 10:44:59 +0200
Subject: [PATCH 059/175] osx: yield to main loop after input action has been
 handled

---
 xbmc/windowing/WinEventsSDL.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinEventsSDL.cpp b/xbmc/windowing/WinEventsSDL.cpp
index b88f527..364f12c 100644
--- a/xbmc/windowing/WinEventsSDL.cpp
+++ b/xbmc/windowing/WinEventsSDL.cpp
@@ -220,7 +220,7 @@ bool CWinEventsSDL::MessagePump()
   SDL_Event event;
   bool ret = false;
 
-  while (SDL_PollEvent(&event))
+  while (!ret && SDL_PollEvent(&event))
   {
     switch(event.type)
     {
-- 
2.7.4


From 2eb635372c71604cc628981fbfb78d2fc35bbc51 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 10:52:01 +0200
Subject: [PATCH 060/175] X11: yield to main loop after input action has been
 handled

---
 xbmc/windowing/WinEventsX11.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index e638511..5890cea 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -316,7 +316,7 @@ bool CWinEventsX11Imp::MessagePump()
   XEvent xevent;
   unsigned long serial = 0;
 
-  while (WinEvents && XPending(WinEvents->m_display))
+  while (!ret && XPending(WinEvents->m_display))
   {
     memset(&xevent, 0, sizeof (XEvent));
     XNextEvent(WinEvents->m_display, &xevent);
-- 
2.7.4


From 6ad2dcc10da203fa3abbde0a0b2746596bd6ad40 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Fri, 23 Sep 2016 20:10:52 +0200
Subject: [PATCH 061/175] upgrade autotools for aarch64 depends build

---
 tools/depends/Makefile.include.in             |   4 +-
 tools/depends/build-aux/config.guess          | 502 +++++++++++---------------
 tools/depends/build-aux/config.sub            | 185 ++++++----
 tools/depends/configure.ac                    |  12 +
 tools/depends/native/autoconf-native/Makefile |   2 +-
 tools/depends/native/automake-native/Makefile |   2 +-
 6 files changed, 355 insertions(+), 352 deletions(-)

diff --git a/tools/depends/Makefile.include.in b/tools/depends/Makefile.include.in
index c023f96..61e2b23 100644
--- a/tools/depends/Makefile.include.in
+++ b/tools/depends/Makefile.include.in
@@ -38,8 +38,8 @@ BASE_URL=$(KODI_MIRROR)/build-deps/sources
 endif
 RETRIEVE_TOOL_FLAGS=-Ls --create-dirs -f -O
 ARCHIVE_TOOL_FLAGS=--strip-components=1 -xf
-CONFIG_SUB=@prefix@/@tool_dir@/share/automake-1.11/config.sub
-CONFIG_GUESS=@prefix@/@tool_dir@/share/automake-1.11/config.guess
+CONFIG_SUB=@prefix@/@tool_dir@/share/automake-1.15/config.sub
+CONFIG_GUESS=@prefix@/@tool_dir@/share/automake-1.15/config.guess
 
 RPL=@prefix@/@tool_dir@/bin/python @prefix@/@tool_dir@/bin/rpl
 
diff --git a/tools/depends/build-aux/config.guess b/tools/depends/build-aux/config.guess
index 49ba16f..c4bd827 100644
--- a/tools/depends/build-aux/config.guess
+++ b/tools/depends/build-aux/config.guess
@@ -1,14 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011, 2012 Free Software Foundation, Inc.
+#   Copyright 1992-2016 Free Software Foundation, Inc.
 
-timestamp='2012-01-01'
+timestamp='2016-05-15'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -17,26 +15,22 @@ timestamp='2012-01-01'
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner.  Please send patches (context
-# diff format) to <config-patches@gnu.org> and include a ChangeLog
-# entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+#
+# Please send patches to <config-patches@gnu.org>.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -56,9 +50,7 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-Free Software Foundation, Inc.
+Copyright 1992-2016 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -140,6 +132,27 @@ UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "${UNAME_SYSTEM}" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
@@ -155,19 +168,29 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    /sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || \
+	    echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
+		;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
+	# to ELF recently (or will in the future) and ABI.
 	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		os=netbsdelf
+		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
@@ -184,6 +207,13 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 		os=netbsd
 		;;
 	esac
+	# Determine ABI tags.
+	case "${UNAME_MACHINE_ARCH}" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo ${UNAME_MACHINE_ARCH} | sed -e "$expr"`
+		;;
+	esac
 	# The OS release
 	# Debian GNU/NetBSD machines have a different userland, and
 	# thus, need a distinct triplet. However, they do not need
@@ -194,18 +224,26 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 		release='-gnu'
 		;;
 	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		release=`echo ${UNAME_RELEASE} | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+	echo "${machine}-${os}${release}${abi}"
+	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
 	exit ;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
 	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
 	exit ;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-libertybsd${UNAME_RELEASE}
+	exit ;;
     *:ekkoBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
 	exit ;;
@@ -218,6 +256,9 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     *:MirBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
 	exit ;;
+    *:Sortix:*:*)
+	echo ${UNAME_MACHINE}-unknown-sortix
+	exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
@@ -234,42 +275,42 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
+		UNAME_MACHINE=alphaev5 ;;
 	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
+		UNAME_MACHINE=alphaev56 ;;
 	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
+		UNAME_MACHINE=alphapca56 ;;
 	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
+		UNAME_MACHINE=alphapca57 ;;
 	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
+		UNAME_MACHINE=alphaev6 ;;
 	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
+		UNAME_MACHINE=alphaev67 ;;
 	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
+		UNAME_MACHINE=alphaev69 ;;
 	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
+		UNAME_MACHINE=alphaev7 ;;
 	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
+		UNAME_MACHINE=alphaev79 ;;
 	esac
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
 	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
 	exitcode=$?
 	trap '' 0
@@ -304,7 +345,7 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
 	echo arm-unknown-riscos
 	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
@@ -342,16 +383,16 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	eval $set_cc_for_build
-	SUN_ARCH="i386"
+	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
-		SUN_ARCH="x86_64"
+		SUN_ARCH=x86_64
 	    fi
 	fi
 	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
@@ -376,7 +417,7 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
 	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	test "x${UNAME_RELEASE}" = x && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
 		echo m68k-sun-sunos${UNAME_RELEASE}
@@ -562,8 +603,9 @@ EOF
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
@@ -600,13 +642,13 @@ EOF
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
 		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
 		    case "${sc_cpu_version}" in
-		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
 			case "${sc_kernel_bits}" in
-			  32) HP_ARCH="hppa2.0n" ;;
-			  64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
 			esac ;;
 		    esac
 		fi
@@ -645,11 +687,11 @@ EOF
 		    exit (0);
 		}
 EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    (CCOPTS="" $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
+	if [ ${HP_ARCH} = hppa2.0w ]
 	then
 	    eval $set_cc_for_build
 
@@ -662,12 +704,12 @@ EOF
 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
 	    # => hppa64-hp-hpux11.23
 
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
 		grep -q __LP64__
 	    then
-		HP_ARCH="hppa2.0w"
+		HP_ARCH=hppa2.0w
 	    else
-		HP_ARCH="hppa64"
+		HP_ARCH=hppa64
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
@@ -772,14 +814,14 @@ EOF
 	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
 	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
 	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     5000:UNIX_System_V:4.*:*)
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
 	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
@@ -803,10 +845,13 @@ EOF
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
 	exit ;;
+    *:MINGW64*:*)
+	echo ${UNAME_MACHINE}-pc-mingw64
+	exit ;;
     *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
-    i*:MSYS*:*)
+    *:MSYS*:*)
 	echo ${UNAME_MACHINE}-pc-msys
 	exit ;;
     i*:windows32*:*)
@@ -854,15 +899,22 @@ EOF
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
+    aarch64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
@@ -874,59 +926,60 @@ EOF
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arm*:Linux:*:*)
 	eval $set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
 	    then
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
 	    else
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabihf
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
 	    fi
 	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     cris:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     crisv32:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
+	exit ;;
+    e2k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     frv:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     hexagon:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:Linux:*:*)
-	LIBC=gnu
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
-	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    k1om:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
@@ -945,54 +998,63 @@ EOF
 	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
-    or32:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-${LIBC}
+	exit ;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
+	echo sparc-unknown-linux-${LIBC}
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+	echo hppa64-unknown-linux-${LIBC}
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
+	echo powerpc64-unknown-linux-${LIBC}
 	exit ;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
+	echo powerpc-unknown-linux-${LIBC}
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-${LIBC}
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-${LIBC}
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
 	exit ;;
     sh64*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     tile*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
@@ -1068,7 +1130,7 @@ EOF
 	# uname -m prints for DJGPP always 'pc', but it prints nothing about
 	# the processor, so we play safe by assuming i586.
 	# Note: whatever this is, it MUST be the same as what config.sub
-	# prints for the "djgpp" host, or else GDB configury will decide that
+	# prints for the "djgpp" host, or else GDB configure will decide that
 	# this is a cross-build.
 	echo i586-pc-msdosdjgpp
 	exit ;;
@@ -1196,6 +1258,9 @@ EOF
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
 	echo i586-pc-haiku
 	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
 	exit ;;
@@ -1214,6 +1279,9 @@ EOF
     SX-8R:SUPER-UX:*:*)
 	echo sx8r-nec-superux${UNAME_RELEASE}
 	exit ;;
+    SX-ACE:SUPER-UX:*:*)
+	echo sxace-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
 	exit ;;
@@ -1222,24 +1290,36 @@ EOF
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    i386)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="x86_64"
-		  fi
-		fi ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
+	eval $set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		    (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
+	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
+	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
@@ -1251,7 +1331,7 @@ EOF
     NEO-?:NONSTOP_KERNEL:*:*)
 	echo neo-tandem-nsk${UNAME_RELEASE}
 	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
+    NSE-*:NONSTOP_KERNEL:*:*)
 	echo nse-tandem-nsk${UNAME_RELEASE}
 	exit ;;
     NSR-?:NONSTOP_KERNEL:*:*)
@@ -1270,7 +1350,7 @@ EOF
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	if test "$cputype" = "386"; then
+	if test "$cputype" = 386; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
@@ -1312,7 +1392,7 @@ EOF
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE} | sed -e 's/ .*$//'`
 	exit ;;
     i*86:rdos:*:*)
 	echo ${UNAME_MACHINE}-pc-rdos
@@ -1320,174 +1400,28 @@ EOF
     i*86:AROS:*:*)
 	echo ${UNAME_MACHINE}-pc-aros
 	exit ;;
-esac
-
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-	"4"
-#else
-	""
-#endif
-	); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
+    x86_64:VMkernel:*:*)
+	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
-    c34*)
-	echo c34-convex-bsd
+    amd64:Isilon\ OneFS:*:*)
+	echo x86_64-unknown-onefs
 	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
+esac
 
 cat >&2 <<EOF
 $0: unable to guess system type
 
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite
+config.guess and config.sub with the latest versions from:
 
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
diff --git a/tools/depends/build-aux/config.sub b/tools/depends/build-aux/config.sub
index d6b6b3c..a1f8229 100644
--- a/tools/depends/build-aux/config.sub
+++ b/tools/depends/build-aux/config.sub
@@ -1,38 +1,31 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011, 2012 Free Software Foundation, Inc.
+#   Copyright 1992-2016 Free Software Foundation, Inc.
 
-timestamp='2012-01-01'
+timestamp='2016-08-25'
 
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted GNU ChangeLog entry.
+# Please send patches to <config-patches@gnu.org>.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
@@ -40,7 +33,7 @@ timestamp='2012-01-01'
 # Otherwise, we print the canonical config type on stdout and succeed.
 
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
@@ -60,8 +53,7 @@ timestamp='2012-01-01'
 me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
+Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
 
 Canonicalize a configuration name.
 
@@ -75,9 +67,7 @@ Report bugs and patches to <config-patches@gnu.org>."
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
-Free Software Foundation, Inc.
+Copyright 1992-2016 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -125,13 +115,17 @@ esac
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
-  linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
-  knetbsd*-gnu* | netbsd*-gnu* | \
+  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \
   kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
+  android-linux)
+    os=-linux-android
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
+    ;;
   *)
     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
     if [ $basic_machine != $1 ]
@@ -154,7 +148,7 @@ case $os in
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray | -microblaze)
+	-apple | -axis | -knuth | -cray | -microblaze*)
 		os=
 		basic_machine=$1
 		;;
@@ -223,6 +217,12 @@ case $os in
 	-isc*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-lynx*178)
+		os=-lynxos178
+		;;
+	-lynx*5)
+		os=-lynxos5
+		;;
 	-lynx*)
 		os=-lynxos
 		;;
@@ -247,24 +247,29 @@ case $basic_machine in
 	# Some are omitted here because they have special meanings below.
 	1750a | 580 \
 	| a29k \
+	| aarch64 | aarch64_be \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
-        | be32 | be64 \
+	| arc | arceb \
+	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
+	| avr | avr32 \
+	| ba \
+	| be32 | be64 \
 	| bfin \
-	| c4x | clipper \
+	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| epiphany \
-	| fido | fr30 | frv \
+	| e2k | epiphany \
+	| fido | fr30 | frv | ft32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| hexagon \
 	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
+	| k1om \
 	| le32 | le64 \
 	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore | mep | metag \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
@@ -278,26 +283,29 @@ case $basic_machine in
 	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa32r6 | mipsisa32r6el \
 	| mipsisa64 | mipsisa64el \
 	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64r6 | mipsisa64r6el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipsr5900 | mipsr5900el \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
 	| moxie \
 	| mt \
 	| msp430 \
 	| nds32 | nds32le | nds32be \
-	| nios | nios2 \
+	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
-	| open8 \
-	| or32 \
+	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
+	| riscv32 | riscv64 \
 	| rl78 | rx \
 	| score \
-	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[234]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
@@ -305,6 +313,7 @@ case $basic_machine in
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
 	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| visium \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
@@ -319,7 +328,10 @@ case $basic_machine in
 	c6x)
 		basic_machine=tic6x-unknown
 		;;
-	m6811 | m68hc11 | m6812 | m68hc12 | picochip)
+	leon|leon[3-9])
+		basic_machine=sparc-$basic_machine
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
 		;;
@@ -332,7 +344,10 @@ case $basic_machine in
 	strongarm | thumb | xscale)
 		basic_machine=arm-unknown
 		;;
-
+	xgate)
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
 	xscaleeb)
 		basic_machine=armeb-unknown
 		;;
@@ -355,28 +370,32 @@ case $basic_machine in
 	# Recognize the basic CPU types with company name.
 	580-* \
 	| a29k-* \
+	| aarch64-* | aarch64_be-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| ba-* \
 	| be32-* | be64-* \
 	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* \
-	| clipper-* | craynv-* | cydra-* \
+	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
+	| e2k-* | elxsi-* \
 	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| hexagon-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
+	| k1om-* \
 	| le32-* | le64-* \
 	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
@@ -390,28 +409,33 @@ case $basic_machine in
 	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa32r6-* | mipsisa32r6el-* \
 	| mipsisa64-* | mipsisa64el-* \
 	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64r6-* | mipsisa64r6el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipsr5900-* | mipsr5900el-* \
 	| mipstx39-* | mipstx39el-* \
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
 	| nds32-* | nds32le-* | nds32be-* \
-	| nios-* | nios2-* \
+	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
 	| open8-* \
+	| or1k*-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
 	| pyramid-* \
+	| riscv32-* | riscv64-* \
 	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
 	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx*-* \
 	| tahoe-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tile*-* \
@@ -419,6 +443,7 @@ case $basic_machine in
 	| ubicom32-* \
 	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
+	| visium-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
@@ -495,6 +520,9 @@ case $basic_machine in
 		basic_machine=i386-pc
 		os=-aros
 		;;
+	asmjs)
+		basic_machine=asmjs-unknown
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -615,6 +643,14 @@ case $basic_machine in
 		basic_machine=m68k-bull
 		os=-sysv3
 		;;
+	e500v[12])
+		basic_machine=powerpc-unknown
+		os=$os"spe"
+		;;
+	e500v[12]-*)
+		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=$os"spe"
+		;;
 	ebmon29k)
 		basic_machine=a29k-amd
 		os=-ebmon
@@ -756,6 +792,9 @@ case $basic_machine in
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	leon-*|leon[3-9]-*)
+		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
+		;;
 	m68knommu)
 		basic_machine=m68k-unknown
 		os=-linux
@@ -775,11 +814,15 @@ case $basic_machine in
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
-	microblaze)
+	microblaze*)
 		basic_machine=microblaze-xilinx
 		;;
+	mingw64)
+		basic_machine=x86_64-pc
+		os=-mingw64
+		;;
 	mingw32)
-		basic_machine=i386-pc
+		basic_machine=i686-pc
 		os=-mingw32
 		;;
 	mingw32ce)
@@ -807,6 +850,10 @@ case $basic_machine in
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
+		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
@@ -815,7 +862,7 @@ case $basic_machine in
 		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
 		;;
 	msys)
-		basic_machine=i386-pc
+		basic_machine=i686-pc
 		os=-msys
 		;;
 	mvs)
@@ -983,7 +1030,7 @@ case $basic_machine in
 	ppc-* | ppcbe-*)
 		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	ppcle | powerpclittle | ppc-le | powerpc-little)
+	ppcle | powerpclittle)
 		basic_machine=powerpcle-unknown
 		;;
 	ppcle-* | powerpclittle-*)
@@ -993,7 +1040,7 @@ case $basic_machine in
 		;;
 	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+	ppc64le | powerpc64little)
 		basic_machine=powerpc64le-unknown
 		;;
 	ppc64le-* | powerpc64little-*)
@@ -1006,7 +1053,11 @@ case $basic_machine in
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
-	rdos)
+	rdos | rdos64)
+		basic_machine=x86_64-pc
+		os=-rdos
+		;;
+	rdos32)
 		basic_machine=i386-pc
 		os=-rdos
 		;;
@@ -1333,29 +1384,30 @@ case $os in
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
-	      | -sym* | -kopensolaris* \
+	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* | -aros* \
+	      | -aos* | -aros* | -cloudabi* | -sortix* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -openbsd* | -solidbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* | -libertybsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
 	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -chorusos* | -chorusrdb* | -cegcc* \
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-android* \
-	      | -linux-newlib* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -midipix* | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
+	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* \
+	      | -onefs* | -tirtos* | -phoenix*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1479,9 +1531,6 @@ case $os in
 	-aros*)
 		os=-aros
 		;;
-	-kaos*)
-		os=-kaos
-		;;
 	-zvmoe)
 		os=-zvmoe
 		;;
@@ -1490,6 +1539,8 @@ case $os in
 		;;
 	-nacl*)
 		;;
+	-ios)
+		;;
 	-none)
 		;;
 	*)
@@ -1530,6 +1581,12 @@ case $basic_machine in
 	c4x-* | tic4x-*)
 		os=-coff
 		;;
+	c8051-*)
+		os=-elf
+		;;
+	hexagon-*)
+		os=-elf
+		;;
 	tic54x-*)
 		os=-coff
 		;;
diff --git a/tools/depends/configure.ac b/tools/depends/configure.ac
index 9c8ddad..298abd9 100644
--- a/tools/depends/configure.ac
+++ b/tools/depends/configure.ac
@@ -169,6 +169,18 @@ case $host in
       platform_os="linux"
     fi
   ;;
+  aarch64*-*-linux-gnu*|aarch*-*-linux-be*)
+    if test "$use_platform" = "auto"; then
+      if test "x$use_cpu" = "xauto"; then
+        use_cpu=$host_cpu
+      fi
+      use_toolchain="${use_toolchain:-/usr}"
+      platform_cflags="-Os -fPIC -DPIC"
+      platform_ldflags="-Wl,-rpath-link=$prefix/$deps_dir/lib"
+      platform_cxxflags="$platform_cflags"
+      platform_os="linux"
+    fi
+  ;;
   *i686*-linux-gnu*|i*86*-*-linux-uclibc*)
     use_cpu=$host_cpu
     use_toolchain="${use_toolchain:-/usr}"
diff --git a/tools/depends/native/autoconf-native/Makefile b/tools/depends/native/autoconf-native/Makefile
index efa8277..f2ddde0 100644
--- a/tools/depends/native/autoconf-native/Makefile
+++ b/tools/depends/native/autoconf-native/Makefile
@@ -5,7 +5,7 @@ DEPS= ../../Makefile.include.in Makefile
 
 # lib name, version
 LIBNAME=autoconf
-VERSION=2.68
+VERSION=2.69
 SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.gz
 
diff --git a/tools/depends/native/automake-native/Makefile b/tools/depends/native/automake-native/Makefile
index eaf7517..f1b1ae6 100644
--- a/tools/depends/native/automake-native/Makefile
+++ b/tools/depends/native/automake-native/Makefile
@@ -4,7 +4,7 @@ DEPS= ../../Makefile.include.in Makefile
 
 # lib name, version
 LIBNAME=automake
-VERSION=1.11.3
+VERSION=1.15
 SOURCE=$(LIBNAME)-$(VERSION)
 ARCHIVE=$(SOURCE).tar.gz
 
-- 
2.7.4


From ca3074451facd187f320951ee9067082ccd82eb1 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Sun, 25 Sep 2016 14:48:09 +0200
Subject: [PATCH 062/175] aarch64 compile stuff

---
 project/cmake/modules/FindLibDvd.cmake            |  2 +
 project/cmake/scripts/android/ArchSetup.cmake     |  2 +
 tools/depends/Makefile.include.in                 |  2 +-
 tools/depends/configure.ac                        | 17 ++++++
 tools/depends/target/config.site.in               |  6 +--
 tools/depends/target/ffmpeg/Makefile              | 10 ++--
 tools/depends/target/libnfs/Makefile              |  1 +
 tools/depends/target/libnfs/vfstat_redefine.patch | 63 +++++++++++++++++++++++
 tools/depends/target/pcre/Makefile                |  1 +
 tools/depends/target/pcre/jit_aarch64.patch       | 11 ++++
 10 files changed, 108 insertions(+), 7 deletions(-)
 create mode 100644 tools/depends/target/libnfs/vfstat_redefine.patch
 create mode 100644 tools/depends/target/pcre/jit_aarch64.patch

diff --git a/project/cmake/modules/FindLibDvd.cmake b/project/cmake/modules/FindLibDvd.cmake
index 9a1f596..dd26c96 100644
--- a/project/cmake/modules/FindLibDvd.cmake
+++ b/project/cmake/modules/FindLibDvd.cmake
@@ -88,6 +88,8 @@ if(NOT WIN32)
     if(CORE_SYSTEM_NAME STREQUAL android)
       if(ARCH STREQUAL arm)
         set(HOST_ARCH arm-linux-androideabi)
+      elseif(ARCH STREQUAL aarch64)
+        set(HOST_ARCH aarch64-linux-android)
       elseif(ARCH STREQUAL i486-linux)
         set(HOST_ARCH i686-linux-android)
       endif()
diff --git a/project/cmake/scripts/android/ArchSetup.cmake b/project/cmake/scripts/android/ArchSetup.cmake
index 3ae9505..281f94f 100644
--- a/project/cmake/scripts/android/ArchSetup.cmake
+++ b/project/cmake/scripts/android/ArchSetup.cmake
@@ -14,6 +14,8 @@ else()
   if(CPU STREQUAL armeabi-v7a)
     set(ARCH arm)
     set(NEON True)
+  elseif(CPU STREQUAL arm64-v8a)
+    set(ARCH aarch64)
   elseif(CPU STREQUAL i686)
     set(ARCH i486-linux)
     set(NEON False)
diff --git a/tools/depends/Makefile.include.in b/tools/depends/Makefile.include.in
index 61e2b23..a6e419f 100644
--- a/tools/depends/Makefile.include.in
+++ b/tools/depends/Makefile.include.in
@@ -57,7 +57,7 @@ OBJDUMP=@OBJDUMP@
 
 CMAKE=@prefix@/@tool_dir@/bin/cmake -DCMAKE_TOOLCHAIN_FILE=$(PREFIX)/share/Toolchain.cmake -DCMAKE_INSTALL_PREFIX=$(PREFIX)
 CFLAGS=@platform_cflags@ @platform_includes@ -isystem @prefix@/@deps_dir@/include
-LDFLAGS=-L@prefix@/@deps_dir@/lib @platform_ldflags@
+LDFLAGS=-L@prefix@/@deps_dir@/lib -L@prefix@/@deps_dir@/lib64 @platform_ldflags@
 CXXFLAGS=@platform_cxxflags@ @platform_includes@ -isystem @prefix@/@deps_dir@/include
 CPPFLAGS=@platform_cflags@ @platform_includes@ -isystem @prefix@/@deps_dir@/include
 
diff --git a/tools/depends/configure.ac b/tools/depends/configure.ac
index 298abd9..6345adb 100644
--- a/tools/depends/configure.ac
+++ b/tools/depends/configure.ac
@@ -143,6 +143,23 @@ case $host in
     #android builds are always cross
     cross_compiling="yes"
   ;;
+  aarch64*-*linux-android*)
+    if test "x$use_cpu" = "xauto"; then
+      use_cpu="arm64-v8a"
+    fi
+    use_sdk="${use_sdk:-android-21}"
+    deps_dir="$use_host-$use_sdk"
+    platform_cflags="-DANDROID -Os -fexceptions"
+    if test "x$use_cpu" = "xarm64-v8a"; then
+      platform_cflags+=" -march=armv8-a -mtune=cortex-a53"
+    fi
+    platform_ldflags="-L$prefix/$deps_dir/lib/$use_sdk"
+    platform_cxxflags="$platform_cflags -frtti"
+    platform_includes="-I$prefix/$deps_dir/include/$use_sdk"
+    platform_os="android"
+    #android builds are always cross
+    cross_compiling="yes"
+  ;;
   i*86*-linux-android*)
     if test "x$use_cpu" = "xauto"; then
       use_cpu=$host_cpu
diff --git a/tools/depends/target/config.site.in b/tools/depends/target/config.site.in
index 1a9961c..8c7e68d 100644
--- a/tools/depends/target/config.site.in
+++ b/tools/depends/target/config.site.in
@@ -21,7 +21,7 @@ if test "@platform_os@" = "ios" ; then
 fi
 
 CFLAGS="@platform_cflags@ @platform_includes@ -isystem @prefix@/@deps_dir@/include $CFLAGS"
-LDFLAGS="-L@prefix@/@deps_dir@/lib @platform_ldflags@ $LDFLAGS"
+LDFLAGS="-L@prefix@/@deps_dir@/lib -L@prefix@/@deps_dir@/lib64 @platform_ldflags@ $LDFLAGS"
 CXXFLAGS="@platform_cxxflags@ @platform_includes@ -isystem @prefix@/@deps_dir@/include $CXXFLAGS"
 CPPFLAGS="@platform_cflags@ @platform_includes@ -isystem @prefix@/@deps_dir@/include $CPPFLAGS"
 
@@ -36,7 +36,7 @@ PATH=@prefix@/@tool_dir@/bin:@use_toolchain@/usr/bin:@use_toolchain@/bin:$PATH
 LD_LIBRARY_PATH=@prefix@/@tool_dir@/lib:$LD_LIBRARY_PATH
 
 PYTHON_VERSION=2.7
-PYTHON_LDFLAGS="-L@prefix@/@deps_dir@/lib -lpython${PYTHON_VERSION} -lc -ldl -lm -lexpat -lffi -lintl -lutil -lssl -lcrypto"
+PYTHON_LDFLAGS="-L@prefix@/@deps_dir@/lib -L@prefix@/@deps_dir@/lib64 -lpython${PYTHON_VERSION} -lc -ldl -lm -lexpat -lffi -lintl -lutil -lssl -lcrypto"
 PYTHON_CPPFLAGS=-I@prefix@/@deps_dir@/include/python${PYTHON_VERSION}
 PYTHON_SITE_PKG=@prefix@/@deps_dir@/lib/python${PYTHON_VERSION}/site-packages
 PYTHON_NOVERSIONCHECK=no-check
@@ -136,7 +136,7 @@ if test "@platform_os@" = "android"; then
   ac_cv_func_rand=yes
 
   #python: android doesn't have libutil
-  PYTHON_LDFLAGS="-L@prefix@/@deps_dir@/lib -lpython${PYTHON_VERSION} -lc -ldl -lm -lexpat -lffi -lintl -lssl -lcrypto"
+  PYTHON_LDFLAGS="-L@prefix@/@deps_dir@/lib -L@prefix@/@deps_dir@/lib64 -lpython${PYTHON_VERSION} -lc -ldl -lm -lexpat -lffi -lintl -lssl -lcrypto"
 
 fi
 
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 984521b..eaf9fc4 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -29,10 +29,14 @@ ifeq ($(OS), linux)
   ffmpg_config += --enable-vdpau --enable-vaapi --enable-pic
 endif
 ifeq ($(OS), android)
-  ifeq ($(findstring arm, $(CPU)), arm)
-    ffmpg_config += --cpu=cortex-a9
+  ifeq ($(findstring arm64, $(CPU)), arm64)
+    ffmpg_config += --arch=aarch64 --cpu=cortex-a53
   else
-    ffmpg_config += --cpu=i686 --disable-mmx
+    ifeq ($(findstring arm, $(CPU)), arm)
+      ffmpg_config += --cpu=cortex-a9
+    else
+      ffmpg_config += --cpu=i686 --disable-mmx
+    endif
   endif
   ffmpg_config += --target-os=linux --extra-libs=-liconv
 endif
diff --git a/tools/depends/target/libnfs/Makefile b/tools/depends/target/libnfs/Makefile
index ce92998..48b91a8 100644
--- a/tools/depends/target/libnfs/Makefile
+++ b/tools/depends/target/libnfs/Makefile
@@ -23,6 +23,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	-rm -rf $(PLATFORM); mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); ./bootstrap
+	cd $(PLATFORM); patch -p1 < ../vfstat_redefine.patch
 	cd $(PLATFORM); $(CONFIGURE)
 
 $(LIBDYLIB): $(PLATFORM)
diff --git a/tools/depends/target/libnfs/vfstat_redefine.patch b/tools/depends/target/libnfs/vfstat_redefine.patch
new file mode 100644
index 0000000..33ae6fa
--- /dev/null
+++ b/tools/depends/target/libnfs/vfstat_redefine.patch
@@ -0,0 +1,63 @@
+From 41c41aec0bfd2288afde4068e433e58513268668 Mon Sep 17 00:00:00 2001
+From: Jean-Baptiste Kempf <jb@videolan.org>
+Date: Fri, 11 Mar 2016 00:09:16 +0100
+Subject: [PATCH] Android: only redefine statvfs if it is not already defined
+
+It is defined with recent platforms version 21 and more recent
+---
+ lib/libnfs-sync.c | 8 ++++----
+ lib/libnfs.c      | 8 ++++----
+ 2 files changed, 8 insertions(+), 8 deletions(-)
+
+diff --git a/lib/libnfs-sync.c b/lib/libnfs-sync.c
+index 664ccfc..69caee3 100644
+--- a/lib/libnfs-sync.c
++++ b/lib/libnfs-sync.c
+@@ -37,10 +37,6 @@
+ #include <net/if.h>
+ #endif
+ 
+-#ifdef __ANDROID__
+-#define statvfs statfs
+-#endif
+-
+ #ifdef HAVE_SYS_VFS_H
+ #include <sys/vfs.h>
+ #endif
+@@ -49,6 +45,10 @@
+ #include <sys/statvfs.h>
+ #endif
+ 
++#if defined(__ANDROID__) && !defined(HAVE_SYS_STATVFS_H)
++#define statvfs statfs
++#endif
++
+ #ifdef HAVE_SYS_IOCTL_H
+ #include <sys/ioctl.h>
+ #endif
+diff --git a/lib/libnfs.c b/lib/libnfs.c
+index 1f16e5f..36c1430 100644
+--- a/lib/libnfs.c
++++ b/lib/libnfs.c
+@@ -33,10 +33,6 @@
+ #include <utime.h>
+ #endif
+ 
+-#ifdef __ANDROID__
+-#define statvfs statfs
+-#endif
+-
+ #define _GNU_SOURCE
+ 
+ #ifdef HAVE_UNISTD_H
+@@ -51,6 +47,10 @@
+ #include <sys/statvfs.h>
+ #endif
+ 
++#if defined(__ANDROID__) && !defined(HAVE_SYS_STATVFS_H)
++#define statvfs statfs
++#endif
++
+ #ifdef HAVE_NETINET_IN_H
+ #include <netinet/in.h>
+ #endif
diff --git a/tools/depends/target/pcre/Makefile b/tools/depends/target/pcre/Makefile
index 75848bb..ff5aa49 100644
--- a/tools/depends/target/pcre/Makefile
+++ b/tools/depends/target/pcre/Makefile
@@ -27,6 +27,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM)/*; mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); patch -p1 < ../tvos-bitcode-fix.patch
+	cd $(PLATFORM); patch -p0 < ../jit_aarch64.patch
 	cd $(PLATFORM); $(CONFIGURE)
 
 $(LIBDYLIB): $(PLATFORM)
diff --git a/tools/depends/target/pcre/jit_aarch64.patch b/tools/depends/target/pcre/jit_aarch64.patch
new file mode 100644
index 0000000..5f99207
--- /dev/null
+++ b/tools/depends/target/pcre/jit_aarch64.patch
@@ -0,0 +1,11 @@
+--- sljit/sljitConfigInternal.h.orig	2016-09-25 12:41:56.067863204 +0200
++++ sljit/sljitConfigInternal.h	2016-09-25 12:42:22.155862977 +0200
+@@ -310,7 +310,7 @@
+ #define SLJIT_CACHE_FLUSH(from, to) \
+ 	sys_icache_invalidate((char*)(from), (char*)(to) - (char*)(from))
+ 
+-#elif defined __ANDROID__
++#elif (defined __ANDROID__ && !defined SLJIT_CONFIG_ARM_64)
+ 
+ /* Android lacks __clear_cache; instead, cacheflush should be used. */
+ 
-- 
2.7.4


From 0136da9961ea3a9ec907815c7e3b8be5eefcc55f Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Sun, 25 Sep 2016 09:25:21 +0200
Subject: [PATCH 063/175] ffmpeg: add android aarch64 support

---
 tools/depends/target/ffmpeg/CMakeLists.txt | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/tools/depends/target/ffmpeg/CMakeLists.txt b/tools/depends/target/ffmpeg/CMakeLists.txt
index 046429f..57cb563 100644
--- a/tools/depends/target/ffmpeg/CMakeLists.txt
+++ b/tools/depends/target/ffmpeg/CMakeLists.txt
@@ -18,7 +18,9 @@ endif()
 if(CORE_SYSTEM_NAME STREQUAL linux OR CORE_SYSTEM_NAME STREQUAL freebsd)
   list(APPEND ffmpeg_conf --enable-vdpau --enable-vaapi --enable-pic)
 elseif(CORE_SYSTEM_NAME STREQUAL android)
-  if(CPU MATCHES arm)
+  if(CPU MATCHES arm64)
+    list(APPEND ffmpeg_conf --cpu=cortex-a53 --arch=aarch64)
+  elseif(CPU MATCHES arm)
     list(APPEND ffmpeg_conf --cpu=cortex-a9)
   else()
     list(APPEND ffmpeg_conf --cpu=i686 --disable-mmx)
-- 
2.7.4


From 0eaeb0d82b7b78162ff0c653ca16ed4abd630089 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Sun, 25 Sep 2016 10:25:23 +0200
Subject: [PATCH 064/175] add aarch64 support

---
 xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp                     | 2 ++
 xbmc/cores/DllLoader/exports/emu_msvcrt.cpp                           | 2 +-
 .../VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp    | 4 ++--
 .../VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.h      | 4 +++-
 xbmc/filesystem/AndroidAppFile.cpp                                    | 2 --
 xbmc/linux/XTimeUtils.cpp                                             | 4 ++--
 xbmc/platform/android/activity/CMakeLists.txt                         | 1 +
 xbmc/platform/android/activity/XBMCApp.cpp                            | 2 ++
 xbmc/platform/android/activity/XBMCApp.h                              | 2 ++
 xbmc/platform/android/activity/android_main.cpp                       | 2 ++
 xbmc/platform/android/jni/AudioFormat.cpp                             | 1 +
 xbmc/platform/android/jni/AudioFormat.h                               | 2 ++
 xbmc/platform/android/jni/JNIThreading.cpp                            | 2 ++
 xbmc/platform/android/jni/JNIThreading.h                              | 2 ++
 xbmc/platform/android/jni/jutils/jutils-details.hpp                   | 2 ++
 xbmc/platform/android/jni/jutils/jutils.hpp                           | 2 ++
 16 files changed, 28 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
index 5013e2a..5a1f58b 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+#define HAVE_INTTYPES_H 1
+
 #include "AESinkAUDIOTRACK.h"
 #include "cores/AudioEngine/Utils/AEUtil.h"
 #include "platform/android/activity/XBMCApp.h"
diff --git a/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp b/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
index 44578fe..ab14942 100644
--- a/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
+++ b/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
@@ -34,7 +34,7 @@
 #endif
 #include <sys/stat.h>
 #include <sys/types.h>
-#if !defined(TARGET_FREEBSD)
+#if !defined(TARGET_FREEBSD) && (!defined(TARGET_ANDROID) && defined(__LP64__))
 #include <sys/timeb.h>
 #endif
 #include "system.h" // for HAS_DVD_DRIVE
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp
index a4cae0a..9d3a614 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.cpp
@@ -235,7 +235,7 @@ void CDVDMediaCodecInfo::ReleaseOutputBuffer(bool render)
   }
 }
 
-int CDVDMediaCodecInfo::GetIndex() const
+ssize_t CDVDMediaCodecInfo::GetIndex() const
 {
   CSingleLock lock(m_section);
 
@@ -1408,4 +1408,4 @@ void CDVDVideoCodecAndroidMediaCodec::ReleaseSurfaceTexture(void)
     glDeleteTextures(1, &texture_id);
     m_textureId = 0;
   }
-}
\ No newline at end of file
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.h
index fd20801..fb39ea5 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.h
@@ -20,6 +20,8 @@
  *
  */
 
+#include "system.h"
+
 #include <queue>
 #include <vector>
 #include <memory>
@@ -64,7 +66,7 @@ public:
   // MediaCodec related
   void                ReleaseOutputBuffer(bool render);
   // SurfaceTexture released
-  int                 GetIndex() const;
+  ssize_t             GetIndex() const;
   int                 GetTextureID() const;
   void                GetTransformMatrix(float *textureMatrix);
   void                UpdateTexImage();
diff --git a/xbmc/filesystem/AndroidAppFile.cpp b/xbmc/filesystem/AndroidAppFile.cpp
index cd5f84e..14819ea 100644
--- a/xbmc/filesystem/AndroidAppFile.cpp
+++ b/xbmc/filesystem/AndroidAppFile.cpp
@@ -18,8 +18,6 @@
  *
  */
 
-#include "system.h"
-
 #if defined(TARGET_ANDROID)
 
 #include "AndroidAppFile.h"
diff --git a/xbmc/linux/XTimeUtils.cpp b/xbmc/linux/XTimeUtils.cpp
index bcdc5ce..463b595 100644
--- a/xbmc/linux/XTimeUtils.cpp
+++ b/xbmc/linux/XTimeUtils.cpp
@@ -26,7 +26,7 @@
 #include "threads/Atomics.h"
 #endif
 
-#if defined(TARGET_ANDROID)
+#if defined(TARGET_ANDROID) && !defined(__LP64__)
 #include <time64.h>
 #endif
 
@@ -121,7 +121,7 @@ BOOL   SystemTimeToFileTime(const SYSTEMTIME* lpSystemTime,  LPFILETIME lpFileTi
   CAtomicSpinLock lock(timegm_lock);
 #endif
 
-#if defined(TARGET_ANDROID)
+#if defined(TARGET_ANDROID) && !defined(__LP64__)
   time64_t t = timegm64(&sysTime);
 #else
   time_t t = timegm(&sysTime);
diff --git a/xbmc/platform/android/activity/CMakeLists.txt b/xbmc/platform/android/activity/CMakeLists.txt
index 11fd016..b6c7f96 100644
--- a/xbmc/platform/android/activity/CMakeLists.txt
+++ b/xbmc/platform/android/activity/CMakeLists.txt
@@ -28,3 +28,4 @@ core_add_library(platform_android_activity)
 target_include_directories(${CORE_LIBRARY}
                            PRIVATE ${NDKROOT}/sources/android/native_app_glue
                                    ${NDKROOT}/sources/android/cpufeatures)
+target_compile_definitions(${CORE_LIBRARY} PRIVATE -DHAVE_INTTYPES_H)
diff --git a/xbmc/platform/android/activity/XBMCApp.cpp b/xbmc/platform/android/activity/XBMCApp.cpp
index f889c75..6dfd119 100644
--- a/xbmc/platform/android/activity/XBMCApp.cpp
+++ b/xbmc/platform/android/activity/XBMCApp.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+#include "XBMCApp.h"
+
 #include <sstream>
 
 #include <unistd.h>
diff --git a/xbmc/platform/android/activity/XBMCApp.h b/xbmc/platform/android/activity/XBMCApp.h
index ee44234..ee6e749 100644
--- a/xbmc/platform/android/activity/XBMCApp.h
+++ b/xbmc/platform/android/activity/XBMCApp.h
@@ -19,6 +19,8 @@
  *
  */
 
+#include "system.h"
+
 #include <math.h>
 #include <pthread.h>
 #include <string>
diff --git a/xbmc/platform/android/activity/android_main.cpp b/xbmc/platform/android/activity/android_main.cpp
index f97a941..9745197 100644
--- a/xbmc/platform/android/activity/android_main.cpp
+++ b/xbmc/platform/android/activity/android_main.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+#include "system.h"
+
 #include <stdlib.h>
 #include <errno.h>
 #include <android_native_app_glue.h>
diff --git a/xbmc/platform/android/jni/AudioFormat.cpp b/xbmc/platform/android/jni/AudioFormat.cpp
index 1781082..83aae34 100644
--- a/xbmc/platform/android/jni/AudioFormat.cpp
+++ b/xbmc/platform/android/jni/AudioFormat.cpp
@@ -18,6 +18,7 @@
  *
  */
 
+
 #include "AudioFormat.h"
 #include "JNIBase.h"
 #include "jutils/jutils-details.hpp"
diff --git a/xbmc/platform/android/jni/AudioFormat.h b/xbmc/platform/android/jni/AudioFormat.h
index 5975524..82f813f 100644
--- a/xbmc/platform/android/jni/AudioFormat.h
+++ b/xbmc/platform/android/jni/AudioFormat.h
@@ -19,6 +19,8 @@
  *
  */
 
+#define HAVE_INTTYPES_H 1
+
 #include "jutils/jutils-details.hpp"
 
 namespace jni
diff --git a/xbmc/platform/android/jni/JNIThreading.cpp b/xbmc/platform/android/jni/JNIThreading.cpp
index 9f3e58e..0cd6ba9 100644
--- a/xbmc/platform/android/jni/JNIThreading.cpp
+++ b/xbmc/platform/android/jni/JNIThreading.cpp
@@ -35,6 +35,8 @@
   were renamed to avoid collisions when linking against the originals.
 */
 
+#define HAVE_INTTYPES_H 1
+
 #include <jni.h>
 #include <pthread.h>
 #include <stdlib.h>
diff --git a/xbmc/platform/android/jni/JNIThreading.h b/xbmc/platform/android/jni/JNIThreading.h
index 84f3718..e7fd6a1 100644
--- a/xbmc/platform/android/jni/JNIThreading.h
+++ b/xbmc/platform/android/jni/JNIThreading.h
@@ -32,6 +32,8 @@
  */
 
 #pragma once
+#define HAVE_INTTYPES_H 1
+
 #include <jni.h>
 
 int xbmc_jni_on_load(JavaVM *vm, JNIEnv *env);
diff --git a/xbmc/platform/android/jni/jutils/jutils-details.hpp b/xbmc/platform/android/jni/jutils/jutils-details.hpp
index eefd367..eebb565 100644
--- a/xbmc/platform/android/jni/jutils/jutils-details.hpp
+++ b/xbmc/platform/android/jni/jutils/jutils-details.hpp
@@ -47,6 +47,8 @@
  */
 
 #pragma once
+#define HAVE_INTTYPES_H 1
+
 #include <jni.h>
 #include <string>
 #include "jutils.hpp"
diff --git a/xbmc/platform/android/jni/jutils/jutils.hpp b/xbmc/platform/android/jni/jutils/jutils.hpp
index 059a2c0..50d8d01 100644
--- a/xbmc/platform/android/jni/jutils/jutils.hpp
+++ b/xbmc/platform/android/jni/jutils/jutils.hpp
@@ -48,6 +48,8 @@
 
 #pragma once
 
+#define HAVE_INTTYPES_H 1
+
 #include <jni.h>
 #include <string>
 #include <android/log.h>
-- 
2.7.4


From e03cfd79de6dfc522dd34a0ca45843a0f3560704 Mon Sep 17 00:00:00 2001
From: Chris Koying Browet <cbro@semperpax.com>
Date: Thu, 28 Jul 2016 16:01:38 +0200
Subject: [PATCH 065/175] CHG: [NDK21] sambav3

Force all off_t to off64_t
---
 tools/depends/target/samba-gplv3/Makefile          |   5 +-
 .../depends/target/samba-gplv3/samba_android.patch | 114 +---
 .../depends/target/samba-gplv3/samba_off64_t.patch | 581 +++++++++++++++++++++
 3 files changed, 592 insertions(+), 108 deletions(-)
 create mode 100644 tools/depends/target/samba-gplv3/samba_off64_t.patch

diff --git a/tools/depends/target/samba-gplv3/Makefile b/tools/depends/target/samba-gplv3/Makefile
index 17a5224..f5d84ba 100644
--- a/tools/depends/target/samba-gplv3/Makefile
+++ b/tools/depends/target/samba-gplv3/Makefile
@@ -31,7 +31,9 @@ CONFIGURE= cp -f $(CONFIG_SUB) $(CONFIG_GUESS) .; \
 # Then xbmc will correctly access smb shares with LFS enabled
 # using the altered libsmbclient.h.
 ifeq ($(OS),android)
-export CFLAGS+=-D_FILE_OFFSET_BITS=64 -D_OFF_T_DEFINED_ -Doff_t=off64_t -Dlseek=lseek64
+ifeq ($(findstring arm64, $(CPU)), arm64)
+export CFLAGS+=-DHAVE_BZERO
+endif
 endif
 
 LIBDYLIB=$(PLATFORM)/source3/bin/libsmbclient.a
@@ -48,6 +50,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 ifeq ($(OS),android)
 	cd $(PLATFORM); patch -p0 < ../samba_android.patch
+	cd $(PLATFORM); patch -p1 < ../samba_off64_t.patch
 endif
 ifeq ($(TARGET_PLATFORM),appletvos)
 	cd $(PLATFORM); patch -p0 < ../no_fork_and_exec.patch
diff --git a/tools/depends/target/samba-gplv3/samba_android.patch b/tools/depends/target/samba-gplv3/samba_android.patch
index a3e25dc..ad84ba1 100644
--- a/tools/depends/target/samba-gplv3/samba_android.patch
+++ b/tools/depends/target/samba-gplv3/samba_android.patch
@@ -4,19 +4,19 @@ diff -ru lib/util/charset/iconv.c lib/util/charset/iconv.c
 @@ -23,6 +23,11 @@
  #include "system/iconv.h"
  #include "system/filesys.h"
- 
+
 +#if defined(ANDROID)
 +#include <stdint.h>
-+#include <asm/byteorder.h>
++#include <byteswap.h>
 +#endif
 +
  #ifdef strcasecmp
  #undef strcasecmp
  #endif
-@@ -502,6 +507,19 @@
- 	return 0;
+@@ -502,6 +507,19 @@ static size_t ucs2hex_push(void *cd, con
+        return 0;
  }
- 
+
 +#if defined(ANDROID)
 +void swab(const void *from, void*to, ssize_t n)
 +{
@@ -26,12 +26,12 @@ diff -ru lib/util/charset/iconv.c lib/util/charset/iconv.c
 +    return;
 +
 +  for (i = 0; i < (n/2)*2; i += 2)
-+    *((uint16_t*)to+i) = __arch__swab16(*((uint16_t*)from+i));
++    *((uint16_t*)to+i) = bswap_16(*((uint16_t*)from+i));
 +}
 +#endif
 +
  static size_t iconv_swab(void *cd, const char **inbuf, size_t *inbytesleft,
- 			 char **outbuf, size_t *outbytesleft)
+                         char **outbuf, size_t *outbytesleft)
  {
 diff -ru lib/util/system.c lib/util/system.c
 --- lib/util/system.c	2013-01-29 09:49:31.000000000 +0100
@@ -162,106 +162,6 @@ diff -ru source3/configure source3/configure
  fi
  
  fi
-diff -ru source3/include/libsmbclient.h source3/include/libsmbclient.h
---- source3/include/libsmbclient.h	2013-01-29 09:49:31.000000000 +0100
-+++ source3/include/libsmbclient.h	2015-03-28 08:30:53.847217275 +0100
-@@ -75,7 +75,13 @@
- /* Make sure we have the following includes for now ... */
- #include <sys/types.h>
- #include <sys/stat.h>
-+#if !defined(ANDROID)
- #include <sys/statvfs.h>
-+#else
-+#include <sys/vfs.h>
-+#define statvfs statfs
-+#define fstatvfs fstatfs
-+#endif
- #include <fcntl.h>
- #include <utime.h>
- 
-@@ -862,9 +868,9 @@
- smbc_rename_fn smbc_getFunctionRename(SMBCCTX *c);
- void smbc_setFunctionRename(SMBCCTX *c, smbc_rename_fn fn);
- 
--typedef off_t (*smbc_lseek_fn)(SMBCCTX *c,
-+typedef off64_t (*smbc_lseek_fn)(SMBCCTX *c,
-                                SMBCFILE * file,
--                               off_t offset,
-+                               off64_t offset,
-                                int whence);
- smbc_lseek_fn smbc_getFunctionLseek(SMBCCTX *c);
- void smbc_setFunctionLseek(SMBCCTX *c, smbc_lseek_fn fn);
-@@ -895,7 +901,7 @@
- 
- typedef int (*smbc_ftruncate_fn)(SMBCCTX *c,
-                                  SMBCFILE *f,
--                                 off_t size);
-+                                 off64_t size);
- smbc_ftruncate_fn smbc_getFunctionFtruncate(SMBCCTX *c);
- void smbc_setFunctionFtruncate(SMBCCTX *c, smbc_ftruncate_fn fn);
- 
-@@ -945,14 +951,14 @@
- smbc_rmdir_fn smbc_getFunctionRmdir(SMBCCTX *c);
- void smbc_setFunctionRmdir(SMBCCTX *c, smbc_rmdir_fn fn);
- 
--typedef off_t (*smbc_telldir_fn)(SMBCCTX *c,
-+typedef off64_t (*smbc_telldir_fn)(SMBCCTX *c,
-                                  SMBCFILE *dir);
- smbc_telldir_fn smbc_getFunctionTelldir(SMBCCTX *c);
- void smbc_setFunctionTelldir(SMBCCTX *c, smbc_telldir_fn fn);
- 
- typedef int (*smbc_lseekdir_fn)(SMBCCTX *c,
-                                 SMBCFILE *dir,
--                                off_t offset);
-+                                off64_t offset);
- smbc_lseekdir_fn smbc_getFunctionLseekdir(SMBCCTX *c);
- void smbc_setFunctionLseekdir(SMBCCTX *c, smbc_lseekdir_fn fn);
- 
-@@ -1324,7 +1330,7 @@
-  * @return          Upon successful completion, lseek returns the 
-  *                  resulting offset location as measured in bytes 
-  *                  from the beginning  of the file. Otherwise, a value
-- *                  of (off_t)-1 is returned and errno is set to 
-+ *                  of (off64_t)-1 is returned and errno is set to 
-  *                  indicate the error:
-  *                  - EBADF  Fildes is not an open file descriptor.
-  *                  - EINVAL Whence is not a proper value or smbc_init
-@@ -1334,7 +1340,7 @@
-  * 
-  * @todo Are errno values complete and correct?
-  */
--off_t smbc_lseek(int fd, off_t offset, int whence);
-+off64_t smbc_lseek(int fd, off64_t offset, int whence);
- 
- 
- /**@ingroup file
-@@ -1518,7 +1524,7 @@
-  * @see             smbc_readdir()
-  *
-  */
--off_t smbc_telldir(int dh);
-+off64_t smbc_telldir(int dh);
- 
- 
- /**@ingroup directory
-@@ -1543,7 +1549,7 @@
-  *
-  * @todo In what does the reture and errno values mean?
-  */
--int smbc_lseekdir(int fd, off_t offset);
-+int smbc_lseekdir(int fd, off64_t offset);
- 
- /**@ingroup directory
-  * Create a directory.
-@@ -1700,7 +1706,7 @@
-  * @see             , Unix ftruncate()
-  *
-  */
--int smbc_ftruncate(int fd, off_t size);
-+int smbc_ftruncate(int fd, off64_t size);
- 
- 
- /**@ingroup attribute
 diff -ru source3/lib/fault.c source3/lib/fault.c
 --- source3/lib/fault.c	2013-01-29 09:49:31.000000000 +0100
 +++ source3/lib/fault.c	2015-03-28 08:30:54.539217284 +0100
diff --git a/tools/depends/target/samba-gplv3/samba_off64_t.patch b/tools/depends/target/samba-gplv3/samba_off64_t.patch
new file mode 100644
index 0000000..123bd6d
--- /dev/null
+++ b/tools/depends/target/samba-gplv3/samba_off64_t.patch
@@ -0,0 +1,581 @@
+diff -pur samba-3.6.12/lib/util/util.c arm-linux-androideabi-21/lib/util/util.c
+--- samba-3.6.12/lib/util/util.c	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/lib/util/util.c	2016-07-27 20:01:54.128052081 +0200
+@@ -255,7 +255,7 @@ _PUBLIC_ bool process_exists_by_pid(pid_
+  is dealt with in posix.c
+ **/
+ 
+-_PUBLIC_ bool fcntl_lock(int fd, int op, off_t offset, off_t count, int type)
++_PUBLIC_ bool fcntl_lock(int fd, int op, off64_t offset, off64_t count, int type)
+ {
+ 	struct flock lock;
+ 	int ret;
+diff -pur samba-3.6.12/lib/util/util.h arm-linux-androideabi-21/lib/util/util.h
+--- samba-3.6.12/lib/util/util.h	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/lib/util/util.h	2016-07-27 20:01:44.155992544 +0200
+@@ -674,7 +674,7 @@ _PUBLIC_ bool process_exists_by_pid(pid_
+  Simple routine to do POSIX file locking. Cruft in NFS and 64->32 bit mapping
+  is dealt with in posix.c
+ **/
+-_PUBLIC_ bool fcntl_lock(int fd, int op, off_t offset, off_t count, int type);
++_PUBLIC_ bool fcntl_lock(int fd, int op, off64_t offset, off64_t count, int type);
+ 
+ /**
+  * Write dump of binary data to a callback
+diff -pur samba-3.6.12/source3/include/libsmb_internal.h arm-linux-androideabi-21/source3/include/libsmb_internal.h
+--- samba-3.6.12/source3/include/libsmb_internal.h	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/source3/include/libsmb_internal.h	2016-07-27 20:07:42.306136381 +0200
+@@ -300,14 +300,14 @@ int
+ SMBC_rmdir_ctx(SMBCCTX *context,
+                const char *fname);
+ 
+-off_t
++off64_t
+ SMBC_telldir_ctx(SMBCCTX *context,
+                  SMBCFILE *dir);
+ 
+ int
+ SMBC_lseekdir_ctx(SMBCCTX *context,
+                   SMBCFILE *dir,
+-                  off_t offset);
++                  off64_t offset);
+ 
+ int
+ SMBC_fstatdir_ctx(SMBCCTX *context,
+@@ -383,16 +383,16 @@ SMBC_setatr(SMBCCTX * context, SMBCSRV *
+             time_t change_time,
+             uint16 mode);
+ 
+-off_t
++off64_t
+ SMBC_lseek_ctx(SMBCCTX *context,
+                SMBCFILE *file,
+-               off_t offset,
++               off64_t offset,
+                int whence);
+ 
+ int
+ SMBC_ftruncate_ctx(SMBCCTX *context,
+                    SMBCFILE *file,
+-                   off_t length);
++                   off64_t length);
+ 
+ 
+ /* Functions in libsmb_misc.c */
+diff -pur samba-3.6.12/source3/include/libsmbclient.h arm-linux-androideabi-21/source3/include/libsmbclient.h
+--- samba-3.6.12/source3/include/libsmbclient.h	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/source3/include/libsmbclient.h	2016-07-28 10:21:20.267305706 +0200
+@@ -862,9 +862,9 @@ typedef int (*smbc_rename_fn)(SMBCCTX *o
+ smbc_rename_fn smbc_getFunctionRename(SMBCCTX *c);
+ void smbc_setFunctionRename(SMBCCTX *c, smbc_rename_fn fn);
+ 
+-typedef off_t (*smbc_lseek_fn)(SMBCCTX *c,
++typedef off64_t (*smbc_lseek_fn)(SMBCCTX *c,
+                                SMBCFILE * file,
+-                               off_t offset,
++                               off64_t offset,
+                                int whence);
+ smbc_lseek_fn smbc_getFunctionLseek(SMBCCTX *c);
+ void smbc_setFunctionLseek(SMBCCTX *c, smbc_lseek_fn fn);
+@@ -895,7 +895,7 @@ void smbc_setFunctionFstatVFS(SMBCCTX *c
+ 
+ typedef int (*smbc_ftruncate_fn)(SMBCCTX *c,
+                                  SMBCFILE *f,
+-                                 off_t size);
++                                 off64_t size);
+ smbc_ftruncate_fn smbc_getFunctionFtruncate(SMBCCTX *c);
+ void smbc_setFunctionFtruncate(SMBCCTX *c, smbc_ftruncate_fn fn);
+ 
+@@ -945,14 +945,14 @@ typedef int (*smbc_rmdir_fn)(SMBCCTX *c,
+ smbc_rmdir_fn smbc_getFunctionRmdir(SMBCCTX *c);
+ void smbc_setFunctionRmdir(SMBCCTX *c, smbc_rmdir_fn fn);
+ 
+-typedef off_t (*smbc_telldir_fn)(SMBCCTX *c,
++typedef off64_t (*smbc_telldir_fn)(SMBCCTX *c,
+                                  SMBCFILE *dir);
+ smbc_telldir_fn smbc_getFunctionTelldir(SMBCCTX *c);
+ void smbc_setFunctionTelldir(SMBCCTX *c, smbc_telldir_fn fn);
+ 
+ typedef int (*smbc_lseekdir_fn)(SMBCCTX *c,
+                                 SMBCFILE *dir,
+-                                off_t offset);
++                                off64_t offset);
+ smbc_lseekdir_fn smbc_getFunctionLseekdir(SMBCCTX *c);
+ void smbc_setFunctionLseekdir(SMBCCTX *c, smbc_lseekdir_fn fn);
+ 
+@@ -1324,7 +1324,7 @@ ssize_t smbc_write(int fd, const void *b
+  * @return          Upon successful completion, lseek returns the 
+  *                  resulting offset location as measured in bytes 
+  *                  from the beginning  of the file. Otherwise, a value
+- *                  of (off_t)-1 is returned and errno is set to 
++ *                  of (off64_t)-1 is returned and errno is set to 
+  *                  indicate the error:
+  *                  - EBADF  Fildes is not an open file descriptor.
+  *                  - EINVAL Whence is not a proper value or smbc_init
+@@ -1334,7 +1334,7 @@ ssize_t smbc_write(int fd, const void *b
+  * 
+  * @todo Are errno values complete and correct?
+  */
+-off_t smbc_lseek(int fd, off_t offset, int whence);
++off64_t smbc_lseek(int fd, off64_t offset, int whence);
+ 
+ 
+ /**@ingroup file
+@@ -1518,7 +1518,7 @@ struct smbc_dirent* smbc_readdir(unsigne
+  * @see             smbc_readdir()
+  *
+  */
+-off_t smbc_telldir(int dh);
++off64_t smbc_telldir(int dh);
+ 
+ 
+ /**@ingroup directory
+@@ -1543,7 +1543,7 @@ off_t smbc_telldir(int dh);
+  *
+  * @todo In what does the reture and errno values mean?
+  */
+-int smbc_lseekdir(int fd, off_t offset);
++int smbc_lseekdir(int fd, off64_t offset);
+ 
+ /**@ingroup directory
+  * Create a directory.
+@@ -1700,7 +1700,7 @@ smbc_fstatvfs(int fd,
+  * @see             , Unix ftruncate()
+  *
+  */
+-int smbc_ftruncate(int fd, off_t size);
++int smbc_ftruncate(int fd, off64_t size);
+ 
+ 
+ /**@ingroup attribute
+diff -pur samba-3.6.12/source3/libsmb/clireadwrite.c arm-linux-androideabi-21/source3/libsmb/clireadwrite.c
+--- samba-3.6.12/source3/libsmb/clireadwrite.c	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/source3/libsmb/clireadwrite.c	2016-07-27 20:08:06.134279334 +0200
+@@ -102,7 +102,7 @@ static void cli_read_andx_done(struct te
+ struct tevent_req *cli_read_andx_create(TALLOC_CTX *mem_ctx,
+ 					struct event_context *ev,
+ 					struct cli_state *cli, uint16_t fnum,
+-					off_t offset, size_t size,
++					off64_t offset, size_t size,
+ 					struct tevent_req **psmbreq)
+ {
+ 	struct tevent_req *req, *subreq;
+@@ -160,7 +160,7 @@ struct tevent_req *cli_read_andx_create(
+ struct tevent_req *cli_read_andx_send(TALLOC_CTX *mem_ctx,
+ 				      struct event_context *ev,
+ 				      struct cli_state *cli, uint16_t fnum,
+-				      off_t offset, size_t size)
++				      off64_t offset, size_t size)
+ {
+ 	struct tevent_req *req, *subreq;
+ 	NTSTATUS status;
+@@ -257,7 +257,7 @@ struct cli_readall_state {
+ 	struct tevent_context *ev;
+ 	struct cli_state *cli;
+ 	uint16_t fnum;
+-	off_t start_offset;
++	off64_t start_offset;
+ 	size_t size;
+ 	size_t received;
+ 	uint8_t *buf;
+@@ -269,7 +269,7 @@ static struct tevent_req *cli_readall_se
+ 					   struct event_context *ev,
+ 					   struct cli_state *cli,
+ 					   uint16_t fnum,
+-					   off_t offset, size_t size)
++					   off64_t offset, size_t size)
+ {
+ 	struct tevent_req *req, *subreq;
+ 	struct cli_readall_state *state;
+@@ -392,7 +392,7 @@ struct cli_pull_state {
+ 	struct event_context *ev;
+ 	struct cli_state *cli;
+ 	uint16_t fnum;
+-	off_t start_offset;
++	off64_t start_offset;
+ 	SMB_OFF_T size;
+ 
+ 	NTSTATUS (*sink)(char *buf, size_t n, void *priv);
+@@ -451,7 +451,7 @@ static void cli_pull_read_done(struct te
+ struct tevent_req *cli_pull_send(TALLOC_CTX *mem_ctx,
+ 				 struct event_context *ev,
+ 				 struct cli_state *cli,
+-				 uint16_t fnum, off_t start_offset,
++				 uint16_t fnum, off64_t start_offset,
+ 				 SMB_OFF_T size, size_t window_size,
+ 				 NTSTATUS (*sink)(char *buf, size_t n,
+ 						  void *priv),
+@@ -649,7 +649,7 @@ NTSTATUS cli_pull_recv(struct tevent_req
+ }
+ 
+ NTSTATUS cli_pull(struct cli_state *cli, uint16_t fnum,
+-		  off_t start_offset, SMB_OFF_T size, size_t window_size,
++		  off64_t start_offset, SMB_OFF_T size, size_t window_size,
+ 		  NTSTATUS (*sink)(char *buf, size_t n, void *priv),
+ 		  void *priv, SMB_OFF_T *received)
+ {
+@@ -699,7 +699,7 @@ static NTSTATUS cli_read_sink(char *buf,
+ }
+ 
+ ssize_t cli_read(struct cli_state *cli, uint16_t fnum, char *buf,
+-		 off_t offset, size_t size)
++		 off64_t offset, size_t size)
+ {
+ 	NTSTATUS status;
+ 	SMB_OFF_T ret;
+@@ -717,7 +717,7 @@ ssize_t cli_read(struct cli_state *cli,
+ ****************************************************************************/
+ 
+ NTSTATUS cli_smbwrite(struct cli_state *cli, uint16_t fnum, char *buf,
+-		      off_t offset, size_t size1, size_t *ptotal)
++		      off64_t offset, size_t size1, size_t *ptotal)
+ {
+ 	uint8_t *bytes;
+ 	ssize_t total = 0;
+@@ -797,7 +797,7 @@ struct tevent_req *cli_write_andx_create
+ 					 struct event_context *ev,
+ 					 struct cli_state *cli, uint16_t fnum,
+ 					 uint16_t mode, const uint8_t *buf,
+-					 off_t offset, size_t size,
++					 off64_t offset, size_t size,
+ 					 struct tevent_req **reqs_before,
+ 					 int num_reqs_before,
+ 					 struct tevent_req **psmbreq)
+@@ -860,7 +860,7 @@ struct tevent_req *cli_write_andx_send(T
+ 				       struct event_context *ev,
+ 				       struct cli_state *cli, uint16_t fnum,
+ 				       uint16_t mode, const uint8_t *buf,
+-				       off_t offset, size_t size)
++				       off64_t offset, size_t size)
+ {
+ 	struct tevent_req *req, *subreq;
+ 	NTSTATUS status;
+@@ -931,7 +931,7 @@ struct cli_writeall_state {
+ 	uint16_t fnum;
+ 	uint16_t mode;
+ 	const uint8_t *buf;
+-	off_t offset;
++	off64_t offset;
+ 	size_t size;
+ 	size_t written;
+ };
+@@ -944,7 +944,7 @@ static struct tevent_req *cli_writeall_s
+ 					    uint16_t fnum,
+ 					    uint16_t mode,
+ 					    const uint8_t *buf,
+-					    off_t offset, size_t size)
++					    off64_t offset, size_t size)
+ {
+ 	struct tevent_req *req, *subreq;
+ 	struct cli_writeall_state *state;
+@@ -1028,7 +1028,7 @@ static NTSTATUS cli_writeall_recv(struct
+ }
+ 
+ NTSTATUS cli_writeall(struct cli_state *cli, uint16_t fnum, uint16_t mode,
+-		      const uint8_t *buf, off_t offset, size_t size,
++		      const uint8_t *buf, off64_t offset, size_t size,
+ 		      size_t *pwritten)
+ {
+ 	TALLOC_CTX *frame = talloc_stackframe();
+@@ -1064,7 +1064,7 @@ NTSTATUS cli_writeall(struct cli_state *
+ struct cli_push_write_state {
+ 	struct tevent_req *req;/* This is the main request! Not the subreq */
+ 	uint32_t idx;
+-	off_t ofs;
++	off64_t ofs;
+ 	uint8_t *buf;
+ 	size_t size;
+ };
+@@ -1074,7 +1074,7 @@ struct cli_push_state {
+ 	struct cli_state *cli;
+ 	uint16_t fnum;
+ 	uint16_t mode;
+-	off_t start_offset;
++	off64_t start_offset;
+ 	size_t window_size;
+ 
+ 	size_t (*source)(uint8_t *buf, size_t n, void *priv);
+@@ -1083,7 +1083,7 @@ struct cli_push_state {
+ 	bool eof;
+ 
+ 	size_t chunk_size;
+-	off_t next_offset;
++	off64_t next_offset;
+ 
+ 	/*
+ 	 * Outstanding requests
+@@ -1146,7 +1146,7 @@ static bool cli_push_write_setup(struct
+ struct tevent_req *cli_push_send(TALLOC_CTX *mem_ctx, struct event_context *ev,
+ 				 struct cli_state *cli,
+ 				 uint16_t fnum, uint16_t mode,
+-				 off_t start_offset, size_t window_size,
++				 off64_t start_offset, size_t window_size,
+ 				 size_t (*source)(uint8_t *buf, size_t n,
+ 						  void *priv),
+ 				 void *priv)
+@@ -1249,7 +1249,7 @@ NTSTATUS cli_push_recv(struct tevent_req
+ }
+ 
+ NTSTATUS cli_push(struct cli_state *cli, uint16_t fnum, uint16_t mode,
+-		  off_t start_offset, size_t window_size,
++		  off64_t start_offset, size_t window_size,
+ 		  size_t (*source)(uint8_t *buf, size_t n, void *priv),
+ 		  void *priv)
+ {
+diff -pur samba-3.6.12/source3/libsmb/libsmb_compat.c arm-linux-androideabi-21/source3/libsmb/libsmb_compat.c
+--- samba-3.6.12/source3/libsmb/libsmb_compat.c	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/source3/libsmb/libsmb_compat.c	2016-07-27 20:03:05.636479317 +0200
+@@ -213,9 +213,9 @@ smbc_write(int fd,
+         return smbc_getFunctionWrite(statcont)(statcont, file, buf, bufsize);
+ }
+ 
+-off_t
++off64_t
+ smbc_lseek(int fd,
+-           off_t offset,
++           off64_t offset,
+            int whence)
+ {
+ 	SMBCFILE * file = find_fd(fd);
+@@ -285,7 +285,7 @@ smbc_readdir(unsigned int dh)
+         return smbc_getFunctionReaddir(statcont)(statcont, file);
+ }
+ 
+-off_t
++off64_t
+ smbc_telldir(int dh)
+ {
+ 	SMBCFILE * file = find_fd(dh);
+@@ -294,7 +294,7 @@ smbc_telldir(int dh)
+ 
+ int
+ smbc_lseekdir(int fd,
+-              off_t offset)
++              off64_t offset)
+ {
+ 	SMBCFILE * file = find_fd(fd);
+         return smbc_getFunctionLseekdir(statcont)(statcont, file, offset);
+@@ -345,7 +345,7 @@ smbc_fstatvfs(int fd,
+ 
+ int
+ smbc_ftruncate(int fd,
+-               off_t size)
++               off64_t size)
+ {
+ 	SMBCFILE * file = find_fd(fd);
+         return smbc_getFunctionFtruncate(statcont)(statcont, file, size);
+diff -pur samba-3.6.12/source3/libsmb/libsmb_dir.c arm-linux-androideabi-21/source3/libsmb/libsmb_dir.c
+--- samba-3.6.12/source3/libsmb/libsmb_dir.c	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/source3/libsmb/libsmb_dir.c	2016-07-27 20:08:51.646552457 +0200
+@@ -1383,7 +1383,7 @@ SMBC_rmdir_ctx(SMBCCTX *context,
+  * Routine to return the current directory position
+  */
+ 
+-off_t
++off64_t
+ SMBC_telldir_ctx(SMBCCTX *context,
+                  SMBCFILE *dir)
+ {
+@@ -1424,7 +1424,7 @@ SMBC_telldir_ctx(SMBCCTX *context,
+ 	 * We return the pointer here as the offset
+ 	 */
+ 	TALLOC_FREE(frame);
+-        return (off_t)(long)dir->dir_next->dirent;
++        return (off64_t)(long)dir->dir_next->dirent;
+ }
+ 
+ /*
+@@ -1465,7 +1465,7 @@ check_dir_ent(struct smbc_dir_list *list
+ int
+ SMBC_lseekdir_ctx(SMBCCTX *context,
+                   SMBCFILE *dir,
+-                  off_t offset)
++                  off64_t offset)
+ {
+ 	long int l_offset = offset;  /* Handle problems of size */
+ 	struct smbc_dirent *dirent = (struct smbc_dirent *)l_offset;
+diff -pur samba-3.6.12/source3/libsmb/libsmb_file.c arm-linux-androideabi-21/source3/libsmb/libsmb_file.c
+--- samba-3.6.12/source3/libsmb/libsmb_file.c	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/source3/libsmb/libsmb_file.c	2016-07-27 20:09:06.190639760 +0200
+@@ -235,12 +235,12 @@ SMBC_read_ctx(SMBCCTX *context,
+          * offset:
+          *
+          * Compiler bug (possibly) -- gcc (GCC) 3.3.5 (Debian 1:3.3.5-2) --
+-         * appears to pass file->offset (which is type off_t) differently than
+-         * a local variable of type off_t.  Using local variable "offset" in
++         * appears to pass file->offset (which is type off64_t) differently than
++         * a local variable of type off64_t.  Using local variable "offset" in
+          * the call to cli_read() instead of file->offset fixes a problem
+          * retrieving data at an offset greater than 4GB.
+          */
+-        off_t offset;
++        off64_t offset;
+ 
+ 	if (!context || !context->internal->initialized) {
+ 		errno = EINVAL;
+@@ -319,7 +319,7 @@ SMBC_write_ctx(SMBCCTX *context,
+                const void *buf,
+                size_t count)
+ {
+-        off_t offset;
++        off64_t offset;
+ 	char *server = NULL, *share = NULL, *user = NULL, *password = NULL;
+ 	char *path = NULL;
+ 	char *targetpath = NULL;
+@@ -665,10 +665,10 @@ SMBC_setatr(SMBCCTX * context, SMBCSRV *
+  * A routine to lseek() a file
+  */
+ 
+-off_t
++off64_t
+ SMBC_lseek_ctx(SMBCCTX *context,
+                SMBCFILE *file,
+-               off_t offset,
++               off64_t offset,
+                int whence)
+ {
+ 	SMB_OFF_T size;
+@@ -763,7 +763,7 @@ SMBC_lseek_ctx(SMBCCTX *context,
+ int
+ SMBC_ftruncate_ctx(SMBCCTX *context,
+                    SMBCFILE *file,
+-                   off_t length)
++                   off64_t length)
+ {
+ 	SMB_OFF_T size = length;
+ 	char *server = NULL;
+diff -pur samba-3.6.12/source3/libsmb/proto.h arm-linux-androideabi-21/source3/libsmb/proto.h
+--- samba-3.6.12/source3/libsmb/proto.h	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/source3/libsmb/proto.h	2016-07-27 20:08:33.766445144 +0200
+@@ -691,36 +691,36 @@ NTSTATUS cli_set_fs_quota_info(struct cl
+ struct tevent_req *cli_read_andx_create(TALLOC_CTX *mem_ctx,
+ 					struct event_context *ev,
+ 					struct cli_state *cli, uint16_t fnum,
+-					off_t offset, size_t size,
++					off64_t offset, size_t size,
+ 					struct tevent_req **psmbreq);
+ struct tevent_req *cli_read_andx_send(TALLOC_CTX *mem_ctx,
+ 				      struct event_context *ev,
+ 				      struct cli_state *cli, uint16_t fnum,
+-				      off_t offset, size_t size);
++				      off64_t offset, size_t size);
+ NTSTATUS cli_read_andx_recv(struct tevent_req *req, ssize_t *received,
+ 			    uint8_t **rcvbuf);
+ struct tevent_req *cli_pull_send(TALLOC_CTX *mem_ctx,
+ 				 struct event_context *ev,
+ 				 struct cli_state *cli,
+-				 uint16_t fnum, off_t start_offset,
++				 uint16_t fnum, off64_t start_offset,
+ 				 SMB_OFF_T size, size_t window_size,
+ 				 NTSTATUS (*sink)(char *buf, size_t n,
+ 						  void *priv),
+ 				 void *priv);
+ NTSTATUS cli_pull_recv(struct tevent_req *req, SMB_OFF_T *received);
+ NTSTATUS cli_pull(struct cli_state *cli, uint16_t fnum,
+-		  off_t start_offset, SMB_OFF_T size, size_t window_size,
++		  off64_t start_offset, SMB_OFF_T size, size_t window_size,
+ 		  NTSTATUS (*sink)(char *buf, size_t n, void *priv),
+ 		  void *priv, SMB_OFF_T *received);
+ ssize_t cli_read(struct cli_state *cli, uint16_t fnum, char *buf,
+-		 off_t offset, size_t size);
++		 off64_t offset, size_t size);
+ NTSTATUS cli_smbwrite(struct cli_state *cli, uint16_t fnum, char *buf,
+-		      off_t offset, size_t size1, size_t *ptotal);
++		      off64_t offset, size_t size1, size_t *ptotal);
+ struct tevent_req *cli_write_andx_create(TALLOC_CTX *mem_ctx,
+ 					 struct event_context *ev,
+ 					 struct cli_state *cli, uint16_t fnum,
+ 					 uint16_t mode, const uint8_t *buf,
+-					 off_t offset, size_t size,
++					 off64_t offset, size_t size,
+ 					 struct tevent_req **reqs_before,
+ 					 int num_reqs_before,
+ 					 struct tevent_req **psmbreq);
+@@ -728,23 +728,23 @@ struct tevent_req *cli_write_andx_send(T
+ 				       struct event_context *ev,
+ 				       struct cli_state *cli, uint16_t fnum,
+ 				       uint16_t mode, const uint8_t *buf,
+-				       off_t offset, size_t size);
++				       off64_t offset, size_t size);
+ NTSTATUS cli_write_andx_recv(struct tevent_req *req, size_t *pwritten);
+ 
+ NTSTATUS cli_writeall(struct cli_state *cli, uint16_t fnum, uint16_t mode,
+-		      const uint8_t *buf, off_t offset, size_t size,
++		      const uint8_t *buf, off64_t offset, size_t size,
+ 		      size_t *pwritten);
+ 
+ struct tevent_req *cli_push_send(TALLOC_CTX *mem_ctx, struct event_context *ev,
+ 				 struct cli_state *cli,
+ 				 uint16_t fnum, uint16_t mode,
+-				 off_t start_offset, size_t window_size,
++				 off64_t start_offset, size_t window_size,
+ 				 size_t (*source)(uint8_t *buf, size_t n,
+ 						  void *priv),
+ 				 void *priv);
+ NTSTATUS cli_push_recv(struct tevent_req *req);
+ NTSTATUS cli_push(struct cli_state *cli, uint16_t fnum, uint16_t mode,
+-		  off_t start_offset, size_t window_size,
++		  off64_t start_offset, size_t window_size,
+ 		  size_t (*source)(uint8_t *buf, size_t n, void *priv),
+ 		  void *priv);
+ 
+diff -pur samba-3.6.12/source3/registry/regfio.c arm-linux-androideabi-21/source3/registry/regfio.c
+--- samba-3.6.12/source3/registry/regfio.c	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/source3/registry/regfio.c	2016-07-27 20:09:31.246790183 +0200
+@@ -492,7 +492,7 @@ static bool read_regf_block( REGF_FILE *
+ /*******************************************************************
+ *******************************************************************/
+ 
+-static REGF_HBIN* read_hbin_block( REGF_FILE *file, off_t offset )
++static REGF_HBIN* read_hbin_block( REGF_FILE *file, off64_t offset )
+ {
+ 	REGF_HBIN *hbin;
+ 	uint32 record_size, curr_off, block_size, header;
+diff -pur samba-3.6.12/source3/utils/smbget.c arm-linux-androideabi-21/source3/utils/smbget.c
+--- samba-3.6.12/source3/utils/smbget.c	2013-01-29 09:49:31.000000000 +0100
++++ arm-linux-androideabi-21/source3/utils/smbget.c	2016-07-27 20:09:47.194885943 +0200
+@@ -36,7 +36,7 @@ static char *outputfile;
+ 
+ 
+ static time_t total_start_time = 0;
+-static off_t total_bytes = 0;
++static off64_t total_bytes = 0;
+ 
+ #define SMB_MAXPATHLEN MAXPATHLEN
+ 
+@@ -75,7 +75,7 @@ static void change_columns(int sig)
+ 	columns = get_num_cols();
+ }
+ 
+-static void human_readable(off_t s, char *buffer, int l)
++static void human_readable(off64_t s, char *buffer, int l)
+ {
+ 	if (s > 1024 * 1024 * 1024) {
+ 		snprintf(buffer, l, "%.2fGB", 1.0 * s / (1024 * 1024 * 1024));
+@@ -239,7 +239,7 @@ static char *print_time(long t)
+ 	return buffer;
+ }
+ 
+-static void print_progress(const char *name, time_t start, time_t now, off_t start_pos, off_t pos, off_t total)
++static void print_progress(const char *name, time_t start, time_t now, off64_t start_pos, off64_t pos, off64_t total)
+ {
+ 	double avg = 0.0;
+ 	long  eta = -1; 
+@@ -287,7 +287,7 @@ static int smb_download_file(const char
+ 	char path[SMB_MAXPATHLEN];
+ 	char checkbuf[2][RESUME_CHECK_SIZE];
+ 	char *readbuf = NULL;
+-	off_t offset_download = 0, offset_check = 0, curpos = 0, start_offset = 0;
++	off64_t offset_download = 0, offset_check = 0, curpos = 0, start_offset = 0;
+ 	struct stat localstat, remotestat;
+ 
+ 	snprintf(path, SMB_MAXPATHLEN-1, "%s%s%s", base, (*base && *name && name[0] != '/' && base[strlen(base)-1] != '/')?"/":"", name);
+@@ -395,7 +395,7 @@ static int smb_download_file(const char
+ 		}
+ 
+ 		if(offset_check) { 
+-			off_t off1, off2;
++			off64_t off1, off2;
+ 			/* First, check all bytes from offset_check to offset_download */
+ 			off1 = lseek(localhandle, offset_check, SEEK_SET);
+ 			if(off1 < 0) {
-- 
2.7.4


From 21b63b1b81ff0b77969eb6e900b6e398a08007f7 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Sun, 25 Sep 2016 20:32:49 +0200
Subject: [PATCH 066/175] android: resolve symlinks when copying libs to
 install dir

---
 project/cmake/scripts/android/Install.cmake | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/project/cmake/scripts/android/Install.cmake b/project/cmake/scripts/android/Install.cmake
index d8c8ba2..d95ba94 100644
--- a/project/cmake/scripts/android/Install.cmake
+++ b/project/cmake/scripts/android/Install.cmake
@@ -61,9 +61,16 @@ function(add_bundle_file file destination relative)
   endif()
 
   string(REPLACE "${relative}/" "" outfile ${file})
+  get_filename_component(file ${file} REALPATH)
   get_filename_component(outdir ${outfile} DIRECTORY)
   file(APPEND ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/BundleFiles.cmake
        "file(COPY \"${file}\" DESTINATION \"${destination}/${outdir}\")\n")
+  if(file MATCHES "\.so\..+$")
+    get_filename_component(srcfile "${file}" NAME)
+    string(REGEX REPLACE "\.so\..+$" "\.so" destfile ${srcfile})
+    file(APPEND ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/BundleFiles.cmake
+         "file(RENAME \"${destination}/${outdir}/${srcfile}\" \"${destination}/${destfile}\")\n")
+  endif()
 endfunction()
 
 # Copy files into prefix
-- 
2.7.4


From 872eba71b74676a23cdd1718f6479fcf34b9a371 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Sun, 25 Sep 2016 20:58:41 +0200
Subject: [PATCH 067/175] set CMAKE_STRIP in Toolchain.cmake

---
 tools/depends/target/Toolchain.cmake.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/tools/depends/target/Toolchain.cmake.in b/tools/depends/target/Toolchain.cmake.in
index 7f86d8b..e4da859 100644
--- a/tools/depends/target/Toolchain.cmake.in
+++ b/tools/depends/target/Toolchain.cmake.in
@@ -72,6 +72,7 @@ set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
 set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
 set(ENV{PKG_CONFIG_LIBDIR} @prefix@/@deps_dir@/lib/pkgconfig)
 
+set(CMAKE_STRIP @STRIP@)
 # Binary Addons
 if(NOT OS STREQUAL "linux")
   set(ADDONS_PREFER_STATIC_LIBS ON)
-- 
2.7.4


From e89f63e9ce4c891f7ce0491f8c1d9e6ea26c02de Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Sun, 25 Sep 2016 21:50:40 +0200
Subject: [PATCH 068/175] fix packaging for aarch64

---
 tools/android/packaging/Makefile.in | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/tools/android/packaging/Makefile.in b/tools/android/packaging/Makefile.in
index b53ca30..3922df2 100644
--- a/tools/android/packaging/Makefile.in
+++ b/tools/android/packaging/Makefile.in
@@ -34,8 +34,10 @@ ARCH=x86
 CPU=x86
 endif
 ifeq ($(findstring arm,$(CPU)),arm)
-ARCH=arm
-CPU=armeabi-v7a
+  ifneq ($(findstring arm64,$(CPU)),arm64)
+    ARCH=arm
+    CPU=armeabi-v7a
+endif
 endif
 
 #older ndk x86
@@ -51,6 +53,10 @@ ifneq ($(shell test -f $(GDBPATH) && echo 1),1)
 GDBPATH=$(NDKROOT)/prebuilt/android-$(ARCH)/gdbserver/gdbserver
 endif
 
+ifeq ($(ARCH),aarch64)
+GDBPATH=$(NDKROOT)/prebuilt/android-arm64/gdbserver/gdbserver
+endif
+
 SRCLIBS = $(addprefix $(PREFIX)/lib/,$(OBJS)) $(addprefix $(PREFIX)/lib/$(SDK_PLATFORM)/,$(PLATFORM_OBJS))
 DSTLIBS = $(CPU)/lib/lib@APP_NAME_LC@.so $(addprefix $(CPU)/lib/,$(OBJS)) $(addprefix $(CPU)/lib/,$(PLATFORM_OBJS))
 libs= $(DSTLIBS)
@@ -115,7 +121,7 @@ res:
 libs: $(PREFIX)/lib/@APP_NAME_LC@/lib@APP_NAME_LC@.so
 	rm -rf xbmc/lib/$(CPU) xbmc/libs/$(CPU) xbmc/obj/local/$(CPU)
 	mkdir -p xbmc/lib/$(CPU) xbmc/assets/python2.7/lib/ xbmc/libs/$(CPU) xbmc/obj/local/$(CPU)
-	cp -fp $(SRCLIBS) xbmc/obj/local/$(CPU)/
+	cp -fpL $(SRCLIBS) xbmc/obj/local/$(CPU)/
 	cp -fp $(PREFIX)/lib/@APP_NAME_LC@/lib@APP_NAME_LC@.so xbmc/obj/local/$(CPU)/
 	find $(PREFIX)/lib/@APP_NAME_LC@/addons -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \;
 	find $(PREFIX)/share/@APP_NAME_LC@/addons -name "*.so" -exec cp -fp {} xbmc/obj/local/$(CPU)/ \;
-- 
2.7.4


From 7be7b07637786b3c51d7bfd85ed338e91eb92c81 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Tue, 27 Sep 2016 10:04:59 +0200
Subject: [PATCH 069/175] bump default sdk version to 21 / remove offs64
 overrides in dvdnav/read

---
 tools/depends/configure.ac               | 2 +-
 tools/depends/target/libdvdnav/Makefile  | 3 ---
 tools/depends/target/libdvdread/Makefile | 3 ---
 3 files changed, 1 insertion(+), 7 deletions(-)

diff --git a/tools/depends/configure.ac b/tools/depends/configure.ac
index 6345adb..b09c2b7 100644
--- a/tools/depends/configure.ac
+++ b/tools/depends/configure.ac
@@ -130,7 +130,7 @@ case $host in
     if test "x$use_cpu" = "xauto"; then
       use_cpu="armeabi-v7a"
     fi
-    use_sdk="${use_sdk:-android-17}"
+    use_sdk="${use_sdk:-android-21}"
     deps_dir="$use_host-$use_sdk"
     platform_cflags="-DANDROID -Os -fexceptions"
     if test "x$use_cpu" = "xarmeabi-v7a"; then
diff --git a/tools/depends/target/libdvdnav/Makefile b/tools/depends/target/libdvdnav/Makefile
index 3127c13..cd44351 100644
--- a/tools/depends/target/libdvdnav/Makefile
+++ b/tools/depends/target/libdvdnav/Makefile
@@ -22,9 +22,6 @@ else
 endif
 
 
-ifeq ($(OS),android)
-  EXTRA_CFLAGS +=  -D_FILE_OFFSET_BITS=64 -D_OFF_T_DEFINED_ -Doff_t=off64_t -Dlseek=lseek64
-endif
 ifeq ($(OS),osx)
   EXTRA_CFLAGS +=  -D__DARWIN__
 endif
diff --git a/tools/depends/target/libdvdread/Makefile b/tools/depends/target/libdvdread/Makefile
index a4f0441..3652f1b 100644
--- a/tools/depends/target/libdvdread/Makefile
+++ b/tools/depends/target/libdvdread/Makefile
@@ -25,9 +25,6 @@ ifneq ($(OS),ios)
   config += --with-libdvdcss
   EXTRA_CFLAGS += -DHAVE_DVDCSS_DVDCSS_H
 endif
-ifeq ($(OS),android)
-  EXTRA_CFLAGS +=  -D_FILE_OFFSET_BITS=64 -D_OFF_T_DEFINED_ -Doff_t=off64_t -Dlseek=lseek64
-endif
 ifeq ($(OS),osx)
   EXTRA_CFLAGS +=  -D__DARWIN__
 endif
-- 
2.7.4


From 8fe698af66ea63647d4f7bbfa1a5b49153b2b637 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Thu, 29 Sep 2016 09:05:23 +0200
Subject: [PATCH 070/175] Fix BundleFiles RegExp

---
 project/cmake/scripts/android/Install.cmake | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/project/cmake/scripts/android/Install.cmake b/project/cmake/scripts/android/Install.cmake
index d95ba94..5c66f41 100644
--- a/project/cmake/scripts/android/Install.cmake
+++ b/project/cmake/scripts/android/Install.cmake
@@ -65,11 +65,11 @@ function(add_bundle_file file destination relative)
   get_filename_component(outdir ${outfile} DIRECTORY)
   file(APPEND ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/BundleFiles.cmake
        "file(COPY \"${file}\" DESTINATION \"${destination}/${outdir}\")\n")
-  if(file MATCHES "\.so\..+$")
+  if(file MATCHES "\\.so\\..+$")
     get_filename_component(srcfile "${file}" NAME)
-    string(REGEX REPLACE "\.so\..+$" "\.so" destfile ${srcfile})
+    string(REGEX REPLACE "\\.so\\..+$" "\.so" destfile ${srcfile})
     file(APPEND ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/BundleFiles.cmake
-         "file(RENAME \"${destination}/${outdir}/${srcfile}\" \"${destination}/${destfile}\")\n")
+         "file(RENAME \"${destination}/${outdir}/${srcfile}\" \"${destination}/${outdir}/${destfile}\")\n")
   endif()
 endfunction()
 
-- 
2.7.4


From 17a085e350a1d6ad1059a364bb8bd4dcd6b1f986 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Tue, 27 Sep 2016 20:45:28 +0200
Subject: [PATCH 071/175] allow building with jdk 8

TODO: use cmake's Java_JAVAC_EXECUTABLE var and version instead of calling javac directly
---
 tools/android/packaging/Makefile.in | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/tools/android/packaging/Makefile.in b/tools/android/packaging/Makefile.in
index 3922df2..9e3a4d6 100644
--- a/tools/android/packaging/Makefile.in
+++ b/tools/android/packaging/Makefile.in
@@ -57,6 +57,12 @@ ifeq ($(ARCH),aarch64)
 GDBPATH=$(NDKROOT)/prebuilt/android-arm64/gdbserver/gdbserver
 endif
 
+# check for java 1.8
+JAVA8=$(shell java -version 2>&1 | grep -q '1.8.[0-9]' && echo yes)
+ifeq ($(JAVA8),yes)
+  JAVAC_EXTRA_ARGS = -source 1.7 -target 1.7
+endif
+
 SRCLIBS = $(addprefix $(PREFIX)/lib/,$(OBJS)) $(addprefix $(PREFIX)/lib/$(SDK_PLATFORM)/,$(PLATFORM_OBJS))
 DSTLIBS = $(CPU)/lib/lib@APP_NAME_LC@.so $(addprefix $(CPU)/lib/,$(OBJS)) $(addprefix $(CPU)/lib/,$(PLATFORM_OBJS))
 libs= $(DSTLIBS)
@@ -137,8 +143,8 @@ libs: $(PREFIX)/lib/@APP_NAME_LC@/lib@APP_NAME_LC@.so
 
 xbmc/classes.dex: res
 	mkdir -p xbmc/obj
-	@javac -classpath $(SDKROOT)/platforms/$(SDK_PLATFORM)/android.jar:xbmc/obj -d xbmc/obj -sourcepath xbmc/src xbmc/src/*.java
-	@javac -classpath $(SDKROOT)/platforms/$(SDK_PLATFORM)/android.jar:xbmc/obj -d xbmc/obj -sourcepath xbmc/src xbmc/src/org/xbmc/kodi/*.java
+	@javac -classpath $(SDKROOT)/platforms/$(SDK_PLATFORM)/android.jar:xbmc/obj -d xbmc/obj -sourcepath xbmc/src xbmc/src/*.java $(JAVAC_EXTRA_ARGS)
+	@javac -classpath $(SDKROOT)/platforms/$(SDK_PLATFORM)/android.jar:xbmc/obj -d xbmc/obj -sourcepath xbmc/src xbmc/src/org/xbmc/kodi/*.java $(JAVAC_EXTRA_ARGS)
 	@$(DX) --dex --output=xbmc/classes.dex xbmc/obj
 
 package: libs python xbmc/classes.dex
-- 
2.7.4


From a8bae49dddd30139193df9df28cda4a3a55505dc Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Thu, 29 Sep 2016 21:49:56 +0200
Subject: [PATCH 072/175] version bump / strip force

---
 tools/buildsteps/defaultenv             | 4 ++--
 tools/depends/configure.ac              | 4 ++--
 tools/depends/target/Toolchain.cmake.in | 2 +-
 3 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/tools/buildsteps/defaultenv b/tools/buildsteps/defaultenv
index 6d620ab..8674b63 100644
--- a/tools/buildsteps/defaultenv
+++ b/tools/buildsteps/defaultenv
@@ -30,8 +30,8 @@ case $XBMC_PLATFORM_DIR in
     ;;
 
   android)
-    DEFAULT_SDK_VERSION="17"
-    DEFAULT_NDK_VERSION="10e"
+    DEFAULT_SDK_VERSION="21"
+    DEFAULT_NDK_VERSION="12b"
     DEFAULT_XBMC_DEPENDS_ROOT=$WORKSPACE/tools/depends/xbmc-depends
     DEFAULT_CONFIGURATION="Debug"
     ;;
diff --git a/tools/depends/configure.ac b/tools/depends/configure.ac
index b09c2b7..f6f9fc3 100644
--- a/tools/depends/configure.ac
+++ b/tools/depends/configure.ac
@@ -59,7 +59,7 @@ AC_ARG_WITH([sdk-path],
 
 AC_ARG_WITH([sdk],
   [AS_HELP_STRING([--with-sdk],
-  [spcify sdk platform version (optional for android). default is android-17])],
+  [spcify sdk platform version (optional for android). default is android-21])],
   [use_sdk=$withval])
 
 AC_ARG_ENABLE([gplv3],
@@ -164,7 +164,7 @@ case $host in
     if test "x$use_cpu" = "xauto"; then
       use_cpu=$host_cpu
     fi
-    use_sdk="${use_sdk:-android-17}"
+    use_sdk="${use_sdk:-android-21}"
     deps_dir="$use_host-$use_sdk"
     platform_cflags="-DANDROID -Os -fexceptions"
     platform_ldflags="-L$prefix/$deps_dir/lib/$use_sdk"
diff --git a/tools/depends/target/Toolchain.cmake.in b/tools/depends/target/Toolchain.cmake.in
index e4da859..d333417 100644
--- a/tools/depends/target/Toolchain.cmake.in
+++ b/tools/depends/target/Toolchain.cmake.in
@@ -72,7 +72,7 @@ set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
 set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
 set(ENV{PKG_CONFIG_LIBDIR} @prefix@/@deps_dir@/lib/pkgconfig)
 
-set(CMAKE_STRIP @STRIP@)
+set(CMAKE_STRIP @STRIP@ CACHE PATH "strip binary" FORCE)
 # Binary Addons
 if(NOT OS STREQUAL "linux")
   set(ADDONS_PREFER_STATIC_LIBS ON)
-- 
2.7.4


From 5e87ae3157f4fa3506f8d2a8e80c3d3acf6f5989 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Thu, 29 Sep 2016 21:55:01 +0200
Subject: [PATCH 073/175] add aarch64 buildstep

---
 .../buildsteps/android-arm64-v8a/configure-depends | 21 +++++++++++++++
 tools/buildsteps/android-arm64-v8a/configure-xbmc  |  5 ++++
 .../android-arm64-v8a/make-binary-addons           | 31 ++++++++++++++++++++++
 tools/buildsteps/android-arm64-v8a/make-depends    |  9 +++++++
 .../android-arm64-v8a/make-native-depends          |  9 +++++++
 tools/buildsteps/android-arm64-v8a/make-xbmc       |  5 ++++
 tools/buildsteps/android-arm64-v8a/package         | 23 ++++++++++++++++
 tools/buildsteps/android-arm64-v8a/prepare-depends | 15 +++++++++++
 tools/buildsteps/android-arm64-v8a/prepare-xbmc    |  9 +++++++
 9 files changed, 127 insertions(+)
 create mode 100644 tools/buildsteps/android-arm64-v8a/configure-depends
 create mode 100644 tools/buildsteps/android-arm64-v8a/configure-xbmc
 create mode 100644 tools/buildsteps/android-arm64-v8a/make-binary-addons
 create mode 100644 tools/buildsteps/android-arm64-v8a/make-depends
 create mode 100644 tools/buildsteps/android-arm64-v8a/make-native-depends
 create mode 100644 tools/buildsteps/android-arm64-v8a/make-xbmc
 create mode 100644 tools/buildsteps/android-arm64-v8a/package
 create mode 100644 tools/buildsteps/android-arm64-v8a/prepare-depends
 create mode 100644 tools/buildsteps/android-arm64-v8a/prepare-xbmc

diff --git a/tools/buildsteps/android-arm64-v8a/configure-depends b/tools/buildsteps/android-arm64-v8a/configure-depends
new file mode 100644
index 0000000..7ab5d71
--- /dev/null
+++ b/tools/buildsteps/android-arm64-v8a/configure-depends
@@ -0,0 +1,21 @@
+WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
+XBMC_PLATFORM_DIR=android
+. $WORKSPACE/tools/buildsteps/defaultenv
+
+NDK_ARCH=aarch64
+#the following pathes must exist on the slave and use the defined scheme here!
+NDK_PATH=$ANDROID_DEV_ROOT/android-ndk-r$NDK_VERSION
+TOOLCHAIN=$ANDROID_DEV_ROOT/android-toolchain-$NDK_ARCH-$SDK_VERSION-r$NDK_VERSION
+
+if [ "$(pathChanged $WORKSPACE/tools/depends)" == "1" ]
+then
+  cd $WORKSPACE/tools/depends;./configure \
+    --with-tarballs=$TARBALLS \
+    --host=aarch64-linux-android \
+    --with-sdk-path=$SDK_PATH \
+    --with-ndk=$NDK_PATH \
+    $(if [ "$SDK_VERSION" != "Default" ]; then echo --with-sdk=android-$SDK_VERSION;fi) \
+    --with-toolchain=$TOOLCHAIN \
+    --prefix=$XBMC_DEPENDS_ROOT \
+    --enable-neon
+fi
diff --git a/tools/buildsteps/android-arm64-v8a/configure-xbmc b/tools/buildsteps/android-arm64-v8a/configure-xbmc
new file mode 100644
index 0000000..81c0d3c
--- /dev/null
+++ b/tools/buildsteps/android-arm64-v8a/configure-xbmc
@@ -0,0 +1,5 @@
+WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
+XBMC_PLATFORM_DIR=android
+. $WORKSPACE/tools/buildsteps/defaultenv
+
+make -C $WORKSPACE/tools/depends/target/cmakebuildsys
diff --git a/tools/buildsteps/android-arm64-v8a/make-binary-addons b/tools/buildsteps/android-arm64-v8a/make-binary-addons
new file mode 100644
index 0000000..19a9d85
--- /dev/null
+++ b/tools/buildsteps/android-arm64-v8a/make-binary-addons
@@ -0,0 +1,31 @@
+WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
+XBMC_PLATFORM_DIR=android
+. $WORKSPACE/tools/buildsteps/defaultenv
+
+. $WORKSPACE/tools/buildsteps/$XBMC_PLATFORM_DIR/make-native-depends
+
+#clear the build failed file
+rm -f $WORKSPACE/project/cmake/$FAILED_BUILD_FILENAME
+
+ALL_BINARY_ADDONS_BUILT="1"
+#only build binary addons when requested by env/jenkins
+if [ "$BUILD_BINARY_ADDONS" == "true" ]
+then
+  for addon in $BINARY_ADDONS
+  do
+    echo "building $addon"
+    git clean -xffd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon
+
+    # Must match prefix in android/PathSetup.cmake
+    INSTALL_PREFIX="../../../../../build/install"
+    cd $WORKSPACE/$BINARY_ADDONS_ROOT/$addon;make -j $BUILDTHREADS V=99 VERBOSE=1 INSTALL_PREFIX="$INSTALL_PREFIX"  || ALL_BINARY_ADDONS_BUILT="0"
+  done
+fi
+
+if [ "$ALL_BINARY_ADDONS_BUILT" == "1" ]
+then
+  tagSuccessFulBuild $WORKSPACE/project/cmake
+else
+  #mark the build failure in the filesystem but leave jenkins running
+  tagFailedBuild $WORKSPACE/project/cmake
+fi
diff --git a/tools/buildsteps/android-arm64-v8a/make-depends b/tools/buildsteps/android-arm64-v8a/make-depends
new file mode 100644
index 0000000..c5869b2
--- /dev/null
+++ b/tools/buildsteps/android-arm64-v8a/make-depends
@@ -0,0 +1,9 @@
+WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
+XBMC_PLATFORM_DIR=android
+. $WORKSPACE/tools/buildsteps/defaultenv
+
+if [ "$(pathChanged $WORKSPACE/tools/depends)" == "1" ]
+then
+  cd $WORKSPACE/tools/depends;make -j $BUILDTHREADS && tagSuccessFulBuild $WORKSPACE/tools/depends
+fi
+
diff --git a/tools/buildsteps/android-arm64-v8a/make-native-depends b/tools/buildsteps/android-arm64-v8a/make-native-depends
new file mode 100644
index 0000000..c327180
--- /dev/null
+++ b/tools/buildsteps/android-arm64-v8a/make-native-depends
@@ -0,0 +1,9 @@
+WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
+XBMC_PLATFORM_DIR=android
+. $WORKSPACE/tools/buildsteps/defaultenv
+
+if [ "$(pathChanged $WORKSPACE/tools/depends)" == "1" ] && [ "$BINARY_ADDONS_CLEAN_NATIVETOOLS" != "0" ]
+then
+  git clean -xffd $WORKSPACE/tools/depends/native
+  cd $WORKSPACE/tools/depends/native;make -j $BUILDTHREADS && tagSuccessFulBuild $WORKSPACE/tools/depends
+fi
diff --git a/tools/buildsteps/android-arm64-v8a/make-xbmc b/tools/buildsteps/android-arm64-v8a/make-xbmc
new file mode 100644
index 0000000..11d8d70
--- /dev/null
+++ b/tools/buildsteps/android-arm64-v8a/make-xbmc
@@ -0,0 +1,5 @@
+WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
+XBMC_PLATFORM_DIR=android
+. $WORKSPACE/tools/buildsteps/defaultenv
+
+cd $WORKSPACE/build;make -j$BUILDTHREADS || make
diff --git a/tools/buildsteps/android-arm64-v8a/package b/tools/buildsteps/android-arm64-v8a/package
new file mode 100644
index 0000000..78b2b00
--- /dev/null
+++ b/tools/buildsteps/android-arm64-v8a/package
@@ -0,0 +1,23 @@
+WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
+XBMC_PLATFORM_DIR=android
+. $WORKSPACE/tools/buildsteps/defaultenv
+
+if [ "x$BUILD_OBB" == "xtrue" ]; then
+  TARGET=apk-obb-unsigned
+else
+  TARGET=apk-unsigned
+fi
+
+cd $WORKSPACE/build;make -j$BUILDTHREADS $TARGET
+$RUN_SIGNSTEP
+
+cd $WORKSPACE
+
+#rename for upload
+#e.x. xbmc-20130314-8c2fb31-Frodo-arm64-v8a.apk
+UPLOAD_FILENAME="kodi-$(getBuildRevDateStr)-arm64-v8a"
+mv kodiapp-arm64-v8a-*.apk $UPLOAD_FILENAME.apk
+if [ -f *.obb ]
+then
+  mv *.obb $UPLOAD_FILENAME.obb
+fi
diff --git a/tools/buildsteps/android-arm64-v8a/prepare-depends b/tools/buildsteps/android-arm64-v8a/prepare-depends
new file mode 100644
index 0000000..933ea45
--- /dev/null
+++ b/tools/buildsteps/android-arm64-v8a/prepare-depends
@@ -0,0 +1,15 @@
+WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
+XBMC_PLATFORM_DIR=android
+. $WORKSPACE/tools/buildsteps/defaultenv
+
+#clean without depends for skipping depends build if possible
+#also skip binary addons (pvr, audioencoder) as long as they are deployed in tree
+cd $WORKSPACE;git clean -xfd -e "project/cmake/.last_success_revision" -e "tools/depends" ${DEPLOYED_BINARY_ADDONS}
+
+# if depends path has changed - cleanout everything and do a full rebuild
+if [ "$(pathChanged $WORKSPACE/tools/depends)" == "1" ]
+then
+  #clean up the rest too
+  cd $WORKSPACE;git clean -xffd
+  cd $WORKSPACE/tools/depends/;./bootstrap
+fi
diff --git a/tools/buildsteps/android-arm64-v8a/prepare-xbmc b/tools/buildsteps/android-arm64-v8a/prepare-xbmc
new file mode 100644
index 0000000..144ed52
--- /dev/null
+++ b/tools/buildsteps/android-arm64-v8a/prepare-xbmc
@@ -0,0 +1,9 @@
+WORKSPACE=${WORKSPACE:-$( cd $(dirname $0)/../../.. ; pwd -P )}
+XBMC_PLATFORM_DIR=android
+. $WORKSPACE/tools/buildsteps/defaultenv
+
+#build binary addons before building xbmc...
+#make sure that binary_addons don't clean the native tools
+#here (e.x. on release builds where pathChanged always returns 1
+BINARY_ADDONS_CLEAN_NATIVETOOLS="0"
+. $WORKSPACE/tools/buildsteps/$XBMC_PLATFORM_DIR/make-binary-addons
-- 
2.7.4


From 21e177567780e4c16ef2c9826f0e25e23757fd06 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Fri, 30 Sep 2016 08:59:38 +0200
Subject: [PATCH 074/175] packaging fix

---
 tools/android/packaging/Makefile.in | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/tools/android/packaging/Makefile.in b/tools/android/packaging/Makefile.in
index 9e3a4d6..25df090 100644
--- a/tools/android/packaging/Makefile.in
+++ b/tools/android/packaging/Makefile.in
@@ -30,14 +30,15 @@ ARMOVERRIDES=XBMC_OVERRIDE_HOST=arm-linux-androideabi XBMC_OVERRIDE_TOOLCHAIN=$(
 #prebuilt stuff follow different name shemes for
 #arm and x86
 ifeq ($(findstring i686,$(CPU)),i686)
-ARCH=x86
-CPU=x86
-endif
-ifeq ($(findstring arm,$(CPU)),arm)
-  ifneq ($(findstring arm64,$(CPU)),arm64)
-    ARCH=arm
-    CPU=armeabi-v7a
+  ARCH=x86
+  CPU=x86
 endif
+ifeq ($(findstring arm64,$(CPU)),arm64)
+  ARCH=arm64
+  CPU=arm64-v8a
+else ifeq ($(findstring arm,$(CPU)),arm)
+  ARCH=arm
+  CPU=armeabi-v7a
 endif
 
 #older ndk x86
-- 
2.7.4


From 3d3dba63509ef81db31bb5c498768282145d6a21 Mon Sep 17 00:00:00 2001
From: mapfau <pfau@peak3d.de>
Date: Fri, 30 Sep 2016 15:13:34 +0200
Subject: [PATCH 075/175] splash fix for arm64

---
 .../xbmc/src/org/xbmc/kodi/Splash.java.in          | 68 ++++++++++------------
 1 file changed, 30 insertions(+), 38 deletions(-)

diff --git a/tools/android/packaging/xbmc/src/org/xbmc/kodi/Splash.java.in b/tools/android/packaging/xbmc/src/org/xbmc/kodi/Splash.java.in
index f52498c..41a5d3d 100644
--- a/tools/android/packaging/xbmc/src/org/xbmc/kodi/Splash.java.in
+++ b/tools/android/packaging/xbmc/src/org/xbmc/kodi/Splash.java.in
@@ -682,53 +682,45 @@ public class Splash extends Activity {
 
     mStateMachine.sendEmptyMessage(Checking);
 
-    String curArch = "";
-    String curArch2 = "";
-    try
-    {
-      curArch = Build.CPU_ABI.substring(0,3);
-    } catch (IndexOutOfBoundsException e)
-    {
-      mErrorMsg = "Error! Unexpected architecture: " + Build.CPU_ABI;
+    String pkg_arch = "";
+    // Read the properties
+    try {
+      Resources resources = this.getResources();
+      InputStream xbmcprop = resources.openRawResource(R.raw.xbmc);
+      Properties properties = new Properties();
+      properties.load(xbmcprop);
+      pkg_arch = properties.getProperty("native_arch");
+    } catch (NotFoundException e) {
+      mErrorMsg = "Cannot find properties file";
+      Log.e(TAG, mErrorMsg);
+      mState = InError;
+    } catch (IOException e) {
+      mErrorMsg = "Failed to open properties file";
       Log.e(TAG, mErrorMsg);
       mState = InError;
     }
-    try
-    {
-      curArch2 = Build.CPU_ABI2.substring(0,3);
-    } catch (IndexOutOfBoundsException e) {}
 
-    if (mState != InError)
+    boolean arch_ok = false;
+    String[] abis = Build.SUPPORTED_ABIS;
+    for (int i=0; i<abis.length; ++i)
     {
-      // Check if we are on the proper arch
-
-      // Read the properties
-      try {
-        Resources resources = this.getResources();
-        InputStream xbmcprop = resources.openRawResource(R.raw.xbmc);
-        Properties properties = new Properties();
-        properties.load(xbmcprop);
-
-        if (!curArch.equalsIgnoreCase(properties.getProperty("native_arch"))
-              && !curArch2.equalsIgnoreCase(properties.getProperty("native_arch")))
-        {
-          mErrorMsg = "This @APP_NAME@ package is not compatible with your device (device=" + curArch + " vs. package=" + properties.getProperty("native_arch") +").\nPlease check the <a href=\"http://wiki.kodi.tv/index.php?title=XBMC_for_Android_specific_FAQ\">Kodi Android wiki</a> for more information.";
-          Log.e(TAG, mErrorMsg);
-          mState = InError;
-        }
-      } catch (NotFoundException e) {
-        mErrorMsg = "Cannot find properties file";
-        Log.e(TAG, mErrorMsg);
-        mState = InError;
-      } catch (IOException e) {
-        mErrorMsg = "Failed to open properties file";
-        Log.e(TAG, mErrorMsg);
-        mState = InError;
+      Log.i(TAG, "ABI: " + abis[i]);
+      if (abis[i].equalsIgnoreCase(pkg_arch))
+      {
+        arch_ok = true;
+        //break;
       }
     }
 
+    if (!arch_ok)
+    {
+      mErrorMsg = "This package is not compatible with your device (" + pkg_arch +").\nPlease check the <a href=\"http://wiki.kodi.tv/index.php?title=XBMC_for_Android_specific_FAQ\">Kodi Android wiki</a> for more information.";
+      Log.e(TAG, mErrorMsg);
+      mState = InError;
+    }
+
     if (mState != InError) {
-      if (curArch.equalsIgnoreCase("arm")) {
+      if (pkg_arch.equalsIgnoreCase("arm")) {
         // arm arch: check if the cpu supports neon
         boolean ret = ParseCpuFeature();
         //Log.d(TAG, "/proc/cpuinfo = " + mCpuinfo);
-- 
2.7.4


From 135bbe1633ce70e5eb3934dc5f4d91d84da859b8 Mon Sep 17 00:00:00 2001
From: mapfau <pfau@peak3d.de>
Date: Fri, 30 Sep 2016 18:10:08 +0200
Subject: [PATCH 076/175] pass CPU instead ARCH as xbmc.property

---
 tools/android/packaging/Makefile.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/android/packaging/Makefile.in b/tools/android/packaging/Makefile.in
index 25df090..992c9f3 100644
--- a/tools/android/packaging/Makefile.in
+++ b/tools/android/packaging/Makefile.in
@@ -110,7 +110,7 @@ python: | xbmc/assets
 
 res:
 	mkdir -p xbmc/res xbmc/res/raw xbmc/res/values images
-	@echo "native_arch=$(ARCH)" > xbmc/res/raw/xbmc.properties
+	@echo "native_arch=$(CPU)" > xbmc/res/raw/xbmc.properties
 	cp -fp $(CORE_SOURCE_DIR)/media/Splash.png xbmc/res/drawable/splash.png
 	cp -fp media/drawable-hdpi/ic_launcher.png xbmc/res/drawable-hdpi/ic_launcher.png
 	cp -fp media/drawable-ldpi/ic_launcher.png xbmc/res/drawable-ldpi/ic_launcher.png
-- 
2.7.4


From 354e73ae705f48747ee9a284e861491323a7dcd1 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Sat, 1 Oct 2016 10:34:15 +0200
Subject: [PATCH 077/175] FIX: [aarch64] elf64 support. Credits to koying

---
 xbmc/platform/android/loader/AndroidDyload.cpp | 28 +++++++++++++++++---------
 1 file changed, 19 insertions(+), 9 deletions(-)

diff --git a/xbmc/platform/android/loader/AndroidDyload.cpp b/xbmc/platform/android/loader/AndroidDyload.cpp
index 336f041..2e2409a 100644
--- a/xbmc/platform/android/loader/AndroidDyload.cpp
+++ b/xbmc/platform/android/loader/AndroidDyload.cpp
@@ -33,6 +33,16 @@
 
 //#define DEBUG_SPEW
 
+#ifdef __LP64__
+#define Elf_Ehdr Elf64_Ehdr
+#define Elf_Shdr Elf64_Shdr
+#define Elf_Dyn Elf64_Dyn
+#else
+#define Elf_Ehdr Elf32_Ehdr
+#define Elf_Shdr Elf32_Shdr
+#define Elf_Dyn Elf32_Dyn
+#endif
+
 std::list<recursivelib> CAndroidDyload::m_recursivelibs;
 solib CAndroidDyload::m_libs;
 
@@ -151,7 +161,7 @@ int CAndroidDyload::DecRef(const std::string &filename)
 
 void CAndroidDyload::GetDeps(std::string filename, strings *results)
 {
-  Elf32_Ehdr header;
+  Elf_Ehdr header;
   char *data = NULL;
   int fd, i;
 
@@ -173,16 +183,16 @@ void CAndroidDyload::GetDeps(std::string filename, strings *results)
 
   for(i = 0; i < header.e_shnum; i++)
   {
-    Elf32_Shdr sheader;
+    Elf_Shdr sheader;
 
     lseek(fd, header.e_shoff + (i * header.e_shentsize), SEEK_SET);
     read(fd, &sheader, sizeof(sheader));
 
     if(sheader.sh_type == SHT_DYNSYM)
     {
-      Elf32_Shdr symheader;
+      Elf_Shdr symheader;
       lseek(fd, header.e_shoff + (sheader.sh_link * header.e_shentsize), SEEK_SET);
-      read(fd, &symheader, sizeof(Elf32_Shdr));
+      read(fd, &symheader, sizeof(Elf_Shdr));
       lseek(fd, symheader.sh_offset, SEEK_SET);
       data = (char*)malloc(symheader.sh_size);
       read(fd, data, symheader.sh_size);
@@ -198,20 +208,20 @@ void CAndroidDyload::GetDeps(std::string filename, strings *results)
 
   for(i = 0; i < header.e_shnum; i++)
   {
-    Elf32_Shdr sheader;
+    Elf_Shdr sheader;
 
     lseek(fd, header.e_shoff + (i * header.e_shentsize), SEEK_SET);
-    read(fd, &sheader, sizeof(Elf32_Shdr));
+    read(fd, &sheader, sizeof(Elf_Shdr));
 
     if (sheader.sh_type == SHT_DYNAMIC)
     {
       unsigned int j;
 
       lseek(fd, sheader.sh_offset, SEEK_SET);
-      for(j = 0; j < sheader.sh_size / sizeof(Elf32_Dyn); j++)
+      for(j = 0; j < sheader.sh_size / sizeof(Elf_Dyn); j++)
       {
-        Elf32_Dyn cur;
-        read(fd, &cur, sizeof(Elf32_Dyn));
+        Elf_Dyn cur;
+        read(fd, &cur, sizeof(Elf_Dyn));
         if(cur.d_tag == DT_NEEDED)
         {
           char *final = data + cur.d_un.d_val;
-- 
2.7.4


From 956815876ac7c89871911d4fdabe6db2b4419702 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Sat, 1 Oct 2016 10:35:32 +0200
Subject: [PATCH 078/175] set DT_SONAME in wrapped libs

---
 project/cmake/scripts/linux/Macros.cmake | 1 +
 1 file changed, 1 insertion(+)

diff --git a/project/cmake/scripts/linux/Macros.cmake b/project/cmake/scripts/linux/Macros.cmake
index 0bd7657..13dcd95 100644
--- a/project/cmake/scripts/linux/Macros.cmake
+++ b/project/cmake/scripts/linux/Macros.cmake
@@ -38,6 +38,7 @@ function(core_link_library lib wraplib)
                      ARGS    -Wl,--whole-archive
                              "${link_lib}" ${extra_libs}
                              -Wl,--no-whole-archive -lm
+                             -Wl,-soname,${wraplib}-${ARCH}${CMAKE_SHARED_MODULE_SUFFIX}
                              -shared -o ${CMAKE_BINARY_DIR}/${wraplib}-${ARCH}${CMAKE_SHARED_MODULE_SUFFIX}
                              ${export}
                      DEPENDS ${target} wrapper.def wrapper)
-- 
2.7.4


From 744595e3c459113ad3ecd21fb14b481cbe29fd98 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Sun, 2 Oct 2016 09:29:01 +0200
Subject: [PATCH 079/175] FIX: [droid] don't try /proc/self/exe (selinux).
 credits to koying

---
 xbmc/Util.cpp | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/xbmc/Util.cpp b/xbmc/Util.cpp
index 86a0f50..c356794 100644
--- a/xbmc/Util.cpp
+++ b/xbmc/Util.cpp
@@ -39,6 +39,9 @@
 #endif
 #if defined(TARGET_ANDROID)
 #include "platform/android/bionic_supplement/bionic_supplement.h"
+#include "platform/android/activity/XBMCApp.h"
+#include "platform/android/jni/ApplicationInfo.h"
+#include "CompileInfo.h"
 #endif
 #include <stdlib.h>
 #include <algorithm>
@@ -1781,6 +1784,13 @@ std::string CUtil::ResolveExecutablePath()
     strExecutablePath = "";
   else
     strExecutablePath = buf;
+#elif defined(TARGET_ANDROID)
+  strExecutablePath = CXBMCApp::getApplicationInfo().nativeLibraryDir;
+
+  std::string appName = CCompileInfo::GetAppName();
+  std::string libName = "lib" + appName + ".so";
+  StringUtils::ToLower(libName);
+  strExecutablePath += "/" + libName;
 #else
   /* Get our PID and build the name of the link in /proc */
   pid_t pid = getpid();
-- 
2.7.4


From c908f462ba0e874211ab050d395d1c99d4fda9ad Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Wed, 5 Oct 2016 22:30:47 +0200
Subject: [PATCH 080/175] android: link wrap libs against libdummy

---
 xbmc/cores/DllLoader/exports/CMakeLists.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/DllLoader/exports/CMakeLists.txt b/xbmc/cores/DllLoader/exports/CMakeLists.txt
index c0cec95..beddd5c 100644
--- a/xbmc/cores/DllLoader/exports/CMakeLists.txt
+++ b/xbmc/cores/DllLoader/exports/CMakeLists.txt
@@ -21,7 +21,7 @@ elseif(NOT CORE_SYSTEM_NAME STREQUAL windows)
   add_custom_target(wrapper.def ALL nm ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/wrapper.dir/wrapper.c.o | grep __wrap | awk '{ printf(\"%s \", \$\$3) }' | sed \"s/___wrap_/__wrap_/g\" | sed \"s/__wrap_/-Wl,-wrap,/g\" > wrapper.def)
 
   if(CORE_SYSTEM_NAME STREQUAL android)
-    add_custom_command(TARGET wrapper.def COMMAND echo \"-l$<TARGET_FILE:${APP_NAME_LC}>\" >> wrapper.def)
+    add_custom_command(TARGET wrapper.def COMMAND echo \"-L${DEPENDS_PATH}/lib/dummy-lib${APP_NAME_LC} -l${APP_NAME_LC}\" >> wrapper.def)
     add_dependencies(wrapper.def ${APP_NAME_LC})
   endif()
 
-- 
2.7.4


From acd017c18c16453c0c0e73157776203daf8096c6 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Thu, 6 Oct 2016 09:36:49 +0200
Subject: [PATCH 081/175] ADD: [droid] capture stderr/stdout to logcat / thanks
 to @koying

---
 xbmc/platform/android/activity/android_main.cpp | 44 +++++++++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/xbmc/platform/android/activity/android_main.cpp b/xbmc/platform/android/activity/android_main.cpp
index 9745197..3b77b22 100644
--- a/xbmc/platform/android/activity/android_main.cpp
+++ b/xbmc/platform/android/activity/android_main.cpp
@@ -31,6 +31,48 @@
 
 #include "platform/android/activity/JNIMainActivity.h"
 
+
+// redirect stdout / stderr to logcat
+// https://codelab.wordpress.com/2014/11/03/how-to-use-standard-output-streams-for-logging-in-android-apps/
+static int pfd[2];
+static pthread_t thr;
+static const char *tag = "myapp";
+
+static void *thread_logger(void*)
+{
+  ssize_t rdsz;
+  char buf[128];
+  while((rdsz = read(pfd[0], buf, sizeof buf - 1)) > 0)
+  {
+    if(buf[rdsz - 1] == '\n')
+      --rdsz;
+    buf[rdsz] = 0;  /* add null-terminator */
+    __android_log_write(ANDROID_LOG_DEBUG, tag, buf);
+  }
+  return 0;
+}
+
+int start_logger(const char *app_name)
+{
+  tag = app_name;
+
+  /* make stdout line-buffered and stderr unbuffered */
+  setvbuf(stdout, 0, _IOLBF, 0);
+  setvbuf(stderr, 0, _IONBF, 0);
+
+  /* create the pipe and redirect stdout and stderr */
+  pipe(pfd);
+  dup2(pfd[1], 1);
+  dup2(pfd[1], 2);
+
+  /* spawn the logging thread */
+  if(pthread_create(&thr, 0, thread_logger, 0) == -1)
+    return -1;
+  pthread_detach(thr);
+  return 0;
+}
+
+
 // copied from new android_native_app_glue.c
 static void process_input(struct android_app* app, struct android_poll_source* source) {
     AInputEvent* event = NULL;
@@ -65,6 +107,8 @@ extern void android_main(struct android_app* state)
     CXBMCApp xbmcApp(state->activity);
     if (xbmcApp.isValid())
     {
+      start_logger("Kodi");
+
       IInputHandler inputHandler;
       eventLoop.run(xbmcApp, inputHandler);
     }
-- 
2.7.4


From 459f33f80add4eb8815a3ec1f0f9b17782c98858 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Thu, 6 Oct 2016 14:08:40 +0200
Subject: [PATCH 082/175] check for inttypes

---
 project/cmake/scripts/common/ArchSetup.cmake | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/project/cmake/scripts/common/ArchSetup.cmake b/project/cmake/scripts/common/ArchSetup.cmake
index eed1dbb..3d2fad2 100644
--- a/project/cmake/scripts/common/ArchSetup.cmake
+++ b/project/cmake/scripts/common/ArchSetup.cmake
@@ -95,6 +95,7 @@ check_type(string char16_t HAVE_CHAR16_T)
 check_type(string char32_t HAVE_CHAR32_T)
 check_type(stdint.h uint_least16_t HAVE_STDINT_H)
 check_symbol_exists(posix_fadvise fcntl.h HAVE_POSIX_FADVISE)
+check_symbol_exists(PRIdMAX inttypes.h HAVE_INTTYPES_H)
 check_builtin("long* temp=0; long ret=__sync_add_and_fetch(temp, 1)" HAS_BUILTIN_SYNC_ADD_AND_FETCH)
 check_builtin("long* temp=0; long ret=__sync_sub_and_fetch(temp, 1)" HAS_BUILTIN_SYNC_SUB_AND_FETCH)
 check_builtin("long* temp=0; long ret=__sync_val_compare_and_swap(temp, 1, 1)" HAS_BUILTIN_SYNC_VAL_COMPARE_AND_SWAP)
@@ -105,6 +106,9 @@ check_function_exists(localtime_r HAVE_LOCALTIME_R)
 if(HAVE_LOCALTIME_R)
   list(APPEND SYSTEM_DEFINES -DHAVE_LOCALTIME_R=1)
 endif()
+if(HAVE_INTTYPES_H)
+  list(APPEND SYSTEM_DEFINES -DHAVE_INTTYPES_H=1)
+endif()
 
 find_package(SSE)
 foreach(_sse SSE SSE2 SSE3 SSSE3 SSE4_1 SSE4_2 AVX AVX2)
-- 
2.7.4


From 846dd5187819482ba4e0d7edcf6b6e179c93679b Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Thu, 6 Oct 2016 14:13:50 +0200
Subject: [PATCH 083/175] don't define INTTYPES_H in core

---
 xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp   | 2 --
 xbmc/platform/android/activity/CMakeLists.txt       | 1 -
 xbmc/platform/android/jni/AudioFormat.h             | 2 --
 xbmc/platform/android/jni/JNIThreading.cpp          | 2 --
 xbmc/platform/android/jni/JNIThreading.h            | 1 -
 xbmc/platform/android/jni/jutils/jutils-details.hpp | 1 -
 xbmc/platform/android/jni/jutils/jutils.hpp         | 2 --
 7 files changed, 11 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
index 5a1f58b..5013e2a 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
@@ -18,8 +18,6 @@
  *
  */
 
-#define HAVE_INTTYPES_H 1
-
 #include "AESinkAUDIOTRACK.h"
 #include "cores/AudioEngine/Utils/AEUtil.h"
 #include "platform/android/activity/XBMCApp.h"
diff --git a/xbmc/platform/android/activity/CMakeLists.txt b/xbmc/platform/android/activity/CMakeLists.txt
index b6c7f96..11fd016 100644
--- a/xbmc/platform/android/activity/CMakeLists.txt
+++ b/xbmc/platform/android/activity/CMakeLists.txt
@@ -28,4 +28,3 @@ core_add_library(platform_android_activity)
 target_include_directories(${CORE_LIBRARY}
                            PRIVATE ${NDKROOT}/sources/android/native_app_glue
                                    ${NDKROOT}/sources/android/cpufeatures)
-target_compile_definitions(${CORE_LIBRARY} PRIVATE -DHAVE_INTTYPES_H)
diff --git a/xbmc/platform/android/jni/AudioFormat.h b/xbmc/platform/android/jni/AudioFormat.h
index 82f813f..5975524 100644
--- a/xbmc/platform/android/jni/AudioFormat.h
+++ b/xbmc/platform/android/jni/AudioFormat.h
@@ -19,8 +19,6 @@
  *
  */
 
-#define HAVE_INTTYPES_H 1
-
 #include "jutils/jutils-details.hpp"
 
 namespace jni
diff --git a/xbmc/platform/android/jni/JNIThreading.cpp b/xbmc/platform/android/jni/JNIThreading.cpp
index 0cd6ba9..9f3e58e 100644
--- a/xbmc/platform/android/jni/JNIThreading.cpp
+++ b/xbmc/platform/android/jni/JNIThreading.cpp
@@ -35,8 +35,6 @@
   were renamed to avoid collisions when linking against the originals.
 */
 
-#define HAVE_INTTYPES_H 1
-
 #include <jni.h>
 #include <pthread.h>
 #include <stdlib.h>
diff --git a/xbmc/platform/android/jni/JNIThreading.h b/xbmc/platform/android/jni/JNIThreading.h
index e7fd6a1..36cf453 100644
--- a/xbmc/platform/android/jni/JNIThreading.h
+++ b/xbmc/platform/android/jni/JNIThreading.h
@@ -32,7 +32,6 @@
  */
 
 #pragma once
-#define HAVE_INTTYPES_H 1
 
 #include <jni.h>
 
diff --git a/xbmc/platform/android/jni/jutils/jutils-details.hpp b/xbmc/platform/android/jni/jutils/jutils-details.hpp
index eebb565..7278fdb 100644
--- a/xbmc/platform/android/jni/jutils/jutils-details.hpp
+++ b/xbmc/platform/android/jni/jutils/jutils-details.hpp
@@ -47,7 +47,6 @@
  */
 
 #pragma once
-#define HAVE_INTTYPES_H 1
 
 #include <jni.h>
 #include <string>
diff --git a/xbmc/platform/android/jni/jutils/jutils.hpp b/xbmc/platform/android/jni/jutils/jutils.hpp
index 50d8d01..059a2c0 100644
--- a/xbmc/platform/android/jni/jutils/jutils.hpp
+++ b/xbmc/platform/android/jni/jutils/jutils.hpp
@@ -48,8 +48,6 @@
 
 #pragma once
 
-#define HAVE_INTTYPES_H 1
-
 #include <jni.h>
 #include <string>
 #include <android/log.h>
-- 
2.7.4


From c64af0401a23631e2c6063f983b36ee234740163 Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peakwork.de>
Date: Fri, 7 Oct 2016 21:17:16 +0200
Subject: [PATCH 084/175] add aarch64 lock-obj patch to libgpg-error

---
 tools/depends/target/libgpg-error/Makefile         |  4 ++++
 .../lock-obj-pub.aarch64-unknown-linux-android.h   | 25 ++++++++++++++++++++++
 2 files changed, 29 insertions(+)
 create mode 100644 tools/depends/target/libgpg-error/lock-obj-pub.aarch64-unknown-linux-android.h

diff --git a/tools/depends/target/libgpg-error/Makefile b/tools/depends/target/libgpg-error/Makefile
index 271e023..275a5b9 100644
--- a/tools/depends/target/libgpg-error/Makefile
+++ b/tools/depends/target/libgpg-error/Makefile
@@ -33,8 +33,12 @@ ifeq ($(OS),osx)
 	mv $(PLATFORM)/src/syscfg/tmp.h $(PLATFORM)/src/syscfg/$$(awk 'NR==1 {print $$2}' $(PLATFORM)/src/syscfg/tmp.h)
 endif
 ifeq ($(OS),android)
+ifeq ($(CPU),arm64-v8a)
+	cp lock-obj-pub.aarch64-unknown-linux-android.h $(PLATFORM)/src/syscfg/lock-obj-pub.linux-android.h
+else
 	cp $(PLATFORM)/src/syscfg/lock-obj-pub.arm-unknown-linux-androideabi.h $(PLATFORM)/src/syscfg/lock-obj-pub.linux-android.h
 endif
+endif
 	$(MAKE) -C $(PLATFORM)
 
 .installed-$(PLATFORM): $(LIBDYLIB)
diff --git a/tools/depends/target/libgpg-error/lock-obj-pub.aarch64-unknown-linux-android.h b/tools/depends/target/libgpg-error/lock-obj-pub.aarch64-unknown-linux-android.h
new file mode 100644
index 0000000..6a0fe2c
--- /dev/null
+++ b/tools/depends/target/libgpg-error/lock-obj-pub.aarch64-unknown-linux-android.h
@@ -0,0 +1,25 @@
+## lock-obj-pub.armv8l-unknown-linux-gnu.h
+## File created by gen-posix-lock-obj - DO NOT EDIT
+## To be included by mkheader into gpg-error.h
+
+typedef struct
+{
+  long _vers;
+  union {
+    volatile char _priv[40];
+    long _x_align;
+    long *_xp_align;
+  } u;
+} gpgrt_lock_t;
+
+#define GPGRT_LOCK_INITIALIZER {1,{{0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0}}}
+##
+## Local Variables:
+## mode: c
+## buffer-read-only: t
+## End:
+##
-- 
2.7.4


From 4425a1e812784e1948cb5b874360dd58569f7bc4 Mon Sep 17 00:00:00 2001
From: wsnipex <wsnipex@a1.net>
Date: Sun, 9 Oct 2016 12:19:04 +0200
Subject: [PATCH 085/175] fix encrypted DVD playback

---
 project/cmake/modules/FindLibDvd.cmake | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/project/cmake/modules/FindLibDvd.cmake b/project/cmake/modules/FindLibDvd.cmake
index dd26c96..fa644d6 100644
--- a/project/cmake/modules/FindLibDvd.cmake
+++ b/project/cmake/modules/FindLibDvd.cmake
@@ -37,7 +37,7 @@ if(NOT WIN32)
 
       set(_linklibs ${DVDREAD_LIBRARY})
       if(ENABLE_DVDCSS)
-        list(APPEND _linklibs ${DVDCSS_LIBARY})
+        list(APPEND _linklibs ${DVDCSS_LIBRARY})
       endif()
       core_link_library(${DVDNAV_LIBRARY} system/players/VideoPlayer/libdvdnav dvdnav archives "${_linklibs}")
       set(LIBDVD_LIBRARIES ${DVDNAV_LIBRARY})
-- 
2.7.4


From 49d38fd35ecbf3a3006e356c935b39cbc15ed6f8 Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Sun, 9 Oct 2016 12:37:36 +0200
Subject: [PATCH 086/175] AE: Explicitely check for DTS when making setting
 invisible

---
 system/settings/settings.xml                         |  7 ++++++-
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 10 ++++++++++
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index cb12943..026a42e 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -2516,7 +2516,12 @@
           <level>2</level>
           <default>false</default>
           <dependencies>
-            <dependency type="visible" on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.passthrough</dependency>
+            <dependency type="visible">
+              <and>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.dtspassthrough</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.passthroughdevice">audiooutput.dtspassthrough</condition>
+              </and>
+            </dependency>
             <dependency type="enable" setting="audiooutput.passthrough" operator="is">true</dependency>
           </dependencies>
           <control type="toggle" />
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 5b2243f..aac31a0 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -2689,6 +2689,16 @@ bool CActiveAE::IsSettingVisible(const std::string &settingId)
     if (m_sink.HasPassthroughDevice() && CSettings::GetInstance().GetInt(CSettings::SETTING_AUDIOOUTPUT_CONFIG) != AE_CONFIG_FIXED)
       return true;
   }
+  else if (settingId == CSettings::SETTING_AUDIOOUTPUT_DTSPASSTHROUGH)
+  {
+    AEAudioFormat format;
+    format.m_dataFormat = AE_FMT_RAW;
+    format.m_streamInfo.m_type = CAEStreamInfo::STREAM_TYPE_DTS_512;
+    format.m_sampleRate = 48000;
+    if (m_sink.SupportsFormat(CSettings::GetInstance().GetString(CSettings::SETTING_AUDIOOUTPUT_PASSTHROUGHDEVICE), format) &&
+        CSettings::GetInstance().GetInt(CSettings::SETTING_AUDIOOUTPUT_CONFIG) != AE_CONFIG_FIXED)
+      return true;
+  }
   else if (settingId == CSettings::SETTING_AUDIOOUTPUT_TRUEHDPASSTHROUGH)
   {
     AEAudioFormat format;
-- 
2.7.4


From 9442d9cda534407048753ba3d50ef8dd9f2a90d0 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 14:38:40 +0200
Subject: [PATCH 087/175] VideoPlayer: fix general synchronize, often resulted
 in global timeout

---
 xbmc/cores/VideoPlayer/DVDMessage.cpp       | 30 ++++++++----------
 xbmc/cores/VideoPlayer/DVDMessage.h         | 12 ++++----
 xbmc/cores/VideoPlayer/DVDMessageQueue.cpp  |  2 +-
 xbmc/cores/VideoPlayer/VideoPlayer.cpp      | 48 ++++++++++-------------------
 xbmc/cores/VideoPlayer/VideoPlayer.h        |  4 +--
 xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp |  2 +-
 6 files changed, 38 insertions(+), 60 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDMessage.cpp b/xbmc/cores/VideoPlayer/DVDMessage.cpp
index 0dcc664..37abf20 100644
--- a/xbmc/cores/VideoPlayer/DVDMessage.cpp
+++ b/xbmc/cores/VideoPlayer/DVDMessage.cpp
@@ -31,22 +31,23 @@ class CDVDMsgGeneralSynchronizePriv
 {
 public:
   CDVDMsgGeneralSynchronizePriv(unsigned int timeout, unsigned int sources)
-    : sources(sources ? sources : SYNCSOURCE_ALL)
+    : sources(sources)
     , reached(0)
     , timeout(timeout)
   {}
-  unsigned int                   sources;
-  unsigned int                   reached;
-  CCriticalSection               section;
+  unsigned int sources;
+  unsigned int reached;
+  CCriticalSection section;
   XbmcThreads::ConditionVariable condition;
-  XbmcThreads::EndTime           timeout;
+  XbmcThreads::EndTime timeout;
 };
 
 /**
  * CDVDMsgGeneralSynchronize --- GENERAL_SYNCRONIZR
  */
-CDVDMsgGeneralSynchronize::CDVDMsgGeneralSynchronize(unsigned int timeout, unsigned int sources) : CDVDMsg(GENERAL_SYNCHRONIZE)
-  , m_p(new CDVDMsgGeneralSynchronizePriv(timeout, sources))
+CDVDMsgGeneralSynchronize::CDVDMsgGeneralSynchronize(unsigned int timeout, unsigned int sources) :
+  CDVDMsg(GENERAL_SYNCHRONIZE),
+  m_p(new CDVDMsgGeneralSynchronizePriv(timeout, sources))
 {
 }
 
@@ -57,28 +58,23 @@ CDVDMsgGeneralSynchronize::~CDVDMsgGeneralSynchronize()
 
 bool CDVDMsgGeneralSynchronize::Wait(unsigned int milliseconds, unsigned int source)
 {
-  if (source == 0)
-    source = SYNCSOURCE_OWNER;
-
-  /* if we are not requested to wait on this object just return, reference count will be decremented */
-  if (!(m_p->sources & source))
-    return true;
-
   CSingleLock lock(m_p->section);
 
   XbmcThreads::EndTime timeout(milliseconds);
 
   m_p->reached |= source & m_p->sources;
 
-  while ((long)MathUtils::bitcount(m_p->reached) < GetNrOfReferences())
+  while (m_p->reached != m_p->sources ||
+         (m_p->sources == SYNCSOURCE_ANY && m_p->reached))
   {
     milliseconds = std::min(m_p->timeout.MillisLeft(), timeout.MillisLeft());
-    if(m_p->condition.wait(lock, milliseconds))
+    if (m_p->condition.wait(lock, milliseconds))
       continue;
+
     if (m_p->timeout.IsTimePast())
     {
       CLog::Log(LOGDEBUG, "CDVDMsgGeneralSynchronize - global timeout");
-      return true;  /* global timeout, we are done */
+      return true;  // global timeout, we are done
     }
     if (timeout.IsTimePast())
     {
diff --git a/xbmc/cores/VideoPlayer/DVDMessage.h b/xbmc/cores/VideoPlayer/DVDMessage.h
index 5518721..952dc84 100644
--- a/xbmc/cores/VideoPlayer/DVDMessage.h
+++ b/xbmc/cores/VideoPlayer/DVDMessage.h
@@ -133,11 +133,10 @@ private:
 //////
 ////////////////////////////////////////////////////////////////////////////////
 
-#define SYNCSOURCE_AUDIO  0x00000001
-#define SYNCSOURCE_VIDEO  0x00000002
-#define SYNCSOURCE_SUB    0x00000004
-#define SYNCSOURCE_OWNER  0x80000000 /* only allowed for the constructor of the object */
-#define SYNCSOURCE_ALL    (SYNCSOURCE_AUDIO | SYNCSOURCE_VIDEO | SYNCSOURCE_SUB | SYNCSOURCE_OWNER)
+#define SYNCSOURCE_AUDIO  0x01
+#define SYNCSOURCE_VIDEO  0x02
+#define SYNCSOURCE_PLAYER 0x04
+#define SYNCSOURCE_ANY    0x08
 
 class CDVDMsgGeneralSynchronizePriv;
 class CDVDMsgGeneralSynchronize : public CDVDMsg
@@ -149,8 +148,9 @@ public:
 
   // waits until all threads waiting, released the object
   // if abort is set somehow
-  bool Wait(unsigned int ms         , unsigned int source);
+  bool Wait(unsigned int ms, unsigned int source);
   void Wait(std::atomic<bool>& abort, unsigned int source);
+
 private:
   class CDVDMsgGeneralSynchronizePriv* m_p;
 };
diff --git a/xbmc/cores/VideoPlayer/DVDMessageQueue.cpp b/xbmc/cores/VideoPlayer/DVDMessageQueue.cpp
index 8d82d91..fd5f6ae 100644
--- a/xbmc/cores/VideoPlayer/DVDMessageQueue.cpp
+++ b/xbmc/cores/VideoPlayer/DVDMessageQueue.cpp
@@ -244,7 +244,7 @@ unsigned CDVDMessageQueue::GetPacketCount(CDVDMsg::Message type)
 void CDVDMessageQueue::WaitUntilEmpty()
 {
   CLog::Log(LOGNOTICE, "CDVDMessageQueue(%s)::WaitUntilEmpty", m_owner.c_str());
-  CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(40000, 0);
+  CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(40000, SYNCSOURCE_ANY);
   Put(msg->Acquire());
   msg->Wait(m_bAbortRequest, 0);
   msg->Release();
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index 4cb7cb6..223bbc0 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -2387,39 +2387,19 @@ void CVideoPlayer::CheckAutoSceneSkip()
 }
 
 
-void CVideoPlayer::SynchronizeDemuxer(unsigned int timeout)
+void CVideoPlayer::SynchronizeDemuxer()
 {
   if(IsCurrentThread())
     return;
   if(!m_messenger.IsInited())
     return;
 
-  CDVDMsgGeneralSynchronize* message = new CDVDMsgGeneralSynchronize(timeout, 0);
+  CDVDMsgGeneralSynchronize* message = new CDVDMsgGeneralSynchronize(500, SYNCSOURCE_PLAYER);
   m_messenger.Put(message->Acquire());
   message->Wait(m_bStop, 0);
   message->Release();
 }
 
-void CVideoPlayer::SynchronizePlayers(unsigned int sources)
-{
-  /* we need a big timeout as audio queue is about 8seconds for 2ch ac3 */
-  const int timeout = 10*1000; // in milliseconds
-
-  CDVDMsgGeneralSynchronize* message = new CDVDMsgGeneralSynchronize(timeout, sources);
-  if (m_CurrentAudio.id >= 0)
-    m_VideoPlayerAudio->SendMessage(message->Acquire());
-
-  if (m_CurrentVideo.id >= 0)
-    m_VideoPlayerVideo->SendMessage(message->Acquire());
-//! @todo we have to rewrite the sync class, to not require
-//!       all other players waiting for subtitle, should only
-//!       be the oposite way
-/*  if (m_CurrentSubtitle.id >= 0)
-    m_VideoPlayerSubtitle->SendMessage(message->Acquire());
-*/
-  message->Release();
-}
-
 IDVDStreamPlayer* CVideoPlayer::GetStreamPlayer(unsigned int target)
 {
   if(target == VideoPlayer_AUDIO)
@@ -2928,7 +2908,7 @@ void CVideoPlayer::HandleMessages()
       }
       else if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
       {
-        if (((CDVDMsgGeneralSynchronize*)pMsg)->Wait(100, SYNCSOURCE_OWNER))
+        if (((CDVDMsgGeneralSynchronize*)pMsg)->Wait(100, SYNCSOURCE_PLAYER))
           CLog::Log(LOGDEBUG, "CVideoPlayer - CDVDMsg::GENERAL_SYNCHRONIZE");
       }
       else if (pMsg->IsType(CDVDMsg::PLAYER_AVCHANGE))
@@ -3148,7 +3128,7 @@ void CVideoPlayer::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
   }
 
   m_messenger.Put(new CDVDMsgPlayerSeek((int)seek, !bPlus, true, false, restore));
-  SynchronizeDemuxer(100);
+  SynchronizeDemuxer();
   if (seek < 0) seek = 0;
   m_callback.OnPlayBackSeek((int)seek, (int)(seek - time));
 }
@@ -3173,7 +3153,7 @@ bool CVideoPlayer::SeekScene(bool bPlus)
      * Seeking is flushed and inaccurate, just like Seek()
      */
     m_messenger.Put(new CDVDMsgPlayerSeek(iScenemarker, !bPlus, true, false, false));
-    SynchronizeDemuxer(100);
+    SynchronizeDemuxer();
     return true;
   }
   return false;
@@ -3414,7 +3394,7 @@ int CVideoPlayer::GetAudioStream()
 void CVideoPlayer::SetAudioStream(int iStream)
 {
   m_messenger.Put(new CDVDMsgPlayerSetAudioStream(iStream));
-  SynchronizeDemuxer(100);
+  SynchronizeDemuxer();
 }
 
 int CVideoPlayer::GetVideoStreamCount() const
@@ -3430,7 +3410,7 @@ int CVideoPlayer::GetVideoStream() const
 void CVideoPlayer::SetVideoStream(int iStream)
 {
   m_messenger.Put(new CDVDMsgPlayerSetVideoStream(iStream));
-  SynchronizeDemuxer(100);
+  SynchronizeDemuxer();
 }
 
 TextCacheStruct_t* CVideoPlayer::GetTeletextCache()
@@ -3461,7 +3441,7 @@ void CVideoPlayer::SeekTime(int64_t iTime)
 {
   int seekOffset = (int)(iTime - GetTime());
   m_messenger.Put(new CDVDMsgPlayerSeek((int)iTime, true, true, true));
-  SynchronizeDemuxer(100);
+  SynchronizeDemuxer();
   m_callback.OnPlayBackSeek((int)iTime, seekOffset);
 }
 
@@ -3469,7 +3449,7 @@ bool CVideoPlayer::SeekTimeRelative(int64_t iTime)
 {
   int64_t abstime = GetTime() + iTime;
   m_messenger.Put(new CDVDMsgPlayerSeek((int)abstime, (iTime < 0) ? true : false, true, false));
-  SynchronizeDemuxer(100);
+  SynchronizeDemuxer();
   m_callback.OnPlayBackSeek((int)abstime, iTime);
   return true;
 }
@@ -3935,7 +3915,11 @@ void CVideoPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool syn
     m_VideoPlayerTeletext->SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
     m_VideoPlayerRadioRDS->SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
-    SynchronizePlayers(SYNCSOURCE_ALL);
+    CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(10*1000, SYNCSOURCE_AUDIO | SYNCSOURCE_AUDIO);
+    m_VideoPlayerAudio->SendMessage(msg->Acquire(), 1);
+    m_VideoPlayerVideo->SendMessage(msg->Acquire(), 1);
+    msg->Wait(m_bStop, 0);
+    msg->Release();
   }
   else
   {
@@ -3952,7 +3936,7 @@ void CVideoPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool syn
     || m_playSpeed == DVD_PLAYSPEED_PAUSE)
     {
       // make sure players are properly flushed, should put them in stalled state
-      CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(1000, 0);
+      CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(1000, SYNCSOURCE_AUDIO | SYNCSOURCE_AUDIO);
       m_VideoPlayerAudio->SendMessage(msg->Acquire(), 1);
       m_VideoPlayerVideo->SendMessage(msg->Acquire(), 1);
       msg->Wait(m_bStop, 0);
@@ -4605,7 +4589,7 @@ int CVideoPlayer::SeekChapter(int iChapter)
 
     // Seek to the chapter.
     m_messenger.Put(new CDVDMsgPlayerSeekChapter(iChapter));
-    SynchronizeDemuxer(100);
+    SynchronizeDemuxer();
   }
 
   return 0;
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.h b/xbmc/cores/VideoPlayer/VideoPlayer.h
index 8545f11..8032e7e 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.h
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.h
@@ -466,9 +466,7 @@ protected:
   void HandleMessages();
   void HandlePlaySpeed();
   bool IsInMenuInternal() const;
-
-  void SynchronizePlayers(unsigned int sources);
-  void SynchronizeDemuxer(unsigned int timeout);
+  void SynchronizeDemuxer();
   void CheckAutoSceneSkip();
   bool CheckContinuity(CCurrentStream& current, DemuxPacket* pPacket);
   bool CheckSceneSkip(CCurrentStream& current);
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
index 5da89e5..f822935 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
@@ -282,7 +282,7 @@ void CVideoPlayerAudio::Process()
     // handle messages
     if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
     {
-      if(((CDVDMsgGeneralSynchronize*)pMsg)->Wait( 100, SYNCSOURCE_AUDIO ))
+      if(((CDVDMsgGeneralSynchronize*)pMsg)->Wait(100, SYNCSOURCE_AUDIO))
         CLog::Log(LOGDEBUG, "CVideoPlayerAudio - CDVDMsg::GENERAL_SYNCHRONIZE");
       else
         m_messageQueue.Put(pMsg->Acquire(), 1);  // push back as prio message, to process other prio messages
-- 
2.7.4


From 6630246ffa8d6d8e1c40a953fd126d219cdb86a7 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 09:22:29 +0200
Subject: [PATCH 088/175] VideoPlayer: cosmetics in section seek

---
 xbmc/cores/VideoPlayer/VideoPlayer.cpp | 45 ++++++++++++++++++----------------
 1 file changed, 24 insertions(+), 21 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index 223bbc0..5a91cdf 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -3049,15 +3049,17 @@ void CVideoPlayer::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
     }
   }
 
-  int64_t seek;
+  int64_t seekTarget;
   if (g_advancedSettings.m_videoUseTimeSeeking && GetTotalTime() > 2000*g_advancedSettings.m_videoTimeSeekForwardBig)
   {
     if (bLargeStep)
-      seek = bPlus ? g_advancedSettings.m_videoTimeSeekForwardBig : g_advancedSettings.m_videoTimeSeekBackwardBig;
+      seekTarget = bPlus ? g_advancedSettings.m_videoTimeSeekForwardBig :
+                           g_advancedSettings.m_videoTimeSeekBackwardBig;
     else
-      seek = bPlus ? g_advancedSettings.m_videoTimeSeekForward : g_advancedSettings.m_videoTimeSeekBackward;
-    seek *= 1000;
-    seek += GetTime();
+      seekTarget = bPlus ? g_advancedSettings.m_videoTimeSeekForward :
+                           g_advancedSettings.m_videoTimeSeekBackward;
+    seekTarget *= 1000;
+    seekTarget += GetTime();
   }
   else
   {
@@ -3066,7 +3068,7 @@ void CVideoPlayer::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
       percent = bPlus ? g_advancedSettings.m_videoPercentSeekForwardBig : g_advancedSettings.m_videoPercentSeekBackwardBig;
     else
       percent = bPlus ? g_advancedSettings.m_videoPercentSeekForward : g_advancedSettings.m_videoPercentSeekBackward;
-    seek = (int64_t)(GetTotalTimeInMsec()*(GetPercentage()+percent)/100);
+    seekTarget = (int64_t)(GetTotalTimeInMsec()*(GetPercentage()+percent)/100);
   }
 
   bool restore = true;
@@ -3086,15 +3088,15 @@ void CVideoPlayer::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
      * Small skip does not trigger this in case the start of the commercial break was in fact fine
      * but it skipped too far into the program. In that case small skip backwards behaves as normal.
      */
-    if (!bPlus && bLargeStep
-    &&  m_EdlAutoSkipMarkers.seek_to_start
-    &&  clock >= m_EdlAutoSkipMarkers.commbreak_end
-    &&  clock <= m_EdlAutoSkipMarkers.commbreak_end + 10*1000) // Only if within 10 seconds of the end (in msec)
+    if (!bPlus && bLargeStep &&
+        m_EdlAutoSkipMarkers.seek_to_start &&
+        clock >= m_EdlAutoSkipMarkers.commbreak_end &&
+        clock <= m_EdlAutoSkipMarkers.commbreak_end + 10*1000) // Only if within 10 seconds of the end (in msec)
     {
       CLog::Log(LOGDEBUG, "%s - Seeking back to start of commercial break [%s - %s] as large backwards skip activated within 10 seconds of the automatic commercial skip (only done once per break).",
                 __FUNCTION__, CEdl::MillisecondsToTimeString(m_EdlAutoSkipMarkers.commbreak_start).c_str(),
                 CEdl::MillisecondsToTimeString(m_EdlAutoSkipMarkers.commbreak_end).c_str());
-      seek = m_EdlAutoSkipMarkers.commbreak_start;
+      seekTarget = m_EdlAutoSkipMarkers.commbreak_start;
       restore = false;
       m_EdlAutoSkipMarkers.seek_to_start = false; // So this will only happen within the 10 second grace period once.
     }
@@ -3105,32 +3107,33 @@ void CVideoPlayer::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)
      * correctly than the landing point for a standard big skip (ends seem to be flagged more
      * accurately than the start).
      */
-    else if (bPlus && bLargeStep
-    &&       clock >= m_EdlAutoSkipMarkers.commbreak_start
-    &&       clock <= m_EdlAutoSkipMarkers.commbreak_end)
+    else if (bPlus && bLargeStep &&
+             clock >= m_EdlAutoSkipMarkers.commbreak_start &&
+             clock <= m_EdlAutoSkipMarkers.commbreak_end)
     {
       CLog::Log(LOGDEBUG, "%s - Seeking to end of previously skipped commercial break [%s - %s] as big forwards skip activated within the break.",
                 __FUNCTION__, CEdl::MillisecondsToTimeString(m_EdlAutoSkipMarkers.commbreak_start).c_str(),
                 CEdl::MillisecondsToTimeString(m_EdlAutoSkipMarkers.commbreak_end).c_str());
-      seek = m_EdlAutoSkipMarkers.commbreak_end;
+      seekTarget = m_EdlAutoSkipMarkers.commbreak_end;
       restore = false;
     }
   }
 
   int64_t time = GetTime();
-  if(g_application.CurrentFileItem().IsStack()
-  && (seek > GetTotalTimeInMsec() || seek < 0))
+  if(g_application.CurrentFileItem().IsStack() &&
+     (seekTarget > GetTotalTimeInMsec() || seekTarget < 0))
   {
-    g_application.SeekTime((seek - time) * 0.001 + g_application.GetTime());
+    g_application.SeekTime((seekTarget - time) * 0.001 + g_application.GetTime());
     // warning, don't access any VideoPlayer variables here as
     // the VideoPlayer object may have been destroyed
     return;
   }
 
-  m_messenger.Put(new CDVDMsgPlayerSeek((int)seek, !bPlus, true, false, restore));
+  m_messenger.Put(new CDVDMsgPlayerSeek((int)seekTarget, !bPlus, true, false, restore));
   SynchronizeDemuxer();
-  if (seek < 0) seek = 0;
-  m_callback.OnPlayBackSeek((int)seek, (int)(seek - time));
+  if (seekTarget < 0)
+    seekTarget = 0;
+  m_callback.OnPlayBackSeek((int)seekTarget, (int)(seekTarget - time));
 }
 
 bool CVideoPlayer::SeekScene(bool bPlus)
-- 
2.7.4


From e5ff2aa935b17903d52b9c0353e5400655f44092 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 09:28:12 +0200
Subject: [PATCH 089/175] VideoPlayer: fix indentation in method HandleMessages

---
 xbmc/cores/VideoPlayer/VideoPlayer.cpp | 697 +++++++++++++++++----------------
 1 file changed, 350 insertions(+), 347 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index 5a91cdf..e7183a7 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -2484,443 +2484,446 @@ void CVideoPlayer::HandleMessages()
   while (m_messenger.Get(&pMsg, 0) == MSGQ_OK)
   {
 
-      if (pMsg->IsType(CDVDMsg::PLAYER_SEEK) && m_messenger.GetPacketCount(CDVDMsg::PLAYER_SEEK)         == 0
-                                             && m_messenger.GetPacketCount(CDVDMsg::PLAYER_SEEK_CHAPTER) == 0)
-      {
-        CDVDMsgPlayerSeek &msg(*((CDVDMsgPlayerSeek*)pMsg));
-
-        if (!m_State.canseek)
-        {
-          pMsg->Release();
-          continue;
-        }
-
-        if (!msg.GetTrickPlay())
-        {
-          g_infoManager.SetDisplayAfterSeek(100000);
-          if(msg.GetFlush())
-            SetCaching(CACHESTATE_FLUSH);
-        }
+    if (pMsg->IsType(CDVDMsg::PLAYER_SEEK) &&
+        m_messenger.GetPacketCount(CDVDMsg::PLAYER_SEEK) == 0 &&
+        m_messenger.GetPacketCount(CDVDMsg::PLAYER_SEEK_CHAPTER) == 0)
+    {
+      CDVDMsgPlayerSeek &msg(*((CDVDMsgPlayerSeek*)pMsg));
 
-        double start = DVD_NOPTS_VALUE;
+      if (!m_State.canseek)
+      {
+        pMsg->Release();
+        continue;
+      }
 
-        int time = msg.GetRestore() ? m_Edl.RestoreCutTime(msg.GetTime()) : msg.GetTime();
+      if (!msg.GetTrickPlay())
+      {
+        g_infoManager.SetDisplayAfterSeek(100000);
+        if(msg.GetFlush())
+          SetCaching(CACHESTATE_FLUSH);
+      }
 
-        // if input stream doesn't support ISeekTime, convert back to pts
-        //! @todo
-        //! After demuxer we add an offset to input pts so that displayed time and clock are
-        //! increasing steadily. For seeking we need to determine the boundaries and offset
-        //! of the desired segment. With the current approach calculated time may point
-        //! to nirvana
-        if (m_pInputStream->GetIPosTime() == nullptr)
-          time -= DVD_TIME_TO_MSEC(m_State.time_offset);
+      double start = DVD_NOPTS_VALUE;
 
-        CLog::Log(LOGDEBUG, "demuxer seek to: %d", time);
-        if (m_pDemuxer && m_pDemuxer->SeekTime(time, msg.GetBackward(), &start))
-        {
-          CLog::Log(LOGDEBUG, "demuxer seek to: %d, success", time);
-          if(m_pSubtitleDemuxer)
-          {
-            if(!m_pSubtitleDemuxer->SeekTime(time, msg.GetBackward()))
-              CLog::Log(LOGDEBUG, "failed to seek subtitle demuxer: %d, success", time);
-          }
-          // dts after successful seek
-          if (start == DVD_NOPTS_VALUE)
-            start = DVD_MSEC_TO_TIME(time) - m_State.time_offset;
+      int time = msg.GetRestore() ? m_Edl.RestoreCutTime(msg.GetTime()) : msg.GetTime();
 
-          m_State.dts = start;
+      // if input stream doesn't support ISeekTime, convert back to pts
+      //! @todo
+      //! After demuxer we add an offset to input pts so that displayed time and clock are
+      //! increasing steadily. For seeking we need to determine the boundaries and offset
+      //! of the desired segment. With the current approach calculated time may point
+      //! to nirvana
+      if (m_pInputStream->GetIPosTime() == nullptr)
+        time -= DVD_TIME_TO_MSEC(m_State.time_offset);
 
-          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
-        }
-        else if (m_pDemuxer)
+      CLog::Log(LOGDEBUG, "demuxer seek to: %d", time);
+      if (m_pDemuxer && m_pDemuxer->SeekTime(time, msg.GetBackward(), &start))
+      {
+        CLog::Log(LOGDEBUG, "demuxer seek to: %d, success", time);
+        if(m_pSubtitleDemuxer)
         {
-          CLog::Log(LOGDEBUG, "VideoPlayer: seek failed or hit end of stream");
-          // dts after successful seek
-          if (start == DVD_NOPTS_VALUE)
-            start = DVD_MSEC_TO_TIME(time) - m_State.time_offset;
-
-          m_State.dts = start;
-
-          FlushBuffers(false, start, false, true);
-          if (m_playSpeed != DVD_PLAYSPEED_PAUSE)
-          {
-            SetPlaySpeed(DVD_PLAYSPEED_NORMAL);
-          }
+          if(!m_pSubtitleDemuxer->SeekTime(time, msg.GetBackward()))
+            CLog::Log(LOGDEBUG, "failed to seek subtitle demuxer: %d, success", time);
         }
+        // dts after successful seek
+        if (start == DVD_NOPTS_VALUE)
+          start = DVD_MSEC_TO_TIME(time) - m_State.time_offset;
 
-        // set flag to indicate we have finished a seeking request
-        if(!msg.GetTrickPlay())
-          g_infoManager.SetDisplayAfterSeek();
+        m_State.dts = start;
 
-        // dvd's will issue a HOP_CHANNEL that we need to skip
-        if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
-          m_dvd.state = DVDSTATE_SEEK;
+        FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_SEEK_CHAPTER) && m_messenger.GetPacketCount(CDVDMsg::PLAYER_SEEK)         == 0
-                                                          && m_messenger.GetPacketCount(CDVDMsg::PLAYER_SEEK_CHAPTER) == 0)
+      else if (m_pDemuxer)
       {
-        g_infoManager.SetDisplayAfterSeek(100000);
-        SetCaching(CACHESTATE_FLUSH);
+        CLog::Log(LOGDEBUG, "VideoPlayer: seek failed or hit end of stream");
+        // dts after successful seek
+        if (start == DVD_NOPTS_VALUE)
+          start = DVD_MSEC_TO_TIME(time) - m_State.time_offset;
 
-        CDVDMsgPlayerSeekChapter &msg(*((CDVDMsgPlayerSeekChapter*)pMsg));
-        double start = DVD_NOPTS_VALUE;
-        double offset = 0;
-        int64_t beforeSeek = GetTime();
+        m_State.dts = start;
 
-        // This should always be the case.
-        if(m_pDemuxer && m_pDemuxer->SeekChapter(msg.GetChapter(), &start))
+        FlushBuffers(false, start, false, true);
+        if (m_playSpeed != DVD_PLAYSPEED_PAUSE)
         {
-          FlushBuffers(false, start, true);
-          offset = DVD_TIME_TO_MSEC(start) - beforeSeek;
-          m_callback.OnPlayBackSeekChapter(msg.GetChapter());
+          SetPlaySpeed(DVD_PLAYSPEED_NORMAL);
         }
-
-        g_infoManager.SetDisplayAfterSeek(2500, offset);
       }
-      else if (pMsg->IsType(CDVDMsg::DEMUXER_RESET))
+
+      // set flag to indicate we have finished a seeking request
+      if(!msg.GetTrickPlay())
+        g_infoManager.SetDisplayAfterSeek();
+
+      // dvd's will issue a HOP_CHANNEL that we need to skip
+      if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+        m_dvd.state = DVDSTATE_SEEK;
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SEEK_CHAPTER) &&
+             m_messenger.GetPacketCount(CDVDMsg::PLAYER_SEEK) == 0 &&
+             m_messenger.GetPacketCount(CDVDMsg::PLAYER_SEEK_CHAPTER) == 0)
+    {
+      g_infoManager.SetDisplayAfterSeek(100000);
+      SetCaching(CACHESTATE_FLUSH);
+
+      CDVDMsgPlayerSeekChapter &msg(*((CDVDMsgPlayerSeekChapter*)pMsg));
+      double start = DVD_NOPTS_VALUE;
+      double offset = 0;
+      int64_t beforeSeek = GetTime();
+
+      // This should always be the case.
+      if(m_pDemuxer && m_pDemuxer->SeekChapter(msg.GetChapter(), &start))
       {
-          m_CurrentAudio.stream = NULL;
-          m_CurrentVideo.stream = NULL;
-          m_CurrentSubtitle.stream = NULL;
-
-          // we need to reset the demuxer, probably because the streams have changed
-          if(m_pDemuxer)
-            m_pDemuxer->Reset();
-          if(m_pSubtitleDemuxer)
-            m_pSubtitleDemuxer->Reset();
+        FlushBuffers(false, start, true);
+        offset = DVD_TIME_TO_MSEC(start) - beforeSeek;
+        m_callback.OnPlayBackSeekChapter(msg.GetChapter());
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_SET_AUDIOSTREAM))
-      {
-        CDVDMsgPlayerSetAudioStream* pMsg2 = (CDVDMsgPlayerSetAudioStream*)pMsg;
 
-        SelectionStream& st = m_SelectionStreams.Get(STREAM_AUDIO, pMsg2->GetStreamId());
-        if(st.source != STREAM_SOURCE_NONE)
+      g_infoManager.SetDisplayAfterSeek(2500, offset);
+    }
+    else if (pMsg->IsType(CDVDMsg::DEMUXER_RESET))
+    {
+      m_CurrentAudio.stream = NULL;
+      m_CurrentVideo.stream = NULL;
+      m_CurrentSubtitle.stream = NULL;
+
+      // we need to reset the demuxer, probably because the streams have changed
+      if(m_pDemuxer)
+        m_pDemuxer->Reset();
+      if(m_pSubtitleDemuxer)
+        m_pSubtitleDemuxer->Reset();
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SET_AUDIOSTREAM))
+    {
+      CDVDMsgPlayerSetAudioStream* pMsg2 = (CDVDMsgPlayerSetAudioStream*)pMsg;
+
+      SelectionStream& st = m_SelectionStreams.Get(STREAM_AUDIO, pMsg2->GetStreamId());
+      if(st.source != STREAM_SOURCE_NONE)
+      {
+        if(st.source == STREAM_SOURCE_NAV && m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
         {
-          if(st.source == STREAM_SOURCE_NAV && m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
-          {
-            CDVDInputStreamNavigator* pStream = (CDVDInputStreamNavigator*)m_pInputStream;
-            if(pStream->SetActiveAudioStream(st.id))
-            {
-              m_dvd.iSelectedAudioStream = -1;
-              CloseStream(m_CurrentAudio, false);
-              m_messenger.Put(new CDVDMsgPlayerSeek((int) GetTime(), true, true, true, true, true));
-            }
-          }
-          else
+          CDVDInputStreamNavigator* pStream = (CDVDInputStreamNavigator*)m_pInputStream;
+          if(pStream->SetActiveAudioStream(st.id))
           {
+            m_dvd.iSelectedAudioStream = -1;
             CloseStream(m_CurrentAudio, false);
-            OpenStream(m_CurrentAudio, st.demuxerId, st.id, st.source);
-            AdaptForcedSubtitles();
-            
             m_messenger.Put(new CDVDMsgPlayerSeek((int) GetTime(), true, true, true, true, true));
           }
         }
+        else
+        {
+          CloseStream(m_CurrentAudio, false);
+          OpenStream(m_CurrentAudio, st.demuxerId, st.id, st.source);
+          AdaptForcedSubtitles();
+
+          m_messenger.Put(new CDVDMsgPlayerSeek((int) GetTime(), true, true, true, true, true));
+        }
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_SET_VIDEOSTREAM))
-      {
-        CDVDMsgPlayerSetVideoStream* pMsg2 = (CDVDMsgPlayerSetVideoStream*)pMsg;
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SET_VIDEOSTREAM))
+    {
+      CDVDMsgPlayerSetVideoStream* pMsg2 = (CDVDMsgPlayerSetVideoStream*)pMsg;
 
-        SelectionStream& st = m_SelectionStreams.Get(STREAM_VIDEO, pMsg2->GetStreamId());
-        if (st.source != STREAM_SOURCE_NONE)
+      SelectionStream& st = m_SelectionStreams.Get(STREAM_VIDEO, pMsg2->GetStreamId());
+      if (st.source != STREAM_SOURCE_NONE)
+      {
+        if (st.source == STREAM_SOURCE_NAV && m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
         {
-          if (st.source == STREAM_SOURCE_NAV && m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+          CDVDInputStreamNavigator* pStream = (CDVDInputStreamNavigator*)m_pInputStream;
+          if (pStream->SetAngle(st.id))
           {
-            CDVDInputStreamNavigator* pStream = (CDVDInputStreamNavigator*)m_pInputStream;
-            if (pStream->SetAngle(st.id))
-            {
-              m_dvd.iSelectedVideoStream = st.id;
-              m_messenger.Put(new CDVDMsgPlayerSeek((int)GetTime(), true, true, true, true, true));
-            }
-          }
-          else
-          {
-            CloseStream(m_CurrentVideo, false);
-            OpenStream(m_CurrentVideo, st.demuxerId, st.id, st.source);
+            m_dvd.iSelectedVideoStream = st.id;
             m_messenger.Put(new CDVDMsgPlayerSeek((int)GetTime(), true, true, true, true, true));
           }
         }
+        else
+        {
+          CloseStream(m_CurrentVideo, false);
+          OpenStream(m_CurrentVideo, st.demuxerId, st.id, st.source);
+          m_messenger.Put(new CDVDMsgPlayerSeek((int)GetTime(), true, true, true, true, true));
+        }
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_SET_SUBTITLESTREAM))
-      {
-        CDVDMsgPlayerSetSubtitleStream* pMsg2 = (CDVDMsgPlayerSetSubtitleStream*)pMsg;
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SET_SUBTITLESTREAM))
+    {
+      CDVDMsgPlayerSetSubtitleStream* pMsg2 = (CDVDMsgPlayerSetSubtitleStream*)pMsg;
 
-        SelectionStream& st = m_SelectionStreams.Get(STREAM_SUBTITLE, pMsg2->GetStreamId());
-        if(st.source != STREAM_SOURCE_NONE)
+      SelectionStream& st = m_SelectionStreams.Get(STREAM_SUBTITLE, pMsg2->GetStreamId());
+      if(st.source != STREAM_SOURCE_NONE)
+      {
+        if(st.source == STREAM_SOURCE_NAV && m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
         {
-          if(st.source == STREAM_SOURCE_NAV && m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
-          {
-            CDVDInputStreamNavigator* pStream = (CDVDInputStreamNavigator*)m_pInputStream;
-            if(pStream->SetActiveSubtitleStream(st.id))
-            {
-              m_dvd.iSelectedSPUStream = -1;
-              CloseStream(m_CurrentSubtitle, false);
-            }
-          }
-          else
+          CDVDInputStreamNavigator* pStream = (CDVDInputStreamNavigator*)m_pInputStream;
+          if(pStream->SetActiveSubtitleStream(st.id))
           {
+            m_dvd.iSelectedSPUStream = -1;
             CloseStream(m_CurrentSubtitle, false);
-            OpenStream(m_CurrentSubtitle, st.demuxerId, st.id, st.source);
           }
         }
+        else
+        {
+          CloseStream(m_CurrentSubtitle, false);
+          OpenStream(m_CurrentSubtitle, st.demuxerId, st.id, st.source);
+        }
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_SET_SUBTITLESTREAM_VISIBLE))
-      {
-        CDVDMsgBool* pValue = (CDVDMsgBool*)pMsg;
-        SetSubtitleVisibleInternal(pValue->m_value);
-      }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_SET_STATE))
-      {
-        g_infoManager.SetDisplayAfterSeek(100000);
-        SetCaching(CACHESTATE_FLUSH);
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SET_SUBTITLESTREAM_VISIBLE))
+    {
+      CDVDMsgBool* pValue = (CDVDMsgBool*)pMsg;
+      SetSubtitleVisibleInternal(pValue->m_value);
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SET_STATE))
+    {
+      g_infoManager.SetDisplayAfterSeek(100000);
+      SetCaching(CACHESTATE_FLUSH);
 
-        CDVDMsgPlayerSetState* pMsgPlayerSetState = (CDVDMsgPlayerSetState*)pMsg;
+      CDVDMsgPlayerSetState* pMsgPlayerSetState = (CDVDMsgPlayerSetState*)pMsg;
 
-        if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
+      if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
+      {
+        if(ptr->SetState(pMsgPlayerSetState->GetState()))
         {
-          if(ptr->SetState(pMsgPlayerSetState->GetState()))
-          {
-            m_dvd.state = DVDSTATE_NORMAL;
-            m_dvd.iDVDStillStartTime = 0;
-            m_dvd.iDVDStillTime = 0;
-          }
+          m_dvd.state = DVDSTATE_NORMAL;
+          m_dvd.iDVDStillStartTime = 0;
+          m_dvd.iDVDStillTime = 0;
         }
-
-        g_infoManager.SetDisplayAfterSeek();
-      }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_SET_RECORD))
-      {
-        CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
-        if(input)
-          input->Record(*(CDVDMsgBool*)pMsg);
       }
-      else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH))
+
+      g_infoManager.SetDisplayAfterSeek();
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SET_RECORD))
+    {
+      CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+      if(input)
+        input->Record(*(CDVDMsgBool*)pMsg);
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH))
+    {
+      FlushBuffers(false);
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
+    {
+      int speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
+
+      // correct our current clock, as it would start going wrong otherwise
+      if (m_State.timestamp > 0)
       {
-        FlushBuffers(false);
+        double offset;
+        offset = m_clock.GetAbsoluteClock() - m_State.timestamp;
+        offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
+        offset = DVD_TIME_TO_MSEC(offset);
+        if (offset > 1000)
+          offset = 1000;
+        if (offset < -1000)
+          offset = -1000;
+        m_State.time += offset;
+        m_State.timestamp = m_clock.GetAbsoluteClock();
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
-      {
-        int speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
 
-        // correct our current clock, as it would start going wrong otherwise
-        if (m_State.timestamp > 0)
-        {
-          double offset;
-          offset = m_clock.GetAbsoluteClock() - m_State.timestamp;
-          offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
-          offset = DVD_TIME_TO_MSEC(offset);
-          if (offset > 1000)
-            offset = 1000;
-          if (offset < -1000)
-            offset = -1000;
-          m_State.time += offset;
-          m_State.timestamp = m_clock.GetAbsoluteClock();
-        }
+      if (speed != DVD_PLAYSPEED_PAUSE && m_playSpeed != DVD_PLAYSPEED_PAUSE && speed != m_playSpeed)
+        m_callback.OnPlayBackSpeedChanged(speed / DVD_PLAYSPEED_NORMAL);
 
-        if (speed != DVD_PLAYSPEED_PAUSE && m_playSpeed != DVD_PLAYSPEED_PAUSE && speed != m_playSpeed)
-          m_callback.OnPlayBackSpeedChanged(speed / DVD_PLAYSPEED_NORMAL);
+      // notifiy GUI, skins may want to show the seekbar
+      g_infoManager.SetDisplayAfterSeek();
 
-        // notifiy GUI, skins may want to show the seekbar
-        g_infoManager.SetDisplayAfterSeek();
+      if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && speed != m_playSpeed)
+      {
+        CDVDInputStreamPVRManager* pvrinputstream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+        pvrinputstream->Pause( speed == 0 );
+      }
 
-        if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && speed != m_playSpeed)
-        {
-          CDVDInputStreamPVRManager* pvrinputstream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
-          pvrinputstream->Pause( speed == 0 );
-        }
+      // do a seek after rewind, clock is not in sync with current pts
+      if ((speed == DVD_PLAYSPEED_NORMAL) &&
+          (m_playSpeed != DVD_PLAYSPEED_NORMAL) &&
+          (m_playSpeed != DVD_PLAYSPEED_PAUSE) &&
+          !m_omxplayer_mode)
+      {
+        int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset);
+        if (m_State.time != DVD_NOPTS_VALUE)
+          iTime = m_State.time;
+        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, m_playSpeed < 0, true, false, false, true));
+      }
 
-        // do a seek after rewind, clock is not in sync with current pts
-        if ((speed == DVD_PLAYSPEED_NORMAL) &&
-            (m_playSpeed != DVD_PLAYSPEED_NORMAL) &&
-            (m_playSpeed != DVD_PLAYSPEED_PAUSE) &&
-            !m_omxplayer_mode)
+      // !!! omx alterative code path !!!
+      // should be done differently
+      if (m_omxplayer_mode)
+      {
+        // when switching from trickplay to normal, we may not have a full set of reference frames
+        // in decoder and we may get corrupt frames out. Seeking to current time will avoid this.
+        if ( (speed != DVD_PLAYSPEED_PAUSE && speed != DVD_PLAYSPEED_NORMAL) ||
+            (m_playSpeed != DVD_PLAYSPEED_PAUSE && m_playSpeed != DVD_PLAYSPEED_NORMAL) )
         {
-          int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset);
-          if (m_State.time != DVD_NOPTS_VALUE)
-            iTime = m_State.time;
-          m_messenger.Put(new CDVDMsgPlayerSeek(iTime, m_playSpeed < 0, true, false, false, true));
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), (speed < 0), true, true, false, true));
         }
-
-        // !!! omx alterative code path !!!
-        // should be done differently
-        if (m_omxplayer_mode)
+        else
         {
-          // when switching from trickplay to normal, we may not have a full set of reference frames
-          // in decoder and we may get corrupt frames out. Seeking to current time will avoid this.
-          if ( (speed != DVD_PLAYSPEED_PAUSE && speed != DVD_PLAYSPEED_NORMAL) ||
-               (m_playSpeed != DVD_PLAYSPEED_PAUSE && m_playSpeed != DVD_PLAYSPEED_NORMAL) )
-          {
-            m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), (speed < 0), true, true, false, true));
-          }
-          else
-          {
-            m_OmxPlayerState.av_clock.OMXPause();
-          }
-
-          m_OmxPlayerState.av_clock.OMXSetSpeed(speed);
-          CLog::Log(LOGDEBUG, "%s::%s CDVDMsg::PLAYER_SETSPEED speed : %d (%d)", "CVideoPlayer", __FUNCTION__, speed, static_cast<int>(m_playSpeed));
+          m_OmxPlayerState.av_clock.OMXPause();
         }
 
-        m_playSpeed = speed;
-        m_newPlaySpeed = speed;
-        m_caching = CACHESTATE_DONE;
-        m_clock.SetSpeed(speed);
-        m_VideoPlayerAudio->SetSpeed(speed);
-        m_VideoPlayerVideo->SetSpeed(speed);
-        m_streamPlayerSpeed = speed;
-        if (m_pDemuxer)
-          m_pDemuxer->SetSpeed(speed);
+        m_OmxPlayerState.av_clock.OMXSetSpeed(speed);
+        CLog::Log(LOGDEBUG, "%s::%s CDVDMsg::PLAYER_SETSPEED speed : %d (%d)", "CVideoPlayer", __FUNCTION__, speed, static_cast<int>(m_playSpeed));
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_SELECT_NUMBER) && m_messenger.GetPacketCount(CDVDMsg::PLAYER_CHANNEL_SELECT_NUMBER) == 0)
+
+      m_playSpeed = speed;
+      m_newPlaySpeed = speed;
+      m_caching = CACHESTATE_DONE;
+      m_clock.SetSpeed(speed);
+      m_VideoPlayerAudio->SetSpeed(speed);
+      m_VideoPlayerVideo->SetSpeed(speed);
+      m_streamPlayerSpeed = speed;
+      if (m_pDemuxer)
+        m_pDemuxer->SetSpeed(speed);
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_SELECT_NUMBER) &&
+             m_messenger.GetPacketCount(CDVDMsg::PLAYER_CHANNEL_SELECT_NUMBER) == 0)
+    {
+      FlushBuffers(false);
+      CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+      //! @todo find a better solution for the "otherStreaHack"
+      //! a stream is not sopposed to be terminated before demuxer
+      if (input && input->IsOtherStreamHack())
       {
-        FlushBuffers(false);
-        CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
-        //! @todo find a better solution for the "otherStreaHack"
-        //! a stream is not sopposed to be terminated before demuxer
-        if (input && input->IsOtherStreamHack())
-        {
-          CloseDemuxer();
-        }
-        if(input && input->SelectChannelByNumber(static_cast<CDVDMsgInt*>(pMsg)->m_value))
-        {
-          CloseDemuxer();
-          m_playSpeed = DVD_PLAYSPEED_NORMAL;
+        CloseDemuxer();
+      }
+      if(input && input->SelectChannelByNumber(static_cast<CDVDMsgInt*>(pMsg)->m_value))
+      {
+        CloseDemuxer();
+        m_playSpeed = DVD_PLAYSPEED_NORMAL;
 
-          // when using fast channel switching some shortcuts are taken which 
-          // means we'll have to update the view mode manually
-          m_renderManager.SetViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode);
-        }
-        else
-        {
-          CLog::Log(LOGWARNING, "%s - failed to switch channel. playback stopped", __FUNCTION__);
-          CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
-        }
-        ShowPVRChannelInfo();
+        // when using fast channel switching some shortcuts are taken which
+        // means we'll have to update the view mode manually
+        m_renderManager.SetViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode);
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_SELECT) && m_messenger.GetPacketCount(CDVDMsg::PLAYER_CHANNEL_SELECT) == 0)
+      else
       {
-        FlushBuffers(false);
-        CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
-        if (input && input->IsOtherStreamHack())
-        {
-          CloseDemuxer();
-        }
-        if(input && input->SelectChannel(static_cast<CDVDMsgType <CPVRChannelPtr> *>(pMsg)->m_value))
-        {
-          CloseDemuxer();
-          m_playSpeed = DVD_PLAYSPEED_NORMAL;
-        }
-        else
-        {
-          CLog::Log(LOGWARNING, "%s - failed to switch channel. playback stopped", __FUNCTION__);
-          CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
-        }
-        g_PVRManager.SetChannelPreview(false);
-        ShowPVRChannelInfo();
+        CLog::Log(LOGWARNING, "%s - failed to switch channel. playback stopped", __FUNCTION__);
+        CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREV) ||
-               pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_PREV))
+      ShowPVRChannelInfo();
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_SELECT) &&
+             m_messenger.GetPacketCount(CDVDMsg::PLAYER_CHANNEL_SELECT) == 0)
+    {
+      FlushBuffers(false);
+      CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+      if (input && input->IsOtherStreamHack())
       {
-        CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
-        if (input)
-        {
-          bool bSwitchSuccessful(false);
-          bool bShowPreview(pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_NEXT) ||
-                            pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_PREV) ||
-                            CSettings::GetInstance().GetInt(CSettings::SETTING_PVRPLAYBACK_CHANNELENTRYTIMEOUT) > 0);
+        CloseDemuxer();
+      }
+      if(input && input->SelectChannel(static_cast<CDVDMsgType <CPVRChannelPtr> *>(pMsg)->m_value))
+      {
+        CloseDemuxer();
+        m_playSpeed = DVD_PLAYSPEED_NORMAL;
+      }
+      else
+      {
+        CLog::Log(LOGWARNING, "%s - failed to switch channel. playback stopped", __FUNCTION__);
+        CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
+      }
+      g_PVRManager.SetChannelPreview(false);
+      ShowPVRChannelInfo();
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREV) ||
+             pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_PREV))
+    {
+      CDVDInputStreamPVRManager* input = dynamic_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+      if (input)
+      {
+        bool bSwitchSuccessful(false);
+        bool bShowPreview(pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_NEXT) ||
+                          pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_PREV) ||
+                          CSettings::GetInstance().GetInt(CSettings::SETTING_PVRPLAYBACK_CHANNELENTRYTIMEOUT) > 0);
 
-          if (!bShowPreview)
+        if (!bShowPreview)
+        {
+          g_infoManager.SetDisplayAfterSeek(100000);
+          FlushBuffers(false);
+          if (input->IsOtherStreamHack())
           {
-            g_infoManager.SetDisplayAfterSeek(100000);
-            FlushBuffers(false);
-            if (input->IsOtherStreamHack())
-            {
-              CloseDemuxer();
-            }
+            CloseDemuxer();
           }
+        }
 
-          if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_NEXT))
-            bSwitchSuccessful = input->NextChannel(bShowPreview);
-          else
-            bSwitchSuccessful = input->PrevChannel(bShowPreview);
+        if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_NEXT))
+          bSwitchSuccessful = input->NextChannel(bShowPreview);
+        else
+          bSwitchSuccessful = input->PrevChannel(bShowPreview);
 
-          if (bSwitchSuccessful)
+        if (bSwitchSuccessful)
+        {
+          if (bShowPreview)
           {
-            if (bShowPreview)
-            {
-              UpdateApplication(0);
+            UpdateApplication(0);
 
-              if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_PREV))
-                m_ChannelEntryTimeOut.SetInfinite();
-              else
-                m_ChannelEntryTimeOut.Set(CSettings::GetInstance().GetInt(CSettings::SETTING_PVRPLAYBACK_CHANNELENTRYTIMEOUT));
-            }
-            else
-            {
+            if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREVIEW_PREV))
               m_ChannelEntryTimeOut.SetInfinite();
-              CloseDemuxer();
-              m_playSpeed = DVD_PLAYSPEED_NORMAL;
-
-              g_infoManager.SetDisplayAfterSeek();
-              g_PVRManager.SetChannelPreview(false);
-
-              // when using fast channel switching some shortcuts are taken which 
-              // means we'll have to update the view mode manually
-              m_renderManager.SetViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode);
-            }
-            ShowPVRChannelInfo();
+            else
+              m_ChannelEntryTimeOut.Set(CSettings::GetInstance().GetInt(CSettings::SETTING_PVRPLAYBACK_CHANNELENTRYTIMEOUT));
           }
           else
           {
-            CLog::Log(LOGWARNING, "%s - failed to switch channel. playback stopped", __FUNCTION__);
-            CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
+            m_ChannelEntryTimeOut.SetInfinite();
+            CloseDemuxer();
+            m_playSpeed = DVD_PLAYSPEED_NORMAL;
+
+            g_infoManager.SetDisplayAfterSeek();
+            g_PVRManager.SetChannelPreview(false);
+
+            // when using fast channel switching some shortcuts are taken which
+            // means we'll have to update the view mode manually
+            m_renderManager.SetViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode);
           }
+          ShowPVRChannelInfo();
         }
-      }
-      else if (pMsg->IsType(CDVDMsg::GENERAL_GUI_ACTION))
-        OnAction(((CDVDMsgType<CAction>*)pMsg)->m_value);
-      else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
-      {
-        SStartMsg& msg = ((CDVDMsgType<SStartMsg>*)pMsg)->m_value;
-        if (msg.player == VideoPlayer_AUDIO)
-        {
-          m_CurrentAudio.syncState = IDVDStreamPlayer::SYNC_WAITSYNC;
-          m_CurrentAudio.cachetime = msg.cachetime;
-          m_CurrentAudio.cachetotal = msg.cachetotal;
-          m_CurrentAudio.starttime = msg.timestamp;
-        }
-        if (msg.player == VideoPlayer_VIDEO)
+        else
         {
-          m_CurrentVideo.syncState = IDVDStreamPlayer::SYNC_WAITSYNC;
-          m_CurrentVideo.cachetime = msg.cachetime;
-          m_CurrentVideo.cachetotal = msg.cachetotal;
-          m_CurrentVideo.starttime = msg.timestamp;
+          CLog::Log(LOGWARNING, "%s - failed to switch channel. playback stopped", __FUNCTION__);
+          CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
         }
-        CLog::Log(LOGDEBUG, "CVideoPlayer::HandleMessages - player started %d", msg.player);
       }
-      else if (pMsg->IsType(CDVDMsg::SUBTITLE_ADDFILE))
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_GUI_ACTION))
+      OnAction(((CDVDMsgType<CAction>*)pMsg)->m_value);
+    else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
+    {
+      SStartMsg& msg = ((CDVDMsgType<SStartMsg>*)pMsg)->m_value;
+      if (msg.player == VideoPlayer_AUDIO)
       {
-        int id = AddSubtitleFile(((CDVDMsgType<std::string>*) pMsg)->m_value);
-        if (id >= 0)
-        {
-          SetSubtitle(id);
-          SetSubtitleVisibleInternal(true);
-        }
+        m_CurrentAudio.syncState = IDVDStreamPlayer::SYNC_WAITSYNC;
+        m_CurrentAudio.cachetime = msg.cachetime;
+        m_CurrentAudio.cachetotal = msg.cachetotal;
+        m_CurrentAudio.starttime = msg.timestamp;
       }
-      else if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
+      if (msg.player == VideoPlayer_VIDEO)
       {
-        if (((CDVDMsgGeneralSynchronize*)pMsg)->Wait(100, SYNCSOURCE_PLAYER))
-          CLog::Log(LOGDEBUG, "CVideoPlayer - CDVDMsg::GENERAL_SYNCHRONIZE");
+        m_CurrentVideo.syncState = IDVDStreamPlayer::SYNC_WAITSYNC;
+        m_CurrentVideo.cachetime = msg.cachetime;
+        m_CurrentVideo.cachetotal = msg.cachetotal;
+        m_CurrentVideo.starttime = msg.timestamp;
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_AVCHANGE))
+      CLog::Log(LOGDEBUG, "CVideoPlayer::HandleMessages - player started %d", msg.player);
+    }
+    else if (pMsg->IsType(CDVDMsg::SUBTITLE_ADDFILE))
+    {
+      int id = AddSubtitleFile(((CDVDMsgType<std::string>*) pMsg)->m_value);
+      if (id >= 0)
       {
-        UpdateStreamInfos();
-        CServiceBroker::GetDataCacheCore().SignalAudioInfoChange();
-        CServiceBroker::GetDataCacheCore().SignalVideoInfoChange();
+        SetSubtitle(id);
+        SetSubtitleVisibleInternal(true);
       }
+    }
+    else if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
+    {
+      if (((CDVDMsgGeneralSynchronize*)pMsg)->Wait(100, SYNCSOURCE_PLAYER))
+        CLog::Log(LOGDEBUG, "CVideoPlayer - CDVDMsg::GENERAL_SYNCHRONIZE");
+    }
+    else if (pMsg->IsType(CDVDMsg::PLAYER_AVCHANGE))
+    {
+      UpdateStreamInfos();
+      CServiceBroker::GetDataCacheCore().SignalAudioInfoChange();
+      CServiceBroker::GetDataCacheCore().SignalVideoInfoChange();
+    }
 
     pMsg->Release();
   }
-
 }
 
 void CVideoPlayer::SetCaching(ECacheState state)
-- 
2.7.4


From e7f49d4f4d4c4367da098fc1600144ca960bf088 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 10:46:45 +0200
Subject: [PATCH 090/175] VideoPlayer: do not signal started if pic was dropped

---
 xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
index 9184826..3c15bf1 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
@@ -620,7 +620,9 @@ bool CVideoPlayerVideo::ProcessDecoderOutput(int &decoderState, double &frametim
 
       frametime = (double)DVD_TIME_BASE / m_fFrameRate;
 
-      if (m_syncState == IDVDStreamPlayer::SYNC_STARTING && !(m_picture.iFlags & DVP_FLAG_DROPPED))
+      if (m_syncState == IDVDStreamPlayer::SYNC_STARTING &&
+          !(iResult & EOS_DROPPED) &&
+          !(m_picture.iFlags & DVP_FLAG_DROPPED))
       {
         m_syncState = IDVDStreamPlayer::SYNC_WAITSYNC;
         SStartMsg msg;
-- 
2.7.4


From 988556a4cf11eb445106c671e366c3d9f4887dd8 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 10:47:34 +0200
Subject: [PATCH 091/175] VideoPlayer: skip seeks if last seek is still in
 process

---
 xbmc/cores/VideoPlayer/VideoPlayer.cpp | 15 +++++++++++++++
 xbmc/cores/VideoPlayer/VideoPlayer.h   |  2 ++
 2 files changed, 17 insertions(+)

diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index e7183a7..4c39682 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -2496,6 +2496,20 @@ void CVideoPlayer::HandleMessages()
         continue;
       }
 
+      // skip seeks if player has not finished the last seek
+      if (m_CurrentVideo.id >= 0 &&
+          m_CurrentVideo.syncState != IDVDStreamPlayer::SYNC_INSYNC)
+      {
+        double now = m_clock.GetAbsoluteClock();
+        if (m_playSpeed == DVD_PLAYSPEED_NORMAL &&
+            DVD_TIME_TO_MSEC(now - m_State.lastSeek) < 2000 &&
+            !msg.GetAccurate())
+        {
+          pMsg->Release();
+          continue;
+        }
+      }
+
       if (!msg.GetTrickPlay())
       {
         g_infoManager.SetDisplayAfterSeek(100000);
@@ -2530,6 +2544,7 @@ void CVideoPlayer::HandleMessages()
           start = DVD_MSEC_TO_TIME(time) - m_State.time_offset;
 
         m_State.dts = start;
+        m_State.lastSeek = m_clock.GetAbsoluteClock();
 
         FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
       }
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.h b/xbmc/cores/VideoPlayer/VideoPlayer.h
index 8032e7e..c82afb7 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.h
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.h
@@ -109,9 +109,11 @@ struct SPlayerState
     cache_level = 0.0;
     cache_delay = 0.0;
     cache_offset = 0.0;
+    lastSeek = 0;
   }
 
   double timestamp;         // last time of update
+  double lastSeek;          // time of last seek
   double time_offset;       // difference between time and pts
 
   double time;              // current playback time
-- 
2.7.4


From 5eea1cfc77efe021b5ed4ccc763bc9de0f791db3 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 20:05:22 +0200
Subject: [PATCH 092/175] VideoPlayer: fix general synchronize after
 48301edd6a88c044243e6468ceeb54ff65f35f26

---
 xbmc/cores/VideoPlayer/DVDMessage.cpp  | 9 ++++++---
 xbmc/cores/VideoPlayer/VideoPlayer.cpp | 4 ++--
 2 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDMessage.cpp b/xbmc/cores/VideoPlayer/DVDMessage.cpp
index 37abf20..c7df4a6 100644
--- a/xbmc/cores/VideoPlayer/DVDMessage.cpp
+++ b/xbmc/cores/VideoPlayer/DVDMessage.cpp
@@ -62,10 +62,13 @@ bool CDVDMsgGeneralSynchronize::Wait(unsigned int milliseconds, unsigned int sou
 
   XbmcThreads::EndTime timeout(milliseconds);
 
-  m_p->reached |= source & m_p->sources;
+  m_p->reached |= (source & m_p->sources);
+  if ((m_p->sources & SYNCSOURCE_ANY) && source)
+    m_p->reached |= SYNCSOURCE_ANY;
 
-  while (m_p->reached != m_p->sources ||
-         (m_p->sources == SYNCSOURCE_ANY && m_p->reached))
+  m_p->condition.notifyAll();
+
+  while (m_p->reached != m_p->sources)
   {
     milliseconds = std::min(m_p->timeout.MillisLeft(), timeout.MillisLeft());
     if (m_p->condition.wait(lock, milliseconds))
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index 4c39682..b07561a 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -3936,7 +3936,7 @@ void CVideoPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool syn
     m_VideoPlayerTeletext->SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
     m_VideoPlayerRadioRDS->SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
-    CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(10*1000, SYNCSOURCE_AUDIO | SYNCSOURCE_AUDIO);
+    CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(10*1000, SYNCSOURCE_AUDIO | SYNCSOURCE_VIDEO);
     m_VideoPlayerAudio->SendMessage(msg->Acquire(), 1);
     m_VideoPlayerVideo->SendMessage(msg->Acquire(), 1);
     msg->Wait(m_bStop, 0);
@@ -3957,7 +3957,7 @@ void CVideoPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool syn
     || m_playSpeed == DVD_PLAYSPEED_PAUSE)
     {
       // make sure players are properly flushed, should put them in stalled state
-      CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(1000, SYNCSOURCE_AUDIO | SYNCSOURCE_AUDIO);
+      CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(1000, SYNCSOURCE_AUDIO | SYNCSOURCE_VIDEO);
       m_VideoPlayerAudio->SendMessage(msg->Acquire(), 1);
       m_VideoPlayerVideo->SendMessage(msg->Acquire(), 1);
       msg->Wait(m_bStop, 0);
-- 
2.7.4


From f87d977924694e058266aae295ce849112a3509d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 20:26:31 +0200
Subject: [PATCH 093/175] VideoPlayer: do not wait for teletext msg queue to be
 empty, makes no sense

---
 xbmc/cores/VideoPlayer/VideoPlayerTeletext.cpp | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoPlayerTeletext.cpp b/xbmc/cores/VideoPlayer/VideoPlayerTeletext.cpp
index 89c8365..c4a2126 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerTeletext.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerTeletext.cpp
@@ -136,9 +136,6 @@ bool CDVDTeletextData::OpenStream(CDVDStreamInfo &hints)
 
 void CDVDTeletextData::CloseStream(bool bWaitForBuffers)
 {
-  // wait until buffers are empty
-  if (bWaitForBuffers && m_speed > 0) m_messageQueue.WaitUntilEmpty();
-
   m_messageQueue.Abort();
 
   // wait for decode_video thread to end
-- 
2.7.4


From cd975661e722207a491ec812223a4b61173c92c3 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 9 Oct 2016 20:45:55 +0200
Subject: [PATCH 094/175] Revert "X11, osx: yield to main loop after input
 action has been handled"

---
 xbmc/windowing/WinEventsSDL.cpp | 2 +-
 xbmc/windowing/WinEventsX11.cpp | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/WinEventsSDL.cpp b/xbmc/windowing/WinEventsSDL.cpp
index 364f12c..b88f527 100644
--- a/xbmc/windowing/WinEventsSDL.cpp
+++ b/xbmc/windowing/WinEventsSDL.cpp
@@ -220,7 +220,7 @@ bool CWinEventsSDL::MessagePump()
   SDL_Event event;
   bool ret = false;
 
-  while (!ret && SDL_PollEvent(&event))
+  while (SDL_PollEvent(&event))
   {
     switch(event.type)
     {
diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 5890cea..e638511 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -316,7 +316,7 @@ bool CWinEventsX11Imp::MessagePump()
   XEvent xevent;
   unsigned long serial = 0;
 
-  while (!ret && XPending(WinEvents->m_display))
+  while (WinEvents && XPending(WinEvents->m_display))
   {
     memset(&xevent, 0, sizeof (XEvent));
     XNextEvent(WinEvents->m_display, &xevent);
-- 
2.7.4


From c1e80d4e487a5f670e8b6776c169b82585f66ff6 Mon Sep 17 00:00:00 2001
From: ronie <ronie@users.noreply.github.com>
Date: Sun, 9 Oct 2016 22:18:35 +0200
Subject: [PATCH 095/175] smartplaylist rules container did not work with a
 mouse

---
 addons/skin.estuary/1080i/SmartPlaylistEditor.xml | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
index 678b419..461f142 100644
--- a/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
+++ b/addons/skin.estuary/1080i/SmartPlaylistEditor.xml
@@ -77,7 +77,7 @@
 				<height>530</height>
 				<texture border="40">buttons/dialogbutton-nofo.png</texture>
 			</control>
-			<control type="panel" id="10">
+			<control type="list" id="10">
 				<description>Rules List Control</description>
 				<left>740</left>
 				<top>115</top>
@@ -85,7 +85,6 @@
 				<height>480</height>
 				<onleft>500</onleft>
 				<onright>9001</onright>
-				<orientation>horizontal</orientation>
 				<include content="DefaultSimpleListLayout">
 					<param name="width" value="600" />
 					<param name="list_id" value="10" />
-- 
2.7.4


From 8f42cb4da29e6ba7138c0d65d6a0c82312a04bc5 Mon Sep 17 00:00:00 2001
From: Christian Fetzer <fetzer.ch@gmail.com>
Date: Sat, 8 Oct 2016 09:40:07 +0200
Subject: [PATCH 096/175] Update usage instructions

---
 project/Win32BuildSetup/BuildSetup.bat | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/project/Win32BuildSetup/BuildSetup.bat b/project/Win32BuildSetup/BuildSetup.bat
index 9086d27..ab4ed5d 100644
--- a/project/Win32BuildSetup/BuildSetup.bat
+++ b/project/Win32BuildSetup/BuildSetup.bat
@@ -25,12 +25,13 @@ IF NOT [%TAG%] == [] (
 )
 
 rem ----Usage----
-rem BuildSetup [clean|noclean]
+rem BuildSetup [clean|noclean] [noprompt] [nomingwlibs] [nobinaryaddons] [sh]
 rem clean to force a full rebuild
 rem noclean to force a build without clean
 rem noprompt to avoid all prompts
 rem nomingwlibs to skip building all libs built with mingw
-rem cmake to build with cmake instead of VS solution
+rem nobinaryaddons to skip building binary addons
+rem sh to use sh shell instead rxvt
 CLS
 COLOR 1B
 TITLE %APP_NAME% for Windows Build Script
-- 
2.7.4


From f8c2e876130f355fd4f38c2746dff99b00f5dd47 Mon Sep 17 00:00:00 2001
From: Christian Fetzer <fetzer.ch@gmail.com>
Date: Sun, 4 Sep 2016 17:41:03 +0200
Subject: [PATCH 097/175] Don't install/mirror skins and audioencoder plugins
 twice

Skins are already handled in main CMakeLists.txt. Audioencoders
are listed twice in installdata.
---
 project/cmake/installdata/common/addons.txt | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/project/cmake/installdata/common/addons.txt b/project/cmake/installdata/common/addons.txt
index 3f86c78..b5cd8f5 100644
--- a/project/cmake/installdata/common/addons.txt
+++ b/project/cmake/installdata/common/addons.txt
@@ -1,4 +1,5 @@
 addons/audioencoder.xbmc.builtin.aac/*
+addons/audioencoder.xbmc.builtin.wav/*
 addons/audioencoder.xbmc.builtin.wma/*
 addons/game.controller.default/*
 addons/kodi.adsp/*
@@ -31,15 +32,10 @@ addons/screensaver.xbmc.builtin.dim/*
 addons/screensaver.xbmc.builtin.black/*
 addons/script.module.pil/*
 addons/script.module.pysqlite/*
-addons/audioencoder.xbmc.builtin.aac/*
-addons/audioencoder.xbmc.builtin.wav/*
-addons/audioencoder.xbmc.builtin.wma/*
 addons/resource.language.en_gb/*
 addons/resource.uisounds.confluence/*
 addons/resource.images.weathericons.default/*
 addons/service.xbmc.versioncheck/*
-addons/skin.estuary/*
-addons/skin.estouchy/*
 addons/metadata.local/*
 addons/metadata.album.universal/*
 addons/metadata.artists.universal/*
-- 
2.7.4


From 1600a17525f5a9b9cae227f21f6017c9022bd665 Mon Sep 17 00:00:00 2001
From: Christian Fetzer <fetzer.ch@gmail.com>
Date: Sat, 8 Oct 2016 15:00:36 +0200
Subject: [PATCH 098/175] Remove unnecessary skin building

CMake's pack-skin target already packages the skin (builds the xbt files).
The current scripts produced empty xbt files, and the final package only
worked because of an error in CMake which was overriding the xbt file
again with a working version.
---
 addons/skin.estouchy/build.bat               | 21 ---------------------
 addons/skin.estuary/build.bat                | 26 --------------------------
 project/Win32BuildSetup/BuildSetup.bat       | 14 --------------
 project/Win32BuildSetup/genNsisIncludes.bat  | 16 ----------------
 project/Win32BuildSetup/genNsisInstaller.nsi |  2 --
 5 files changed, 79 deletions(-)
 delete mode 100644 addons/skin.estouchy/build.bat
 delete mode 100644 addons/skin.estuary/build.bat

diff --git a/addons/skin.estouchy/build.bat b/addons/skin.estouchy/build.bat
deleted file mode 100644
index 2af3b67..0000000
--- a/addons/skin.estouchy/build.bat
+++ /dev/null
@@ -1,21 +0,0 @@
-@echo off
-ECHO ----------------------------------------
-echo Creating estouchy Build Folder
-IF Exist %base_dir%\project\Win32BuildSetup\BUILD_WIN32\addons\skin.estouchy rmdir %base_dir%\project\Win32BuildSetup\BUILD_WIN32\addons\skin.estouchy /S /Q
-md %base_dir%\project\Win32BuildSetup\BUILD_WIN32\addons\skin.estouchy\media\
-
-Echo build.bat>>exclude.txt
-Echo .git>>exclude.txt
-Echo \skin.estouchy\media\>>exclude.txt
-Echo exclude.txt>>exclude.txt
-
-ECHO ----------------------------------------
-ECHO Creating XBT File...
-START /B /WAIT %base_dir%\Tools\TexturePacker\TexturePacker -dupecheck -input media -output %base_dir%\project\Win32BuildSetup\BUILD_WIN32\addons\skin.estouchy\media\Textures.xbt
-
-ECHO ----------------------------------------
-ECHO XBT Texture Files Created...
-ECHO Building Skin Directory...
-xcopy "..\skin.estouchy" "%base_dir%\project\Win32BuildSetup\BUILD_WIN32\addons\skin.estouchy" /E /Q /I /Y /EXCLUDE:exclude.txt
-
-del exclude.txt
diff --git a/addons/skin.estuary/build.bat b/addons/skin.estuary/build.bat
deleted file mode 100644
index 8d6cb50..0000000
--- a/addons/skin.estuary/build.bat
+++ /dev/null
@@ -1,26 +0,0 @@
-@echo off
-ECHO ----------------------------------------
-echo Creating Estuary Build Folder
-IF Exist %base_dir%\project\Win32BuildSetup\BUILD_WIN32\application\addons\skin.estuary rmdir %base_dir%\project\Win32BuildSetup\BUILD_WIN32\application\addons\skin.estuary /S /Q
-md %base_dir%\project\Win32BuildSetup\BUILD_WIN32\application\addons\skin.estuary\media\
-
-Echo .svn>exclude.txt
-Echo Thumbs.db>>exclude.txt
-Echo Desktop.ini>>exclude.txt
-Echo dsstdfx.bin>>exclude.txt
-Echo build.bat>>exclude.txt
-Echo \skin.estuary\media\>>exclude.txt
-Echo \skin.estuary\themes\>>exclude.txt
-Echo exclude.txt>>exclude.txt
-
-ECHO ----------------------------------------
-ECHO Creating XBT File...
-START /B /WAIT %base_dir%\Tools\TexturePacker\TexturePacker -dupecheck -input media -output %base_dir%\project\Win32BuildSetup\BUILD_WIN32\application\addons\skin.estuary\media\Textures.xbt
-START /B /WAIT %base_dir%\Tools\TexturePacker\TexturePacker -dupecheck -input themes\curial -output %base_dir%\project\Win32BuildSetup\BUILD_WIN32\application\addons\skin.estuary\media\curial.xbt
-
-ECHO ----------------------------------------
-ECHO XBT Texture Files Created...
-ECHO Building Skin Directory...
-xcopy "..\skin.estuary" "%base_dir%\project\Win32BuildSetup\BUILD_WIN32\application\addons\skin.estuary" /E /Q /I /Y /EXCLUDE:exclude.txt
-
-del exclude.txt
diff --git a/project/Win32BuildSetup/BuildSetup.bat b/project/Win32BuildSetup/BuildSetup.bat
index ab4ed5d..49b6c42 100644
--- a/project/Win32BuildSetup/BuildSetup.bat
+++ b/project/Win32BuildSetup/BuildSetup.bat
@@ -152,9 +152,6 @@ set WORKSPACE=%CD%\..\..\kodi-build
   Echo userdata\database\>>exclude.txt
   Echo userdata\playlists\>>exclude.txt
   Echo userdata\thumbnails\>>exclude.txt
-  rem Exclude skins as they're copied by their own script
-  Echo addons\skin.estuary\>>exclude.txt
-  Echo addons\skin.estouchy\>>exclude.txt
 
   rem Exclude dlls from system to avoid duplicates
   Echo .dll>>exclude_dll.txt
@@ -196,17 +193,6 @@ set WORKSPACE=%CD%\..\..\kodi-build
     IF EXIST error.log del error.log > NUL
   )
 
-  ECHO ------------------------------------------------------------
-  ECHO Building Estuary Skin...
-  cd %WORKSPACE%\addons\skin.estuary
-  call build.bat > NUL
-  cd %build_path%
-
-  ECHO Building Estouchy Skin...
-  cd %WORKSPACE%\addons\skin.estouchy
-  call build.bat > NUL
-  cd %build_path%
-  
   rem restore color and title, some scripts mess these up
   COLOR 1B
   TITLE %APP_NAME% for Windows Build Script
diff --git a/project/Win32BuildSetup/genNsisIncludes.bat b/project/Win32BuildSetup/genNsisIncludes.bat
index 037a9fc..2e481e6 100644
--- a/project/Win32BuildSetup/genNsisIncludes.bat
+++ b/project/Win32BuildSetup/genNsisIncludes.bat
@@ -108,22 +108,6 @@ IF EXIST BUILD_WIN32\addons\visualization.* (
 )
 
 SET Counter=1
-IF EXIST BUILD_WIN32\addons\skin.* (
-  ECHO SectionGroup "Skin Add-ons" SecSkinAddons >> skin-addons.nsi
-  FOR /F "tokens=*" %%P IN ('dir /B /AD BUILD_WIN32\addons\skin.*') DO (
-    FOR /f "delims=<" %%N in ('powershell.exe -ExecutionPolicy Unrestricted -command "& {[xml]$a = get-content BUILD_WIN32\addons\%%P\addon.xml;$a.addon.name}"') do (
-      ECHO Section "%%N" SecSkinAddons!Counter! >> skin-addons.nsi
-      ECHO SectionIn 1 >> skin-addons.nsi
-      ECHO SetOutPath "$INSTDIR\addons\%%P" >> skin-addons.nsi
-      ECHO File /r "${app_root}\addons\%%P\*.*" >> skin-addons.nsi
-      ECHO SectionEnd >> skin-addons.nsi
-      SET /A Counter = !Counter! + 1
-      )
-    )
-  ECHO SectionGroupEnd >> skin-addons.nsi
-)
-
-SET Counter=1
 IF EXIST BUILD_WIN32\addons\inputstream.* (
   ECHO SectionGroup "Inputstream Add-ons" SecInputstreamAddons >> inputstream-addons.nsi
   FOR /F "tokens=*" %%P IN ('dir /B /AD BUILD_WIN32\addons\inputstream.*') DO (
diff --git a/project/Win32BuildSetup/genNsisInstaller.nsi b/project/Win32BuildSetup/genNsisInstaller.nsi
index 9ee3b34..c6dd8a1 100644
--- a/project/Win32BuildSetup/genNsisInstaller.nsi
+++ b/project/Win32BuildSetup/genNsisInstaller.nsi
@@ -176,7 +176,6 @@ Section "${APP_NAME}" SecAPP
   SetOutPath "$INSTDIR\addons"
   File /r "${app_root}\application\addons\*.*"
   File /nonfatal /r "${app_root}\addons\peripheral.*"
-  File /r "${app_root}\addons\skin.*"
   SetOutPath "$INSTDIR\media"
   File /r "${app_root}\application\media\*.*"
   SetOutPath "$INSTDIR\system"
@@ -233,7 +232,6 @@ SectionEnd
 !include /nonfatal "audiodsp-addons.nsi"
 !include /nonfatal "inputstream-addons.nsi"
 !include /nonfatal "pvr-addons.nsi"
-;!include /nonfatal "skin-addons.nsi"
 !include /nonfatal "screensaver-addons.nsi"
 !include /nonfatal "visualization-addons.nsi"
 
-- 
2.7.4


From fd93d33bc96b93f6f2bb324d5684517c6f391f12 Mon Sep 17 00:00:00 2001
From: ronie <ronie@users.noreply.github.com>
Date: Sun, 9 Oct 2016 19:22:48 +0200
Subject: [PATCH 099/175] update

---
 addons/skin.estouchy/addon.xml                     |   2 +-
 addons/skin.estouchy/xml/Includes.xml              |   8 +-
 .../skin.estouchy/xml/IncludesPlayerControls.xml   |   1 +
 addons/skin.estouchy/xml/SkinSettings.xml          |  10 +-
 addons/skin.estouchy/xml/SmartPlaylistEditor.xml   | 116 ++++++++++++---------
 addons/skin.estouchy/xml/SmartPlaylistRule.xml     |   4 +-
 6 files changed, 82 insertions(+), 59 deletions(-)

diff --git a/addons/skin.estouchy/addon.xml b/addons/skin.estouchy/addon.xml
index 03d809c..cc99f4e 100644
--- a/addons/skin.estouchy/addon.xml
+++ b/addons/skin.estouchy/addon.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<addon id="skin.estouchy" version="1.0.22" name="Estouchy" provider-name="Team Kodi">
+<addon id="skin.estouchy" version="1.0.23" name="Estouchy" provider-name="Team Kodi">
 	<requires>
 		<import addon="xbmc.gui" version="5.12.0"/>
 	</requires>
diff --git a/addons/skin.estouchy/xml/Includes.xml b/addons/skin.estouchy/xml/Includes.xml
index 35a8c99..a146dd1 100644
--- a/addons/skin.estouchy/xml/Includes.xml
+++ b/addons/skin.estouchy/xml/Includes.xml
@@ -1024,14 +1024,14 @@
 			<onclick>ActivateWindow(TVChannels)</onclick>
 			<icon>icon_menu_livetv.png</icon>
 			<thumb></thumb>
-			<visible>Skin.HasSetting(ShowHomeButtonLiveTV)</visible>
+			<visible>System.HasPVRAddon + !Skin.HasSetting(HideHomeButtonLiveTV)</visible>
 		</item>
 		<item id="2">
 			<label>19021</label>
 			<onclick>ActivateWindow(RadioChannels)</onclick>
 			<icon>icon_menu_radio.png</icon>
 			<thumb></thumb>
-			<visible>Skin.HasSetting(ShowHomeButtonRadio)</visible>
+			<visible>System.HasPVRAddon + !Skin.HasSetting(HideHomeButtonRadio)</visible>
 		</item>
 		<item id="3">
 			<label>20342</label>
@@ -1240,7 +1240,7 @@
 			<alttexturenofocus border="40,0,40,5">list_nofocus.png</alttexturenofocus>
 			<label>653</label>
 			<altlabel>13353</altlabel>
-			<usealttexture>library.isscanningmusic</usealttexture> 
+			<usealttexture>library.isscanningmusic</usealttexture>
 		</control>
 		<control type="radiobutton" id="16">
 			<description>PartyMode</description>
@@ -1496,7 +1496,7 @@
 			<alttexturenofocus border="40,0,40,5">list_nofocus.png</alttexturenofocus>
 			<label>653</label>
 			<altlabel>13353</altlabel>
-			<usealttexture>library.isscanningvideo</usealttexture> 
+			<usealttexture>library.isscanningvideo</usealttexture>
 		</control>
 		<control type="radiobutton" id="16">
 			<description>PartyMode</description>
diff --git a/addons/skin.estouchy/xml/IncludesPlayerControls.xml b/addons/skin.estouchy/xml/IncludesPlayerControls.xml
index 9a72eb6..b7c594c 100644
--- a/addons/skin.estouchy/xml/IncludesPlayerControls.xml
+++ b/addons/skin.estouchy/xml/IncludesPlayerControls.xml
@@ -18,6 +18,7 @@
 			<font></font>
 			<texturenofocus></texturenofocus>
 			<texturefocus></texturefocus>
+			<onclick>Dialog.Close(all)</onclick>
 			<onclick>ActivateWindow(Home)</onclick>
 		</control>
 		<control type="image">
diff --git a/addons/skin.estouchy/xml/SkinSettings.xml b/addons/skin.estouchy/xml/SkinSettings.xml
index 0271f7b..fd5309d 100644
--- a/addons/skin.estouchy/xml/SkinSettings.xml
+++ b/addons/skin.estouchy/xml/SkinSettings.xml
@@ -127,8 +127,9 @@
 					<texturenofocus border="40,0,40,5">list_nofocus.png</texturenofocus>
 					<pulseonselect>false</pulseonselect>
 					<label>$LOCALIZE[31556]</label>
-					<onclick>Skin.ToggleSetting(ShowHomeButtonLiveTV)</onclick>
-					<selected>Skin.HasSetting(ShowHomeButtonLiveTV)</selected>
+					<onclick>Skin.ToggleSetting(HideHomeButtonLiveTV)</onclick>
+					<selected>!Skin.HasSetting(HideHomeButtonLiveTV)</selected>
+					<enable>System.HasPVRAddon</enable>
 					<textoffsetx>20</textoffsetx>
 				</control>
 				<control type="radiobutton" id="103">
@@ -142,8 +143,9 @@
 					<texturenofocus border="40,0,40,5">list_nofocus.png</texturenofocus>
 					<pulseonselect>false</pulseonselect>
 					<label>$LOCALIZE[19021]</label>
-					<onclick>Skin.ToggleSetting(ShowHomeButtonRadio)</onclick>
-					<selected>Skin.HasSetting(ShowHomeButtonRadio)</selected>
+					<onclick>Skin.ToggleSetting(HideHomeButtonRadio)</onclick>
+					<selected>!Skin.HasSetting(HideHomeButtonRadio)</selected>
+					<enable>System.HasPVRAddon</enable>
 					<textoffsetx>20</textoffsetx>
 				</control>
 				<control type="radiobutton" id="104">
diff --git a/addons/skin.estouchy/xml/SmartPlaylistEditor.xml b/addons/skin.estouchy/xml/SmartPlaylistEditor.xml
index 639c6bf..52b4dbd 100644
--- a/addons/skin.estouchy/xml/SmartPlaylistEditor.xml
+++ b/addons/skin.estouchy/xml/SmartPlaylistEditor.xml
@@ -43,7 +43,7 @@
 			<height>70</height>
 			<texture colordiffuse="40000000">panel.png</texture>
 		</control>
-		<control type="spincontrolex" id="22">
+		<control type="button" id="22">
 			<description>Set Playlist type</description>
 			<posx>0</posx>
 			<posy>60</posy>
@@ -74,7 +74,7 @@
 			<height>70</height>
 			<texture colordiffuse="40000000">panel.png</texture>
 		</control>
-		<control type="edit" id="12">
+		<control type="button" id="12">
 			<description>Name Button</description>
 			<posx>0</posx>
 			<posy>170</posy>
@@ -99,14 +99,14 @@
 			<posx>0</posx>
 			<posy>242</posy>
 			<width>760</width>
-			<height>260</height>
+			<height>195</height>
 			<texture colordiffuse="40000000">panel.png</texture>
 		</control>
 		<control type="list" id="10">
 			<posx>0</posx>
 			<posy>242</posy>
 			<width>760</width>
-			<height>260</height>
+			<height>195</height>
 			<onup>9001</onup>
 			<onleft>9000</onleft>
 			<onright>60</onright>
@@ -166,28 +166,10 @@
 		<control type="group" id="9000">
 			<posx>780</posx>
 			<posy>272</posy>
-			<control type="button" id="13">
-				<description>Add Rule Button</description>
-				<posx>0</posx>
-				<posy>0</posy>
-				<width>200</width>
-				<height>60</height>
-				<label>15019</label>
-				<align>center</align>
-				<aligny>center</aligny>
-				<font>font18_title</font>
-				<texturefocus>list_focus.png</texturefocus>
-				<texturenofocus>button_nofocus.png</texturenofocus>
-				<pulseonselect>false</pulseonselect>
-				<onup>18</onup>
-				<onleft>60</onleft>
-				<onright>10</onright>
-				<ondown>13</ondown>
-			</control>
 			<control type="button" id="14">
 				<description>Remove Rule Button</description>
 				<posx>0</posx>
-				<posy>70</posy>
+				<posy>0</posy>
 				<width>200</width>
 				<height>60</height>
 				<label>1210</label>
@@ -205,7 +187,7 @@
 			<control type="button" id="15">
 				<description>Edit Rule Button</description>
 				<posx>0</posx>
-				<posy>140</posy>
+				<posy>70</posy>
 				<width>200</width>
 				<height>60</height>
 				<label>21435</label>
@@ -223,21 +205,21 @@
 		</control>
 		<control type="image">
 			<posx>0</posx>
-			<posy>502</posy>
+			<posy>437</posy>
 			<width>1000</width>
 			<height>2</height>
 			<texture border="2">separator.png</texture>
 		</control>
 		<control type="image">
 			<posx>0</posx>
-			<posy>504</posy>
+			<posy>437</posy>
 			<width>1000</width>
 			<height>140</height>
 			<texture colordiffuse="40000000">panel.png</texture>
 		</control>
-		<control type="spincontrolex" id="16">
+		<control type="button" id="16">
 			<posx>0</posx>
-			<posy>504</posy>
+			<posy>439</posy>
 			<width>1000</width>
 			<height>70</height>
 			<label>21424</label>
@@ -247,9 +229,9 @@
 			<onup>10</onup>
 			<ondown>17</ondown>
 		</control>
-		<control type="spincontrolex" id="17">
+		<control type="button" id="17">
 			<posx>0</posx>
-			<posy>574</posy>
+			<posy>509</posy>
 			<width>1000</width>
 			<height>70</height>
 			<label>21427</label>
@@ -261,15 +243,15 @@
 		</control>
 		<control type="image">
 			<posx>0</posx>
-			<posy>644</posy>
-			<width>760</width>
+			<posy>579</posy>
+			<width>490</width>
 			<height>70</height>
 			<texture colordiffuse="40000000">panel.png</texture>
 		</control>
-		<control type="spincontrolex" id="18">
+		<control type="button" id="18">
 			<posx>0</posx>
-			<posy>644</posy>
-			<width>760</width>
+			<posy>579</posy>
+			<width>490</width>
 			<height>70</height>
 			<label>21429</label>
 			<font>font25</font>
@@ -278,20 +260,58 @@
 			<onup>17</onup>
 			<ondown>9001</ondown>
 		</control>
-		<control type="togglebutton" id="19">
-			<posx>780</posx>
+		<control type="image">
+			<posx>510</posx>
+			<posy>579</posy>
+			<width>490</width>
+			<height>70</height>
+			<texture colordiffuse="40000000">panel.png</texture>
+		</control>
+		<control type="button" id="19">
+			<posx>510</posx>
+			<posy>579</posy>
+			<width>490</width>
+			<height>70</height>
+			<label>580</label>
+			<font>font25</font>
+			<onright>18</onright>
+			<onleft>18</onleft>
+			<onup>17</onup>
+			<ondown>9001</ondown>
+		</control>
+		<control type="image">
+			<posx>0</posx>
 			<posy>649</posy>
-			<width>200</width>
-			<height>60</height>
-			<font>font18_title</font>
-			<align>center</align>
-			<aligny>center</aligny>
-			<texturefocus>list_focus.png</texturefocus>
-			<texturenofocus>button_nofocus.png</texturenofocus>
-			<alttexturefocus>list_focus.png</alttexturefocus>
-			<alttexturenofocus>button_nofocus.png</alttexturenofocus>
-			<label>21431</label>
-			<altlabel>21430</altlabel>
+			<width>490</width>
+			<height>70</height>
+			<texture colordiffuse="40000000">panel.png</texture>
+		</control>
+		<control type="button" id="23">
+			<posx>0</posx>
+			<posy>649</posy>
+			<width>490</width>
+			<height>70</height>
+			<label>21458</label>
+			<font>font25</font>
+			<onright>19</onright>
+			<onleft>19</onleft>
+			<onup>17</onup>
+			<ondown>9001</ondown>
+		</control>
+		<control type="image">
+			<posx>510</posx>
+			<posy>649</posy>
+			<width>490</width>
+			<height>70</height>
+			<texture colordiffuse="40000000">panel.png</texture>
+		</control>
+		<control type="radiobutton" id="24">
+			<posx>510</posx>
+			<posy>649</posy>
+			<width>490</width>
+			<height>70</height>
+			<label>$LOCALIZE[467]: $LOCALIZE[21459]</label>
+			<font>font25</font>
 			<onright>18</onright>
 			<onleft>18</onleft>
 			<onup>17</onup>
diff --git a/addons/skin.estouchy/xml/SmartPlaylistRule.xml b/addons/skin.estouchy/xml/SmartPlaylistRule.xml
index 6a20427..1c7be79 100644
--- a/addons/skin.estouchy/xml/SmartPlaylistRule.xml
+++ b/addons/skin.estouchy/xml/SmartPlaylistRule.xml
@@ -55,7 +55,7 @@
 			<texture colordiffuse="40000000">panel.png</texture>
 		</control>
 		<control type="group" id="9001">
-			<control type="spincontrolex" id="15">
+			<control type="button" id="15">
 				<description>Rule Field</description>
 				<posx>0</posx>
 				<posy>100</posy>
@@ -85,7 +85,7 @@
 				<height>70</height>
 				<texture border="2">separator.png</texture>
 			</control>
-			<control type="spincontrolex" id="16">
+			<control type="button" id="16">
 				<description>Rule operator</description>
 				<posx>500</posx>
 				<posy>100</posy>
-- 
2.7.4


From 7fcf3a482c878c2210716d78a7b2f8d9435fcf60 Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Mon, 10 Oct 2016 14:43:08 +0200
Subject: [PATCH 100/175] Recording home screen widget: Fix info dialog (show
 recording info, not generic video info).

---
 xbmc/listproviders/DirectoryProvider.cpp       |  6 ++++++
 xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp | 15 +++++++++++++++
 xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.h   |  2 ++
 3 files changed, 23 insertions(+)

diff --git a/xbmc/listproviders/DirectoryProvider.cpp b/xbmc/listproviders/DirectoryProvider.cpp
index b0660f9..36a5698 100644
--- a/xbmc/listproviders/DirectoryProvider.cpp
+++ b/xbmc/listproviders/DirectoryProvider.cpp
@@ -34,6 +34,7 @@
 #include "music/MusicThumbLoader.h"
 #include "pictures/PictureThumbLoader.h"
 #include "pvr/PVRManager.h"
+#include "pvr/dialogs/GUIDialogPVRRecordingInfo.h"
 #include "settings/Settings.h"
 #include "threads/SingleLock.h"
 #include "utils/JobManager.h"
@@ -386,6 +387,11 @@ bool CDirectoryProvider::OnInfo(const CGUIListItemPtr& item)
 
   if (fileItem->HasAddonInfo())
     return CGUIDialogAddonInfo::ShowForItem(fileItem);
+  else if (fileItem->HasPVRRecordingInfoTag())
+  {
+    CGUIDialogPVRRecordingInfo::ShowFor(fileItem);
+    return true;
+  }
   else if (fileItem->HasVideoInfoTag())
   {
     CGUIDialogVideoInfo::ShowFor(*fileItem.get());
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp b/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp
index ddb07d6..dd7d612 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp
@@ -19,6 +19,7 @@
  */
 
 #include "FileItem.h"
+#include "guilib/GUIWindowManager.h"
 #include "pvr/windows/GUIWindowPVRBase.h"
 
 #include "GUIDialogPVRRecordingInfo.h"
@@ -90,3 +91,17 @@ CFileItemPtr CGUIDialogPVRRecordingInfo::GetCurrentListItem(int offset)
 {
   return m_recordItem;
 }
+
+void CGUIDialogPVRRecordingInfo::ShowFor(const CFileItemPtr& item)
+{
+  if (item && item->IsPVRRecording())
+  {
+    CGUIDialogPVRRecordingInfo* pDlgInfo = dynamic_cast<CGUIDialogPVRRecordingInfo*>(g_windowManager.GetWindow(WINDOW_DIALOG_PVR_RECORDING_INFO));
+    if (pDlgInfo)
+    {
+      pDlgInfo->SetRecording(item.get());
+      pDlgInfo->Open();
+    }
+  }
+}
+
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.h b/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.h
index 60a9130..84d2331 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.h
+++ b/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.h
@@ -35,6 +35,8 @@ namespace PVR
 
     void SetRecording(const CFileItem *item);
 
+    static void ShowFor(const CFileItemPtr& item);
+
   protected:
     bool OnClickButtonOK(CGUIMessage &message);
     bool OnClickButtonPlay(CGUIMessage &message);
-- 
2.7.4


From 8b952a12f04bb9b2ae0590d3cf1b600f089abf45 Mon Sep 17 00:00:00 2001
From: peak3d <pfau@peak3d.de>
Date: Mon, 10 Oct 2016 20:49:39 +0200
Subject: [PATCH 101/175] Dont load inputstream addons on startup if they are
 disabled

---
 xbmc/addons/InputStream.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/addons/InputStream.cpp b/xbmc/addons/InputStream.cpp
index 9d6aee2..4c07918 100644
--- a/xbmc/addons/InputStream.cpp
+++ b/xbmc/addons/InputStream.cpp
@@ -38,7 +38,8 @@ std::unique_ptr<CInputStream> CInputStream::FromExtension(AddonProps props, cons
   std::string name(ext->plugin->identifier);
   std::unique_ptr<CInputStream> istr(new CInputStream(props, name, listitemprops,
                                                       extensions, protocols));
-  istr->CheckConfig();
+  if (!CAddonMgr::GetInstance().IsAddonDisabled(props.id))
+    istr->CheckConfig();
   return istr;
 }
 
-- 
2.7.4


From 91356897a5770b2769383b9c558020fa85c0d7ae Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Mon, 10 Oct 2016 23:07:11 +0200
Subject: [PATCH 102/175] - fixed loading interlacemode_none from
 defaultsettings

---
 xbmc/settings/MediaSettings.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/settings/MediaSettings.cpp b/xbmc/settings/MediaSettings.cpp
index ff466c4..d441d83 100644
--- a/xbmc/settings/MediaSettings.cpp
+++ b/xbmc/settings/MediaSettings.cpp
@@ -86,7 +86,7 @@ bool CMediaSettings::Load(const TiXmlNode *settings)
   if (pElement != NULL)
   {
     int interlaceMethod;
-    bool interlaceMethodPresent = XMLUtils::GetInt(pElement, "interlacemethod", interlaceMethod, VS_INTERLACEMETHOD_AUTO, VS_INTERLACEMETHOD_MAX);
+    bool interlaceMethodPresent = XMLUtils::GetInt(pElement, "interlacemethod", interlaceMethod, VS_INTERLACEMETHOD_NONE, VS_INTERLACEMETHOD_MAX);
 
     m_defaultVideoSettings.m_InterlaceMethod = (EINTERLACEMETHOD)interlaceMethod;
     int scalingMethod;
-- 
2.7.4


From 0fde3a9bbfa8368762b322dec5fa4285e169a36d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 5 May 2015 17:27:39 +0100
Subject: [PATCH 103/175] build: Allow installed links to be overwritten

---
 tools/depends/target/Makefile     | 72 +++++++++++++++++++--------------------
 tools/depends/xbmc-addons.include | 36 ++++++++++----------
 2 files changed, 54 insertions(+), 54 deletions(-)

diff --git a/tools/depends/target/Makefile b/tools/depends/target/Makefile
index c35e484..9bca188 100644
--- a/tools/depends/target/Makefile
+++ b/tools/depends/target/Makefile
@@ -130,41 +130,41 @@ distclean::
 	for d in $(DEPENDS); do $(MAKE) -C $$d distclean; done
 
 linux-system-libs-egl:
-	[ -f $(PREFIX)/lib/pkgconfig/egl.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/egl.pc $(PREFIX)/lib/pkgconfig/egl.pc
-	[ -f $(PREFIX)/lib/pkgconfig/damageproto.pc ] || ln -s  /usr/share/pkgconfig/damageproto.pc $(PREFIX)/lib/pkgconfig/damageproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/fixesproto.pc ] || ln -s  /usr/share/pkgconfig/fixesproto.pc $(PREFIX)/lib/pkgconfig/fixesproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/x11-xcb.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/x11-xcb.pc $(PREFIX)/lib/pkgconfig/x11-xcb.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-dri2.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/xcb-dri2.pc $(PREFIX)/lib/pkgconfig/xcb-dri2.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-dri3.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/xcb-dri3.pc $(PREFIX)/lib/pkgconfig/xcb-dri3.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-glx.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/xcb-glx.pc $(PREFIX)/lib/pkgconfig/xcb-glx.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-xfixes.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/xcb-xfixes.pc $(PREFIX)/lib/pkgconfig/xcb-xfixes.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-present.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/xcb-present.pc $(PREFIX)/lib/pkgconfig/xcb-present.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-randr.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xcb-randr.pc $(PREFIX)/lib/pkgconfig/xcb-randr.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-render.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xcb-render.pc $(PREFIX)/lib/pkgconfig/xcb-render.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-shape.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/xcb-shape.pc $(PREFIX)/lib/pkgconfig/xcb-shape.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb-sync.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/xcb-sync.pc $(PREFIX)/lib/pkgconfig/xcb-sync.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xdamage.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xdamage.pc $(PREFIX)/lib/pkgconfig/xdamage.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xf86vidmodeproto.pc ] || ln -s /usr/share/pkgconfig/xf86vidmodeproto.pc $(PREFIX)/lib/pkgconfig/xf86vidmodeproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xfixes.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/xfixes.pc $(PREFIX)/lib/pkgconfig/xfixes.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xshmfence.pc ] || ln -s  /usr/lib/$(HOST)/pkgconfig/xshmfence.pc $(PREFIX)/lib/pkgconfig/xshmfence.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xxf86vm.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xxf86vm.pc $(PREFIX)/lib/pkgconfig/xxf86vm.pc
+	[ -f $(PREFIX)/lib/pkgconfig/egl.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/egl.pc $(PREFIX)/lib/pkgconfig/egl.pc
+	[ -f $(PREFIX)/lib/pkgconfig/damageproto.pc ] || ln -sf  /usr/share/pkgconfig/damageproto.pc $(PREFIX)/lib/pkgconfig/damageproto.pc
+	[ -f $(PREFIX)/lib/pkgconfig/fixesproto.pc ] || ln -sf  /usr/share/pkgconfig/fixesproto.pc $(PREFIX)/lib/pkgconfig/fixesproto.pc
+	[ -f $(PREFIX)/lib/pkgconfig/x11-xcb.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/x11-xcb.pc $(PREFIX)/lib/pkgconfig/x11-xcb.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb-dri2.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-dri2.pc $(PREFIX)/lib/pkgconfig/xcb-dri2.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb-dri3.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-dri3.pc $(PREFIX)/lib/pkgconfig/xcb-dri3.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb-glx.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-glx.pc $(PREFIX)/lib/pkgconfig/xcb-glx.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb-xfixes.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-xfixes.pc $(PREFIX)/lib/pkgconfig/xcb-xfixes.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb-present.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-present.pc $(PREFIX)/lib/pkgconfig/xcb-present.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb-randr.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xcb-randr.pc $(PREFIX)/lib/pkgconfig/xcb-randr.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb-render.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xcb-render.pc $(PREFIX)/lib/pkgconfig/xcb-render.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb-shape.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-shape.pc $(PREFIX)/lib/pkgconfig/xcb-shape.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb-sync.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xcb-sync.pc $(PREFIX)/lib/pkgconfig/xcb-sync.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xdamage.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xdamage.pc $(PREFIX)/lib/pkgconfig/xdamage.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xf86vidmodeproto.pc ] || ln -sf /usr/share/pkgconfig/xf86vidmodeproto.pc $(PREFIX)/lib/pkgconfig/xf86vidmodeproto.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xfixes.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xfixes.pc $(PREFIX)/lib/pkgconfig/xfixes.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xshmfence.pc ] || ln -sf  /usr/lib/$(HOST)/pkgconfig/xshmfence.pc $(PREFIX)/lib/pkgconfig/xshmfence.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xxf86vm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xxf86vm.pc $(PREFIX)/lib/pkgconfig/xxf86vm.pc
 
 linux-system-libs: linux-system-libs-egl
-	[ -f $(PREFIX)/lib/pkgconfig/x11.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/x11.pc $(PREFIX)/lib/pkgconfig/x11.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xproto.pc ] || ln -s /usr/share/pkgconfig/xproto.pc $(PREFIX)/lib/pkgconfig/xproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/kbproto.pc ] || ln -s /usr/share/pkgconfig/kbproto.pc $(PREFIX)/lib/pkgconfig/kbproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xcb.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xcb.pc $(PREFIX)/lib/pkgconfig/xcb.pc
-	[ -f $(PREFIX)/lib/pkgconfig/pthread-stubs.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/pthread-stubs.pc $(PREFIX)/lib/pkgconfig/pthread-stubs.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xau.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xau.pc $(PREFIX)/lib/pkgconfig/xau.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xdmcp.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xdmcp.pc $(PREFIX)/lib/pkgconfig/xdmcp.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xext.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xext.pc $(PREFIX)/lib/pkgconfig/xext.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xextproto.pc ] || ln -s /usr/share/pkgconfig/xextproto.pc $(PREFIX)/lib/pkgconfig/xextproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xrandr.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xrandr.pc $(PREFIX)/lib/pkgconfig/xrandr.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xrender.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xrender.pc $(PREFIX)/lib/pkgconfig/xrender.pc
-	[ -f $(PREFIX)/lib/pkgconfig/randrproto.pc ] || ln -s /usr/share/pkgconfig/randrproto.pc $(PREFIX)/lib/pkgconfig/randrproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/renderproto.pc ] || ln -s /usr/share/pkgconfig/renderproto.pc $(PREFIX)/lib/pkgconfig/renderproto.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xt.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xt.pc $(PREFIX)/lib/pkgconfig/xt.pc
-	[ -f $(PREFIX)/lib/pkgconfig/ice.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/ice.pc $(PREFIX)/lib/pkgconfig/ice.pc
-	[ -f $(PREFIX)/lib/pkgconfig/sm.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/sm.pc $(PREFIX)/lib/pkgconfig/sm.pc
-	[ -f $(PREFIX)/lib/pkgconfig/xmu.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/xmu.pc $(PREFIX)/lib/pkgconfig/xmu.pc
-	[ -f $(PREFIX)/lib/pkgconfig/libdrm.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/libdrm.pc $(PREFIX)/lib/pkgconfig/libdrm.pc
+	[ -f $(PREFIX)/lib/pkgconfig/x11.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/x11.pc $(PREFIX)/lib/pkgconfig/x11.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xproto.pc ] || ln -sf /usr/share/pkgconfig/xproto.pc $(PREFIX)/lib/pkgconfig/xproto.pc
+	[ -f $(PREFIX)/lib/pkgconfig/kbproto.pc ] || ln -sf /usr/share/pkgconfig/kbproto.pc $(PREFIX)/lib/pkgconfig/kbproto.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xcb.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xcb.pc $(PREFIX)/lib/pkgconfig/xcb.pc
+	[ -f $(PREFIX)/lib/pkgconfig/pthread-stubs.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/pthread-stubs.pc $(PREFIX)/lib/pkgconfig/pthread-stubs.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xau.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xau.pc $(PREFIX)/lib/pkgconfig/xau.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xdmcp.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xdmcp.pc $(PREFIX)/lib/pkgconfig/xdmcp.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xext.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xext.pc $(PREFIX)/lib/pkgconfig/xext.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xextproto.pc ] || ln -sf /usr/share/pkgconfig/xextproto.pc $(PREFIX)/lib/pkgconfig/xextproto.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xrandr.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xrandr.pc $(PREFIX)/lib/pkgconfig/xrandr.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xrender.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xrender.pc $(PREFIX)/lib/pkgconfig/xrender.pc
+	[ -f $(PREFIX)/lib/pkgconfig/randrproto.pc ] || ln -sf /usr/share/pkgconfig/randrproto.pc $(PREFIX)/lib/pkgconfig/randrproto.pc
+	[ -f $(PREFIX)/lib/pkgconfig/renderproto.pc ] || ln -sf /usr/share/pkgconfig/renderproto.pc $(PREFIX)/lib/pkgconfig/renderproto.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xt.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xt.pc $(PREFIX)/lib/pkgconfig/xt.pc
+	[ -f $(PREFIX)/lib/pkgconfig/ice.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/ice.pc $(PREFIX)/lib/pkgconfig/ice.pc
+	[ -f $(PREFIX)/lib/pkgconfig/sm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/sm.pc $(PREFIX)/lib/pkgconfig/sm.pc
+	[ -f $(PREFIX)/lib/pkgconfig/xmu.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/xmu.pc $(PREFIX)/lib/pkgconfig/xmu.pc
+	[ -f $(PREFIX)/lib/pkgconfig/libdrm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/libdrm.pc $(PREFIX)/lib/pkgconfig/libdrm.pc
diff --git a/tools/depends/xbmc-addons.include b/tools/depends/xbmc-addons.include
index 5eb06d2..499d41f 100644
--- a/tools/depends/xbmc-addons.include
+++ b/tools/depends/xbmc-addons.include
@@ -77,23 +77,23 @@ $(TOOLCHAIN_FILE): $(abs_top_srcdir)/target/Toolchain_binaddons.cmake
 
 linux-system-libs:
 	mkdir -p $(ADDON_DEPS_DIR)/lib/pkgconfig $(ADDON_DEPS_DIR)/include
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/x11.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/x*.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/
-	[ -f $(ADDON_DEPS_DIR)/lib/libX11.so ] || ln -s /usr/lib/$(HOST)/libX11.so* $(ADDON_DEPS_DIR)/lib/
-	[ -L $(ADDON_DEPS_DIR)/include/X11 ] || ln -s /usr/include/X11 $(ADDON_DEPS_DIR)/include/X11
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/xproto.pc ] || ln -s /usr/share/pkgconfig/x*.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/kbproto.pc ] || ln -s /usr/share/pkgconfig/kbproto.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/kbproto.pc
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/damageproto.pc ] || ln -s /usr/share/pkgconfig/damageproto.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/damageproto.pc
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/fixesproto.pc ] || ln -s /usr/share/pkgconfig/fixesproto.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/fixesproto.pc
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/pthread-stubs.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/pthread-stubs.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/pthread-stubs.pc
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/ice.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/ice.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/ice.pc
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/sm.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/sm.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/sm.pc
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/libdrm.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/libdrm.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/libdrm.pc
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/gl.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/gl.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/gl.pc
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/glu.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/glu.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/glu.pc
-	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/glew.pc ] || ln -s /usr/lib/$(HOST)/pkgconfig/glew.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/glew.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/x11.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/x*.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/
+	[ -f $(ADDON_DEPS_DIR)/lib/libX11.so ] || ln -sf /usr/lib/$(HOST)/libX11.so* $(ADDON_DEPS_DIR)/lib/
+	[ -L $(ADDON_DEPS_DIR)/include/X11 ] || ln -sf /usr/include/X11 $(ADDON_DEPS_DIR)/include/X11
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/xproto.pc ] || ln -sf /usr/share/pkgconfig/x*.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/kbproto.pc ] || ln -sf /usr/share/pkgconfig/kbproto.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/kbproto.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/damageproto.pc ] || ln -sf /usr/share/pkgconfig/damageproto.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/damageproto.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/fixesproto.pc ] || ln -sf /usr/share/pkgconfig/fixesproto.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/fixesproto.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/pthread-stubs.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/pthread-stubs.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/pthread-stubs.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/ice.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/ice.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/ice.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/sm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/sm.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/sm.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/libdrm.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/libdrm.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/libdrm.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/gl.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/gl.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/gl.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/glu.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/glu.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/glu.pc
+	[ -f $(ADDON_DEPS_DIR)/lib/pkgconfig/glew.pc ] || ln -sf /usr/lib/$(HOST)/pkgconfig/glew.pc $(ADDON_DEPS_DIR)/lib/pkgconfig/glew.pc
 	[ -f $(ADDON_DEPS_DIR)/lib/libGL.so ] || \
-          (ln -s /usr/lib/$(HOST)/mesa $(ADDON_DEPS_DIR)/lib/mesa && ln -s $(ADDON_DEPS_DIR)/lib/mesa/libGL.so $(ADDON_DEPS_DIR)/lib/libGL.so)
-	[ -f $(ADDON_DEPS_DIR)/lib/libGLEW.so ] || ln -s /usr/lib/$(HOST)/libGLEW.so* $(ADDON_DEPS_DIR)/lib/
-	[ -L $(ADDON_DEPS_DIR)/include/GL ] || ln -s /usr/include/GL $(ADDON_DEPS_DIR)/include/GL
-	[ -f $(ADDON_DEPS_DIR)/lib/libm.so ] || ln -s /usr/lib/$(HOST)/libm.so $(ADDON_DEPS_DIR)/lib/
+          (ln -sf /usr/lib/$(HOST)/mesa $(ADDON_DEPS_DIR)/lib/mesa && ln -sf $(ADDON_DEPS_DIR)/lib/mesa/libGL.so $(ADDON_DEPS_DIR)/lib/libGL.so)
+	[ -f $(ADDON_DEPS_DIR)/lib/libGLEW.so ] || ln -sf /usr/lib/$(HOST)/libGLEW.so* $(ADDON_DEPS_DIR)/lib/
+	[ -L $(ADDON_DEPS_DIR)/include/GL ] || ln -sf /usr/include/GL $(ADDON_DEPS_DIR)/include/GL
+	[ -f $(ADDON_DEPS_DIR)/lib/libm.so ] || ln -sf /usr/lib/$(HOST)/libm.so $(ADDON_DEPS_DIR)/lib/
 
-- 
2.7.4


From 5b981e60530366a4f919ced50d350d047ad35fc0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 18:19:32 +0100
Subject: [PATCH 104/175] When opening a stream don't try to update gui so
 often

---
 xbmc/dialogs/GUIDialogBusy.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/dialogs/GUIDialogBusy.cpp b/xbmc/dialogs/GUIDialogBusy.cpp
index 8ea5161..811019a 100644
--- a/xbmc/dialogs/GUIDialogBusy.cpp
+++ b/xbmc/dialogs/GUIDialogBusy.cpp
@@ -69,7 +69,11 @@ bool CGUIDialogBusy::WaitOnEvent(CEvent &event, unsigned int displaytime /* = 10
     {
       dialog->Open();
 
+#ifdef TARGET_RASPBERRY_PI
+      while(!event.WaitMSec(100))
+#else
       while(!event.WaitMSec(1))
+#endif
       {
         dialog->ProcessRenderLoop(false);
         if (allowCancel && dialog->IsCanceled())
-- 
2.7.4


From f7d03f13cb98c5ccc22c71c92ea55fc103c58060 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 8 Mar 2014 15:36:06 +0000
Subject: [PATCH 105/175] Hack: force it to be recognised as IEC958 capable to
 enable passthrough options

---
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index f52d54a..d23d4c8 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -1353,6 +1353,10 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
     if (snd_card_get_name(cardNr, &cardName) == 0)
       info.m_displayName = cardName;
 
+    // hack: hifiberry digi doesn't correctly report as iec958 device. Needs fixing in kernel driver
+    if (info.m_displayName == "snd_rpi_hifiberry_digi")
+      info.m_deviceType = AE_DEVTYPE_IEC958;
+
     if (info.m_deviceType == AE_DEVTYPE_HDMI && info.m_displayName.size() > 5 &&
         info.m_displayName.substr(info.m_displayName.size()-5) == " HDMI")
     {
-- 
2.7.4


From 586601262ebeacd6b3e1015379436f7b20022814 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 1 May 2014 16:28:39 +0100
Subject: [PATCH 106/175] Improved file buffering in CArchive

Even though memcpy is typically inlined by the compiler into byte/word loads
and stores (at least for release builds), the frequency with which 1, 2 and 4
byte loads/stores are encountered in cases where the size is *not*
determinable at compile time is still high enough that it's worth handling
these specially. On the ARM1176JZF-S in the Raspberry Pi, this improves the
total time to open a library (in the case where it's fetched from a CArchive)
by around 4%.

It should be noted that this code uses 16-bit and 32-bit word loads and
stores that are not necessarily aligned to their respective widths. It is
possible that there are some architectures out there which do not support
this, although all ARMs since ARMv6 have supported it (and ARMs earlier than
that are probably not powerful enough to be good targets for XBMC).
---
 xbmc/utils/Archive.h | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/xbmc/utils/Archive.h b/xbmc/utils/Archive.h
index 23cac27..89d31d4 100644
--- a/xbmc/utils/Archive.h
+++ b/xbmc/utils/Archive.h
@@ -155,9 +155,17 @@ protected:
      * than waiting until we attempt to put more data into an already full buffer */
     if (m_BufferRemain > size)
     {
+      switch (size)
+      {
+      case 1: *m_BufferPos++ = *ptr; m_BufferRemain--; break;
+      case 2: *(uint16_t *) m_BufferPos = *(const uint16_t *) ptr; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) m_BufferPos = *(const uint32_t *) ptr; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(m_BufferPos, ptr, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
 
@@ -170,9 +178,17 @@ protected:
     /* Note, refilling the buffer is deferred until we know we need to read more from it */
     if (m_BufferRemain >= size)
     {
+      switch (size)
+      {
+      case 1: *ptr = *m_BufferPos++; m_BufferRemain--; break;
+      case 2: *(uint16_t *) ptr = *(const uint16_t *) m_BufferPos; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) ptr = *(const uint32_t *) m_BufferPos; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(ptr, m_BufferPos, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
 
-- 
2.7.4


From 0ed859e6e34958538fd7cd62e7f35d95ae18a506 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 10 Aug 2014 16:45:16 +0100
Subject: [PATCH 107/175] filesystem: Make support of browsing into archives
 optional

The ability to browse, scan and play content in archives can cause problems on low powered/low memory devices.
It's quite common to see reports of a large rar file that causes xbmc to crash with an out-of-memory error when browsing or scanning.
It also can be slow as any archive in the directory is opened and extracted.

This causes issues for people who scan library with archives disabled, then subsequently enable it.
The library has the .rar files in which don't play without removing and re-adding.

We'll let people who don't use archives disable it manually
---
 addons/resource.language.en_gb/resources/strings.po |  9 +++++++++
 system/settings/rbp.xml                             | 11 +++++++++++
 xbmc/Util.cpp                                       |  4 ++--
 xbmc/filesystem/FileDirectoryFactory.cpp            |  4 ++++
 4 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 31ac537..0b2cd92 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -19324,6 +19324,15 @@ msgstr ""
 #: system/settings/rbp.xml
 msgctxt "#38010"
 msgid "GPU accelerated"
+
+#: system/settings/settings.xml
+msgctxt "#38040"
+msgid "Support browsing into archives"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38041"
+msgid "Allow viewing and playing files in archives (e.g. zip, rar)"
 msgstr ""
 
 #. Setting #38011 "Show All Items entry"
diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 62e9c8e..e8b0d3d 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -102,4 +102,15 @@
       </group>
     </category>
   </section>
+  <section id="library">
+    <category id="filelists">
+      <group id="1">
+        <setting id="filelists.browsearchives" type="boolean" label="38040" help="38041">
+          <level>1</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
+      </group>
+    </category>
+  </section>
 </settings>
diff --git a/xbmc/Util.cpp b/xbmc/Util.cpp
index c356794..da1508d 100644
--- a/xbmc/Util.cpp
+++ b/xbmc/Util.cpp
@@ -1899,7 +1899,7 @@ void CUtil::ScanPathsForAssociatedItems(const std::string& videoName,
     URIUtils::RemoveExtension(strCandidate);
     if (StringUtils::StartsWithNoCase(strCandidate, videoName))
     {
-      if (URIUtils::IsRAR(pItem->GetPath()) || URIUtils::IsZIP(pItem->GetPath()))
+      if (CSettings::GetInstance().GetBool("filelists.browsearchives") && (URIUtils::IsRAR(pItem->GetPath()) || URIUtils::IsZIP(pItem->GetPath())))
         CUtil::ScanArchiveForAssociatedItems(pItem->GetPath(), "", item_exts, associatedFiles);
       else
       {
@@ -1909,7 +1909,7 @@ void CUtil::ScanPathsForAssociatedItems(const std::string& videoName,
     }
     else
     {
-      if (URIUtils::IsRAR(pItem->GetPath()) || URIUtils::IsZIP(pItem->GetPath()))
+      if (CSettings::GetInstance().GetBool("filelists.browsearchives") && (URIUtils::IsRAR(pItem->GetPath()) || URIUtils::IsZIP(pItem->GetPath())))
         CUtil::ScanArchiveForAssociatedItems(pItem->GetPath(), videoName, item_exts, associatedFiles);
     }
   }
diff --git a/xbmc/filesystem/FileDirectoryFactory.cpp b/xbmc/filesystem/FileDirectoryFactory.cpp
index a0fd0a9..688b71a 100644
--- a/xbmc/filesystem/FileDirectoryFactory.cpp
+++ b/xbmc/filesystem/FileDirectoryFactory.cpp
@@ -40,6 +40,7 @@
 #include "playlists/PlayListFactory.h"
 #include "Directory.h"
 #include "File.h"
+#include "settings/Settings.h"
 #include "FileItem.h"
 #include "utils/StringUtils.h"
 #include "URL.h"
@@ -116,6 +117,8 @@ IFileDirectory* CFileDirectoryFactory::Create(const CURL& url, CFileItem* pItem,
     return NULL;
   }
 #endif
+  if (CSettings::GetInstance().GetBool("filelists.browsearchives"))
+  {
   if (url.IsFileType("zip"))
   {
     CURL zipURL = URIUtils::CreateArchivePath("zip", url);
@@ -189,6 +192,7 @@ IFileDirectory* CFileDirectoryFactory::Create(const CURL& url, CFileItem* pItem,
     }
     return NULL;
   }
+  }
   if (url.IsFileType("xbt"))
   {
     CURL xbtUrl = URIUtils::CreateArchivePath("xbt", url);
-- 
2.7.4


From 7c09b8b29e96cb400ab9ea43da241ff509c7d236 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 27 Oct 2014 13:06:57 +0000
Subject: [PATCH 108/175] Make cachemembuffersize default depend on memory size

---
 xbmc/linux/RBP.cpp                 | 10 ++++++++++
 xbmc/linux/RBP.h                   |  1 +
 xbmc/settings/AdvancedSettings.cpp | 12 +++++++++++-
 3 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index c417308..6b06c25 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -23,6 +23,7 @@
 
 #include <assert.h>
 #include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
 #include "utils/log.h"
 
 #include "cores/omxplayer/OMXImage.h"
@@ -58,6 +59,12 @@ CRBP::~CRBP()
   delete m_DllBcmHost;
 }
 
+void CRBP::InitializeSettings()
+{
+  if (m_initialized && g_advancedSettings.m_cacheMemSize == ~0U)
+    g_advancedSettings.m_cacheMemSize = m_arm_mem < 256 ? 1024 * 1024 * 2 : 1024 * 1024 * 20;
+}
+
 bool CRBP::Initialize()
 {
   CSingleLock lock(m_critSection);
@@ -97,6 +104,8 @@ bool CRBP::Initialize()
   if (!m_gui_resolution_limit)
     m_gui_resolution_limit = m_gpu_mem < 128 ? 720:1080;
 
+  InitializeSettings();
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;
@@ -109,6 +118,7 @@ void CRBP::LogFirmwareVerison()
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s", response);
   CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB MPG2:%d WVC1:%d", m_arm_mem, m_gpu_mem, m_codec_mpg2_enabled, m_codec_wvc1_enabled);
+  CLog::Log(LOGNOTICE, "cache.memorysize: %dMB",  g_advancedSettings.m_cacheMemSize >> 20);
   m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config int");
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Config:\n%s", response);
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index a35a509..fffa518 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -62,6 +62,7 @@ public:
   ~CRBP();
 
   bool Initialize();
+  void InitializeSettings();
   void LogFirmwareVerison();
   void Deinitialize();
   int GetArmMem() { return m_arm_mem; }
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 89f7919..6272960 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -50,6 +50,9 @@
 #if defined(TARGET_DARWIN_IOS)
 #include "platform/darwin/DarwinUtils.h"
 #endif
+#if defined(TARGET_RASPBERRY_PI)
+#include "linux/RBP.h"
+#endif
 
 using namespace ADDON;
 using namespace XFILE;
@@ -355,7 +358,12 @@ void CAdvancedSettings::Initialize()
   m_bPVRAutoScanIconsUserSet       = false;
   m_iPVRNumericChannelSwitchTimeout = 1000;
 
+#ifdef TARGET_RASPBERRY_PI
+  // want default to be memory dependent, but interface to gpu not available yet, so set in RBP.cpp
+  m_cacheMemSize = ~0;
+#else
   m_cacheMemSize = 1024 * 1024 * 20;
+#endif
   m_cacheBufferMode = CACHE_BUFFER_MODE_INTERNET; // Default (buffer all internet streams/filesystems)
   // the following setting determines the readRate of a player data
   // as multiply of the default data read rate
@@ -404,7 +412,9 @@ void CAdvancedSettings::Initialize()
   m_extraLogLevels = 0;
 
   m_userAgent = g_sysinfo.GetUserAgent();
-
+#ifdef TARGET_RASPBERRY_PI
+  g_RBP.InitializeSettings();
+#endif
   m_initialized = true;
 }
 
-- 
2.7.4


From 8624a2d337a553f42f1c7ac877f51aaad2f0b155 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 30 May 2014 14:58:43 +0100
Subject: [PATCH 109/175] Experiment: Report DESKTOP resolution in video
 settings

---
 xbmc/settings/DisplaySettings.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index c1cca7e..e03f3c8 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -704,6 +704,9 @@ void CDisplaySettings::SettingOptionsResolutionsFiller(const CSetting *setting,
     std::vector<RESOLUTION_WHR> resolutions = g_Windowing.ScreenResolutions(info.iScreen, info.fRefreshRate);
     for (std::vector<RESOLUTION_WHR>::const_iterator resolution = resolutions.begin(); resolution != resolutions.end(); ++resolution)
     {
+if (resolution->ResInfo_Index == RES_DESKTOP)
+      list.push_back(std::make_pair(StringUtils::Format("DESKTOP"), resolution->ResInfo_Index));
+else
       list.push_back(std::make_pair(
         StringUtils::Format("%dx%d%s", resolution->width, resolution->height,
                             ModeFlagsToString(resolution->flags, false).c_str()),
-- 
2.7.4


From be17d70a8da2da03a9d503c2c8d311a124dbbdb2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 24 Sep 2014 23:13:52 +0100
Subject: [PATCH 110/175] Add settings option to boost centre channel when
 downmixing

This allows a dB volume increase to be added to centre channel.
This can help improve dialgue in the presence of background music/effects.
It can go up to 30dB for testing purposes, but value of 6 is probably more reasonable.
It is recommended to ensure "Normalise levels on downmix" is enabled when boosting by large values to avoid clipping.

Should work with Pi Sink (dvdplayer/paplayer) and omxplayer
---
 addons/resource.language.en_gb/resources/strings.po       | 15 +++++++++++++++
 system/settings/settings.xml                              | 12 ++++++++++++
 .../Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp           |  7 +++++++
 .../AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp   |  6 ++++++
 xbmc/cores/omxplayer/OMXAudio.cpp                         |  6 ++++++
 5 files changed, 46 insertions(+)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 0b2cd92..0adf3b0 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -19522,6 +19522,21 @@ msgstr ""
 
 #empty strings from id 38047 to 38099
 
+#: system/settings/settings.xml
+msgctxt "#38007"
+msgid "Boost centre channel when downmixing"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38008"
+msgid "Increase this value to make the dialogue louder compared to background sounds when downmixing multichannel audio"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38009"
+msgid "%i dB"
+msgstr ""
+
 #. Description of section #14200 "Player""
 #: system/settings/settings.xml
 msgctxt "#38100"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 026a42e..bf5ce5a 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -2361,6 +2361,18 @@
           </dependencies>
           <control type="toggle" />
         </setting>
+        <setting id="audiooutput.boostcenter" type="integer" label="38007" help="38008">
+          <level>2</level>
+          <default>0</default>
+          <constraints>
+            <minimum>0</minimum>
+            <step>1</step>
+            <maximum>30</maximum>
+          </constraints>
+          <control type="spinner" format="string">
+            <formatlabel>38009</formatlabel>
+          </control>
+        </setting>
         <setting id="audiooutput.processquality" type="integer" label="13505" help="36169">
           <requirement>HAS_AE_QUALITY_LEVELS</requirement>
           <level>2</level>
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
index af5bf93..d7165de 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
@@ -20,6 +20,7 @@
 
 #include "cores/AudioEngine/Utils/AEUtil.h"
 #include "ActiveAEResampleFFMPEG.h"
+#include "settings/Settings.h"
 #include "utils/log.h"
 
 extern "C" {
@@ -104,6 +105,12 @@ bool CActiveAEResampleFFMPEG::Init(uint64_t dst_chan_layout, int dst_channels, i
   {
      av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
   }
+  int boost_center = CSettings::GetInstance().GetInt("audiooutput.boostcenter");
+  if (boost_center)
+  {
+    float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+    av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+  }
 
   if (remapLayout)
   {
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
index 7807149..698a6ae 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
@@ -164,6 +164,12 @@ bool CActiveAEResamplePi::Init(uint64_t dst_chan_layout, int dst_channels, int d
   {
     av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
   }
+  int boost_center = CSettings::GetInstance().GetInt("audiooutput.boostcenter");
+  if (boost_center)
+  {
+    float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+    av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+  }
 
   if (remapLayout)
   {
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index f16b822..993d4b3 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -633,6 +633,12 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
     {
        av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
     }
+    int boost_center = CSettings::GetInstance().GetInt("audiooutput.boostcenter");
+    if (boost_center)
+    {
+      float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+      av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+    }
 
     // stereo upmix
     if (upmix && m_src_channels == 2 && m_dst_channels > 2)
-- 
2.7.4


From c538416e5f9eef0dcaac1ea0883602f0fc57ff75 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 27 Oct 2014 15:23:51 +0000
Subject: [PATCH 111/175] Default extract thumbnails to false

It can take 80 seconds for a single file on a Pi. It can cause crashes with out-of-memory errors.
It genereates a lot of support issues. Best to default to disabled and let users enable it if they must
---
 system/settings/rbp.xml | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index e8b0d3d..289dc55 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -43,6 +43,12 @@
         <setting id="myvideos.extractchapterthumbs">
           <default>false</default>
         </setting>
+        <setting id="myvideos.extractflags">
+          <default>false</default>
+        </setting>
+        <setting id="myvideos.extractthumb">
+          <default>false</default>
+        </setting>
       </group>
     </category>
   </section>
-- 
2.7.4


From 0710694fa8f808f5b6f6cff8895655a6ad4a5e8a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 27 Nov 2014 16:31:56 +0000
Subject: [PATCH 112/175] Reduce priority of python threads

---
 xbmc/interfaces/generic/LanguageInvokerThread.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/xbmc/interfaces/generic/LanguageInvokerThread.cpp b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
index fcdd063..16f0c89 100644
--- a/xbmc/interfaces/generic/LanguageInvokerThread.cpp
+++ b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
@@ -50,6 +50,11 @@ bool CLanguageInvokerThread::execute(const std::string &script, const std::vecto
   m_args = arguments;
 
   Create();
+  #ifdef TARGET_RASPBERRY_PI
+  /* low prio */
+  SetPriority(GetPriority()-1);
+  #endif
+
   return true;
 }
 
-- 
2.7.4


From 5122442318637c2fa0f426faa6bf3b1f2e59dcc3 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 14 Dec 2013 16:55:05 +0000
Subject: [PATCH 113/175] logging: Add microsecond timer to log messages

---
 xbmc/utils/log.cpp | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/xbmc/utils/log.cpp b/xbmc/utils/log.cpp
index 3443f12..d330320 100644
--- a/xbmc/utils/log.cpp
+++ b/xbmc/utils/log.cpp
@@ -24,6 +24,7 @@
 #include "threads/Thread.h"
 #include "utils/StringUtils.h"
 #include "CompileInfo.h"
+#include "utils/TimeUtils.h"
 
 static const char* const levelNames[] =
 {"DEBUG", "INFO", "NOTICE", "WARNING", "ERROR", "SEVERE", "FATAL", "NONE"};
@@ -198,19 +199,29 @@ void CLog::PrintDebugString(const std::string& line)
 
 bool CLog::WriteLogString(int logLevel, const std::string& logString)
 {
+#if defined(TARGET_LINUX)
+  static const char* prefixFormat = "%02.2d:%02.2d:%02.2d %10.6f T:%" PRIu64" %7s: ";
+#else
   static const char* prefixFormat = "%02.2d:%02.2d:%02.2d T:%" PRIu64" %7s: ";
-
+#endif
   std::string strData(logString);
   /* fixup newline alignment, number of spaces should equal prefix length */
   StringUtils::Replace(strData, "\n", "\n                                            ");
 
   int hour, minute, second;
   s_globals.m_platform.GetCurrentLocalTime(hour, minute, second);
-  
+
+#if defined(TARGET_LINUX)
+  float Now = CurrentHostCounter() * 1e-9;
+#endif
+
   strData = StringUtils::Format(prefixFormat,
                                   hour,
                                   minute,
                                   second,
+#if defined(TARGET_LINUX)
+                                  Now,
+#endif
                                   (uint64_t)CThread::GetCurrentThreadId(),
                                   levelNames[logLevel]) + strData;
 
-- 
2.7.4


From 6dbed1bc24ede42c2415469e7ea0611672f216bc Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 29 Nov 2014 15:25:16 +0000
Subject: [PATCH 114/175] hack: wait for splash to complete before changing
 hdmi mode

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 52 +++++++++++++++++++++++++
 1 file changed, 52 insertions(+)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index ee29770..bbe501d 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -32,6 +32,9 @@
 #include "guilib/StereoscopicsManager.h"
 #include "rendering/RenderSystem.h"
 #include <cassert>
+#ifdef TARGET_POSIX
+#include "linux/XTimeUtils.h"
+#endif
 
 #ifndef __VIDEOCORE4__
 #define __VIDEOCORE4__
@@ -221,12 +224,61 @@ int CEGLNativeTypeRaspberryPI::AddUniqueResolution(RESOLUTION_INFO &res, std::ve
 }
 #endif
 
+#include <dirent.h>
+
+pid_t proc_find(const char* name)
+{
+    DIR* dir;
+    struct dirent* ent;
+    char buf[512];
+
+    long  pid;
+    char pname[100] = {0,};
+    char state;
+    FILE *fp=NULL;
+
+    if (!(dir = opendir("/proc"))) {
+        perror("can't open /proc");
+        return -1;
+    }
+
+    while((ent = readdir(dir)) != NULL) {
+        long lpid = atol(ent->d_name);
+        if(lpid < 0)
+            continue;
+        snprintf(buf, sizeof(buf), "/proc/%ld/stat", lpid);
+        fp = fopen(buf, "r");
+
+        if (fp) {
+            if ( (fscanf(fp, "%ld (%[^)]) %c", &pid, pname, &state)) != 3 ){
+                printf("fscanf failed \n");
+                fclose(fp);
+                closedir(dir);
+                return -1;
+            }
+            if (!strcmp(pname, name)) {
+                fclose(fp);
+                closedir(dir);
+                return (pid_t)lpid;
+            }
+            fclose(fp);
+        }
+    }
+
+    closedir(dir);
+    return -1;
+}
+
+
 bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 {
 #if defined(TARGET_RASPBERRY_PI)
   if(!m_DllBcmHost || !m_nativeWindow)
     return false;
 
+  while (proc_find("hello_video.bin") >= 0)
+    Sleep(100);
+
   DestroyDispmaxWindow();
 
   RENDER_STEREO_MODE stereo_mode = g_graphicsContext.GetStereoMode();
-- 
2.7.4


From 84495363fc0a09b0f065f98b8cacf24d374d6bea Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 11 Dec 2014 17:00:57 +0000
Subject: [PATCH 115/175] Fix for UI not showing both extractflags and
 extractthumb

---
 addons/resource.language.en_gb/resources/strings.po | 10 +++++++---
 system/settings/settings.xml                        |  4 ++--
 2 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 0adf3b0..a260fdf 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -12452,7 +12452,7 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#20433"
-msgid "Extract thumbnails and video information"
+msgid "Extract video information from files"
 msgstr ""
 
 #: xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
@@ -16960,7 +16960,7 @@ msgstr ""
 #. Description of setting with label #20433 "Extract thumbnails and video information"
 #: system/settings/settings.xml
 msgctxt "#36178"
-msgid "Extract thumbnails and metadata information such as codec and aspect ratio from videos."
+msgid "Extract metadata information such as codec and aspect ratio from videos."
 msgstr ""
 
 #. Description of setting with label #20419 "Replace file names with library titles"
@@ -16972,7 +16972,7 @@ msgstr ""
 #. Description of setting with label #20433 "Extract thumbnails and video information"
 #: system/settings/settings.xml
 msgctxt "#36180"
-msgid "Extract thumbnails and information, such as codecs and aspect ratio, to display in library mode."
+msgid "Extract thumbnails, to display in library Mode."
 msgstr ""
 
 #: system/settings/settings.xml
@@ -19669,3 +19669,7 @@ msgstr ""
 msgctxt "#39010"
 msgid "Select sort method"
 msgstr ""
+
+msgctxt "#38190"
+msgid "Extract thumbnails from video files"
+msgstr ""
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index bf5ce5a..a254e70 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -977,8 +977,8 @@
           <default>true</default>
           <control type="toggle" />
         </setting>
-        <setting id="myvideos.extractthumb" type="boolean" label="20433" help="36180">
-          <level>4</level>
+        <setting id="myvideos.extractthumb" type="boolean" label="38190" help="36180">
+          <level>1</level>
           <default>true</default>
           <control type="toggle" />
         </setting>
-- 
2.7.4


From 779f51d0aefca3a4a520f037bf6c87b4e1fc2be2 Mon Sep 17 00:00:00 2001
From: anaconda <anaconda@menakite.eu>
Date: Thu, 11 Sep 2014 21:30:43 +0200
Subject: [PATCH 116/175] Disable autoscrolling while on screensaver and while
 opening streams.

---
 xbmc/Application.cpp                | 10 ++++++++++
 xbmc/Application.h                  |  2 ++
 xbmc/guilib/GUIFadeLabelControl.cpp |  4 +++-
 xbmc/guilib/GUIFont.cpp             |  4 ++++
 xbmc/guilib/GUILabel.cpp            |  4 +++-
 xbmc/guilib/GUITextBox.cpp          |  3 ++-
 6 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 13ff95b..263e124 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -5250,3 +5250,13 @@ bool CApplication::NotifyActionListeners(const CAction &action) const
   
   return false;
 }
+
+bool CApplication::ScreenSaverDisablesAutoScrolling()
+{
+  bool onBlackDimScreenSaver = IsInScreenSaver() && m_screenSaver &&
+    (m_screenSaver->ID() == "screensaver.xbmc.builtin.black" ||
+     m_screenSaver->ID() == "screensaver.xbmc.builtin.dim");
+  bool openingStreams = m_pPlayer->IsPlaying() && g_windowManager.IsWindowActive(WINDOW_DIALOG_BUSY);
+
+  return onBlackDimScreenSaver || openingStreams;
+}
diff --git a/xbmc/Application.h b/xbmc/Application.h
index 8e1e616..c296900 100644
--- a/xbmc/Application.h
+++ b/xbmc/Application.h
@@ -407,6 +407,8 @@ public:
    */
   void UnregisterActionListener(IActionListener *listener);
 
+  bool ScreenSaverDisablesAutoScrolling();
+
   std::unique_ptr<CServiceManager> m_ServiceManager;
 
   /*! \Allow OSMC's sigterm handler to know when to do the business or not, otherwise we get code on EXIT and POWERDOWN/REBOOT paths
diff --git a/xbmc/guilib/GUIFadeLabelControl.cpp b/xbmc/guilib/GUIFadeLabelControl.cpp
index 01826a5..553a645 100644
--- a/xbmc/guilib/GUIFadeLabelControl.cpp
+++ b/xbmc/guilib/GUIFadeLabelControl.cpp
@@ -21,6 +21,8 @@
 #include "GUIFadeLabelControl.h"
 #include "utils/Random.h"
 
+#include "Application.h"
+
 CGUIFadeLabelControl::CGUIFadeLabelControl(int parentID, int controlID, float posX, float posY, float width, float height, const CLabelInfo& labelInfo, bool scrollOut, unsigned int timeToDelayAtEnd, bool resetOnLabelChange, bool randomized)
     : CGUIControl(parentID, controlID, posX, posY, width, height), m_label(labelInfo), m_scrollInfo(50, labelInfo.offsetX, labelInfo.scrollSpeed)
     , m_textLayout(labelInfo.font, false)
@@ -106,7 +108,7 @@ void CGUIFadeLabelControl::Process(unsigned int currentTime, CDirtyRegionList &d
     m_lastLabel = m_currentLabel;
   }
 
-  if (m_infoLabels.size() > 1 || !m_shortText)
+  if ((m_infoLabels.size() > 1 || !m_shortText) && !g_application.ScreenSaverDisablesAutoScrolling())
   { // have scrolling text
     bool moveToNextLabel = false;
     if (!m_scrollOut)
diff --git a/xbmc/guilib/GUIFont.cpp b/xbmc/guilib/GUIFont.cpp
index 7f11089..1192b74 100644
--- a/xbmc/guilib/GUIFont.cpp
+++ b/xbmc/guilib/GUIFont.cpp
@@ -22,6 +22,7 @@
 #include "GUIFontTTF.h"
 #include "GraphicContext.h"
 
+#include "Application.h"
 #include "threads/SingleLock.h"
 #include "utils/TimeUtils.h"
 #include "utils/MathUtils.h"
@@ -128,6 +129,9 @@ bool CGUIFont::UpdateScrollInfo(const vecText &text, CScrollInfo &scrollInfo)
   //   If the string is smaller than the viewport, then it may be plotted even
   //   more times than that.
   //
+  if (g_application.ScreenSaverDisablesAutoScrolling())
+    return false;
+
   if (scrollInfo.waitTime)
   {
     scrollInfo.waitTime--;
diff --git a/xbmc/guilib/GUILabel.cpp b/xbmc/guilib/GUILabel.cpp
index db20131..1c8c30d 100644
--- a/xbmc/guilib/GUILabel.cpp
+++ b/xbmc/guilib/GUILabel.cpp
@@ -21,6 +21,8 @@
 #include "GUILabel.h"
 #include <limits>
 
+#include "Application.h"
+
 CGUILabel::CGUILabel(float posX, float posY, float width, float height, const CLabelInfo& labelInfo, CGUILabel::OVER_FLOW overflow)
     : m_label(labelInfo)
     , m_textLayout(labelInfo.font, overflow == OVER_FLOW_WRAP, height)
@@ -104,7 +106,7 @@ void CGUILabel::Render()
   color_t color = GetColor();
   bool renderSolid = (m_color == COLOR_DISABLED);
   bool overFlows = (m_renderRect.Width() + 0.5f < m_textLayout.GetTextWidth()); // 0.5f to deal with floating point rounding issues
-  if (overFlows && m_scrolling && !renderSolid)
+  if (overFlows && m_scrolling && !renderSolid && !g_application.ScreenSaverDisablesAutoScrolling())
     m_textLayout.RenderScrolling(m_renderRect.x1, m_renderRect.y1, m_label.angle, color, m_label.shadowColor, 0, m_renderRect.Width(), m_scrollInfo);
   else
   {
diff --git a/xbmc/guilib/GUITextBox.cpp b/xbmc/guilib/GUITextBox.cpp
index d7bc1c5..ac76629 100644
--- a/xbmc/guilib/GUITextBox.cpp
+++ b/xbmc/guilib/GUITextBox.cpp
@@ -24,6 +24,7 @@
 #include "utils/MathUtils.h"
 #include "utils/StringUtils.h"
 #include "guiinfo/GUIInfoLabels.h"
+#include "Application.h"
 
 #include <algorithm>
 
@@ -133,7 +134,7 @@ void CGUITextBox::Process(unsigned int currentTime, CDirtyRegionList &dirtyregio
   // update our auto-scrolling as necessary
   if (m_autoScrollTime && m_lines.size() > m_itemsPerPage)
   {
-    if (!m_autoScrollCondition || m_autoScrollCondition->Get())
+    if ((!m_autoScrollCondition || m_autoScrollCondition->Get()) && !g_application.ScreenSaverDisablesAutoScrolling())
     {
       if (m_lastRenderTime)
         m_autoScrollDelayTime += currentTime - m_lastRenderTime;
-- 
2.7.4


From 109fcb1c36883d58fb71fdd2d911744e78985ce7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 13 Dec 2014 18:35:20 +0000
Subject: [PATCH 117/175] Avoid memcpy on every demuxer packet

Avoids an unnecessary memcpy on every demuxer packet which for
high bitrate videos can be significant.
---
 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 17 ++++++++++++-----
 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxPacket.h   |  3 +++
 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.cpp  |  7 ++++++-
 3 files changed, 21 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 926cc74..090af6f 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -895,7 +895,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
           {
             if(m_pkt.pkt.stream_index == (int)m_pFormatContext->programs[m_program]->stream_index[i])
             {
-              pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+              pPacket = CDVDDemuxUtils::AllocateDemuxPacket(0);
               break;
             }
           }
@@ -904,7 +904,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
             bReturnEmpty = true;
         }
         else
-          pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+          pPacket = CDVDDemuxUtils::AllocateDemuxPacket(0);
       }
       else
         bReturnEmpty = true;
@@ -934,9 +934,13 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
-        // maybe we can avoid a memcpy here by detecting where pkt.destruct is pointing too?
         if (m_pkt.pkt.data)
-          memcpy(pPacket->pData, m_pkt.pkt.data, pPacket->iSize);
+        {
+          pPacket->pData = m_pkt.pkt.data;
+          // so we can free AVPacket when DemuxPacket is freed
+          pPacket->pkt = new AVPacket(m_pkt.pkt);
+        }
+
 
         pPacket->pts = ConvertTimestamp(m_pkt.pkt.pts, stream->time_base.den, stream->time_base.num);
         pPacket->dts = ConvertTimestamp(m_pkt.pkt.dts, stream->time_base.den, stream->time_base.num);
@@ -990,7 +994,10 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
         pPacket->iStreamId = m_pkt.pkt.stream_index;
       }
       m_pkt.result = -1;
-      av_packet_unref(&m_pkt.pkt);
+      if (pPacket && pPacket->pkt)
+        memset(&m_pkt.pkt, 0, sizeof(AVPacket));
+      else
+        av_packet_unref(&m_pkt.pkt);
     }
   }
   } // end of lock scope
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxPacket.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxPacket.h
index 4f47118..2280578 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxPacket.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxPacket.h
@@ -25,6 +25,8 @@
 #define DMX_SPECIALID_STREAMINFO    -10
 #define DMX_SPECIALID_STREAMCHANGE  -11
 
+struct AVPacket;
+
 typedef struct DemuxPacket
 {
   unsigned char* pData;   // data
@@ -36,6 +38,7 @@ typedef struct DemuxPacket
   double pts; // pts in DVD_TIME_BASE
   double dts; // dts in DVD_TIME_BASE
   double duration; // duration in DVD_TIME_BASE if available
+  AVPacket *pkt; // to allow packet to be freed
 
   int dispTime;
 } DemuxPacket;
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.cpp
index df0f35b..b4b591a 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.cpp
@@ -39,7 +39,12 @@ void CDVDDemuxUtils::FreeDemuxPacket(DemuxPacket* pPacket)
   if (pPacket)
   {
     try {
-      if (pPacket->pData) _aligned_free(pPacket->pData);
+      if (pPacket->pkt)
+      {
+        av_free_packet(pPacket->pkt);
+        delete pPacket->pkt;
+      }
+      else if (pPacket->pData) _aligned_free(pPacket->pData);
       delete pPacket;
     }
     catch(...) {
-- 
2.7.4


From addab443acf013c1196898881bc2d7931269e82d Mon Sep 17 00:00:00 2001
From: anaconda <anaconda@menakite.eu>
Date: Wed, 25 Feb 2015 18:22:21 +0100
Subject: [PATCH 118/175] Load OSD dialogs on startup.

Fixes skipped frames the first time they're loaded in memory on less powered
devices, like a Raspberry Pi, when using DVDPlayer.
See http://forum.kodi.tv/showthread.php?tid=211501&pid=1938811#pid1938811
---
 xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp          | 1 +
 xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp             | 1 +
 xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp | 4 +++-
 xbmc/video/dialogs/GUIDialogSubtitles.cpp             | 2 +-
 xbmc/video/dialogs/GUIDialogVideoOSD.cpp              | 2 +-
 xbmc/video/dialogs/GUIDialogVideoSettings.cpp         | 4 +++-
 6 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
index 1beb856..ca7c90b 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
@@ -49,6 +49,7 @@ using namespace KODI::MESSAGING;
 CGUIDialogPVRChannelsOSD::CGUIDialogPVRChannelsOSD() :
     CGUIDialog(WINDOW_DIALOG_PVR_OSD_CHANNELS, "DialogPVRChannelsOSD.xml")
 {
+  m_loadType = LOAD_ON_GUI_INIT;
   m_vecItems = new CFileItemList;
 }
 
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
index 8b47243..be1f64d 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
@@ -36,6 +36,7 @@ using namespace PVR;
 CGUIDialogPVRGuideOSD::CGUIDialogPVRGuideOSD()
     : CGUIDialog(WINDOW_DIALOG_PVR_OSD_GUIDE, "DialogPVRGuideOSD.xml")
 {
+  m_loadType = LOAD_ON_GUI_INIT;
   m_vecItems = new CFileItemList;
 }
 
diff --git a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
index eb67552..f31572b 100644
--- a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
@@ -68,7 +68,9 @@ CGUIDialogAudioSubtitleSettings::CGUIDialogAudioSubtitleSettings()
   : CGUIDialogSettingsManualBase(WINDOW_DIALOG_AUDIO_OSD_SETTINGS, "DialogSettings.xml"),
     m_passthrough(false),
     m_dspEnabled(false)
-{ }
+{
+  m_loadType = LOAD_ON_GUI_INIT;
+}
 
 CGUIDialogAudioSubtitleSettings::~CGUIDialogAudioSubtitleSettings()
 { }
diff --git a/xbmc/video/dialogs/GUIDialogSubtitles.cpp b/xbmc/video/dialogs/GUIDialogSubtitles.cpp
index 398558e..4e8a9b1 100644
--- a/xbmc/video/dialogs/GUIDialogSubtitles.cpp
+++ b/xbmc/video/dialogs/GUIDialogSubtitles.cpp
@@ -103,7 +103,7 @@ CGUIDialogSubtitles::CGUIDialogSubtitles(void)
     , m_pausedOnRun(false)
     , m_updateSubsList(false)
 {
-  m_loadType = KEEP_IN_MEMORY;
+  m_loadType  = LOAD_ON_GUI_INIT;
 }
 
 CGUIDialogSubtitles::~CGUIDialogSubtitles(void)
diff --git a/xbmc/video/dialogs/GUIDialogVideoOSD.cpp b/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
index e498e1f..a6648d0 100644
--- a/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
@@ -30,7 +30,7 @@ using namespace PVR;
 CGUIDialogVideoOSD::CGUIDialogVideoOSD(void)
     : CGUIDialog(WINDOW_DIALOG_VIDEO_OSD, "VideoOSD.xml")
 {
-  m_loadType = KEEP_IN_MEMORY;
+  m_loadType = LOAD_ON_GUI_INIT;
 }
 
 CGUIDialogVideoOSD::~CGUIDialogVideoOSD(void)
diff --git a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
index 0534828..5a86dfc 100644
--- a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
@@ -66,7 +66,9 @@
 CGUIDialogVideoSettings::CGUIDialogVideoSettings()
     : CGUIDialogSettingsManualBase(WINDOW_DIALOG_VIDEO_OSD_SETTINGS, "DialogSettings.xml"),
       m_viewModeChanged(false)
-{ }
+{
+  m_loadType = LOAD_ON_GUI_INIT;
+}
 
 CGUIDialogVideoSettings::~CGUIDialogVideoSettings()
 { }
-- 
2.7.4


From e1b0506773ca64a7a59ac885f7487c8d29a1b028 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 14 Apr 2015 20:51:14 +0100
Subject: [PATCH 119/175] Also limit GUI updates when in non full-screen video
 mode

---
 xbmc/Application.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 263e124..0462746 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2789,7 +2789,7 @@ void CApplication::FrameMove(bool processEvents, bool processGUI)
 #if defined(TARGET_RASPBERRY_PI) || defined(HAS_IMXVPU)
     // This code reduces rendering fps of the GUI layer when playing videos in fullscreen mode
     // it makes only sense on architectures with multiple layers
-    if (g_graphicsContext.IsFullScreenVideo() && !m_pPlayer->IsPausedPlayback() && m_pPlayer->IsRenderingVideoLayer())
+    if (m_pPlayer->IsPlayingVideo() && !m_pPlayer->IsPausedPlayback() && m_pPlayer->IsRenderingVideoLayer())
       fps = CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_LIMITGUIUPDATE);
 #endif
 
@@ -2802,6 +2802,8 @@ void CApplication::FrameMove(bool processEvents, bool processGUI)
     {
       if (!m_skipGuiRender)
         g_windowManager.Process(CTimeUtils::GetFrameTime());
+      else if (!g_graphicsContext.IsFullScreenVideo())
+        g_windowManager.FrameMove();
     }
     g_windowManager.FrameMove();
   }
-- 
2.7.4


From 4c8b78aa40742e69e2b3429c43adda5aa5bf2f58 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 5 May 2015 23:58:06 +0100
Subject: [PATCH 120/175] Leave GUI contents available for screensaver

---
 xbmc/guilib/GUIWindowManager.cpp | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/xbmc/guilib/GUIWindowManager.cpp b/xbmc/guilib/GUIWindowManager.cpp
index f6f6441..9350bfd 100644
--- a/xbmc/guilib/GUIWindowManager.cpp
+++ b/xbmc/guilib/GUIWindowManager.cpp
@@ -794,7 +794,16 @@ void CGUIWindowManager::ActivateWindow_Internal(int iWindowID, const std::vector
   int currentWindow = GetActiveWindow();
   CGUIWindow *pWindow = GetWindow(currentWindow);
   if (pWindow)
-    CloseWindowSync(pWindow, iWindowID);
+  {
+    if (iWindowID == WINDOW_SCREENSAVER)
+    {
+      pWindow->Close(true, iWindowID);
+    }
+    else
+    {
+      CloseWindowSync(pWindow, iWindowID);
+    }
+  }
   g_infoManager.SetNextWindow(WINDOW_INVALID);
 
   // Add window to the history list (we must do this before we activate it,
-- 
2.7.4


From 743444d3064e31c9d188f9394a4e286f8458cd83 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 6 Jun 2015 18:43:57 +0100
Subject: [PATCH 121/175] ffmpeg: Automatic switch to software decode for GMC
 with more than one warp point

---
 ...Signal-unsupported-GMC-with-more-than-one.patch | 48 ++++++++++++++++++++++
 tools/depends/target/ffmpeg/Makefile               |  4 +-
 tools/depends/target/ffmpeg/autobuild.sh           |  2 +
 .../VideoPlayer/DVDCodecs/Video/MMALCodec.cpp      |  6 +++
 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h      |  2 +
 .../VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp     |  2 +-
 xbmc/cores/VideoPlayer/DVDStreamInfo.cpp           |  3 ++
 xbmc/cores/VideoPlayer/DVDStreamInfo.h             |  1 +
 xbmc/cores/omxplayer/OMXHelper.cpp                 |  8 +++-
 9 files changed, 73 insertions(+), 3 deletions(-)
 create mode 100644 tools/depends/target/ffmpeg/0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch

diff --git a/tools/depends/target/ffmpeg/0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch b/tools/depends/target/ffmpeg/0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
new file mode 100644
index 0000000..4cb8dd8
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
@@ -0,0 +1,48 @@
+From 84e9a1784bbd3182b68cefa5e5feae8da8b9e184 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Fri, 5 Jun 2015 22:48:33 +0100
+Subject: [PATCH] mpeg4video: Signal unsupported GMC with more than one warp
+ point
+
+---
+ libavcodec/avcodec.h       | 1 +
+ libavcodec/mpeg4videodec.c | 4 ++++
+ 2 files changed, 5 insertions(+)
+
+diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
+index 8c7c420..e63dc2d 100644
+--- a/libavcodec/avcodec.h
++++ b/libavcodec/avcodec.h
+@@ -2527,6 +2527,7 @@ typedef struct AVCodecContext {
+ #define FF_BUG_DC_CLIP          4096
+ #define FF_BUG_MS               8192 ///< Work around various bugs in Microsoft's broken decoders.
+ #define FF_BUG_TRUNCATED       16384
++#define FF_BUG_GMC_UNSUPPORTED 32768
+ 
+     /**
+      * strictly follow the standard (MPEG4, ...).
+diff --git a/libavcodec/mpeg4videodec.c b/libavcodec/mpeg4videodec.c
+index 9bf33dd..0b5d3b9 100644
+--- a/libavcodec/mpeg4videodec.c
++++ b/libavcodec/mpeg4videodec.c
+@@ -2179,6 +2179,9 @@ int ff_mpeg4_workaround_bugs(AVCodecContext *avctx)
+ 
+         if (ctx->divx_version >= 0)
+             s->workaround_bugs |= FF_BUG_HPEL_CHROMA;
++
++        if (ctx->num_sprite_warping_points > 1)
++            s->workaround_bugs |= FF_BUG_GMC_UNSUPPORTED;
+     }
+ 
+     if (s->workaround_bugs & FF_BUG_STD_QPEL) {
+@@ -2203,6 +2206,7 @@ int ff_mpeg4_workaround_bugs(AVCodecContext *avctx)
+                s->workaround_bugs, ctx->lavc_build, ctx->xvid_build,
+                ctx->divx_version, ctx->divx_build, s->divx_packed ? "p" : "");
+ 
++    avctx->workaround_bugs = s->workaround_bugs;
+     if (CONFIG_MPEG4_DECODER && ctx->xvid_build >= 0 &&
+         s->codec_id == AV_CODEC_ID_MPEG4 &&
+         avctx->idct_algo == FF_IDCT_AUTO) {
+-- 
+1.9.1
+
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index eaf9fc4..8dd14cd 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,6 +1,7 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
-DEPS= ../../Makefile.include FFMPEG-VERSION Makefile
+DEPS= ../../Makefile.include FFMPEG-VERSION Makefile \
+  0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -76,6 +77,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM); mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig \&\& pkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
+	cd $(PLATFORM); patch -p1 < ../0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)
diff --git a/tools/depends/target/ffmpeg/autobuild.sh b/tools/depends/target/ffmpeg/autobuild.sh
index 6bbebfc..e491c78 100755
--- a/tools/depends/target/ffmpeg/autobuild.sh
+++ b/tools/depends/target/ffmpeg/autobuild.sh
@@ -127,6 +127,8 @@ mkdir -p "ffmpeg-${VERSION}"
 cd "ffmpeg-${VERSION}" || exit 2
 tar --strip-components=1 -xf $MYDIR/${ARCHIVE}
 
+patch -p1 < ../0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
+
 CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
 ./configure --prefix=$FFMPEG_PREFIX \
 	--extra-version="kodi-${VERSION}" \
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
index 6adeaa6..aa20f18 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
@@ -47,6 +47,10 @@
 
 #include "linux/RBP.h"
 
+#ifndef FF_BUG_GMC_UNSUPPORTED
+#define FF_BUG_GMC_UNSUPPORTED 0
+#endif
+
 using namespace KODI::MESSAGING;
 
 #define CLASSNAME "CMMALVideoBuffer"
@@ -367,6 +371,8 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
   // we always qualify even if DVDFactoryCodec does this too.
   if (!CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_USEMMAL) || hints.software)
     return false;
+  if (hints.workaround_bugs & FF_BUG_GMC_UNSUPPORTED)
+    return false;
 
   m_processInfo.SetVideoDeintMethod("none");
 
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h
index 03fdf6e..e3a32ae 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h
@@ -157,6 +157,7 @@ public:
     type = STREAM_VIDEO;
     iOrientation = 0;
     iBitsPerPixel = 0;
+    workaround_bugs = 0;
   }
 
   virtual ~CDemuxStreamVideo() {}
@@ -171,6 +172,7 @@ public:
   int iOrientation; // orientation of the video in degress counter clockwise
   int iBitsPerPixel;
   std::string stereo_mode; // expected stereo mode
+  int workaround_bugs; // info for decoder
 };
 
 class CDemuxStreamAudio : public CDemuxStream
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 090af6f..b2f2268 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -1367,7 +1367,7 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
         if (!stereoMode.empty())
           st->stereo_mode = stereoMode;
 
-        
+        st->workaround_bugs = pStream->codec->workaround_bugs;
         if ( m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD) )
         {
           if (pStream->codec->codec_id == AV_CODEC_ID_PROBE)
diff --git a/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp b/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp
index e59c84c..28dbdd3 100644
--- a/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp
+++ b/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp
@@ -74,6 +74,7 @@ void CDVDStreamInfo::Clear()
   channellayout = 0;
 
   orientation = 0;
+  workaround_bugs = 0;
 }
 
 bool CDVDStreamInfo::Equal(const CDVDStreamInfo& right, bool withextradata)
@@ -175,6 +176,7 @@ void CDVDStreamInfo::Assign(const CDVDStreamInfo& right, bool withextradata)
   vfr = right.vfr;
   software = right.software;
   stereo_mode = right.stereo_mode;
+  workaround_bugs = right.workaround_bugs;
 
   // AUDIO
   channels      = right.channels;
@@ -233,6 +235,7 @@ void CDVDStreamInfo::Assign(const CDemuxStream& right, bool withextradata)
     orientation = stream->iOrientation;
     bitsperpixel = stream->iBitsPerPixel;
     stereo_mode = stream->stereo_mode;
+    workaround_bugs = stream->workaround_bugs;
   }
   else if(  right.type == STREAM_SUBTITLE )
   {
diff --git a/xbmc/cores/VideoPlayer/DVDStreamInfo.h b/xbmc/cores/VideoPlayer/DVDStreamInfo.h
index f141708..85e402b 100644
--- a/xbmc/cores/VideoPlayer/DVDStreamInfo.h
+++ b/xbmc/cores/VideoPlayer/DVDStreamInfo.h
@@ -73,6 +73,7 @@ public:
   int orientation; // orientation of the video in degress counter clockwise
   int bitsperpixel;
   std::string stereo_mode; // stereoscopic 3d mode
+  int workaround_bugs; // info for decoder
 
   // AUDIO
   int channels;
diff --git a/xbmc/cores/omxplayer/OMXHelper.cpp b/xbmc/cores/omxplayer/OMXHelper.cpp
index f135d42..d9b576b 100644
--- a/xbmc/cores/omxplayer/OMXHelper.cpp
+++ b/xbmc/cores/omxplayer/OMXHelper.cpp
@@ -30,6 +30,10 @@
 #include "cores/omxplayer/OMXPlayerVideo.h"
 #include "threads/SystemClock.h"
 
+#ifndef FF_BUG_GMC_UNSUPPORTED
+#define FF_BUG_GMC_UNSUPPORTED 0
+#endif
+
 #define PREDICATE_RETURN(lh, rh) \
   do { \
     if((lh) != (rh)) \
@@ -81,7 +85,9 @@ bool OMXPlayerUnsuitable(bool m_HasVideo, bool m_HasAudio, CDVDDemux* m_pDemuxer
       CDVDStreamInfo hint(*stream, true);
 
       bool supported = false;
-      if ((hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO) && g_RBP.GetCodecMpg2())
+      if (hint.workaround_bugs & FF_BUG_GMC_UNSUPPORTED)
+        ;
+      else if ((hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO) && g_RBP.GetCodecMpg2())
         supported = true;
       else if ((hint.codec == AV_CODEC_ID_VC1 || hint.codec == AV_CODEC_ID_WMV3) && g_RBP.GetCodecWvc1())
         supported = true;
-- 
2.7.4


From 9e6340c397d8c055c8b24abdaf00dd58c4513c6a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 10 Mar 2016 17:56:11 +0000
Subject: [PATCH 122/175] HW mouse pointer

Updating the mouse point provokes a complete screen update which can make it feel laggy
and results in high cpu.

Render the mouse with an overlay to avoid redrawing the normal gui.
---
 xbmc/guilib/GUIWindowManager.cpp  |   2 +
 xbmc/linux/RBP.cpp                | 135 ++++++++++++++++++++++++++++++++++++++
 xbmc/linux/RBP.h                  |   9 +++
 xbmc/windowing/WinEventsLinux.cpp | 125 +++++++++++++++++++++++++++++++++++
 xbmc/windowing/WinEventsLinux.h   |  11 ++++
 5 files changed, 282 insertions(+)

diff --git a/xbmc/guilib/GUIWindowManager.cpp b/xbmc/guilib/GUIWindowManager.cpp
index 9350bfd..cd45a59 100644
--- a/xbmc/guilib/GUIWindowManager.cpp
+++ b/xbmc/guilib/GUIWindowManager.cpp
@@ -199,7 +199,9 @@ void CGUIWindowManager::CreateWindows()
   Add(new CGUIWindowAddonBrowser);
   Add(new CGUIWindowScreensaverDim);
   Add(new CGUIWindowDebugInfo);
+#ifndef TARGET_RASPBERRY_PI
   Add(new CGUIWindowPointer);
+#endif
   Add(new CGUIDialogYesNo);
   Add(new CGUIDialogProgress);
   Add(new CGUIDialogExtendedProgressBar);
diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 6b06c25..92f20e5 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -28,6 +28,9 @@
 
 #include "cores/omxplayer/OMXImage.h"
 
+#include "guilib/GraphicContext.h"
+#include "settings/DisplaySettings.h"
+
 #include <sys/ioctl.h>
 #include "rpi/rpi_user_vcsm.h"
 #include "utils/TimeUtils.h"
@@ -46,6 +49,10 @@ CRBP::CRBP()
   m_DllBcmHost      = new DllBcmHost();
   m_OMX             = new COMXCore();
   m_display = DISPMANX_NO_HANDLE;
+  m_p = NULL;
+  m_x = 0;
+  m_y = 0;
+  m_enabled = 0;
   m_mb = mbox_open();
   vcsm_init();
   m_vsync_count = 0;
@@ -141,6 +148,7 @@ DISPMANX_DISPLAY_HANDLE_T CRBP::OpenDisplay(uint32_t device)
     m_display = vc_dispmanx_display_open( 0 /*screen*/ );
     int s = vc_dispmanx_vsync_callback(m_display, vsync_callback_static, (void *)this);
     assert(s == 0);
+    init_cursor();
   }
   return m_display;
 }
@@ -148,6 +156,7 @@ DISPMANX_DISPLAY_HANDLE_T CRBP::OpenDisplay(uint32_t device)
 void CRBP::CloseDisplay(DISPMANX_DISPLAY_HANDLE_T display)
 {
   CSingleLock lock(m_critSection);
+  uninit_cursor();
   assert(display == m_display);
   int s = vc_dispmanx_vsync_callback(m_display, NULL, NULL);
   assert(s == 0);
@@ -266,6 +275,9 @@ void CRBP::Deinitialize()
   m_omx_image_init  = false;
   m_initialized     = false;
   m_omx_initialized = false;
+  uninit_cursor();
+  delete m_p;
+  m_p = NULL;
   if (m_mb)
     mbox_close(m_mb);
   m_mb = 0;
@@ -338,6 +350,52 @@ unsigned mem_unlock(int file_desc, unsigned handle)
    return p[5];
 }
 
+unsigned int mailbox_set_cursor_info(int file_desc, int width, int height, int format, uint32_t buffer, int hotspotx, int hotspoty)
+{
+   int i=0;
+   unsigned int p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+   p[i++] = 0x00008010; // set cursor state
+   p[i++] = 24; // buffer size
+   p[i++] = 24; // data size
+
+   p[i++] = width;
+   p[i++] = height;
+   p[i++] = format;
+   p[i++] = buffer;           // ptr to VC memory buffer. Doesn't work in 64bit....
+   p[i++] = hotspotx;
+   p[i++] = hotspoty;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof(*p); // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+
+}
+
+unsigned int mailbox_set_cursor_position(int file_desc, int enabled, int x, int y)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+   p[i++] = 0x00008011; // set cursor state
+   p[i++] = 12; // buffer size
+   p[i++] = 12; // data size
+
+   p[i++] = enabled;
+   p[i++] = x;
+   p[i++] = y;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
 CGPUMEM::CGPUMEM(unsigned int numbytes, bool cached)
 {
   m_numbytes = numbytes;
@@ -369,4 +427,81 @@ void CGPUMEM::Flush()
   vcsm_clean_invalid( &iocache );
 }
 
+#define T 0
+#define W 0xffffffff
+#define B 0xff000000
+
+const static uint32_t default_cursor_pixels[] =
+{
+   B,B,B,B,B,B,B,B,B,T,T,T,T,T,T,T,
+   B,W,W,W,W,W,W,B,T,T,T,T,T,T,T,T,
+   B,W,W,W,W,W,B,T,T,T,T,T,T,T,T,T,
+   B,W,W,W,W,B,T,T,T,T,T,T,T,T,T,T,
+   B,W,W,W,W,W,B,T,T,T,T,T,T,T,T,T,
+   B,W,W,B,W,W,W,B,T,T,T,T,T,T,T,T,
+   B,W,B,T,B,W,W,W,B,T,T,T,T,T,T,T,
+   B,B,T,T,T,B,W,W,W,B,T,T,T,T,T,T,
+   B,T,T,T,T,T,B,W,W,W,B,T,T,T,T,T,
+   T,T,T,T,T,T,T,B,W,W,W,B,T,T,T,T,
+   T,T,T,T,T,T,T,T,B,W,W,W,B,T,T,T,
+   T,T,T,T,T,T,T,T,T,B,W,W,W,B,T,T,
+   T,T,T,T,T,T,T,T,T,T,B,W,W,W,B,T,
+   T,T,T,T,T,T,T,T,T,T,T,B,W,W,W,B,
+   T,T,T,T,T,T,T,T,T,T,T,T,B,W,B,T,
+   T,T,T,T,T,T,T,T,T,T,T,T,T,B,T,T
+};
+
+#undef T
+#undef W
+#undef B
+
+void CRBP::init_cursor()
+{
+  if (!m_mb)
+    return;
+  if (!m_p)
+    m_p = new CGPUMEM(64 * 64 * 4, false);
+  if (m_p && m_p->m_arm && m_p->m_vc)
+    set_cursor(default_cursor_pixels, 16, 16, 0, 0);
+}
+
+void CRBP::set_cursor(const void *pixels, int width, int height, int hotspot_x, int hotspot_y)
+{
+  if (!m_mb || !m_p || !m_p->m_arm || !m_p->m_vc || !pixels || width * height > 64 * 64)
+    return;
+  memcpy(m_p->m_arm, pixels, width * height * 4);
+  unsigned int s = mailbox_set_cursor_info(m_mb, width, height, 0, m_p->m_vc, hotspot_x, hotspot_y);
+  assert(s == 0);
+}
+
+void CRBP::update_cursor(int x, int y, bool enabled)
+{
+  if (!m_mb || !m_p || !m_p->m_arm || !m_p->m_vc)
+    return;
+
+  RESOLUTION res = g_graphicsContext.GetVideoResolution();
+  CRect gui(0, 0, CDisplaySettings::GetInstance().GetResolutionInfo(res).iWidth, CDisplaySettings::GetInstance().GetResolutionInfo(res).iHeight);
+  CRect display(0, 0, CDisplaySettings::GetInstance().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::GetInstance().GetResolutionInfo(res).iScreenHeight);
+
+  int x2 = x * display.Width()  / gui.Width();
+  int y2 = y * display.Height() / gui.Height();
+
+  if (g_graphicsContext.GetStereoMode() == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    y2 *= 2;
+  else if (g_graphicsContext.GetStereoMode() == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    x2 *= 2;
+  if (m_x != x2 || m_y != y2 || m_enabled != enabled)
+    mailbox_set_cursor_position(m_mb, enabled, x2, y2);
+  m_x = x2;
+  m_y = y2;
+  m_enabled = enabled;
+}
+
+void CRBP::uninit_cursor()
+{
+  if (!m_mb || !m_p || !m_p->m_arm || !m_p->m_vc)
+    return;
+  mailbox_set_cursor_position(m_mb, 0, 0, 0);
+}
+
 #endif
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index fffa518..90b04db 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -103,6 +103,15 @@ private:
   CCriticalSection m_critSection;
 
   int m_mb;
+  CGPUMEM *m_p;
+  int m_x;
+  int m_y;
+  bool m_enabled;
+  public:
+  void init_cursor();
+  void set_cursor(const void *pixels, int width, int height, int hotspot_x, int hotspot_y);
+  void update_cursor(int x, int y, bool enabled);
+  void uninit_cursor();
 };
 
 extern CRBP g_RBP;
diff --git a/xbmc/windowing/WinEventsLinux.cpp b/xbmc/windowing/WinEventsLinux.cpp
index a958a23..70f0e4d 100644
--- a/xbmc/windowing/WinEventsLinux.cpp
+++ b/xbmc/windowing/WinEventsLinux.cpp
@@ -30,11 +30,26 @@
 #include "utils/log.h"
 #include "powermanagement/PowerManager.h"
 
+#ifdef TARGET_RASPBERRY_PI
+#include "utils/TimeUtils.h"
+#include "guilib/Resolution.h"
+#include "addons/Skin.h"
+#include "utils/XMLUtils.h"
+#include "utils/StringUtils.h"
+#include "guilib/Texture.h"
+#include "linux/RBP.h"
+#include "input/InputManager.h"
+#endif
+
 bool CWinEventsLinux::m_initialized = false;
 CLinuxInputDevices CWinEventsLinux::m_devices;
 
 CWinEventsLinux::CWinEventsLinux()
 {
+#ifdef TARGET_RASPBERRY_PI
+  m_last_mouse_move_time = 0;
+  m_mouse_state = -1;
+#endif
 }
 
 void CWinEventsLinux::RefreshDevices()
@@ -48,6 +63,72 @@ bool CWinEventsLinux::IsRemoteLowBattery()
   return false;
 }
 
+#ifdef TARGET_RASPBERRY_PI
+bool CWinEventsLinux::LoadXML(const std::string strFileName)
+{
+  RESOLUTION_INFO m_coordsRes; // resolution that the window coordinates are in.
+  // Find appropriate skin folder + resolution to load from
+  std::string strFileNameLower = strFileName;
+  StringUtils::ToLower(strFileNameLower);
+  std::string strLowerPath = g_SkinInfo->GetSkinPath(strFileNameLower, &m_coordsRes);
+  std::string strPath = g_SkinInfo->GetSkinPath(strFileName, &m_coordsRes);
+
+  TiXmlElement* pRootElement = NULL;
+  CXBMCTinyXML xmlDoc;
+  std::string strPathLower = strPath;
+  StringUtils::ToLower(strPathLower);
+  if (!xmlDoc.LoadFile(strPath) && !xmlDoc.LoadFile(strPathLower) && !xmlDoc.LoadFile(strLowerPath))
+  {
+    CLog::Log(LOGERROR, "unable to load:%s, Line %d\n%s", strPath.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+    return false;
+  }
+  pRootElement = (TiXmlElement*)xmlDoc.RootElement()->Clone();
+
+  if (!pRootElement)
+    return false;
+
+  if (strcmpi(pRootElement->Value(), "window"))
+  {
+    CLog::Log(LOGERROR, "file : XML file doesnt contain <window>");
+    return false;
+  }
+
+  TiXmlElement *pChild = pRootElement->FirstChildElement();
+  while (pChild)
+  {
+    if (strcmpi(pChild->Value(), "controls") == 0)
+    {
+      TiXmlElement *pControl = pChild->FirstChildElement();
+      while (pControl)
+      {
+        if (strcmpi(pControl->Value(), "control") == 0)
+        {
+          std::string strStringValue;
+          if (XMLUtils::GetString(pControl, "texture", strStringValue))
+          {
+            const char* idAttr = pControl->Attribute("id");
+            int index = idAttr ? atoi(idAttr)-1 : -1;
+            if (index >= 0 && index < (int)(sizeof m_cursors/sizeof *m_cursors))
+            {
+              if (m_cursors[index].m_filename.size())
+                g_TextureManager.ReleaseTexture(m_cursors[index].m_filename, true);
+              m_cursors[index].m_filename.clear();
+              m_cursors[index].m_texture = g_TextureManager.Load(strStringValue);
+              if (m_cursors[index].m_texture.size())
+                m_cursors[index].m_filename = strStringValue;
+            }
+          }
+        }
+        pControl = pControl->NextSiblingElement();
+      }
+    }
+    pChild = pChild->NextSiblingElement();
+  }
+  delete pRootElement;
+  return true;
+}
+#endif
+
 bool CWinEventsLinux::MessagePump()
 {
   if (!m_initialized)
@@ -55,13 +136,50 @@ bool CWinEventsLinux::MessagePump()
     m_devices.InitAvailable();
     m_checkHotplug = std::unique_ptr<CLinuxInputDevicesCheckHotplugged>(new CLinuxInputDevicesCheckHotplugged(m_devices));
     m_initialized = true;
+#ifdef TARGET_RASPBERRY_PI
+    LoadXML("Pointer.xml");
+#endif
   }
 
   bool ret = false;
   XBMC_Event event = {0};
+#ifdef TARGET_RASPBERRY_PI
+  bool active = CInputManager::GetInstance().IsMouseActive();
+  int64_t Now = CurrentHostCounter();
+  if (!active)
+  {
+    if (m_mouse_state != -1)
+    {
+      g_RBP.update_cursor(0, 0, 0);
+      m_mouse_state = -1;
+    }
+  }
+  else
+  {
+    int state = CInputManager::GetInstance().GetMouseState() - 1;
+    if (m_mouse_state != state)
+    {
+      if (state >= 0 && state < (int)(sizeof m_cursors/sizeof *m_cursors) && !m_cursors[state].m_texture.m_textures.empty())
+      {
+        CBaseTexture *t = (m_cursors[state].m_texture.m_textures)[0];
+        if (t)
+          g_RBP.set_cursor((const void *)t->GetPixels(), t->GetPitch()>>2, t->GetRows(), 0, 0);
+      }
+      m_mouse_state = state;
+    }
+  }
+#endif
   while (1)
   {
     event = m_devices.ReadEvent();
+#ifdef TARGET_RASPBERRY_PI
+    if (active && (event.type == XBMC_MOUSEMOTION || event.type == XBMC_MOUSEBUTTONDOWN || event.type == XBMC_MOUSEBUTTONUP))
+    {
+      if (event.type == XBMC_MOUSEMOTION)
+        g_RBP.update_cursor(event.motion.x, event.motion.y, 1);
+      m_last_mouse_move_time = Now;
+    }
+#endif
     if (event.type != XBMC_NOEVENT)
     {
       ret |= g_application.OnEvent(event);
@@ -72,6 +190,13 @@ bool CWinEventsLinux::MessagePump()
     }
   }
 
+#ifdef TARGET_RASPBERRY_PI
+  if (active && Now - m_last_mouse_move_time > 5 * 1000000000LL)
+  {
+    g_RBP.update_cursor(0, 0, 0);
+    m_mouse_state = -1;
+  }
+#endif
   return ret;
 }
 
diff --git a/xbmc/windowing/WinEventsLinux.h b/xbmc/windowing/WinEventsLinux.h
index 1b1d2f2..c82ba84 100644
--- a/xbmc/windowing/WinEventsLinux.h
+++ b/xbmc/windowing/WinEventsLinux.h
@@ -25,6 +25,7 @@
 #include <memory>
 #include "windowing/WinEvents.h"
 #include "input/linux/LinuxInputDevices.h"
+#include "guilib/TextureManager.h"
 
 class CWinEventsLinux : public IWinEvents
 {
@@ -45,6 +46,16 @@ private:
   static bool m_initialized;
   static CLinuxInputDevices m_devices;
   std::unique_ptr<CLinuxInputDevicesCheckHotplugged> m_checkHotplug;
+#ifdef TARGET_RASPBERRY_PI
+  bool LoadXML(const std::string strFileName);
+  int64_t m_last_mouse_move_time;
+  struct
+  {
+    std::string m_filename;
+    CTextureArray m_texture;
+  } m_cursors[4];
+  int m_mouse_state;
+#endif
 };
 
 #endif
-- 
2.7.4


From e3397d133f4b357504f8958517acf1f75fdc3fbf Mon Sep 17 00:00:00 2001
From: Claudio-Sjo <Claudio.Porfiri@gmail.com>
Date: Mon, 16 Feb 2015 14:51:26 +0100
Subject: [PATCH 123/175] - allow reads < CDIO_CD_FRAMESIZE_RAW by using a
 buffer - fixes #15794

---
 xbmc/filesystem/CDDAFile.cpp | 120 ++++++++++++++++++++++++++++++++-----------
 xbmc/filesystem/CDDAFile.h   |   3 ++
 2 files changed, 92 insertions(+), 31 deletions(-)

diff --git a/xbmc/filesystem/CDDAFile.cpp b/xbmc/filesystem/CDDAFile.cpp
index 722e626..b0f53e5 100644
--- a/xbmc/filesystem/CDDAFile.cpp
+++ b/xbmc/filesystem/CDDAFile.cpp
@@ -42,10 +42,14 @@ CFileCDDA::CFileCDDA(void)
   m_lsnEnd = CDIO_INVALID_LSN;
   m_cdio = CLibcdio::GetInstance();
   m_iSectorCount = 52;
+  m_TrackBuf = (uint8_t *) malloc(CDIO_CD_FRAMESIZE_RAW);
+  p_TrackBuf = 0;
+  f_TrackBuf = 0;
 }
 
 CFileCDDA::~CFileCDDA(void)
 {
+  free(m_TrackBuf);
   Close();
 }
 
@@ -53,6 +57,9 @@ bool CFileCDDA::Open(const CURL& url)
 {
   std::string strURL = url.GetWithoutFilename();
 
+  // Flag TrackBuffer = FALSE, TrackBuffer is empty
+  f_TrackBuf = 0;
+
   if (!g_mediaManager.IsDiscInDrive(strURL) || !IsValidFile(url))
     return false;
 
@@ -117,50 +124,98 @@ int CFileCDDA::Stat(const CURL& url, struct __stat64* buffer)
 
 ssize_t CFileCDDA::Read(void* lpBuf, size_t uiBufSize)
 {
-  if (!m_pCdIo || !g_mediaManager.IsDiscInDrive())
-    return -1;
 
-  if (uiBufSize > SSIZE_MAX)
-    uiBufSize = SSIZE_MAX;
+  ssize_t returnValue;
+  int iSectorCount;
+  void *destBuf;
 
-  // limit number of sectors that fits in buffer by m_iSectorCount
-  int iSectorCount = std::min((int)uiBufSize / CDIO_CD_FRAMESIZE_RAW, m_iSectorCount);
 
-  if (iSectorCount <= 0)
+  if (!m_pCdIo || !g_mediaManager.IsDiscInDrive())
+  {
+    CLog::Log(LOGERROR, "file cdda: Aborted because no disc in drive or no m_pCdIo");
     return -1;
+  }
 
-  // Are there enough sectors left to read
-  if (m_lsnCurrent + iSectorCount > m_lsnEnd)
-    iSectorCount = m_lsnEnd - m_lsnCurrent;
+  uiBufSize = std::min( uiBufSize, (size_t)SSIZE_MAX );
 
-  // The loop tries to solve read error problem by lowering number of sectors to read (iSectorCount).
-  // When problem is solved the proper number of sectors is stored in m_iSectorCount
-  int big_iSectorCount = iSectorCount;
-  while (iSectorCount > 0)
+  // If we have data in the TrackBuffer, they must be used first
+  if (f_TrackBuf)
   {
-    int iret = m_cdio->cdio_read_audio_sectors(m_pCdIo, lpBuf, m_lsnCurrent, iSectorCount);
+    // Get at most the remaining data in m_TrackBuf
+    uiBufSize = std::min(uiBufSize, CDIO_CD_FRAMESIZE_RAW - p_TrackBuf);
+    memcpy(lpBuf, m_TrackBuf + p_TrackBuf, uiBufSize);
+    // Update the data offset
+    p_TrackBuf += uiBufSize;
+    // Is m_TrackBuf empty?
+    f_TrackBuf = (CDIO_CD_FRAMESIZE_RAW == p_TrackBuf);
+    // All done, return read bytes
+    return uiBufSize;
+  }
+
+  // No data left in buffer
+
+  // Is this a short read?
+  if (uiBufSize < CDIO_CD_FRAMESIZE_RAW)
+  {
+    // short request, buffer one full sector
+    iSectorCount = 1;
+    destBuf = m_TrackBuf;
+  }
+  else // normal request
+  {
+    // limit number of sectors that fits in buffer by m_iSectorCount
+    iSectorCount = std::min((int)uiBufSize / CDIO_CD_FRAMESIZE_RAW, m_iSectorCount);
+    destBuf = lpBuf;
+  }
 
+  // Are there enough sectors left to read?
+  iSectorCount = std::min(iSectorCount, m_lsnEnd - m_lsnCurrent);
+
+  // Have we reached EOF?
+  if (iSectorCount == 0)
+  {
+    CLog::Log(LOGNOTICE, "file cdda: Read EoF");
+    return 0; // Success, but nothing read
+  } // Reached EoF
+
+  // At leat one sector to read
+  int retries;
+  int iret;
+  // Try reading a decresing number of sectors, then 3 times with 1 sector
+  for (retries = 3; retries > 0; iSectorCount>1 ? iSectorCount-- : retries--)
+  {
+    iret = m_cdio->cdio_read_audio_sectors(m_pCdIo, destBuf, m_lsnCurrent, iSectorCount);
     if (iret == DRIVER_OP_SUCCESS)
+      break; // Get out from the loop
+    else
     {
-      // If lower iSectorCount solved the problem limit it's value
-      if (iSectorCount < big_iSectorCount)
-      {
-        m_iSectorCount = iSectorCount;
-      }
-      break;
-    }
-
-    // iSectorCount is low so it cannot solve read problem
-    if (iSectorCount <= 10)
-    {
-      CLog::Log(LOGERROR, "file cdda: Reading %d sectors of audio data starting at lsn %d failed with error code %i", iSectorCount, m_lsnCurrent, iret);
-      return -1;
-    }
-
-    iSectorCount = 10;
+      CLog::Log(LOGERROR, "file cdda: Read cdio error when reading track ");
+    } // Errors when reading file
   }
+  // retries == 0 only if failed reading at least one sector
+  if (retries == 0)
+  {
+    CLog::Log(LOGERROR, "file cdda: Reading %d sectors of audio data starting at lsn %d failed with error code %i", iSectorCount, m_lsnCurrent, iret);
+    return -1;
+  }
+
+  // Update position in file
   m_lsnCurrent += iSectorCount;
 
+  // Was it a short request?
+  if (uiBufSize < CDIO_CD_FRAMESIZE_RAW)
+  {
+    // We copy the amount if requested data into the destination buffer
+    memcpy(lpBuf, m_TrackBuf, uiBufSize);
+    // and keep track of the first available data
+    p_TrackBuf = uiBufSize;
+    // Finally, we set the buffer flag as TRUE
+    f_TrackBuf = true;
+    // We will return uiBufSize
+    return uiBufSize;
+  }
+
+  // Otherwise, just return the size of read data
   return iSectorCount*CDIO_CD_FRAMESIZE_RAW;
 }
 
@@ -194,6 +249,9 @@ int64_t CFileCDDA::Seek(int64_t iFilePosition, int iWhence /*=SEEK_SET*/)
 
 void CFileCDDA::Close()
 {
+  // Flag TrackBuffer = FALSE, TrackBuffer is empty
+  f_TrackBuf = 0;
+
   if (m_pCdIo)
   {
     m_cdio->cdio_destroy(m_pCdIo);
diff --git a/xbmc/filesystem/CDDAFile.h b/xbmc/filesystem/CDDAFile.h
index 0427af4..e992362 100644
--- a/xbmc/filesystem/CDDAFile.h
+++ b/xbmc/filesystem/CDDAFile.h
@@ -50,6 +50,9 @@ protected:
 
 protected:
   CdIo_t* m_pCdIo;
+  uint8_t *m_TrackBuf;
+  size_t   p_TrackBuf;
+  int      f_TrackBuf;
   lsn_t m_lsnStart;  // Start of m_iTrack in logical sector number
   lsn_t m_lsnCurrent; // Position inside the track in logical sector number
   lsn_t m_lsnEnd;   // End of m_iTrack in logical sector number
-- 
2.7.4


From b89c84b6c75a5a086b7287d556701630b8d989f2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 24 Jun 2016 19:38:13 +0100
Subject: [PATCH 124/175] codecoverlay: Include codec name in overlay

---
 xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp | 4 ++++
 xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp | 5 ++++-
 xbmc/cores/omxplayer/OMXPlayerAudio.cpp     | 4 ++++
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp     | 8 +++++---
 xbmc/cores/omxplayer/OMXPlayerVideo.h       | 1 -
 5 files changed, 17 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
index f822935..9db3a9c 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
@@ -210,6 +210,10 @@ void CVideoPlayerAudio::UpdatePlayerInfo()
   std::ostringstream s;
   s << "aq:"     << std::setw(2) << std::min(99,m_messageQueue.GetLevel()) << "%";
   s << ", Kb/s:" << std::fixed << std::setprecision(2) << (double)GetAudioBitrate() / 1024.0;
+  s << ", ac:"   << m_processInfo.GetAudioDecoderName().c_str();
+  if (!m_info.passthrough)
+    s << ", chan:" << m_processInfo.GetAudioChannels().c_str();
+  s << ", " << m_streaminfo.samplerate/1000 << " kHz";
 
   //print the inverse of the resample ratio, since that makes more sense
   //if the resample ratio is 0.5, then we're playing twice as fast
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
index 3c15bf1..9ff13f6 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
@@ -917,10 +917,13 @@ int CVideoPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
 
 std::string CVideoPlayerVideo::GetPlayerInfo()
 {
+  int width, height;
+  m_processInfo.GetVideoDimensions(width, height);
   std::ostringstream s;
   s << "vq:"   << std::setw(2) << std::min(99,GetLevel()) << "%";
   s << ", Mb/s:" << std::fixed << std::setprecision(2) << (double)GetVideoBitrate() / (1024.0*1024.0);
-  s << ", fr:"     << std::fixed << std::setprecision(3) << m_fFrameRate;
+  s << ", dc:"   << m_processInfo.GetVideoDecoderName().c_str();
+  s << ", " << width << "x" << height << "[" << std::setprecision(2) << m_processInfo.GetVideoDAR() << "]@" << std::fixed << std::setprecision(3) << m_processInfo.GetVideoFps() << ", deint:" << m_processInfo.GetVideoDeintMethod();
   s << ", drop:" << m_iDroppedFrames;
   s << ", skip:" << m_renderManager.GetSkippedFrames();
 
diff --git a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
index 1e5d2b9..d43350f 100644
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
@@ -659,6 +659,10 @@ std::string OMXPlayerAudio::GetPlayerInfo()
   std::ostringstream s;
   s << "aq:"     << std::setw(2) << std::min(99,m_messageQueue.GetLevel() + MathUtils::round_int(100.0/8.0*GetCacheTime())) << "%";
   s << ", Kb/s:" << std::fixed << std::setprecision(2) << (double)GetAudioBitrate() / 1024.0;
+  s << ", ac:"   << m_processInfo.GetAudioDecoderName().c_str();
+  if (!m_passthrough)
+    s << ", chan:" << m_processInfo.GetAudioChannels().c_str();
+  s << ", " << m_processInfo.GetAudioSampleRate()/1000 << " kHz";
 
   return s.str();
 }
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index cdf67ff..f54f53a 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -593,12 +593,14 @@ void OMXPlayerVideo::SetSpeed(int speed)
 
 std::string OMXPlayerVideo::GetPlayerInfo()
 {
+  int width, height;
+  m_processInfo.GetVideoDimensions(width, height);
   double match = 0.0f, phase = 0.0f, pll = 0.0f;
   std::ostringstream s;
-  s << "fr:"     << std::fixed << std::setprecision(3) << m_fFrameRate;
-  s << ", vq:"   << std::setw(2) << std::min(99,GetLevel()) << "%";
-  s << ", dc:"   << m_codecname;
+  s << "vq:"   << std::setw(2) << std::min(99,GetLevel()) << "%";
   s << ", Mb/s:" << std::fixed << std::setprecision(2) << (double)GetVideoBitrate() / (1024.0*1024.0);
+  s << ", dc:"   << m_processInfo.GetVideoDecoderName().c_str();
+  s << ", " << width << "x" << height << "[" << std::setprecision(2) << m_processInfo.GetVideoDAR() << "]@" << std::fixed << std::setprecision(3) << m_processInfo.GetVideoFps() << ", deint:" << m_processInfo.GetVideoDeintMethod();
   if (m_omxVideo.GetPlayerInfo(match, phase, pll))
   {
      s << ", match:" << std::fixed << std::setprecision(2) << match;
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.h b/xbmc/cores/omxplayer/OMXPlayerVideo.h
index 0df7e72..b505008 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.h
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.h
@@ -55,7 +55,6 @@ protected:
   bool                      m_stalled;
   IDVDStreamPlayer::ESyncState m_syncState;
   bool                      m_flush;
-  std::string               m_codecname;
   std::atomic_bool          m_bAbortOutput;
   double                    m_iSubtitleDelay;
   bool                      m_bRenderSubs;
-- 
2.7.4


From 5be06f69aa7ccb670c61fbed1abf63fdda5c7c54 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <afedchin@ruswizards.com>
Date: Tue, 8 Mar 2016 21:20:58 +0300
Subject: [PATCH 125/175] Add cpu usage info.

---
 .../VideoPlayer/VideoRenderers/DebugRenderer.cpp   | 56 ++++++++--------------
 .../VideoPlayer/VideoRenderers/DebugRenderer.h     |  9 ++--
 .../VideoPlayer/VideoRenderers/RenderManager.cpp   |  7 ++-
 3 files changed, 30 insertions(+), 42 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/DebugRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/DebugRenderer.cpp
index 539a560..08721e1 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/DebugRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/DebugRenderer.cpp
@@ -28,7 +28,7 @@ using namespace OVERLAY;
 
 CDebugRenderer::CDebugRenderer()
 {
-  for (int i=0; i<4; i++)
+  for (int i = 0; i<DEBUG_OVERLAY_COUNT_MAX; i++)
   {
     m_overlay[i] = nullptr;
     m_strDebug[i] = " ";
@@ -37,54 +37,36 @@ CDebugRenderer::CDebugRenderer()
 
 CDebugRenderer::~CDebugRenderer()
 {
-  for (int i=0; i<4; i++)
+  for (int i = 0; i<DEBUG_OVERLAY_COUNT_MAX; i++)
   {
     if (m_overlay[i])
       m_overlay[i]->Release();
   }
 }
 
-void CDebugRenderer::SetInfo(std::string &info1, std::string &info2, std::string &info3, std::string &info4)
+void CDebugRenderer::SetInfo(std::vector<std::string> &infos)
 {
   m_overlayRenderer.Release(0);
 
-  if (info1 != m_strDebug[0])
+  for (size_t i = 0; i < std::min(infos.size(), (size_t)DEBUG_OVERLAY_COUNT_MAX); i++)
   {
-    m_strDebug[0] = info1;
-    if (m_overlay[0])
-      m_overlay[0]->Release();
-    m_overlay[0] = new CDVDOverlayText();
-    m_overlay[0]->AddElement(new CDVDOverlayText::CElementText(m_strDebug[0]));
-  }
-  if (info2 != m_strDebug[1])
-  {
-    m_strDebug[1] = info2;
-    if (m_overlay[1])
-      m_overlay[1]->Release();
-    m_overlay[1] = new CDVDOverlayText();
-    m_overlay[1]->AddElement(new CDVDOverlayText::CElementText(m_strDebug[1]));
-  }
-  if (info3 != m_strDebug[2])
-  {
-    m_strDebug[2] = info3;
-    if (m_overlay[2])
-      m_overlay[2]->Release();
-    m_overlay[2] = new CDVDOverlayText();
-    m_overlay[2]->AddElement(new CDVDOverlayText::CElementText(m_strDebug[2]));
+    if (infos[i] != m_strDebug[i])
+    {
+      if (infos[i].empty())
+        continue;
+      m_strDebug[i] = infos[i];
+      if (m_overlay[i])
+        m_overlay[i]->Release();
+      m_overlay[i] = new CDVDOverlayText();
+      m_overlay[i]->AddElement(new CDVDOverlayText::CElementText(m_strDebug[i]));
+    }
+
   }
-  if (info4 != m_strDebug[3])
+  for (size_t i = 0; i < DEBUG_OVERLAY_COUNT_MAX; i++)
   {
-    m_strDebug[3] = info4;
-    if (m_overlay[3])
-      m_overlay[3]->Release();
-    m_overlay[3] = new CDVDOverlayText();
-    m_overlay[3]->AddElement(new CDVDOverlayText::CElementText(m_strDebug[3]));
+    if (m_overlay[i])
+      m_overlayRenderer.AddOverlay(m_overlay[i], 0, 0);
   }
-
-  m_overlayRenderer.AddOverlay(m_overlay[0], 0, 0);
-  m_overlayRenderer.AddOverlay(m_overlay[1], 0, 0);
-  m_overlayRenderer.AddOverlay(m_overlay[2], 0, 0);
-  m_overlayRenderer.AddOverlay(m_overlay[3], 0, 0);
 }
 
 void CDebugRenderer::Render(CRect &src, CRect &dst, CRect &view)
@@ -121,7 +103,7 @@ void CDebugRenderer::CRenderer::Render(int idx)
 
     COverlayText *text = dynamic_cast<COverlayText*>(o);
     if (text)
-      text->PrepareRender("arial.ttf", 1, 16, 0, m_font, m_fontBorder);
+      text->PrepareRender("arial.ttf", 1, 12, 0, m_font, m_fontBorder);
 
     RESOLUTION_INFO res = g_graphicsContext.GetResInfo(g_graphicsContext.GetVideoResolution());
 
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/DebugRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/DebugRenderer.h
index 85aefaa..8005a13 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/DebugRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/DebugRenderer.h
@@ -22,6 +22,9 @@
 
 #include "OverlayRenderer.h"
 #include <string>
+#include <vector>
+
+#define DEBUG_OVERLAY_COUNT_MAX 6
 
 class CDVDOverlayText;
 
@@ -30,7 +33,7 @@ class CDebugRenderer
 public:
   CDebugRenderer();
   virtual ~CDebugRenderer();
-  void SetInfo(std::string &info1, std::string &info2, std::string &info3, std::string &info4);
+  void SetInfo(std::vector<std::string> &infos);
   void Render(CRect &src, CRect &dst, CRect &view);
   void Flush();
 
@@ -43,7 +46,7 @@ protected:
     void Render(int idx) override;
   };
 
-  std::string m_strDebug[4];
-  CDVDOverlayText *m_overlay[4];
+  std::string m_strDebug[DEBUG_OVERLAY_COUNT_MAX];
+  CDVDOverlayText *m_overlay[DEBUG_OVERLAY_COUNT_MAX];
   CRenderer m_overlayRenderer;
 };
\ No newline at end of file
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
index b2d3a38..9160a9b 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
@@ -24,6 +24,7 @@
 #include "guilib/GraphicContext.h"
 #include "utils/MathUtils.h"
 #include "threads/SingleLock.h"
+#include "utils/CPUInfo.h"
 #include "utils/log.h"
 #include "utils/StringUtils.h"
 #include "windowing/WindowingFactory.h"
@@ -906,7 +907,7 @@ void CRenderManager::Render(bool clear, DWORD flags, DWORD alpha, bool gui)
 
     if (m_renderDebug)
     {
-      std::string audio, video, player, vsync;
+      std::string audio, video, player, vsync, cpu;
 
       m_playerPort->GetDebugInfo(audio, video, player);
 
@@ -920,8 +921,10 @@ void CRenderManager::Render(bool clear, DWORD flags, DWORD alpha, bool gui)
                                      missedvblanks,
                                      clockspeed * 100);
       }
+      cpu = g_cpuInfo.GetCoresUsageString();
 
-      m_debugRenderer.SetInfo(audio, video, player, vsync);
+      std::vector<std::string> infos = { audio, video, player, vsync, cpu };
+      m_debugRenderer.SetInfo(infos);
       m_debugRenderer.Render(src, dst, view);
 
       m_debugTimer.Set(1000);
-- 
2.7.4


From 73bc5ee72c82f9804e868760e1badb9f69809178 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 22 May 2015 13:56:29 +0100
Subject: [PATCH 126/175] ffmpeg: Allow neon to be enabled in unified builds

---
 tools/depends/target/ffmpeg/Makefile | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 8dd14cd..b5f38a4 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -23,7 +23,11 @@ ffmpg_config += --enable-gnutls
 ffmpg_config += --enable-encoder=png --enable-encoder=mjpeg
 
 ifeq ($(CROSS_COMPILING), yes)
+ ifeq ($(CPU), cortex-a7)
+  ffmpg_config += --arch=arm --enable-cross-compile
+ else
   ffmpg_config += --arch=$(CPU) --enable-cross-compile
+ endif
 endif
 ifeq ($(OS), linux)
   ffmpg_config += --target-os=$(OS) --cpu=$(CPU)
-- 
2.7.4


From cd8a52fc13fd37a8de8b6659d6988f0073978b07 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 27 Feb 2015 14:37:27 +0000
Subject: [PATCH 127/175] ffmpeg: Add some upstream HEVC optimisations

---
 tools/depends/target/ffmpeg/Makefile               |    6 +-
 .../added_ARM_NEON_optimized_SAO_patches.patch     | 3328 ++++++++++++++++++++
 tools/depends/target/ffmpeg/autobuild.sh           |    2 +
 ...hevcdsp_ARM_NEON_optimized_epel_functions.patch |  409 +++
 4 files changed, 3744 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/added_ARM_NEON_optimized_SAO_patches.patch
 create mode 100644 tools/depends/target/ffmpeg/hevcdsp_ARM_NEON_optimized_epel_functions.patch

diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index b5f38a4..c46b533 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,7 +1,8 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
 DEPS= ../../Makefile.include FFMPEG-VERSION Makefile \
-  0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
+  0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch \
+  hevcdsp_ARM_NEON_optimized_epel_functions.patch added_ARM_NEON_optimized_SAO_patches.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -82,6 +83,9 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig \&\& pkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
 	cd $(PLATFORM); patch -p1 < ../0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
+	cd $(PLATFORM); patch -p1 < ../hevcdsp_ARM_NEON_optimized_epel_functions.patch
+	cd $(PLATFORM); patch -p1 < ../added_ARM_NEON_optimized_SAO_patches.patch
+
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)
diff --git a/tools/depends/target/ffmpeg/added_ARM_NEON_optimized_SAO_patches.patch b/tools/depends/target/ffmpeg/added_ARM_NEON_optimized_SAO_patches.patch
new file mode 100644
index 0000000..792b5fe
--- /dev/null
+++ b/tools/depends/target/ffmpeg/added_ARM_NEON_optimized_SAO_patches.patch
@@ -0,0 +1,3328 @@
+From b0cb307c253d2c9f4b94a54dfc74ddb83af984cc Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Mon, 8 Dec 2014 13:24:40 +0200
+Subject: [PATCH 1/9] added ARM NEON optimized SAO band offset
+
+---
+ libavcodec/arm/Makefile            |   3 +-
+ libavcodec/arm/hevcdsp_init_neon.c |  47 +++++++++
+ libavcodec/arm/hevcdsp_sao_neon.S  | 204 +++++++++++++++++++++++++++++++++++++
+ 3 files changed, 253 insertions(+), 1 deletion(-)
+ create mode 100644 libavcodec/arm/hevcdsp_sao_neon.S
+
+diff --git a/libavcodec/arm/Makefile b/libavcodec/arm/Makefile
+index 6051ec8..093a2e8 100644
+--- a/libavcodec/arm/Makefile
++++ b/libavcodec/arm/Makefile
+@@ -133,7 +133,8 @@ NEON-OBJS-$(CONFIG_HEVC_DECODER)       += arm/hevcdsp_init_neon.o       \
+                                           arm/hevcdsp_deblock_neon.o    \
+                                           arm/hevcdsp_epel_neon.o       \
+                                           arm/hevcdsp_idct_neon.o       \
+-                                          arm/hevcdsp_qpel_neon.o
++                                          arm/hevcdsp_qpel_neon.o       \
++                                          arm/hevcdsp_sao_neon.o
+ NEON-OBJS-$(CONFIG_RV30_DECODER)       += arm/rv34dsp_neon.o
+ NEON-OBJS-$(CONFIG_RV40_DECODER)       += arm/rv34dsp_neon.o            \
+                                           arm/rv40dsp_neon.o
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index 733ff08..69e2b2c 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -22,6 +22,7 @@
+ #include "libavutil/arm/cpu.h"
+ #include "libavcodec/hevcdsp.h"
+ #include "hevcdsp_arm.h"
++#include "../bit_depth_template.c"
+ 
+ void ff_hevc_v_loop_filter_luma_neon(uint8_t *_pix, ptrdiff_t _stride, int _beta, int *_tc, uint8_t *_no_p, uint8_t *_no_q);
+ void ff_hevc_h_loop_filter_luma_neon(uint8_t *_pix, ptrdiff_t _stride, int _beta, int *_tc, uint8_t *_no_p, uint8_t *_no_q);
+@@ -43,6 +44,11 @@ void ff_hevc_transform_add_16x16_neon_8(uint8_t *_dst, int16_t *coeffs,
+ void ff_hevc_transform_add_32x32_neon_8(uint8_t *_dst, int16_t *coeffs,
+                                       ptrdiff_t stride);
+ 
++void ff_hevc_sao_band_w8_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
++void ff_hevc_sao_band_w16_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
++void ff_hevc_sao_band_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
++void ff_hevc_sao_band_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
++
+ #define PUT_PIXELS(name) \
+     void name(int16_t *dst, uint8_t *src, \
+                                 ptrdiff_t srcstride, int height, \
+@@ -151,6 +157,44 @@ void ff_hevc_put_qpel_bi_neon_wrapper(uint8_t *dst, ptrdiff_t dststride, uint8_t
+     put_hevc_qpel_uw_neon[my][mx](dst, dststride, src, srcstride, width, height, src2, MAX_PB_SIZE);
+ }
+ 
++static void ff_hevc_sao_band_neon_wrapper(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src,
++                                          int16_t *sao_offset_val, int sao_left_class, int width, int height)
++{
++    pixel *dst = (pixel *)_dst;
++    pixel *src = (pixel *)_src;
++    int8_t offset_table[32] = { 0 };
++    int k, y, x;
++    int shift  = 3; // BIT_DEPTH - 5
++
++    stride_src /= sizeof(pixel);
++    stride_dst /= sizeof(pixel);
++
++    for (k = 0; k < 4; k++)
++        offset_table[(k + sao_left_class) & 31] = sao_offset_val[k + 1];
++
++    switch(width){
++    case 8:
++        ff_hevc_sao_band_w8_neon_8(_dst, _src, stride_dst, stride_src, height, offset_table);
++        break;
++    case 16:
++        ff_hevc_sao_band_w16_neon_8(_dst, _src, stride_dst, stride_src, height, offset_table);
++        break;
++    case 32:
++        ff_hevc_sao_band_w32_neon_8(_dst, _src, stride_dst, stride_src, height, offset_table);
++        break;
++    case 64:
++        ff_hevc_sao_band_w64_neon_8(_dst, _src, stride_dst, stride_src, height, offset_table);
++        break;
++    default:
++        for (y = 0; y < height; y++) {
++            for (x = 0; x < width; x++)
++                dst[x] = av_clip_pixel(src[x] + offset_table[src[x] >> shift]);
++            dst += stride_dst;
++            src += stride_src;
++        }
++    }
++}
++
+ av_cold void ff_hevcdsp_init_neon(HEVCDSPContext *c, const int bit_depth)
+ {
+     if (bit_depth == 8) {
+@@ -170,6 +214,9 @@ av_cold void ff_hevcdsp_init_neon(HEVCDSPContext *c, const int bit_depth)
+         c->transform_add[2]            = ff_hevc_transform_add_16x16_neon_8;
+         c->transform_add[3]            = ff_hevc_transform_add_32x32_neon_8;
+         c->idct_4x4_luma               = ff_hevc_transform_luma_4x4_neon_8;
++        for (x = 0; x < sizeof c->sao_band_filter / sizeof *c->sao_band_filter; x++) {
++          c->sao_band_filter[x]        = ff_hevc_sao_band_neon_wrapper;
++        }
+         put_hevc_qpel_neon[1][0]       = ff_hevc_put_qpel_v1_neon_8;
+         put_hevc_qpel_neon[2][0]       = ff_hevc_put_qpel_v2_neon_8;
+         put_hevc_qpel_neon[3][0]       = ff_hevc_put_qpel_v3_neon_8;
+diff --git a/libavcodec/arm/hevcdsp_sao_neon.S b/libavcodec/arm/hevcdsp_sao_neon.S
+new file mode 100644
+index 0000000..1f0ad64
+--- /dev/null
++++ b/libavcodec/arm/hevcdsp_sao_neon.S
+@@ -0,0 +1,204 @@
++/*
++ * Copyright (c) 2014 Seppo Tomperi <seppo.tomperi@vtt.fi>
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++#include "libavutil/arm/asm.S"
++#include "neon.S"
++
++function ff_hevc_sao_band_w8_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // offset_table
++        vpush {d8-d15}
++        vld1.8  {q0, q1}, [r5] // offset table
++
++1:      subs    r4, #1
++        vld1.8   {d24}, [r1], r3
++        vshr.u8  d16, d24, #3
++        vtbl.8   d16, {q0, q1}, d16
++        vmovl.s8 q2, d16
++        vmovl.u8 q6, d24
++        vadd.s16 q2, q6
++        vqmovun.s16 d4, q2
++        vst1.8  {d4}, [r0], r2
++        bne    1b
++
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
++function ff_hevc_sao_band_w16_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // offset_table
++        vpush {d8-d15}
++        vld1.8  {q0, q1}, [r5] // offset table
++
++1:      subs    r4, #1
++        vld1.8  {q12}, [r1], r3
++
++        vshr.u8   q8, q12, #3
++
++        vtbl.8  d16, {q0, q1}, d16
++        vtbl.8  d17, {q0, q1}, d17
++
++        vmovl.s8 q2, d16
++        vmovl.s8 q3, d17
++
++        vmovl.u8 q6, d24
++        vmovl.u8 q7, d25
++
++        vadd.s16 q2, q6
++        vadd.s16 q3, q7
++
++        vqmovun.s16 d4, q2
++        vqmovun.s16 d5, q3
++
++        vstm.8   r0, {q2}
++        add    r0, r2
++        bne    1b
++
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
++function ff_hevc_sao_band_w32_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // offset_table
++        vpush {d8-d15}
++        vld1.8  {q0, q1}, [r5] // offset table
++
++1:      subs    r4, #1
++        vld1.8  {q12-q13}, [r1], r3
++
++        vshr.u8   q8, q12, #3
++        vshr.u8   q9, q13, #3
++
++        vtbl.8  d16, {q0, q1}, d16
++        vtbl.8  d17, {q0, q1}, d17
++        vtbl.8  d18, {q0, q1}, d18
++        vtbl.8  d19, {q0, q1}, d19
++
++        vmovl.s8 q2, d16
++        vmovl.s8 q3, d17 // q8 free
++        vmovl.s8 q4, d18
++        vmovl.s8 q5, d19 // q9 free
++
++        vmovl.u8 q6, d24
++        vmovl.u8 q7, d25 // q12 free
++        vmovl.u8 q8, d26
++        vmovl.u8 q9, d27 // q13 free
++
++        vadd.s16 q2, q6
++        vadd.s16 q3, q7
++        vadd.s16 q4, q8
++        vadd.s16 q5, q9
++
++        vqmovun.s16 d4, q2
++        vqmovun.s16 d5, q3
++        vqmovun.s16 d6, q4 // q4 free
++        vqmovun.s16 d7, q5 // q5 free
++
++        vst1.8 {q2-q3}, [r0], r2
++        bne    1b
++
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
++function ff_hevc_sao_band_w64_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // offset_table
++        vpush {d8-d15}
++        vld1.8  {q0, q1}, [r5] // offset table
++
++1:      subs    r4, #1
++        vld1.8  {q12-q13}, [r1]!
++        vld1.8  {q14-q15}, [r1], r3
++        sub     r1, #32
++
++        vshr.u8   q8, q12, #3
++        vshr.u8   q9, q13, #3
++        vshr.u8  q10, q14, #3
++        vshr.u8  q11, q15, #3
++
++        vtbl.8  d16, {q0, q1}, d16
++        vtbl.8  d17, {q0, q1}, d17
++        vtbl.8  d18, {q0, q1}, d18
++        vtbl.8  d19, {q0, q1}, d19
++        vtbl.8  d20, {q0, q1}, d20
++        vtbl.8  d21, {q0, q1}, d21
++        vtbl.8  d22, {q0, q1}, d22
++        vtbl.8  d23, {q0, q1}, d23
++
++        vmovl.s8 q2, d16
++        vmovl.s8 q3, d17 // q8 free
++        vmovl.s8 q4, d18
++        vmovl.s8 q5, d19 // q9 free
++
++        vmovl.u8 q6, d24
++        vmovl.u8 q7, d25 // q12 free
++        vmovl.u8 q8, d26
++        vmovl.u8 q9, d27 // q13 free
++
++        vadd.s16 q2, q6
++        vadd.s16 q3, q7
++        vadd.s16 q4, q8
++        vadd.s16 q5, q9
++
++        vqmovun.s16 d4, q2
++        vqmovun.s16 d5, q3
++        vqmovun.s16 d6, q4 // q4 free
++        vqmovun.s16 d7, q5 // q5 free
++
++        // free q4 -q9, q12 - q13
++        vmovl.s8 q4, d20
++        vmovl.s8 q5, d21 // q10 free
++        vmovl.s8 q6, d22
++        vmovl.s8 q7, d23 // q11 free
++
++        vmovl.u8  q8, d28
++        vmovl.u8  q9, d29 // q14 free
++        vmovl.u8 q10, d30
++        vmovl.u8 q11, d31 // q15 free
++
++        vadd.s16 q4, q8
++        vadd.s16 q5, q9
++        vadd.s16 q6, q10
++        vadd.s16 q7, q11
++
++        vqmovun.s16  d8, q4
++        vqmovun.s16  d9, q5
++        vqmovun.s16 d10, q6
++        vqmovun.s16 d11, q7
++
++        vstm.8   r0, {q2-q5}
++        add    r0, r2
++        bne    1b
++
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
+-- 
+2.5.0
+
+
+From 8429b1de64bb871d57651ecfe3b084e2dfe0af51 Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Wed, 27 May 2015 18:10:20 +0100
+Subject: [PATCH 2/9] added NEON optimized sao edge for eo1 width 64
+
+---
+ libavcodec/arm/hevcdsp_init_neon.c |  47 ++++++++++++
+ libavcodec/arm/hevcdsp_sao_neon.S  | 147 +++++++++++++++++++++++++++++++++++++
+ 2 files changed, 194 insertions(+)
+
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index 69e2b2c..c7b5404 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -22,6 +22,7 @@
+ #include "libavutil/arm/cpu.h"
+ #include "libavcodec/hevcdsp.h"
+ #include "hevcdsp_arm.h"
++#include "libavcodec/avcodec.h"
+ #include "../bit_depth_template.c"
+ 
+ void ff_hevc_v_loop_filter_luma_neon(uint8_t *_pix, ptrdiff_t _stride, int _beta, int *_tc, uint8_t *_no_p, uint8_t *_no_q);
+@@ -48,6 +49,7 @@ void ff_hevc_sao_band_w8_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_d
+ void ff_hevc_sao_band_w16_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
+ void ff_hevc_sao_band_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
+ void ff_hevc_sao_band_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
++void ff_hevc_sao_edge_eo1_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
+ 
+ #define PUT_PIXELS(name) \
+     void name(int16_t *dst, uint8_t *src, \
+@@ -195,6 +197,50 @@ static void ff_hevc_sao_band_neon_wrapper(uint8_t *_dst, uint8_t *_src, ptrdiff_
+     }
+ }
+ 
++#define CMP(a, b) ((a) > (b) ? 1 : ((a) == (b) ? 0 : -1))
++static void ff_hevc_sao_edge_neon_wrapper(uint8_t *_dst /* align 16 */, uint8_t *_src /* align 32 */, ptrdiff_t stride_dst,
++                                          int16_t *_sao_offset_val, int eo, int width, int height)
++{
++    static const uint8_t edge_idx[] = { 1, 2, 0, 3, 4 };
++    static const int8_t pos[4][2][2] = {
++        { { -1,  0 }, {  1, 0 } }, // horizontal
++        { {  0, -1 }, {  0, 1 } }, // vertical
++        { { -1, -1 }, {  1, 1 } }, // 45 degree
++        { {  1, -1 }, { -1, 1 } }, // 135 degree
++    };
++    int8_t sao_offset_val[8];  // padding of 3 for vld
++    ptrdiff_t stride_src = (2*MAX_PB_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
++    pixel *dst = (pixel *)_dst;
++    pixel *src = (pixel *)_src;
++    int a_stride, b_stride;
++    int x, y;
++
++    for (x = 0; x < 5; x++) {
++        sao_offset_val[x] = _sao_offset_val[x];
++    }
++
++    stride_src /= sizeof(pixel);
++    stride_dst /= sizeof(pixel);
++
++    if (eo == 1 && width == 64) {
++        ff_hevc_sao_edge_eo1_w64_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
++    } else {
++        a_stride = pos[eo][0][0] + pos[eo][0][1] * stride_src;
++        b_stride = pos[eo][1][0] + pos[eo][1][1] * stride_src;
++        for (y = 0; y < height; y++) {
++            for (x = 0; x < width; x++) {
++                int diff0         = CMP(src[x], src[x + a_stride]);
++                int diff1         = CMP(src[x], src[x + b_stride]);
++                int offset_val    = edge_idx[2 + diff0 + diff1];
++                dst[x] = av_clip_pixel(src[x] + sao_offset_val[offset_val]);
++            }
++            src += stride_src;
++            dst += stride_dst;
++        }
++    }
++}
++#undef CMP
++
+ av_cold void ff_hevcdsp_init_neon(HEVCDSPContext *c, const int bit_depth)
+ {
+     if (bit_depth == 8) {
+@@ -216,6 +262,7 @@ av_cold void ff_hevcdsp_init_neon(HEVCDSPContext *c, const int bit_depth)
+         c->idct_4x4_luma               = ff_hevc_transform_luma_4x4_neon_8;
+         for (x = 0; x < sizeof c->sao_band_filter / sizeof *c->sao_band_filter; x++) {
+           c->sao_band_filter[x]        = ff_hevc_sao_band_neon_wrapper;
++          c->sao_edge_filter[x]        = ff_hevc_sao_edge_neon_wrapper;
+         }
+         put_hevc_qpel_neon[1][0]       = ff_hevc_put_qpel_v1_neon_8;
+         put_hevc_qpel_neon[2][0]       = ff_hevc_put_qpel_v2_neon_8;
+diff --git a/libavcodec/arm/hevcdsp_sao_neon.S b/libavcodec/arm/hevcdsp_sao_neon.S
+index 1f0ad64..5ec2de9 100644
+--- a/libavcodec/arm/hevcdsp_sao_neon.S
++++ b/libavcodec/arm/hevcdsp_sao_neon.S
+@@ -202,3 +202,150 @@ function ff_hevc_sao_band_w64_neon_8, export=1
+         bx lr
+ endfunc
+ 
++function ff_hevc_sao_edge_eo1_w64_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // sao_offset_val_table
++        ldr    r6, =0x02
++        vpush {d8-d15}
++1:      subs    r4, #1
++        // load a
++        sub     r1, r3
++        vld1.8  {q0-q1}, [r1]!
++        vld1.8  {q2-q3}, [r1], r3
++        sub     r1, #32
++        // load c
++        vld1.8  {q4-q5}, [r1]!
++        vld1.8  {q6-q7}, [r1], r3
++        sub     r1, #32
++        // load b
++        vld1.8  {q8-q9}, [r1]!
++        vld1.8  {q10-q11}, [r1], r3
++        sub     r1, #32
++
++        vcgt.u8 q12, q4, q0 // c > a -> -1 , otherwise 0
++        vcgt.u8 q0,  q0, q4 // a > c -> -1 , otherwise 0
++        vcgt.u8 q13, q5, q1
++        vcgt.u8 q1,  q1, q5
++        vcgt.u8 q14, q6, q2
++        vcgt.u8 q2,  q2, q6
++        vcgt.u8 q15, q7, q3
++        vcgt.u8 q3,  q3, q7
++
++        vsub.s8 q12, q0, q12 // diff0
++        vsub.s8 q13, q1, q13
++        vsub.s8 q14, q2, q14
++        vsub.s8 q15, q3, q15
++
++        vcgt.u8  q0,  q4, q8 // c > b
++        vcgt.u8  q8,  q8, q4 // b > c
++        vcgt.u8  q1,  q5, q9
++        vcgt.u8  q9,  q9, q5
++        vcgt.u8  q2,  q6, q10
++        vcgt.u8 q10, q10, q6
++        vcgt.u8  q3,  q7, q11
++        vcgt.u8 q11, q11, q7
++
++        vsub.s8 q0, q8, q0 // diff1
++        vsub.s8 q1, q9, q1
++        vsub.s8 q2, q10, q2
++        vsub.s8 q3, q11, q3
++
++        veor.u8 q8, q8  // zero register
++        vdup.s8 q9, r6  // 2 to all elements
++        add     r6, #1
++        vdup.s8 q10, r6 // 3 to all elements
++        sub     r6, #1
++
++        vadd.s8 q0, q12 //diff0 + diff1
++        vadd.s8 q1, q13
++        vadd.s8 q2, q14
++        vadd.s8 q3, q15
++
++        vcgt.s8 q4, q0, q8 // diff0 + diff1 > 0
++        vcgt.s8 q5, q1, q8
++        vcgt.s8 q6, q2, q8
++        vcgt.s8 q7, q3, q8
++
++        vclt.s8 q11, q0, q8 // diff0 + diff1 < 0
++        vclt.s8 q12, q1, q8
++        vclt.s8 q13, q2, q8
++        vclt.s8 q14, q3, q8
++
++        vadd.s8  q8,  q0, q9  // diff0 + diff1 + 2
++        vand.8  q15,  q8, q4
++        vadd.s8  q8,  q0, q10 // diff0 + diff1 + 3
++        vand.8   q8,  q8, q11
++        vadd.s8  q0, q15, q8  // offset_idx
++
++        vadd.s8  q8,  q1, q9  // diff0 + diff1 + 2
++        vand.8  q15,  q8, q5
++        vadd.s8  q8,  q1, q10 // diff0 + diff1 + 3
++        vand.8   q8,  q8, q12
++        vadd.s8  q1, q15, q8  // offset_idx
++
++        vadd.s8  q8,  q2, q9  // diff0 + diff1 + 2 + 2
++        vand.8  q15,  q8, q6
++        vadd.s8  q8,  q2, q10 // diff0 + diff1 + 2 + 3
++        vand.8   q8,  q8, q13
++        vadd.s8  q2, q15, q8  // offset_idx
++
++        vadd.s8  q8,  q3, q9  // diff0 + diff1 + 2 + 2
++        vand.8  q15,  q8, q7
++        vadd.s8  q8,  q3, q10 // diff0 + diff1 + 2 + 3
++        vand.8   q8,  q8, q14
++        vadd.s8  q3, q15, q8  // offset_idx
++        // TODO: load only once
++        vld1.8   d16, [r5]
++
++        vtbl.8   d0, {d16}, d0
++        vtbl.8   d1, {d16}, d1
++        vtbl.8   d2, {d16}, d2
++        vtbl.8   d3, {d16}, d3
++        vtbl.8   d4, {d16}, d4
++        vtbl.8   d5, {d16}, d5
++        vtbl.8   d6, {d16}, d6
++        vtbl.8   d7, {d16}, d7
++
++        // TODO: load only once
++        // load c again
++        sub     r1, r3
++        sub     r1, r3
++        vld1.8  {q4-q5}, [r1]!
++        vld1.8  {q6-q7}, [r1], r3
++        sub     r1, #32
++
++        vmovl.u8   q8, d8
++        vmovl.u8   q9, d9
++        vmovl.u8  q10, d10
++        vmovl.u8  q11, d11
++        vmovl.u8  q12, d12
++        vmovl.u8  q13, d13
++        vmovl.u8  q14, d14
++        vmovl.u8  q15, d15
++
++        vaddw.s8  q8, d0
++        vaddw.s8  q9, d1
++        vaddw.s8 q10, d2
++        vaddw.s8 q11, d3
++        vaddw.s8 q12, d4
++        vaddw.s8 q13, d5
++        vaddw.s8 q14, d6
++        vaddw.s8 q15, d7
++
++        vqmovun.s16  d0, q8
++        vqmovun.s16  d1, q9
++        vqmovun.s16  d2, q10
++        vqmovun.s16  d3, q11
++        vqmovun.s16  d4, q12
++        vqmovun.s16  d5, q13
++        vqmovun.s16  d6, q14
++        vqmovun.s16  d7, q15
++
++        vstm r0, {q0-q3}
++        add  r0, r2
++        bne   1b
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
+-- 
+2.5.0
+
+
+From 402e2bd1c5ad659c757bf9734abe6331904fb9e2 Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Tue, 16 Dec 2014 16:28:25 +0200
+Subject: [PATCH 3/9] Added SAO edge offset for ARM NEON w32 and w64
+
+---
+ libavcodec/arm/hevcdsp_init_neon.c |  46 +++-
+ libavcodec/arm/hevcdsp_sao_neon.S  | 510 +++++++++++++++++++++++++++++++------
+ 2 files changed, 474 insertions(+), 82 deletions(-)
+
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index c7b5404..c32940e 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -49,7 +49,16 @@ void ff_hevc_sao_band_w8_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_d
+ void ff_hevc_sao_band_w16_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
+ void ff_hevc_sao_band_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
+ void ff_hevc_sao_band_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
++
++void ff_hevc_sao_edge_eo0_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
++void ff_hevc_sao_edge_eo1_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
++void ff_hevc_sao_edge_eo2_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
++void ff_hevc_sao_edge_eo3_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
++
++void ff_hevc_sao_edge_eo0_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
+ void ff_hevc_sao_edge_eo1_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
++void ff_hevc_sao_edge_eo2_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
++void ff_hevc_sao_edge_eo3_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
+ 
+ #define PUT_PIXELS(name) \
+     void name(int16_t *dst, uint8_t *src, \
+@@ -222,9 +231,40 @@ static void ff_hevc_sao_edge_neon_wrapper(uint8_t *_dst /* align 16 */, uint8_t
+     stride_src /= sizeof(pixel);
+     stride_dst /= sizeof(pixel);
+ 
+-    if (eo == 1 && width == 64) {
+-        ff_hevc_sao_edge_eo1_w64_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
+-    } else {
++    switch (width) {
++    case 32:
++        switch(eo) {
++        case 0:
++            ff_hevc_sao_edge_eo0_w32_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
++            break;
++        case 1:
++            ff_hevc_sao_edge_eo1_w32_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
++            break;
++        case 2:
++            ff_hevc_sao_edge_eo2_w32_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
++            break;
++        case 3:
++            ff_hevc_sao_edge_eo3_w32_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
++            break;
++        }
++        break;
++    case 64:
++        switch(eo) {
++        case 0:
++            ff_hevc_sao_edge_eo0_w64_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
++            break;
++        case 1:
++            ff_hevc_sao_edge_eo1_w64_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
++            break;
++        case 2:
++            ff_hevc_sao_edge_eo2_w64_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
++            break;
++        case 3:
++            ff_hevc_sao_edge_eo3_w64_neon_8(dst, src, stride_dst, stride_src, height, sao_offset_val);
++            break;
++        }
++        break;
++    default:
+         a_stride = pos[eo][0][0] + pos[eo][0][1] * stride_src;
+         b_stride = pos[eo][1][0] + pos[eo][1][1] * stride_src;
+         for (y = 0; y < height; y++) {
+diff --git a/libavcodec/arm/hevcdsp_sao_neon.S b/libavcodec/arm/hevcdsp_sao_neon.S
+index 5ec2de9..4687012 100644
+--- a/libavcodec/arm/hevcdsp_sao_neon.S
++++ b/libavcodec/arm/hevcdsp_sao_neon.S
+@@ -202,27 +202,7 @@ function ff_hevc_sao_band_w64_neon_8, export=1
+         bx lr
+ endfunc
+ 
+-function ff_hevc_sao_edge_eo1_w64_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // sao_offset_val_table
+-        ldr    r6, =0x02
+-        vpush {d8-d15}
+-1:      subs    r4, #1
+-        // load a
+-        sub     r1, r3
+-        vld1.8  {q0-q1}, [r1]!
+-        vld1.8  {q2-q3}, [r1], r3
+-        sub     r1, #32
+-        // load c
+-        vld1.8  {q4-q5}, [r1]!
+-        vld1.8  {q6-q7}, [r1], r3
+-        sub     r1, #32
+-        // load b
+-        vld1.8  {q8-q9}, [r1]!
+-        vld1.8  {q10-q11}, [r1], r3
+-        sub     r1, #32
+-
++.macro edge_w64_body
+         vcgt.u8 q12, q4, q0 // c > a -> -1 , otherwise 0
+         vcgt.u8 q0,  q0, q4 // a > c -> -1 , otherwise 0
+         vcgt.u8 q13, q5, q1
+@@ -251,69 +231,61 @@ function ff_hevc_sao_edge_eo1_w64_neon_8, export=1
+         vsub.s8 q2, q10, q2
+         vsub.s8 q3, q11, q3
+ 
+-        veor.u8 q8, q8  // zero register
+-        vdup.s8 q9, r6  // 2 to all elements
+-        add     r6, #1
+-        vdup.s8 q10, r6 // 3 to all elements
+-        sub     r6, #1
+-
+         vadd.s8 q0, q12 //diff0 + diff1
+         vadd.s8 q1, q13
+         vadd.s8 q2, q14
+         vadd.s8 q3, q15
+ 
+-        vcgt.s8 q4, q0, q8 // diff0 + diff1 > 0
+-        vcgt.s8 q5, q1, q8
+-        vcgt.s8 q6, q2, q8
+-        vcgt.s8 q7, q3, q8
+-
+-        vclt.s8 q11, q0, q8 // diff0 + diff1 < 0
+-        vclt.s8 q12, q1, q8
+-        vclt.s8 q13, q2, q8
+-        vclt.s8 q14, q3, q8
+-
+-        vadd.s8  q8,  q0, q9  // diff0 + diff1 + 2
+-        vand.8  q15,  q8, q4
+-        vadd.s8  q8,  q0, q10 // diff0 + diff1 + 3
+-        vand.8   q8,  q8, q11
+-        vadd.s8  q0, q15, q8  // offset_idx
+-
+-        vadd.s8  q8,  q1, q9  // diff0 + diff1 + 2
+-        vand.8  q15,  q8, q5
+-        vadd.s8  q8,  q1, q10 // diff0 + diff1 + 3
+-        vand.8   q8,  q8, q12
+-        vadd.s8  q1, q15, q8  // offset_idx
+-
+-        vadd.s8  q8,  q2, q9  // diff0 + diff1 + 2 + 2
+-        vand.8  q15,  q8, q6
+-        vadd.s8  q8,  q2, q10 // diff0 + diff1 + 2 + 3
+-        vand.8   q8,  q8, q13
+-        vadd.s8  q2, q15, q8  // offset_idx
+-
+-        vadd.s8  q8,  q3, q9  // diff0 + diff1 + 2 + 2
+-        vand.8  q15,  q8, q7
+-        vadd.s8  q8,  q3, q10 // diff0 + diff1 + 2 + 3
+-        vand.8   q8,  q8, q14
+-        vadd.s8  q3, q15, q8  // offset_idx
+-        // TODO: load only once
+-        vld1.8   d16, [r5]
+-
+-        vtbl.8   d0, {d16}, d0
+-        vtbl.8   d1, {d16}, d1
+-        vtbl.8   d2, {d16}, d2
+-        vtbl.8   d3, {d16}, d3
+-        vtbl.8   d4, {d16}, d4
+-        vtbl.8   d5, {d16}, d5
+-        vtbl.8   d6, {d16}, d6
+-        vtbl.8   d7, {d16}, d7
+-
+-        // TODO: load only once
+-        // load c again
+-        sub     r1, r3
+-        sub     r1, r3
+-        vld1.8  {q4-q5}, [r1]!
+-        vld1.8  {q6-q7}, [r1], r3
+-        sub     r1, #32
++        vdup.s8 q9, r6 // 3 to all elements
++        sub     r6, #1
++
++        vclt.s8 q12, q0, #0 // diff0 + diff1 < 0
++        vclt.s8 q13, q1, #0
++        vclt.s8 q14, q2, #0
++        vclt.s8 q15, q3, #0
++
++        vadd.s8  q8,  q0, q9 // diff0 + diff1 + 3
++        vadd.s8  q10,  q1, q9
++        vand.8   q12, q8, q12 // if (diff0 + diff1 < 0) then (diff0 + diff1 + 3) else 0
++        vand.8   q13, q10, q13
++        vadd.s8  q8,  q2, q9
++        vadd.s8  q10,  q3, q9
++        vand.8   q14, q8, q14
++        vand.8   q15, q10, q15
++
++        vdup.s8 q9, r6  // 2 to all elements
++        add     r6, #1
++
++        vcgt.s8  q10, q0, #0 // diff0 + diff1 > 0
++        vadd.s8   q8, q0, q9 // diff0 + diff1 + 2
++        vand.8   q11, q8, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
++        vcgt.s8  q10, q1, #0
++        vadd.s8   q0, q11, q12  // offset_idx
++
++        vadd.s8   q8, q1, q9 // diff0 + diff1 + 2
++        vcgt.s8  q12, q2, #0
++        vand.8   q11, q8, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
++        vadd.s8   q8, q2, q9 // diff0 + diff1 + 2
++        vadd.s8   q1, q11, q13
++
++        vand.8   q11, q8, q12 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
++        vcgt.s8  q10, q3, #0
++        vadd.s8   q2, q11, q14
++
++        vadd.s8   q8, q3, q9 // diff0 + diff1 + 2
++        vmov.32  d18[0], r7  // load offset table from general registers
++        vand.8   q11, q8, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
++        vmov.32  d18[1], r5  // load rest of offset table
++        vadd.s8   q3, q11, q15
++
++        vtbl.8   d0, {d18}, d0
++        vtbl.8   d1, {d18}, d1
++        vtbl.8   d2, {d18}, d2
++        vtbl.8   d3, {d18}, d3
++        vtbl.8   d4, {d18}, d4
++        vtbl.8   d5, {d18}, d5
++        vtbl.8   d6, {d18}, d6
++        vtbl.8   d7, {d18}, d7
+ 
+         vmovl.u8   q8, d8
+         vmovl.u8   q9, d9
+@@ -344,8 +316,388 @@ function ff_hevc_sao_edge_eo1_w64_neon_8, export=1
+ 
+         vstm r0, {q0-q3}
+         add  r0, r2
++.endm
++
++.macro edge_w32_body
++        vcgt.u8 q12, q4, q0 // c > a -> -1 , otherwise 0
++        vcgt.u8 q0,  q0, q4 // a > c -> -1 , otherwise 0
++        vcgt.u8 q13, q5, q1
++        vcgt.u8 q1,  q1, q5
++
++        vsub.s8 q12, q0, q12 // diff0
++        vcgt.u8  q0,  q4, q8 // c > b
++        vsub.s8 q13, q1, q13 // diff0 part 2
++
++        vcgt.u8  q6,  q8, q4 // b > c
++        vcgt.u8  q1,  q5, q9
++        vcgt.u8  q7,  q9, q5
++
++        vsub.s8 q0, q6, q0 // diff1
++        vsub.s8 q1, q7, q1 // diff1 part 2
++        vadd.s8 q0, q12 //diff0 + diff1
++
++        vdup.s8 q7, r6 // 3 to all elements
++        sub     r6, #1
++        vadd.s8 q1, q13
++
++        vclt.s8 q12, q0, #0 // diff0 + diff1 < 0
++        vclt.s8 q13, q1, #0
++
++        vadd.s8  q6,  q0, q7 // diff0 + diff1 + 3
++        vadd.s8  q10,  q1, q7
++        vdup.s8 q7, r6  // 2 to all elements
++        add     r6, #1
++        vand.8   q12, q6, q12 // if (diff0 + diff1 < 0) then (diff0 + diff1 + 3) else 0
++        vand.8   q13, q10, q13
++
++
++        vcgt.s8  q10, q0, #0 // diff0 + diff1 > 0
++        vadd.s8   q6, q0, q7 // diff0 + diff1 + 2
++        vand.8   q11, q6, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
++        vcgt.s8  q10, q1, #0
++        vadd.s8   q0, q11, q12  // offset_idx
++
++        vadd.s8   q6, q1, q7 // diff0 + diff1 + 2
++        vmov.32  d14[0], r7  // load offset table from general registers
++        vand.8   q11, q6, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
++        vmov.32  d14[1], r5  // load rest of offset table
++        vadd.s8   q1, q11, q13
++
++        vtbl.8   d0, {d14}, d0
++        vtbl.8   d1, {d14}, d1
++        vtbl.8   d2, {d14}, d2
++        vtbl.8   d3, {d14}, d3
++
++        vmovl.u8   q6, d8
++        vmovl.u8   q7, d9
++        vmovl.u8  q10, d10
++        vmovl.u8  q11, d11
++
++        vaddw.s8  q6, d0
++        vaddw.s8  q7, d1
++        vaddw.s8 q10, d2
++        vaddw.s8 q11, d3
++
++        vqmovun.s16  d0, q6
++        vqmovun.s16  d1, q7
++        vqmovun.s16  d2, q10
++        vqmovun.s16  d3, q11
++
++        vstm r0, {q0-q1}
++        add  r0, r2
++.endm
++
++function ff_hevc_sao_edge_eo0_w64_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // sao_offset_val_table
++        ldr    r6, =0x03
++        ldr    r7, [r5]
++        add    r5, #4
++        ldr    r5, [r5]
++        vpush {d8-d15}
++        sub    r1, #8
++1:      subs    r4, #1
++        vld1.64  {q10-q11}, [r1]!
++        vld1.64  {q12-q13}, [r1]!
++        vld1.64  {q14}, [r1], r3
++        sub      r1, #64
++        // load a
++        vext.8 q0, q10, q11, #7
++        vext.8 q1, q11, q12, #7
++        vext.8 q2, q12, q13, #7
++        vext.8 q3, q13, q14, #7
++        // load c
++        vext.8 q4, q10, q11, #8
++        vext.8 q5, q11, q12, #8
++        vext.8 q6, q12, q13, #8
++        vext.8 q7, q13, q14, #8
++        // load b
++        vext.8 q8, q10, q11, #9
++        vext.8 q9, q11, q12, #9
++        vext.8 q10, q12, q13, #9
++        vext.8 q11, q13, q14, #9
++        edge_w64_body
++        bne   1b
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
++function ff_hevc_sao_edge_eo1_w64_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // sao_offset_val_table
++        ldr    r6, =0x03
++        ldr    r7, [r5]
++        add    r5, #4
++        ldr    r5, [r5]
++        vpush {d8-d15}
++        sub     r1, r3
++        // load a
++        vld1.8  {q0-q1}, [r1]!
++        vld1.8  {q2-q3}, [r1], r3
++        sub     r1, #32
++1:      subs    r4, #1
++        // load c
++        vld1.8  {q4-q5}, [r1]!
++        vld1.8  {q6-q7}, [r1], r3
++        sub     r1, #32
++        // load b
++        vld1.8  {q8-q9}, [r1]!
++        vld1.8  {q10-q11}, [r1]
++        sub     r1, #32
++        edge_w64_body
++        // copy c to a
++        vmov.64 q0, q4
++        vmov.64 q1, q5
++        vmov.64 q2, q6
++        vmov.64 q3, q7
+         bne   1b
+         vpop  {d8-d15}
+         pop   {r4-r8}
+         bx lr
+ endfunc
++
++function ff_hevc_sao_edge_eo2_w64_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // sao_offset_val_table
++        ldr    r6, =0x03
++        ldr    r7, [r5]
++        add    r5, #4
++        ldr    r5, [r5]
++        vpush {d8-d15}
++1:      sub     r1, r3
++        // load a
++        // TODO: fix unaligned load
++        //       don't reload a like in eo1
++        sub     r1, #1
++        vld1.8  {q0-q1}, [r1]!
++        vld1.8  {q2-q3}, [r1], r3
++        sub     r1, #31
++        subs    r4, #1
++        // load c
++        vld1.8  {q4-q5}, [r1]!
++        vld1.8  {q6-q7}, [r1], r3
++        sub     r1, #32
++        // load b
++        add     r1, #1
++        vld1.8  {q8-q9}, [r1]!
++        vld1.8  {q10-q11}, [r1]
++        sub     r1, #33
++        edge_w64_body
++        // copy c to a
++        vmov.64 q0, q4
++        vmov.64 q1, q5
++        vmov.64 q2, q6
++        vmov.64 q3, q7
++        bne   1b
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
++function ff_hevc_sao_edge_eo3_w64_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // sao_offset_val_table
++        ldr    r6, =0x03
++        ldr    r7, [r5]
++        add    r5, #4
++        ldr    r5, [r5]
++        vpush {d8-d15}
++1:      sub     r1, r3
++        // load a
++        // TODO: fix unaligned load
++        //       don't reload a like in eo1
++        add     r1, #1
++        vld1.8  {q0-q1}, [r1]!
++        vld1.8  {q2-q3}, [r1], r3
++        sub     r1, #33
++        subs    r4, #1
++        // load c
++        vld1.8  {q4-q5}, [r1]!
++        vld1.8  {q6-q7}, [r1], r3
++        sub     r1, #32
++        // load b
++        sub     r1, #1
++        vld1.8  {q8-q9}, [r1]!
++        vld1.8  {q10-q11}, [r1]
++        sub     r1, #31
++        edge_w64_body
++        // copy c to a
++        vmov.64 q0, q4
++        vmov.64 q1, q5
++        vmov.64 q2, q6
++        vmov.64 q3, q7
++        bne   1b
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
++function ff_hevc_sao_edge_eo0_w32_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // sao_offset_val_table
++        ldr    r6, =0x03
++        ldr    r7, [r5]
++        add    r5, #4
++        ldr    r5, [r5]
++        vpush {d8-d15}
++        sub    r1, #8 // load 8 extra bytes
++1:      subs    r4, #1
++        vld1.8  {q10-q11}, [r1]
++        add    r1, #32
++        vld1.8  {q12}, [r1], r3 // only first 9 bytes are used
++        sub    r1, #32
++        // a
++        vext.8  q0, q10, q11, #7
++        vext.8  q1, q11, q12, #7
++        // c
++        vext.8  q4, q10, q11, #8
++        vext.8  q5, q11, q12, #8
++        // b
++        vext.8  q8, q10, q11, #9
++        vext.8  q9, q11, q12, #9
++        edge_w32_body
++        bne   1b
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
++function ff_hevc_sao_edge_eo1_w32_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // sao_offset_val_table
++        ldr    r6, =0x03
++        ldr    r7, [r5]
++        add    r5, #4
++        ldr    r5, [r5]
++        vpush {d8-d15}
++        // load a
++        sub     r1, r3
++        vld1.8  {q0-q1}, [r1], r3
++        // load c
++        vld1.8  {q4-q5}, [r1], r3
++1:      subs    r4, #1
++        // load b
++        vld1.8  {q8-q9}, [r1], r3
++        edge_w32_body
++        // inputs for next loop iteration
++        // a
++        vmov.64 q0, q4
++        vmov.64 q1, q5
++        // c
++        vmov.64 q4, q8
++        vmov.64 q5, q9
++        bne   1b
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
++function ff_hevc_sao_edge_eo2_w32_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // sao_offset_val_table
++        ldr    r6, =0x03
++        ldr    r7, [r5]
++        add    r5, #4
++        ldr    r5, [r5]
++        vpush {d8-d15}
++        // load a
++        sub     r1, r3
++        sub    r1, #8
++        vld1.8  {q10-q11}, [r1]
++        add    r1, #32
++        vld1.8  {q12}, [r1], r3
++        sub    r1, #32
++        vext.8  q0, q10, q11, #7
++        vext.8  q1, q11, q12, #7
++        // load c
++        vld1.8  {q10-q11}, [r1]
++        add    r1, #32
++        vld1.8  {q12}, [r1], r3
++        sub    r1, #32
++        vext.8  q4, q10, q11, #8
++        vext.8  q5, q11, q12, #8
++        vext.8  q2, q10, q11, #7
++1:      subs    r4, #1
++        // load b
++        vld1.8  {q10-q11}, [r1]
++        add    r1, #32
++        vld1.8  {q12}, [r1], r3
++        sub    r1, #32
++        vext.8  q8, q10, q11, #9
++        vext.8  q9, q11, q12, #9
++        vext.8  q14, q10, q11, #8
++        vext.8  q15, q11, q12, #8
++        vext.8  q3, q10, q11, #7
++        edge_w32_body
++        // inputs for next loop iteration
++        // a
++        vmov.8 q0, q2
++        vext.8 q1, q4, q5, #15
++        // c
++        vmov.8  q4, q14
++        vmov.8  q5, q15
++        vmov.8  q2, q3
++        bne   1b
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
++function ff_hevc_sao_edge_eo3_w32_neon_8, export=1
++        push  {r4-r8}
++        ldr    r4, [sp, #20] // height
++        ldr    r5, [sp, #24] // sao_offset_val_table
++        ldr    r6, =0x03
++        ldr    r7, [r5]
++        add    r5, #4
++        sub    r1, r3
++        ldr    r5, [r5]
++        sub    r1, #8
++        vpush {d8-d15}
++        // load a
++        vld1.8  {q10-q11}, [r1]
++        add    r1, #32
++        vld1.8  {q12}, [r1], r3
++        sub    r1, #32
++        vext.8  q0, q10, q11, #9
++        vext.8  q1, q11, q12, #9
++        // load c
++        vld1.8  {q10-q11}, [r1]
++        add    r1, #32
++        vld1.8  {q12}, [r1], r3
++        sub    r1, #32
++        vext.8  q4, q10, q11, #8
++        vext.8  q5, q11, q12, #8
++        vext.8  q2, q12, q11, #8
++1:      subs    r4, #1
++        // load b
++        vld1.8  {q10-q11}, [r1]
++        add    r1, #32
++        vld1.8  {q12}, [r1], r3
++        sub    r1, #32
++        vext.8  q8, q10, q11, #7
++        vext.8  q9, q11, q12, #7
++        vext.8  q3, q12, q10, #7
++        edge_w32_body
++        // inputs for next loop iteration
++        // a
++        vext.8 q0, q4, q5, #1
++        vext.8 q1, q5, q2, #1
++        // c
++        vext.8  q4, q8, q9, #1
++        vext.8  q5, q9, q3, #1
++        vext.8  q2, q3, q1, #1
++        bne   1b
++        vpop  {d8-d15}
++        pop   {r4-r8}
++        bx lr
++endfunc
++
+-- 
+2.5.0
+
+
+From 1898d052a73370166d57e17cc7c52b7275887df3 Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Fri, 19 Dec 2014 09:44:10 +0200
+Subject: [PATCH 4/9] Improved SAO band NEON opimizations made SAO buffer 16
+ byte aligned added alignment hints to loads and stores optimized register
+ usage in SAO band neon assembly
+
+---
+ libavcodec/arm/hevcdsp_sao_neon.S | 212 +++++++++++++++-----------------------
+ 1 file changed, 82 insertions(+), 130 deletions(-)
+
+diff --git a/libavcodec/arm/hevcdsp_sao_neon.S b/libavcodec/arm/hevcdsp_sao_neon.S
+index 4687012..ac21013 100644
+--- a/libavcodec/arm/hevcdsp_sao_neon.S
++++ b/libavcodec/arm/hevcdsp_sao_neon.S
+@@ -22,120 +22,84 @@
+ #include "neon.S"
+ 
+ function ff_hevc_sao_band_w8_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // offset_table
+-        vpush {d8-d15}
+-        vld1.8  {q0, q1}, [r5] // offset table
++        ldr      r12, [sp, #4]    // offset_table address
++        vld1.8   {q0, q1}, [r12]  // offset table
++        ldr      r12, [sp, #0]    // height
+ 
+-1:      subs    r4, #1
+-        vld1.8   {d24}, [r1], r3
++1:      subs     r12, #1
++        vld1.8   {d24}, [r1,:64], r3
+         vshr.u8  d16, d24, #3
+         vtbl.8   d16, {q0, q1}, d16
+-        vmovl.s8 q2, d16
+         vmovl.u8 q6, d24
+-        vadd.s16 q2, q6
++        vaddw.s8 q6, d16
+         vqmovun.s16 d4, q2
+-        vst1.8  {d4}, [r0], r2
++        vst1.8  {d4}, [r0,:64], r2
+         bne    1b
+ 
+-        vpop  {d8-d15}
+-        pop   {r4-r8}
+         bx lr
+ endfunc
+ 
+ function ff_hevc_sao_band_w16_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // offset_table
+-        vpush {d8-d15}
+-        vld1.8  {q0, q1}, [r5] // offset table
+-
+-1:      subs    r4, #1
+-        vld1.8  {q12}, [r1], r3
++        ldr      r12, [sp, #4]    // offset_table address
++        vld1.8   {q0, q1}, [r12]  // offset table
++        ldr      r12, [sp, #0]    // height
+ 
++1:      subs     r12, #1
++        vld1.8  {q12}, [r1,:128], r3
+         vshr.u8   q8, q12, #3
+-
+         vtbl.8  d16, {q0, q1}, d16
+         vtbl.8  d17, {q0, q1}, d17
+-
+-        vmovl.s8 q2, d16
+-        vmovl.s8 q3, d17
+-
+-        vmovl.u8 q6, d24
+-        vmovl.u8 q7, d25
+-
+-        vadd.s16 q2, q6
+-        vadd.s16 q3, q7
+-
+-        vqmovun.s16 d4, q2
+-        vqmovun.s16 d5, q3
+-
+-        vstm.8   r0, {q2}
+-        add    r0, r2
++        vmovl.u8 q10, d24
++        vmovl.u8 q11, d25
++        vaddw.s8 q10, d16
++        vaddw.s8 q11, d17
++        vqmovun.s16 d4, q10
++        vqmovun.s16 d5, q11
++        vst1.8   {q2}, [r0,:128], r2
+         bne    1b
+ 
+-        vpop  {d8-d15}
+-        pop   {r4-r8}
+         bx lr
+ endfunc
+ 
+ function ff_hevc_sao_band_w32_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // offset_table
+-        vpush {d8-d15}
+-        vld1.8  {q0, q1}, [r5] // offset table
+-
+-1:      subs    r4, #1
+-        vld1.8  {q12-q13}, [r1], r3
+-
+-        vshr.u8   q8, q12, #3
+-        vshr.u8   q9, q13, #3
+-
+-        vtbl.8  d16, {q0, q1}, d16
+-        vtbl.8  d17, {q0, q1}, d17
+-        vtbl.8  d18, {q0, q1}, d18
+-        vtbl.8  d19, {q0, q1}, d19
+-
+-        vmovl.s8 q2, d16
+-        vmovl.s8 q3, d17 // q8 free
+-        vmovl.s8 q4, d18
+-        vmovl.s8 q5, d19 // q9 free
+-
+-        vmovl.u8 q6, d24
+-        vmovl.u8 q7, d25 // q12 free
+-        vmovl.u8 q8, d26
+-        vmovl.u8 q9, d27 // q13 free
+-
+-        vadd.s16 q2, q6
+-        vadd.s16 q3, q7
+-        vadd.s16 q4, q8
+-        vadd.s16 q5, q9
+-
+-        vqmovun.s16 d4, q2
+-        vqmovun.s16 d5, q3
+-        vqmovun.s16 d6, q4 // q4 free
+-        vqmovun.s16 d7, q5 // q5 free
+-
+-        vst1.8 {q2-q3}, [r0], r2
+-        bne    1b
+-
+-        vpop  {d8-d15}
+-        pop   {r4-r8}
+-        bx lr
++        ldr      r12, [sp, #4]    // offset_table address
++        vld1.8   {q0, q1}, [r12]  // offset table
++        ldr      r12, [sp, #0]    // height
++
++1:      subs     r12, #1
++        vld1.8   {q2-q3}, [r1,:128], r3
++        vshr.u8  q8, q2, #3
++        vshr.u8  q9, q3, #3
++        vtbl.8   d16, {q0, q1}, d16
++        vtbl.8   d17, {q0, q1}, d17
++        vtbl.8   d18, {q0, q1}, d18
++        vtbl.8   d19, {q0, q1}, d19
++        vmovl.u8 q12, d4
++        vmovl.u8 q13, d5
++        vmovl.u8 q14, d6
++        vmovl.u8 q15, d7
++        vaddw.s8 q12, d16
++        vaddw.s8 q13, d17
++        vaddw.s8 q14, d18
++        vaddw.s8 q15, d19
++        vqmovun.s16 d4, q12
++        vqmovun.s16 d5, q13
++        vqmovun.s16 d6, q14
++        vqmovun.s16 d7, q15
++        vst1.8   {q2-q3}, [r0,:128], r2
++        bne      1b
++
++        bx       lr
+ endfunc
+ 
+ function ff_hevc_sao_band_w64_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // offset_table
+-        vpush {d8-d15}
+-        vld1.8  {q0, q1}, [r5] // offset table
++        ldr      r12, [sp, #4]    // offset_table address
++        vld1.8   {q0, q1}, [r12]  // offset table
++        ldr      r12, [sp, #0]    // height
+ 
+-1:      subs    r4, #1
+-        vld1.8  {q12-q13}, [r1]!
+-        vld1.8  {q14-q15}, [r1], r3
++1:      subs     r12, #1
++        vld1.8  {q12-q13}, [r1,:128]!
++        vld1.8  {q14-q15}, [r1,:128], r3
+         sub     r1, #32
+ 
+         vshr.u8   q8, q12, #3
+@@ -152,53 +116,41 @@ function ff_hevc_sao_band_w64_neon_8, export=1
+         vtbl.8  d22, {q0, q1}, d22
+         vtbl.8  d23, {q0, q1}, d23
+ 
+-        vmovl.s8 q2, d16
+-        vmovl.s8 q3, d17 // q8 free
+-        vmovl.s8 q4, d18
+-        vmovl.s8 q5, d19 // q9 free
++        vmovl.u8 q2, d24
++        vmovl.u8 q3, d25
++        vmovl.u8 q12, d26
++        vmovl.u8 q13, d27
+ 
+-        vmovl.u8 q6, d24
+-        vmovl.u8 q7, d25 // q12 free
+-        vmovl.u8 q8, d26
+-        vmovl.u8 q9, d27 // q13 free
+-
+-        vadd.s16 q2, q6
+-        vadd.s16 q3, q7
+-        vadd.s16 q4, q8
+-        vadd.s16 q5, q9
++        vaddw.s8 q2, d16
++        vaddw.s8 q3, d17
++        vaddw.s8 q12, d18
++        vaddw.s8 q13, d19
+ 
+         vqmovun.s16 d4, q2
+         vqmovun.s16 d5, q3
+-        vqmovun.s16 d6, q4 // q4 free
+-        vqmovun.s16 d7, q5 // q5 free
+-
+-        // free q4 -q9, q12 - q13
+-        vmovl.s8 q4, d20
+-        vmovl.s8 q5, d21 // q10 free
+-        vmovl.s8 q6, d22
+-        vmovl.s8 q7, d23 // q11 free
+-
+-        vmovl.u8  q8, d28
+-        vmovl.u8  q9, d29 // q14 free
+-        vmovl.u8 q10, d30
+-        vmovl.u8 q11, d31 // q15 free
+-
+-        vadd.s16 q4, q8
+-        vadd.s16 q5, q9
+-        vadd.s16 q6, q10
+-        vadd.s16 q7, q11
+-
+-        vqmovun.s16  d8, q4
+-        vqmovun.s16  d9, q5
+-        vqmovun.s16 d10, q6
+-        vqmovun.s16 d11, q7
+-
+-        vstm.8   r0, {q2-q5}
+-        add    r0, r2
++        vqmovun.s16 d6, q12
++        vqmovun.s16 d7, q13
++
++        vmovl.u8 q12, d28
++        vmovl.u8 q13, d29
++        vmovl.u8 q14, d30
++        vmovl.u8 q15, d31
++
++        vaddw.s8 q12, d20
++        vaddw.s8 q13, d21
++        vaddw.s8 q14, d22
++        vaddw.s8 q15, d23
++
++        vqmovun.s16  d8, q12
++        vqmovun.s16  d9, q13
++        vqmovun.s16 d10, q14
++        vqmovun.s16 d11, q15
++
++        vst1.8     {q2-q3}, [r0,:128]!
++        vst1.8     {q4-q5}, [r0,:128], r2
++        sub    r0, #32
+         bne    1b
+ 
+-        vpop  {d8-d15}
+-        pop   {r4-r8}
+         bx lr
+ endfunc
+ 
+-- 
+2.5.0
+
+
+From 26bd536800db2f50ff6a021e1fda0d0394d1ea01 Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Mon, 29 Dec 2014 15:00:49 +0200
+Subject: [PATCH 5/9] better code reuse in NEON SAO band
+
+---
+ libavcodec/arm/hevcdsp_init_neon.c |  16 ++--
+ libavcodec/arm/hevcdsp_sao_neon.S  | 155 +++++++++++++------------------------
+ 2 files changed, 61 insertions(+), 110 deletions(-)
+
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index c32940e..6379810 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -45,10 +45,10 @@ void ff_hevc_transform_add_16x16_neon_8(uint8_t *_dst, int16_t *coeffs,
+ void ff_hevc_transform_add_32x32_neon_8(uint8_t *_dst, int16_t *coeffs,
+                                       ptrdiff_t stride);
+ 
+-void ff_hevc_sao_band_w8_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
+-void ff_hevc_sao_band_w16_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
+-void ff_hevc_sao_band_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
+-void ff_hevc_sao_band_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t * offset_table);
++void ff_hevc_sao_band_w8_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int8_t * offset_table, int height);
++void ff_hevc_sao_band_w16_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int8_t * offset_table, int height);
++void ff_hevc_sao_band_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int8_t * offset_table, int height);
++void ff_hevc_sao_band_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int8_t * offset_table, int height);
+ 
+ void ff_hevc_sao_edge_eo0_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
+ void ff_hevc_sao_edge_eo1_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
+@@ -185,16 +185,16 @@ static void ff_hevc_sao_band_neon_wrapper(uint8_t *_dst, uint8_t *_src, ptrdiff_
+ 
+     switch(width){
+     case 8:
+-        ff_hevc_sao_band_w8_neon_8(_dst, _src, stride_dst, stride_src, height, offset_table);
++        ff_hevc_sao_band_w8_neon_8(_dst, _src, stride_dst, stride_src, offset_table, height);
+         break;
+     case 16:
+-        ff_hevc_sao_band_w16_neon_8(_dst, _src, stride_dst, stride_src, height, offset_table);
++        ff_hevc_sao_band_w16_neon_8(_dst, _src, stride_dst, stride_src, offset_table, height);
+         break;
+     case 32:
+-        ff_hevc_sao_band_w32_neon_8(_dst, _src, stride_dst, stride_src, height, offset_table);
++        ff_hevc_sao_band_w32_neon_8(_dst, _src, stride_dst, stride_src, offset_table, height);
+         break;
+     case 64:
+-        ff_hevc_sao_band_w64_neon_8(_dst, _src, stride_dst, stride_src, height, offset_table);
++        ff_hevc_sao_band_w64_neon_8(_dst, _src, stride_dst, stride_src, offset_table, height);
+         break;
+     default:
+         for (y = 0; y < height; y++) {
+diff --git a/libavcodec/arm/hevcdsp_sao_neon.S b/libavcodec/arm/hevcdsp_sao_neon.S
+index ac21013..8852550 100644
+--- a/libavcodec/arm/hevcdsp_sao_neon.S
++++ b/libavcodec/arm/hevcdsp_sao_neon.S
+@@ -21,53 +21,13 @@
+ #include "libavutil/arm/asm.S"
+ #include "neon.S"
+ 
+-function ff_hevc_sao_band_w8_neon_8, export=1
+-        ldr      r12, [sp, #4]    // offset_table address
++.macro init_sao_band
++        ldr      r12, [sp, #0]    // offset_table address
+         vld1.8   {q0, q1}, [r12]  // offset table
+-        ldr      r12, [sp, #0]    // height
+-
+-1:      subs     r12, #1
+-        vld1.8   {d24}, [r1,:64], r3
+-        vshr.u8  d16, d24, #3
+-        vtbl.8   d16, {q0, q1}, d16
+-        vmovl.u8 q6, d24
+-        vaddw.s8 q6, d16
+-        vqmovun.s16 d4, q2
+-        vst1.8  {d4}, [r0,:64], r2
+-        bne    1b
+-
+-        bx lr
+-endfunc
+-
+-function ff_hevc_sao_band_w16_neon_8, export=1
+-        ldr      r12, [sp, #4]    // offset_table address
+-        vld1.8   {q0, q1}, [r12]  // offset table
+-        ldr      r12, [sp, #0]    // height
+-
+-1:      subs     r12, #1
+-        vld1.8  {q12}, [r1,:128], r3
+-        vshr.u8   q8, q12, #3
+-        vtbl.8  d16, {q0, q1}, d16
+-        vtbl.8  d17, {q0, q1}, d17
+-        vmovl.u8 q10, d24
+-        vmovl.u8 q11, d25
+-        vaddw.s8 q10, d16
+-        vaddw.s8 q11, d17
+-        vqmovun.s16 d4, q10
+-        vqmovun.s16 d5, q11
+-        vst1.8   {q2}, [r0,:128], r2
+-        bne    1b
+-
+-        bx lr
+-endfunc
+-
+-function ff_hevc_sao_band_w32_neon_8, export=1
+-        ldr      r12, [sp, #4]    // offset_table address
+-        vld1.8   {q0, q1}, [r12]  // offset table
+-        ldr      r12, [sp, #0]    // height
++        ldr      r12, [sp, #4]    // height
++.endm
+ 
+-1:      subs     r12, #1
+-        vld1.8   {q2-q3}, [r1,:128], r3
++.macro sao_band_32
+         vshr.u8  q8, q2, #3
+         vshr.u8  q9, q3, #3
+         vtbl.8   d16, {q0, q1}, d16
+@@ -86,6 +46,43 @@ function ff_hevc_sao_band_w32_neon_8, export=1
+         vqmovun.s16 d5, q13
+         vqmovun.s16 d6, q14
+         vqmovun.s16 d7, q15
++.endm
++
++function ff_hevc_sao_band_w8_neon_8, export=1
++        init_sao_band
++1:      subs     r12, #4
++        vld1.8   {d4}, [r1,:64], r3
++        vld1.8   {d5}, [r1,:64], r3
++        vld1.8   {d6}, [r1,:64], r3
++        vld1.8   {d7}, [r1,:64], r3
++        sao_band_32
++        vst1.8  {d4}, [r0,:64], r2
++        vst1.8  {d5}, [r0,:64], r2
++        vst1.8  {d6}, [r0,:64], r2
++        vst1.8  {d7}, [r0,:64], r2
++        bne    1b
++
++        bx lr
++endfunc
++
++function ff_hevc_sao_band_w16_neon_8, export=1
++        init_sao_band
++1:      subs     r12, #2
++        vld1.8  {q2}, [r1,:128], r3
++        vld1.8  {q3}, [r1,:128], r3
++        sao_band_32
++        vst1.8   {q2}, [r0,:128], r2
++        vst1.8   {q3}, [r0,:128], r2
++        bne    1b
++
++        bx lr
++endfunc
++
++function ff_hevc_sao_band_w32_neon_8, export=1
++        init_sao_band
++1:      subs     r12, #1
++        vld1.8   {q2-q3}, [r1,:128], r3
++        sao_band_32
+         vst1.8   {q2-q3}, [r0,:128], r2
+         bne      1b
+ 
+@@ -93,63 +90,17 @@ function ff_hevc_sao_band_w32_neon_8, export=1
+ endfunc
+ 
+ function ff_hevc_sao_band_w64_neon_8, export=1
+-        ldr      r12, [sp, #4]    // offset_table address
+-        vld1.8   {q0, q1}, [r12]  // offset table
+-        ldr      r12, [sp, #0]    // height
+-
+-1:      subs     r12, #1
+-        vld1.8  {q12-q13}, [r1,:128]!
+-        vld1.8  {q14-q15}, [r1,:128], r3
+-        sub     r1, #32
+-
+-        vshr.u8   q8, q12, #3
+-        vshr.u8   q9, q13, #3
+-        vshr.u8  q10, q14, #3
+-        vshr.u8  q11, q15, #3
+-
+-        vtbl.8  d16, {q0, q1}, d16
+-        vtbl.8  d17, {q0, q1}, d17
+-        vtbl.8  d18, {q0, q1}, d18
+-        vtbl.8  d19, {q0, q1}, d19
+-        vtbl.8  d20, {q0, q1}, d20
+-        vtbl.8  d21, {q0, q1}, d21
+-        vtbl.8  d22, {q0, q1}, d22
+-        vtbl.8  d23, {q0, q1}, d23
+-
+-        vmovl.u8 q2, d24
+-        vmovl.u8 q3, d25
+-        vmovl.u8 q12, d26
+-        vmovl.u8 q13, d27
+-
+-        vaddw.s8 q2, d16
+-        vaddw.s8 q3, d17
+-        vaddw.s8 q12, d18
+-        vaddw.s8 q13, d19
+-
+-        vqmovun.s16 d4, q2
+-        vqmovun.s16 d5, q3
+-        vqmovun.s16 d6, q12
+-        vqmovun.s16 d7, q13
+-
+-        vmovl.u8 q12, d28
+-        vmovl.u8 q13, d29
+-        vmovl.u8 q14, d30
+-        vmovl.u8 q15, d31
+-
+-        vaddw.s8 q12, d20
+-        vaddw.s8 q13, d21
+-        vaddw.s8 q14, d22
+-        vaddw.s8 q15, d23
+-
+-        vqmovun.s16  d8, q12
+-        vqmovun.s16  d9, q13
+-        vqmovun.s16 d10, q14
+-        vqmovun.s16 d11, q15
+-
+-        vst1.8     {q2-q3}, [r0,:128]!
+-        vst1.8     {q4-q5}, [r0,:128], r2
+-        sub    r0, #32
+-        bne    1b
++        init_sao_band
++1:      subs      r12, #1
++        vld1.8    {q2-q3}, [r1,:128]!
++        sao_band_32
++        vst1.8    {q2-q3}, [r0,:128]!
++        vld1.8    {q2-q3}, [r1,:128], r3
++        sub       r1, #32
++        sao_band_32
++        vst1.8    {q2-q3}, [r0,:128], r2
++        sub       r0, #32
++        bne       1b
+ 
+         bx lr
+ endfunc
+-- 
+2.5.0
+
+
+From f93646a97bc885b81759e774d04be3781916a3e7 Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Wed, 7 Jan 2015 15:27:38 +0200
+Subject: [PATCH 6/9] More SAO NEON optimizations Now uses only 8 bit integers
+ for SAO calculations
+
+---
+ libavcodec/arm/hevcdsp_init_neon.c |   7 +-
+ libavcodec/arm/hevcdsp_sao_neon.S  | 664 +++++++++++++++----------------------
+ 2 files changed, 272 insertions(+), 399 deletions(-)
+
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index 6379810..8d6e863 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -225,7 +225,7 @@ static void ff_hevc_sao_edge_neon_wrapper(uint8_t *_dst /* align 16 */, uint8_t
+     int x, y;
+ 
+     for (x = 0; x < 5; x++) {
+-        sao_offset_val[x] = _sao_offset_val[x];
++        sao_offset_val[x] = _sao_offset_val[edge_idx[x]];
+     }
+ 
+     stride_src /= sizeof(pixel);
+@@ -271,8 +271,9 @@ static void ff_hevc_sao_edge_neon_wrapper(uint8_t *_dst /* align 16 */, uint8_t
+             for (x = 0; x < width; x++) {
+                 int diff0         = CMP(src[x], src[x + a_stride]);
+                 int diff1         = CMP(src[x], src[x + b_stride]);
+-                int offset_val    = edge_idx[2 + diff0 + diff1];
+-                dst[x] = av_clip_pixel(src[x] + sao_offset_val[offset_val]);
++                int idx           = diff0 + diff1;
++                if (idx)
++                    dst[x] = av_clip_pixel(src[x] + sao_offset_val[idx+2]);
+             }
+             src += stride_src;
+             dst += stride_dst;
+diff --git a/libavcodec/arm/hevcdsp_sao_neon.S b/libavcodec/arm/hevcdsp_sao_neon.S
+index 8852550..5fc482b 100644
+--- a/libavcodec/arm/hevcdsp_sao_neon.S
++++ b/libavcodec/arm/hevcdsp_sao_neon.S
+@@ -1,5 +1,5 @@
+ /*
+- * Copyright (c) 2014 Seppo Tomperi <seppo.tomperi@vtt.fi>
++ * Copyright (c) 2014 - 2015 Seppo Tomperi <seppo.tomperi@vtt.fi>
+  *
+  * This file is part of FFmpeg.
+  *
+@@ -23,6 +23,7 @@
+ 
+ .macro init_sao_band
+         ldr      r12, [sp, #0]    // offset_table address
++        pld      [r1]
+         vld1.8   {q0, q1}, [r12]  // offset table
+         ldr      r12, [sp, #4]    // height
+ .endm
+@@ -30,36 +31,31 @@
+ .macro sao_band_32
+         vshr.u8  q8, q2, #3
+         vshr.u8  q9, q3, #3
++        vmov.u8  q14, #128
+         vtbl.8   d16, {q0, q1}, d16
+         vtbl.8   d17, {q0, q1}, d17
+         vtbl.8   d18, {q0, q1}, d18
+         vtbl.8   d19, {q0, q1}, d19
+-        vmovl.u8 q12, d4
+-        vmovl.u8 q13, d5
+-        vmovl.u8 q14, d6
+-        vmovl.u8 q15, d7
+-        vaddw.s8 q12, d16
+-        vaddw.s8 q13, d17
+-        vaddw.s8 q14, d18
+-        vaddw.s8 q15, d19
+-        vqmovun.s16 d4, q12
+-        vqmovun.s16 d5, q13
+-        vqmovun.s16 d6, q14
+-        vqmovun.s16 d7, q15
++        vadd.s8  q2, q14
++        vadd.s8  q3, q14
++        vqadd.s8 q2, q8
++        vqadd.s8 q3, q9
++        vsub.s8  q2, q14
++        vsub.s8  q3, q14
+ .endm
+ 
+ function ff_hevc_sao_band_w8_neon_8, export=1
+         init_sao_band
+ 1:      subs     r12, #4
+-        vld1.8   {d4}, [r1,:64], r3
+-        vld1.8   {d5}, [r1,:64], r3
+-        vld1.8   {d6}, [r1,:64], r3
+-        vld1.8   {d7}, [r1,:64], r3
++        vld1.8   {d4}, [r1, :64], r3
++        vld1.8   {d5}, [r1, :64], r3
++        vld1.8   {d6}, [r1, :64], r3
++        vld1.8   {d7}, [r1, :64], r3
+         sao_band_32
+-        vst1.8  {d4}, [r0,:64], r2
+-        vst1.8  {d5}, [r0,:64], r2
+-        vst1.8  {d6}, [r0,:64], r2
+-        vst1.8  {d7}, [r0,:64], r2
++        vst1.8  {d4}, [r0, :64], r2
++        vst1.8  {d5}, [r0, :64], r2
++        vst1.8  {d6}, [r0, :64], r2
++        vst1.8  {d7}, [r0, :64], r2
+         bne    1b
+ 
+         bx lr
+@@ -68,11 +64,11 @@ endfunc
+ function ff_hevc_sao_band_w16_neon_8, export=1
+         init_sao_band
+ 1:      subs     r12, #2
+-        vld1.8  {q2}, [r1,:128], r3
+-        vld1.8  {q3}, [r1,:128], r3
++        vld1.8  {q2}, [r1, :128], r3
++        vld1.8  {q3}, [r1, :128], r3
+         sao_band_32
+-        vst1.8   {q2}, [r0,:128], r2
+-        vst1.8   {q3}, [r0,:128], r2
++        vst1.8   {q2}, [r0, :128], r2
++        vst1.8   {q3}, [r0, :128], r2
+         bne    1b
+ 
+         bx lr
+@@ -81,9 +77,9 @@ endfunc
+ function ff_hevc_sao_band_w32_neon_8, export=1
+         init_sao_band
+ 1:      subs     r12, #1
+-        vld1.8   {q2-q3}, [r1,:128], r3
++        vld1.8   {q2-q3}, [r1, :128], r3
+         sao_band_32
+-        vst1.8   {q2-q3}, [r0,:128], r2
++        vst1.8   {q2-q3}, [r0, :128], r2
+         bne      1b
+ 
+         bx       lr
+@@ -92,263 +88,153 @@ endfunc
+ function ff_hevc_sao_band_w64_neon_8, export=1
+         init_sao_band
+ 1:      subs      r12, #1
+-        vld1.8    {q2-q3}, [r1,:128]!
++        pld       [r1, r3]
++        vld1.8    {q2-q3}, [r1, :128]!
+         sao_band_32
+-        vst1.8    {q2-q3}, [r0,:128]!
+-        vld1.8    {q2-q3}, [r1,:128], r3
++        vst1.8    {q2-q3}, [r0, :128]!
++        vld1.8    {q2-q3}, [r1, :128], r3
+         sub       r1, #32
+         sao_band_32
+-        vst1.8    {q2-q3}, [r0,:128], r2
++        vst1.8    {q2-q3}, [r0, :128], r2
+         sub       r0, #32
+         bne       1b
+ 
+         bx lr
+ endfunc
+-
++// input
++// a in q0 - q3
++// c in q4 - q7
++// b in q8 - q11
++// offset table in r7 and r5
++// output in q0 - q3
++// clobbers q12 - q15
+ .macro edge_w64_body
+-        vcgt.u8 q12, q4, q0 // c > a -> -1 , otherwise 0
+-        vcgt.u8 q0,  q0, q4 // a > c -> -1 , otherwise 0
+-        vcgt.u8 q13, q5, q1
+-        vcgt.u8 q1,  q1, q5
+-        vcgt.u8 q14, q6, q2
+-        vcgt.u8 q2,  q2, q6
+-        vcgt.u8 q15, q7, q3
+-        vcgt.u8 q3,  q3, q7
+-
+-        vsub.s8 q12, q0, q12 // diff0
+-        vsub.s8 q13, q1, q13
+-        vsub.s8 q14, q2, q14
+-        vsub.s8 q15, q3, q15
+-
++        vcgt.u8 q12,  q4, q0 // c > a -> -1 , otherwise 0
++        vcgt.u8  q0,  q0, q4 // a > c -> -1 , otherwise 0
++        vcgt.u8 q13,  q5, q1
++        vcgt.u8  q1,  q1, q5
++        vsub.s8 q12,  q0, q12 // diff0
+         vcgt.u8  q0,  q4, q8 // c > b
+-        vcgt.u8  q8,  q8, q4 // b > c
++        vsub.s8 q13,  q1, q13
++
++        vcgt.u8 q14,  q8, q4 // b > c
+         vcgt.u8  q1,  q5, q9
+-        vcgt.u8  q9,  q9, q5
+-        vcgt.u8  q2,  q6, q10
+-        vcgt.u8 q10, q10, q6
+-        vcgt.u8  q3,  q7, q11
+-        vcgt.u8 q11, q11, q7
++        vcgt.u8 q15,  q9, q5
++        vsub.s8  q0, q14, q0 // diff1
+ 
+-        vsub.s8 q0, q8, q0 // diff1
+-        vsub.s8 q1, q9, q1
+-        vsub.s8 q2, q10, q2
+-        vsub.s8 q3, q11, q3
++        vsub.s8  q1, q15, q1
+ 
+-        vadd.s8 q0, q12 //diff0 + diff1
+-        vadd.s8 q1, q13
+-        vadd.s8 q2, q14
+-        vadd.s8 q3, q15
+-
+-        vdup.s8 q9, r6 // 3 to all elements
+-        sub     r6, #1
+-
+-        vclt.s8 q12, q0, #0 // diff0 + diff1 < 0
+-        vclt.s8 q13, q1, #0
+-        vclt.s8 q14, q2, #0
+-        vclt.s8 q15, q3, #0
+-
+-        vadd.s8  q8,  q0, q9 // diff0 + diff1 + 3
+-        vadd.s8  q10,  q1, q9
+-        vand.8   q12, q8, q12 // if (diff0 + diff1 < 0) then (diff0 + diff1 + 3) else 0
+-        vand.8   q13, q10, q13
+-        vadd.s8  q8,  q2, q9
+-        vadd.s8  q10,  q3, q9
+-        vand.8   q14, q8, q14
+-        vand.8   q15, q10, q15
+-
+-        vdup.s8 q9, r6  // 2 to all elements
+-        add     r6, #1
+-
+-        vcgt.s8  q10, q0, #0 // diff0 + diff1 > 0
+-        vadd.s8   q8, q0, q9 // diff0 + diff1 + 2
+-        vand.8   q11, q8, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
+-        vcgt.s8  q10, q1, #0
+-        vadd.s8   q0, q11, q12  // offset_idx
+-
+-        vadd.s8   q8, q1, q9 // diff0 + diff1 + 2
+-        vcgt.s8  q12, q2, #0
+-        vand.8   q11, q8, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
+-        vadd.s8   q8, q2, q9 // diff0 + diff1 + 2
+-        vadd.s8   q1, q11, q13
+-
+-        vand.8   q11, q8, q12 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
+-        vcgt.s8  q10, q3, #0
+-        vadd.s8   q2, q11, q14
+-
+-        vadd.s8   q8, q3, q9 // diff0 + diff1 + 2
+-        vmov.32  d18[0], r7  // load offset table from general registers
+-        vand.8   q11, q8, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
+-        vmov.32  d18[1], r5  // load rest of offset table
+-        vadd.s8   q3, q11, q15
+-
+-        vtbl.8   d0, {d18}, d0
+-        vtbl.8   d1, {d18}, d1
+-        vtbl.8   d2, {d18}, d2
+-        vtbl.8   d3, {d18}, d3
+-        vtbl.8   d4, {d18}, d4
+-        vtbl.8   d5, {d18}, d5
+-        vtbl.8   d6, {d18}, d6
+-        vtbl.8   d7, {d18}, d7
+-
+-        vmovl.u8   q8, d8
+-        vmovl.u8   q9, d9
+-        vmovl.u8  q10, d10
+-        vmovl.u8  q11, d11
+-        vmovl.u8  q12, d12
+-        vmovl.u8  q13, d13
+-        vmovl.u8  q14, d14
+-        vmovl.u8  q15, d15
+-
+-        vaddw.s8  q8, d0
+-        vaddw.s8  q9, d1
+-        vaddw.s8 q10, d2
+-        vaddw.s8 q11, d3
+-        vaddw.s8 q12, d4
+-        vaddw.s8 q13, d5
+-        vaddw.s8 q14, d6
+-        vaddw.s8 q15, d7
+-
+-        vqmovun.s16  d0, q8
+-        vqmovun.s16  d1, q9
+-        vqmovun.s16  d2, q10
+-        vqmovun.s16  d3, q11
+-        vqmovun.s16  d4, q12
+-        vqmovun.s16  d5, q13
+-        vqmovun.s16  d6, q14
+-        vqmovun.s16  d7, q15
+-
+-        vstm r0, {q0-q3}
+-        add  r0, r2
+-.endm
++        vadd.s8  q0, q12 //diff0 + diff1
++        vadd.s8  q1, q13
+ 
+-.macro edge_w32_body
+-        vcgt.u8 q12, q4, q0 // c > a -> -1 , otherwise 0
+-        vcgt.u8 q0,  q0, q4 // a > c -> -1 , otherwise 0
+-        vcgt.u8 q13, q5, q1
+-        vcgt.u8 q1,  q1, q5
++        vcgt.u8 q14,  q6, q2
++        vcgt.u8  q2,  q2, q6
++        vcgt.u8 q15,  q7, q3
++        vcgt.u8  q3,  q3, q7
+ 
+-        vsub.s8 q12, q0, q12 // diff0
+-        vcgt.u8  q0,  q4, q8 // c > b
+-        vsub.s8 q13, q1, q13 // diff0 part 2
++        vsub.s8 q14,  q2, q14
++        vcgt.u8  q2,  q6, q10
++        vsub.s8 q15,  q3, q15
+ 
+-        vcgt.u8  q6,  q8, q4 // b > c
+-        vcgt.u8  q1,  q5, q9
+-        vcgt.u8  q7,  q9, q5
++        vcgt.u8 q12, q10, q6
++        vcgt.u8  q3,  q7, q11
++        vcgt.u8 q13, q11, q7
++        vsub.s8  q2, q12, q2
++        vsub.s8  q3, q13, q3
+ 
+-        vsub.s8 q0, q6, q0 // diff1
+-        vsub.s8 q1, q7, q1 // diff1 part 2
+-        vadd.s8 q0, q12 //diff0 + diff1
++        vmov.s8 q13, #2 // 2 to all elements
+ 
+-        vdup.s8 q7, r6 // 3 to all elements
+-        sub     r6, #1
+-        vadd.s8 q1, q13
++        vadd.s8  q2, q14
++        vadd.s8  q3, q15
++
++        vmov.32  d24[0], r4  // load offset table from general registers
++        vmov.32  d24[1], r5  // load rest of offset table
+ 
+-        vclt.s8 q12, q0, #0 // diff0 + diff1 < 0
+-        vclt.s8 q13, q1, #0
+-
+-        vadd.s8  q6,  q0, q7 // diff0 + diff1 + 3
+-        vadd.s8  q10,  q1, q7
+-        vdup.s8 q7, r6  // 2 to all elements
+-        add     r6, #1
+-        vand.8   q12, q6, q12 // if (diff0 + diff1 < 0) then (diff0 + diff1 + 3) else 0
+-        vand.8   q13, q10, q13
+-
+-
+-        vcgt.s8  q10, q0, #0 // diff0 + diff1 > 0
+-        vadd.s8   q6, q0, q7 // diff0 + diff1 + 2
+-        vand.8   q11, q6, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
+-        vcgt.s8  q10, q1, #0
+-        vadd.s8   q0, q11, q12  // offset_idx
+-
+-        vadd.s8   q6, q1, q7 // diff0 + diff1 + 2
+-        vmov.32  d14[0], r7  // load offset table from general registers
+-        vand.8   q11, q6, q10 // if (diff0 + diff1 > 0) then (diff0 + diff1 + 2) else 0
+-        vmov.32  d14[1], r5  // load rest of offset table
+-        vadd.s8   q1, q11, q13
+-
+-        vtbl.8   d0, {d14}, d0
+-        vtbl.8   d1, {d14}, d1
+-        vtbl.8   d2, {d14}, d2
+-        vtbl.8   d3, {d14}, d3
+-
+-        vmovl.u8   q6, d8
+-        vmovl.u8   q7, d9
+-        vmovl.u8  q10, d10
+-        vmovl.u8  q11, d11
+-
+-        vaddw.s8  q6, d0
+-        vaddw.s8  q7, d1
+-        vaddw.s8 q10, d2
+-        vaddw.s8 q11, d3
+-
+-        vqmovun.s16  d0, q6
+-        vqmovun.s16  d1, q7
+-        vqmovun.s16  d2, q10
+-        vqmovun.s16  d3, q11
+-
+-        vstm r0, {q0-q1}
+-        add  r0, r2
++        vadd.s8 q0, q13
++        vadd.s8 q1, q13
++        vadd.s8 q2, q13
++        vadd.s8 q3, q13
++
++        vmov.u8  q15, #128 // s8 #-128
++        vtbl.8   d0, {d24}, d0
++        vtbl.8   d1, {d24}, d1
++        vtbl.8   d2, {d24}, d2
++        vtbl.8   d3, {d24}, d3
++        vtbl.8   d4, {d24}, d4
++        vtbl.8   d5, {d24}, d5
++        vtbl.8   d6, {d24}, d6
++        vtbl.8   d7, {d24}, d7
++
++        vadd.s8  q12,  q4, q15
++        vadd.s8  q13,  q5, q15
++        vadd.s8  q14,  q6, q15
++        vadd.s8  q15,  q7, q15
++        vqadd.s8 q12,  q0
++        vqadd.s8 q15,  q3
++        vmov.u8   q3, #128 // s8 #-128
++        vqadd.s8 q13,  q1
++        vqadd.s8 q14,  q2
++        vsub.s8   q0, q12, q3
++        vsub.s8   q1, q13, q3
++        vsub.s8   q2, q14, q3
++        vsub.s8   q3, q15, q3
++        vst1.8  {q0-q1}, [r0, :128]!
++        vst1.8  {q2-q3}, [r0, :128], r2
++        sub     r0, #32
+ .endm
+ 
+-function ff_hevc_sao_edge_eo0_w64_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // sao_offset_val_table
+-        ldr    r6, =0x03
+-        ldr    r7, [r5]
++.macro init_edge_64
++        push   {r4-r5}
++        ldr    r12, [sp, #8] // height
++        ldr    r5, [sp, #12] // sao_offset_val_table
++        ldr    r4, [r5]
+         add    r5, #4
+         ldr    r5, [r5]
++.endm
++
++function ff_hevc_sao_edge_eo0_w64_neon_8, export=1
++        init_edge_64
+         vpush {d8-d15}
+         sub    r1, #8
+-1:      subs    r4, #1
+-        vld1.64  {q10-q11}, [r1]!
+-        vld1.64  {q12-q13}, [r1]!
+-        vld1.64  {q14}, [r1], r3
+-        sub      r1, #64
++1:      subs    r12, #1
++        vld1.64  {d7}, [r1, :64]!
++        vld1.64  {q4-q5}, [r1, :128]! // load c
++        vld1.64  {q6-q7}, [r1, :128]!
++        vld1.64  {d24}, [r1, :64], r3
++        sub      r1, #72
+         // load a
+-        vext.8 q0, q10, q11, #7
+-        vext.8 q1, q11, q12, #7
+-        vext.8 q2, q12, q13, #7
+-        vext.8 q3, q13, q14, #7
+-        // load c
+-        vext.8 q4, q10, q11, #8
+-        vext.8 q5, q11, q12, #8
+-        vext.8 q6, q12, q13, #8
+-        vext.8 q7, q13, q14, #8
++        vext.8 q0, q3, q4, #15
++        vext.8 q1, q4, q5, #15
++        vext.8 q2, q5, q6, #15
++        vext.8 q3, q6, q7, #15
+         // load b
+-        vext.8 q8, q10, q11, #9
+-        vext.8 q9, q11, q12, #9
+-        vext.8 q10, q12, q13, #9
+-        vext.8 q11, q13, q14, #9
++        vext.8 q8, q4, q5, #1
++        vext.8 q9, q5, q6, #1
++        vext.8 q10, q6, q7, #1
++        vext.8 q11, q7, q12, #1
+         edge_w64_body
+         bne   1b
+         vpop  {d8-d15}
+-        pop   {r4-r8}
++        pop   {r4-r5}
+         bx lr
+ endfunc
+ 
+ function ff_hevc_sao_edge_eo1_w64_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // sao_offset_val_table
+-        ldr    r6, =0x03
+-        ldr    r7, [r5]
+-        add    r5, #4
+-        ldr    r5, [r5]
++        init_edge_64
+         vpush {d8-d15}
+         sub     r1, r3
+         // load a
+-        vld1.8  {q0-q1}, [r1]!
+-        vld1.8  {q2-q3}, [r1], r3
++        vld1.8  {q0-q1}, [r1, :128]!
++        vld1.8  {q2-q3}, [r1, :128], r3
+         sub     r1, #32
+-1:      subs    r4, #1
+         // load c
+-        vld1.8  {q4-q5}, [r1]!
+-        vld1.8  {q6-q7}, [r1], r3
++        vld1.8  {q4-q5}, [r1, :128]!
++        vld1.8  {q6-q7}, [r1, :128], r3
+         sub     r1, #32
++1:      subs    r12, #1
+         // load b
+-        vld1.8  {q8-q9}, [r1]!
+-        vld1.8  {q10-q11}, [r1]
++        vld1.8  {q8-q9}, [r1, :128]!
++        vld1.8  {q10-q11}, [r1, :128], r3
+         sub     r1, #32
+         edge_w64_body
+         // copy c to a
+@@ -356,20 +242,19 @@ function ff_hevc_sao_edge_eo1_w64_neon_8, export=1
+         vmov.64 q1, q5
+         vmov.64 q2, q6
+         vmov.64 q3, q7
++        // copy b to c
++        vmov.64 q4, q8
++        vmov.64 q5, q9
++        vmov.64 q6, q10
++        vmov.64 q7, q11
+         bne   1b
+         vpop  {d8-d15}
+-        pop   {r4-r8}
++        pop   {r4-r5}
+         bx lr
+ endfunc
+ 
+ function ff_hevc_sao_edge_eo2_w64_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // sao_offset_val_table
+-        ldr    r6, =0x03
+-        ldr    r7, [r5]
+-        add    r5, #4
+-        ldr    r5, [r5]
++        init_edge_64
+         vpush {d8-d15}
+ 1:      sub     r1, r3
+         // load a
+@@ -379,10 +264,10 @@ function ff_hevc_sao_edge_eo2_w64_neon_8, export=1
+         vld1.8  {q0-q1}, [r1]!
+         vld1.8  {q2-q3}, [r1], r3
+         sub     r1, #31
+-        subs    r4, #1
++        subs    r12, #1
+         // load c
+-        vld1.8  {q4-q5}, [r1]!
+-        vld1.8  {q6-q7}, [r1], r3
++        vld1.8  {q4-q5}, [r1, :128]!
++        vld1.8  {q6-q7}, [r1, :128], r3
+         sub     r1, #32
+         // load b
+         add     r1, #1
+@@ -390,25 +275,14 @@ function ff_hevc_sao_edge_eo2_w64_neon_8, export=1
+         vld1.8  {q10-q11}, [r1]
+         sub     r1, #33
+         edge_w64_body
+-        // copy c to a
+-        vmov.64 q0, q4
+-        vmov.64 q1, q5
+-        vmov.64 q2, q6
+-        vmov.64 q3, q7
+         bne   1b
+         vpop  {d8-d15}
+-        pop   {r4-r8}
++        pop   {r4-r5}
+         bx lr
+ endfunc
+ 
+ function ff_hevc_sao_edge_eo3_w64_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // sao_offset_val_table
+-        ldr    r6, =0x03
+-        ldr    r7, [r5]
+-        add    r5, #4
+-        ldr    r5, [r5]
++        init_edge_64
+         vpush {d8-d15}
+ 1:      sub     r1, r3
+         // load a
+@@ -418,10 +292,10 @@ function ff_hevc_sao_edge_eo3_w64_neon_8, export=1
+         vld1.8  {q0-q1}, [r1]!
+         vld1.8  {q2-q3}, [r1], r3
+         sub     r1, #33
+-        subs    r4, #1
++        subs    r12, #1
+         // load c
+-        vld1.8  {q4-q5}, [r1]!
+-        vld1.8  {q6-q7}, [r1], r3
++        vld1.8  {q4-q5}, [r1, :128]!
++        vld1.8  {q6-q7}, [r1, :128], r3
+         sub     r1, #32
+         // load b
+         sub     r1, #1
+@@ -429,178 +303,176 @@ function ff_hevc_sao_edge_eo3_w64_neon_8, export=1
+         vld1.8  {q10-q11}, [r1]
+         sub     r1, #31
+         edge_w64_body
+-        // copy c to a
+-        vmov.64 q0, q4
+-        vmov.64 q1, q5
+-        vmov.64 q2, q6
+-        vmov.64 q3, q7
+         bne   1b
+         vpop  {d8-d15}
+-        pop   {r4-r8}
++        pop   {r4-r5}
+         bx lr
+ endfunc
+ 
++// inputs:
++// a in q0, q1
++// c in q2, q3
++// b in q8, q9
++// offset table in d31
++// clobbered registers q0, q1, q10, q11, q12, q13
++// output q0, q1
++.macro edge_w32_body
++        vcgt.u8 q12, q2, q0 // c > a -> -1 , otherwise 0
++        vcgt.u8 q0,  q0, q2 // a > c -> -1 , otherwise 0
++        vcgt.u8 q13, q3, q1
++        vcgt.u8 q1,  q1, q3
++
++        vsub.s8 q12, q0, q12 // diff0
++        vcgt.u8  q0,  q2, q8 // c > b
++        vsub.s8 q13, q1, q13 // diff0 part 2
++
++        vcgt.u8  q10,  q8, q2 // b > c
++        vcgt.u8  q1,  q3, q9
++        vcgt.u8  q11,  q9, q3
++
++        vsub.s8 q0, q10, q0 // diff1
++
++        vmov.s8 q10, #2 // 2 to all elements
++        vsub.s8 q1, q11, q1 // diff1 part 2
++        vadd.s8 q0, q12 //diff0 + diff1
++        vadd.s8 q1, q13
++
++        vadd.s8 q0, q10
++        vadd.s8 q1, q10
++
++        vmov.u8  q10, #128
++        vtbl.8   d0, {d31}, d0
++        vtbl.8   d1, {d31}, d1
++        vtbl.8   d2, {d31}, d2
++        vtbl.8   d3, {d31}, d3
++
++        vadd.s8    q11, q2, q10
++        vadd.s8    q12, q3, q10
++        vqadd.s8   q11, q0
++        vqadd.s8   q12, q1
++        vsub.s8    q0, q11, q10
++        vsub.s8    q1, q12, q10
++        vst1.8   {q0-q1}, [r0, :128], r2
++.endm
++
++.macro init_edge_32
++        ldr     r12, [sp, #4] // sao_offset_val_table
++        vld1.32 {d31}, [r12]
++        ldr     r12, [sp] // height
++.endm
++
+ function ff_hevc_sao_edge_eo0_w32_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // sao_offset_val_table
+-        ldr    r6, =0x03
+-        ldr    r7, [r5]
+-        add    r5, #4
+-        ldr    r5, [r5]
+-        vpush {d8-d15}
+-        sub    r1, #8 // load 8 extra bytes
+-1:      subs    r4, #1
+-        vld1.8  {q10-q11}, [r1]
+-        add    r1, #32
+-        vld1.8  {q12}, [r1], r3 // only first 9 bytes are used
+-        sub    r1, #32
++        init_edge_32
++        sub     r1, #4 // load 4 extra bytes
++1:      subs    r12, #1
++        vld1.32 d3[1], [r1]!
++        vld1.8  {q2-q3}, [r1, :128]! // c
++        vld1.32 d20[0], [r1], r3
++        sub     r1, #36
+         // a
+-        vext.8  q0, q10, q11, #7
+-        vext.8  q1, q11, q12, #7
+-        // c
+-        vext.8  q4, q10, q11, #8
+-        vext.8  q5, q11, q12, #8
++        vext.8  q0, q1, q2, #15
++        vext.8  q1, q2, q3, #15
+         // b
+-        vext.8  q8, q10, q11, #9
+-        vext.8  q9, q11, q12, #9
++        vext.8  q8, q2, q3, #1
++        vext.8  q9, q3, q10, #1
+         edge_w32_body
+-        bne   1b
+-        vpop  {d8-d15}
+-        pop   {r4-r8}
+-        bx lr
++        bne     1b
++        bx      lr
+ endfunc
+ 
+ function ff_hevc_sao_edge_eo1_w32_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // sao_offset_val_table
+-        ldr    r6, =0x03
+-        ldr    r7, [r5]
+-        add    r5, #4
+-        ldr    r5, [r5]
+-        vpush {d8-d15}
++        init_edge_32
+         // load a
+         sub     r1, r3
+-        vld1.8  {q0-q1}, [r1], r3
++        vld1.8  {q0-q1}, [r1, :128], r3
+         // load c
+-        vld1.8  {q4-q5}, [r1], r3
+-1:      subs    r4, #1
++        vld1.8  {q2-q3}, [r1, :128], r3
++1:      subs    r12, #1
+         // load b
+-        vld1.8  {q8-q9}, [r1], r3
++        vld1.8  {q8-q9}, [r1, :128], r3
+         edge_w32_body
+         // inputs for next loop iteration
+         // a
+-        vmov.64 q0, q4
+-        vmov.64 q1, q5
++        vmov.64 q0, q2
++        vmov.64 q1, q3
+         // c
+-        vmov.64 q4, q8
+-        vmov.64 q5, q9
+-        bne   1b
+-        vpop  {d8-d15}
+-        pop   {r4-r8}
+-        bx lr
++        vmov.64 q2, q8
++        vmov.64 q3, q9
++        bne     1b
++        bx      lr
+ endfunc
+ 
+ function ff_hevc_sao_edge_eo2_w32_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // sao_offset_val_table
+-        ldr    r6, =0x03
+-        ldr    r7, [r5]
+-        add    r5, #4
+-        ldr    r5, [r5]
+-        vpush {d8-d15}
++        init_edge_32
++        vpush   {d8-d15}
+         // load a
+         sub     r1, r3
+-        sub    r1, #8
+-        vld1.8  {q10-q11}, [r1]
+-        add    r1, #32
+-        vld1.8  {q12}, [r1], r3
+-        sub    r1, #32
++        sub     r1, #8
++        vld1.8  {q10-q11}, [r1, :64]!
++        vld1.8  {d24}, [r1, :64], r3
++        sub     r1, #32
+         vext.8  q0, q10, q11, #7
+         vext.8  q1, q11, q12, #7
+         // load c
+-        vld1.8  {q10-q11}, [r1]
+-        add    r1, #32
+-        vld1.8  {q12}, [r1], r3
+-        sub    r1, #32
+-        vext.8  q4, q10, q11, #8
+-        vext.8  q5, q11, q12, #8
+-        vext.8  q2, q10, q11, #7
+-1:      subs    r4, #1
++        vld1.8  {d9}, [r1, :64]!
++        vld1.8  {q2-q3}, [r1, :64], r3
++        sub     r1, #8
++        vext.8  q4, q4, q2, #15
++1:      subs    r12, #1
+         // load b
+-        vld1.8  {q10-q11}, [r1]
+-        add    r1, #32
+-        vld1.8  {q12}, [r1], r3
+-        sub    r1, #32
++        vld1.8  {q10-q11}, [r1, :64]!
++        vld1.8  {q12}, [r1, :64], r3
++        sub     r1, #32
+         vext.8  q8, q10, q11, #9
+         vext.8  q9, q11, q12, #9
+-        vext.8  q14, q10, q11, #8
+-        vext.8  q15, q11, q12, #8
+-        vext.8  q3, q10, q11, #7
++        vext.8  q6, q10, q11, #8
++        vext.8  q7, q11, q12, #8
++        vext.8  q5, q10, q11, #7
+         edge_w32_body
+         // inputs for next loop iteration
+         // a
+-        vmov.8 q0, q2
+-        vext.8 q1, q4, q5, #15
++        vmov.8  q0, q4
++        vext.8  q1, q2, q3, #15
+         // c
+-        vmov.8  q4, q14
+-        vmov.8  q5, q15
+-        vmov.8  q2, q3
+-        bne   1b
+-        vpop  {d8-d15}
+-        pop   {r4-r8}
+-        bx lr
++        vmov.8  q2, q6
++        vmov.8  q3, q7
++        vmov.8  q4, q5
++        bne     1b
++        vpop    {d8-d15}
++        bx      lr
+ endfunc
+ 
+ function ff_hevc_sao_edge_eo3_w32_neon_8, export=1
+-        push  {r4-r8}
+-        ldr    r4, [sp, #20] // height
+-        ldr    r5, [sp, #24] // sao_offset_val_table
+-        ldr    r6, =0x03
+-        ldr    r7, [r5]
+-        add    r5, #4
+-        sub    r1, r3
+-        ldr    r5, [r5]
+-        sub    r1, #8
+-        vpush {d8-d15}
++        init_edge_32
++        sub     r1, r3
+         // load a
+-        vld1.8  {q10-q11}, [r1]
+-        add    r1, #32
+-        vld1.8  {q12}, [r1], r3
+-        sub    r1, #32
+-        vext.8  q0, q10, q11, #9
+-        vext.8  q1, q11, q12, #9
++        vld1.8  {q10-q11}, [r1, :64]!
++        vld1.8  {d24}, [r1, :64], r3
++        sub     r1, #32
++        vext.8  q0, q10, q11, #1
++        vext.8  q1, q11, q12, #1
+         // load c
+-        vld1.8  {q10-q11}, [r1]
+-        add    r1, #32
+-        vld1.8  {q12}, [r1], r3
+-        sub    r1, #32
+-        vext.8  q4, q10, q11, #8
+-        vext.8  q5, q11, q12, #8
+-        vext.8  q2, q12, q11, #8
+-1:      subs    r4, #1
++        vld1.8  {q2-q3}, [r1, :64]!
++        vld1.8  {d30}, [r1, :64], r3
++        sub     r1, #40
++1:      subs    r12, #1
+         // load b
+-        vld1.8  {q10-q11}, [r1]
+-        add    r1, #32
+-        vld1.8  {q12}, [r1], r3
+-        sub    r1, #32
++        vld1.8  {q10-q11}, [r1, :64]!
++        vld1.8  {q12}, [r1, :64], r3
++        sub     r1, #32
+         vext.8  q8, q10, q11, #7
+         vext.8  q9, q11, q12, #7
+-        vext.8  q3, q12, q10, #7
++        vext.8  q14, q12, q10, #7
+         edge_w32_body
+         // inputs for next loop iteration
+         // a
+-        vext.8 q0, q4, q5, #1
+-        vext.8 q1, q5, q2, #1
++        vext.8  q0, q2, q3, #1
++        vext.8  q1, q3, q15, #1
+         // c
+-        vext.8  q4, q8, q9, #1
+-        vext.8  q5, q9, q3, #1
+-        vext.8  q2, q3, q1, #1
+-        bne   1b
+-        vpop  {d8-d15}
+-        pop   {r4-r8}
+-        bx lr
++        vext.8  q2, q8, q9, #1
++        vext.8  q3, q9, q14, #1
++        vext.8  d30, d28, d2, #1
++        bne     1b
++        bx      lr
+ endfunc
+ 
+-- 
+2.5.0
+
+
+From 016c39d46b86830204a4519590332d2a38f7ee51 Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Thu, 8 Jan 2015 09:58:55 +0200
+Subject: [PATCH 7/9] small optimization to SAO BAND. correct path for
+ bit_depth_template.c
+
+---
+ libavcodec/arm/hevcdsp_init_neon.c | 2 +-
+ libavcodec/arm/hevcdsp_sao_neon.S  | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index 8d6e863..385c35d 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -23,7 +23,7 @@
+ #include "libavcodec/hevcdsp.h"
+ #include "hevcdsp_arm.h"
+ #include "libavcodec/avcodec.h"
+-#include "../bit_depth_template.c"
++#include "libavcodec/bit_depth_template.c"
+ 
+ void ff_hevc_v_loop_filter_luma_neon(uint8_t *_pix, ptrdiff_t _stride, int _beta, int *_tc, uint8_t *_no_p, uint8_t *_no_q);
+ void ff_hevc_h_loop_filter_luma_neon(uint8_t *_pix, ptrdiff_t _stride, int _beta, int *_tc, uint8_t *_no_p, uint8_t *_no_q);
+diff --git a/libavcodec/arm/hevcdsp_sao_neon.S b/libavcodec/arm/hevcdsp_sao_neon.S
+index 5fc482b..710b32b 100644
+--- a/libavcodec/arm/hevcdsp_sao_neon.S
++++ b/libavcodec/arm/hevcdsp_sao_neon.S
+@@ -26,12 +26,12 @@
+         pld      [r1]
+         vld1.8   {q0, q1}, [r12]  // offset table
+         ldr      r12, [sp, #4]    // height
++        vmov.u8  q14, #128
+ .endm
+ 
+ .macro sao_band_32
+         vshr.u8  q8, q2, #3
+         vshr.u8  q9, q3, #3
+-        vmov.u8  q14, #128
+         vtbl.8   d16, {q0, q1}, d16
+         vtbl.8   d17, {q0, q1}, d17
+         vtbl.8   d18, {q0, q1}, d18
+-- 
+2.5.0
+
+
+From 579f1584d688e1ac24fb7d22697e2a7b64f62e8e Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Fri, 9 Jan 2015 10:28:52 +0200
+Subject: [PATCH 8/9] Added height check for SAO NEON optimizations. Faster SAO
+ band NEON Some reordering to use NEON pipelines more efficiently
+
+---
+ libavcodec/arm/hevcdsp_init_neon.c |  12 +++-
+ libavcodec/arm/hevcdsp_sao_neon.S  | 142 ++++++++++++++++++++++---------------
+ 2 files changed, 93 insertions(+), 61 deletions(-)
+
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index 385c35d..6d0689c 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -176,6 +176,7 @@ static void ff_hevc_sao_band_neon_wrapper(uint8_t *_dst, uint8_t *_src, ptrdiff_
+     int8_t offset_table[32] = { 0 };
+     int k, y, x;
+     int shift  = 3; // BIT_DEPTH - 5
++    int cwidth = 0;
+ 
+     stride_src /= sizeof(pixel);
+     stride_dst /= sizeof(pixel);
+@@ -183,7 +184,10 @@ static void ff_hevc_sao_band_neon_wrapper(uint8_t *_dst, uint8_t *_src, ptrdiff_
+     for (k = 0; k < 4; k++)
+         offset_table[(k + sao_left_class) & 31] = sao_offset_val[k + 1];
+ 
+-    switch(width){
++    if (height % 8 == 0)
++        cwidth = width;
++
++    switch(cwidth){
+     case 8:
+         ff_hevc_sao_band_w8_neon_8(_dst, _src, stride_dst, stride_src, offset_table, height);
+         break;
+@@ -223,15 +227,19 @@ static void ff_hevc_sao_edge_neon_wrapper(uint8_t *_dst /* align 16 */, uint8_t
+     pixel *src = (pixel *)_src;
+     int a_stride, b_stride;
+     int x, y;
++    int cwidth = 0;
+ 
+     for (x = 0; x < 5; x++) {
+         sao_offset_val[x] = _sao_offset_val[edge_idx[x]];
+     }
+ 
++    if (height % 8 == 0)
++        cwidth = width;
++
+     stride_src /= sizeof(pixel);
+     stride_dst /= sizeof(pixel);
+ 
+-    switch (width) {
++    switch (cwidth) {
+     case 32:
+         switch(eo) {
+         case 0:
+diff --git a/libavcodec/arm/hevcdsp_sao_neon.S b/libavcodec/arm/hevcdsp_sao_neon.S
+index 710b32b..08f50b8 100644
+--- a/libavcodec/arm/hevcdsp_sao_neon.S
++++ b/libavcodec/arm/hevcdsp_sao_neon.S
+@@ -26,36 +26,59 @@
+         pld      [r1]
+         vld1.8   {q0, q1}, [r12]  // offset table
+         ldr      r12, [sp, #4]    // height
+-        vmov.u8  q14, #128
++        vmov.u8  q3, #128
+ .endm
+ 
+-.macro sao_band_32
+-        vshr.u8  q8, q2, #3
+-        vshr.u8  q9, q3, #3
+-        vtbl.8   d16, {q0, q1}, d16
+-        vtbl.8   d17, {q0, q1}, d17
+-        vtbl.8   d18, {q0, q1}, d18
+-        vtbl.8   d19, {q0, q1}, d19
+-        vadd.s8  q2, q14
+-        vadd.s8  q3, q14
+-        vqadd.s8 q2, q8
+-        vqadd.s8 q3, q9
+-        vsub.s8  q2, q14
+-        vsub.s8  q3, q14
++// 128 in q3
++// input q8 - q11
++// 32 cycles
++.macro sao_band_64
++        vshr.u8  q12, q8, #3
++        vshr.u8  q13, q9, #3
++        vshr.u8  q14, q10, #3
++        vshr.u8  q15, q11, #3
++        vtbl.8   d24, {d0, d1, d2, d3}, d24
++        vadd.s8  q8, q3
++        vtbl.8   d25, {d0, d1, d2, d3}, d25
++        vadd.s8  q9, q3
++        vtbl.8   d26, {d0, d1, d2, d3}, d26
++        vadd.s8  q10, q3
++        vtbl.8   d27, {d0, d1, d2, d3}, d27
++        vadd.s8  q11, q3
++        vtbl.8   d28, {d0, d1, d2, d3}, d28
++        vqadd.s8 q8, q12
++        vtbl.8   d29, {d0, d1, d2, d3}, d29
++        vqadd.s8 q9, q13
++        vtbl.8   d30, {d0, d1, d2, d3}, d30
++        vqadd.s8 q10, q14
++        vtbl.8   d31, {d0, d1, d2, d3}, d31
++        vqadd.s8 q11, q15
++        vsub.s8  q8, q3
++        vsub.s8  q9, q3
++        vsub.s8  q10, q3
++        vsub.s8  q11, q3
+ .endm
+ 
+ function ff_hevc_sao_band_w8_neon_8, export=1
+         init_sao_band
+-1:      subs     r12, #4
+-        vld1.8   {d4}, [r1, :64], r3
+-        vld1.8   {d5}, [r1, :64], r3
+-        vld1.8   {d6}, [r1, :64], r3
+-        vld1.8   {d7}, [r1, :64], r3
+-        sao_band_32
+-        vst1.8  {d4}, [r0, :64], r2
+-        vst1.8  {d5}, [r0, :64], r2
+-        vst1.8  {d6}, [r0, :64], r2
+-        vst1.8  {d7}, [r0, :64], r2
++1:      subs     r12, #8
++        vld1.8   {d16}, [r1, :64], r3
++        vld1.8   {d17}, [r1, :64], r3
++        vld1.8   {d18}, [r1, :64], r3
++        vld1.8   {d19}, [r1, :64], r3
++        vld1.8   {d20}, [r1, :64], r3
++        vld1.8   {d21}, [r1, :64], r3
++        vld1.8   {d22}, [r1, :64], r3
++        vld1.8   {d23}, [r1, :64], r3
++        sao_band_64
++        vst1.8  {d16}, [r0, :64], r2
++        vst1.8  {d17}, [r0, :64], r2
++        vst1.8  {d18}, [r0, :64], r2
++        vst1.8  {d19}, [r0, :64], r2
++        vst1.8  {d20}, [r0, :64], r2
++        vst1.8  {d21}, [r0, :64], r2
++        vst1.8  {d22}, [r0, :64], r2
++        vst1.8  {d23}, [r0, :64], r2
+         bne    1b
+ 
+         bx lr
+@@ -63,12 +86,16 @@ endfunc
+ 
+ function ff_hevc_sao_band_w16_neon_8, export=1
+         init_sao_band
+-1:      subs     r12, #2
+-        vld1.8  {q2}, [r1, :128], r3
+-        vld1.8  {q3}, [r1, :128], r3
+-        sao_band_32
+-        vst1.8   {q2}, [r0, :128], r2
+-        vst1.8   {q3}, [r0, :128], r2
++1:      subs     r12, #4
++        vld1.8  {q8}, [r1, :128], r3
++        vld1.8  {q9}, [r1, :128], r3
++        vld1.8  {q10}, [r1, :128], r3
++        vld1.8  {q11}, [r1, :128], r3
++        sao_band_64
++        vst1.8   {q8}, [r0, :128], r2
++        vst1.8   {q9}, [r0, :128], r2
++        vst1.8   {q10}, [r0, :128], r2
++        vst1.8   {q11}, [r0, :128], r2
+         bne    1b
+ 
+         bx lr
+@@ -76,10 +103,12 @@ endfunc
+ 
+ function ff_hevc_sao_band_w32_neon_8, export=1
+         init_sao_band
+-1:      subs     r12, #1
+-        vld1.8   {q2-q3}, [r1, :128], r3
+-        sao_band_32
+-        vst1.8   {q2-q3}, [r0, :128], r2
++1:      subs     r12, #2
++        vld1.8   {q8-q9}, [r1, :128], r3
++        vld1.8   {q10-q11}, [r1, :128], r3
++        sao_band_64
++        vst1.8   {q8-q9}, [r0, :128], r2
++        vst1.8   {q10-q11}, [r0, :128], r2
+         bne      1b
+ 
+         bx       lr
+@@ -89,13 +118,12 @@ function ff_hevc_sao_band_w64_neon_8, export=1
+         init_sao_band
+ 1:      subs      r12, #1
+         pld       [r1, r3]
+-        vld1.8    {q2-q3}, [r1, :128]!
+-        sao_band_32
+-        vst1.8    {q2-q3}, [r0, :128]!
+-        vld1.8    {q2-q3}, [r1, :128], r3
++        vld1.8    {q8-q9}, [r1, :128]!
++        vld1.8    {q10-q11}, [r1, :128], r3
+         sub       r1, #32
+-        sao_band_32
+-        vst1.8    {q2-q3}, [r0, :128], r2
++        sao_band_64
++        vst1.8    {q8-q9}, [r0, :128]!
++        vst1.8    {q10-q11}, [r0, :128], r2
+         sub       r0, #32
+         bne       1b
+ 
+@@ -121,7 +149,6 @@ endfunc
+         vcgt.u8  q1,  q5, q9
+         vcgt.u8 q15,  q9, q5
+         vsub.s8  q0, q14, q0 // diff1
+-
+         vsub.s8  q1, q15, q1
+ 
+         vadd.s8  q0, q12 //diff0 + diff1
+@@ -157,27 +184,25 @@ endfunc
+ 
+         vmov.u8  q15, #128 // s8 #-128
+         vtbl.8   d0, {d24}, d0
++        vadd.s8  q13,  q4, q15
+         vtbl.8   d1, {d24}, d1
++        vadd.s8  q14,  q5, q15
+         vtbl.8   d2, {d24}, d2
++        vqadd.s8 q0, q13
+         vtbl.8   d3, {d24}, d3
++        vqadd.s8 q1, q14
+         vtbl.8   d4, {d24}, d4
++        vadd.s8  q13,  q6, q15
+         vtbl.8   d5, {d24}, d5
++        vadd.s8  q14,  q7, q15
+         vtbl.8   d6, {d24}, d6
++        vqadd.s8 q2, q13
+         vtbl.8   d7, {d24}, d7
+-
+-        vadd.s8  q12,  q4, q15
+-        vadd.s8  q13,  q5, q15
+-        vadd.s8  q14,  q6, q15
+-        vadd.s8  q15,  q7, q15
+-        vqadd.s8 q12,  q0
+-        vqadd.s8 q15,  q3
+-        vmov.u8   q3, #128 // s8 #-128
+-        vqadd.s8 q13,  q1
+-        vqadd.s8 q14,  q2
+-        vsub.s8   q0, q12, q3
+-        vsub.s8   q1, q13, q3
+-        vsub.s8   q2, q14, q3
+-        vsub.s8   q3, q15, q3
++        vqadd.s8 q3, q14
++        vsub.s8   q0, q15
++        vsub.s8   q1, q15
++        vsub.s8   q2, q15
++        vsub.s8   q3, q15
+         vst1.8  {q0-q1}, [r0, :128]!
+         vst1.8  {q2-q3}, [r0, :128], r2
+         sub     r0, #32
+@@ -342,13 +367,12 @@ endfunc
+ 
+         vmov.u8  q10, #128
+         vtbl.8   d0, {d31}, d0
++        vadd.s8  q11, q2, q10
+         vtbl.8   d1, {d31}, d1
++        vadd.s8  q12, q3, q10
+         vtbl.8   d2, {d31}, d2
++        vqadd.s8 q11, q0
+         vtbl.8   d3, {d31}, d3
+-
+-        vadd.s8    q11, q2, q10
+-        vadd.s8    q12, q3, q10
+-        vqadd.s8   q11, q0
+         vqadd.s8   q12, q1
+         vsub.s8    q0, q11, q10
+         vsub.s8    q1, q12, q10
+-- 
+2.5.0
+
+
+From 026bac1824e4936e948e6b1efec82868c520ea66 Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Mon, 2 Feb 2015 16:08:27 +0200
+Subject: [PATCH 9/9] Further SAO NEON optimisations
+
+---
+ libavcodec/arm/hevcdsp_init_neon.c |  16 +--
+ libavcodec/arm/hevcdsp_sao_neon.S  | 224 +++++++++++++++++++------------------
+ 2 files changed, 124 insertions(+), 116 deletions(-)
+
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index 6d0689c..e5da7e9 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -45,10 +45,10 @@ void ff_hevc_transform_add_16x16_neon_8(uint8_t *_dst, int16_t *coeffs,
+ void ff_hevc_transform_add_32x32_neon_8(uint8_t *_dst, int16_t *coeffs,
+                                       ptrdiff_t stride);
+ 
+-void ff_hevc_sao_band_w8_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int8_t * offset_table, int height);
+-void ff_hevc_sao_band_w16_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int8_t * offset_table, int height);
+-void ff_hevc_sao_band_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int8_t * offset_table, int height);
+-void ff_hevc_sao_band_w64_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int8_t * offset_table, int height);
++void ff_hevc_sao_band_w8_neon_8(uint8_t *_dst, uint8_t *_src, int8_t * offset_table, ptrdiff_t stride_src, ptrdiff_t stride_dst, int height);
++void ff_hevc_sao_band_w16_neon_8(uint8_t *_dst, uint8_t *_src, int8_t * offset_table, ptrdiff_t stride_src, ptrdiff_t stride_dst, int height);
++void ff_hevc_sao_band_w32_neon_8(uint8_t *_dst, uint8_t *_src, int8_t * offset_table, ptrdiff_t stride_src, ptrdiff_t stride_dst, int height);
++void ff_hevc_sao_band_w64_neon_8(uint8_t *_dst, uint8_t *_src, int8_t * offset_table, ptrdiff_t stride_src, ptrdiff_t stride_dst, int height);
+ 
+ void ff_hevc_sao_edge_eo0_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
+ void ff_hevc_sao_edge_eo1_w32_neon_8(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int height, int8_t *sao_offset_table);
+@@ -189,16 +189,16 @@ static void ff_hevc_sao_band_neon_wrapper(uint8_t *_dst, uint8_t *_src, ptrdiff_
+ 
+     switch(cwidth){
+     case 8:
+-        ff_hevc_sao_band_w8_neon_8(_dst, _src, stride_dst, stride_src, offset_table, height);
++        ff_hevc_sao_band_w8_neon_8(_dst, _src, offset_table, stride_src, stride_dst, height);
+         break;
+     case 16:
+-        ff_hevc_sao_band_w16_neon_8(_dst, _src, stride_dst, stride_src, offset_table, height);
++        ff_hevc_sao_band_w16_neon_8(_dst, _src, offset_table, stride_src, stride_dst, height);
+         break;
+     case 32:
+-        ff_hevc_sao_band_w32_neon_8(_dst, _src, stride_dst, stride_src, offset_table, height);
++        ff_hevc_sao_band_w32_neon_8(_dst, _src, offset_table, stride_src, stride_dst, height);
+         break;
+     case 64:
+-        ff_hevc_sao_band_w64_neon_8(_dst, _src, stride_dst, stride_src, offset_table, height);
++        ff_hevc_sao_band_w64_neon_8(_dst, _src, offset_table, stride_src, stride_dst, height);
+         break;
+     default:
+         for (y = 0; y < height; y++) {
+diff --git a/libavcodec/arm/hevcdsp_sao_neon.S b/libavcodec/arm/hevcdsp_sao_neon.S
+index 08f50b8..9c7808d 100644
+--- a/libavcodec/arm/hevcdsp_sao_neon.S
++++ b/libavcodec/arm/hevcdsp_sao_neon.S
+@@ -22,21 +22,16 @@
+ #include "neon.S"
+ 
+ .macro init_sao_band
+-        ldr      r12, [sp, #0]    // offset_table address
+         pld      [r1]
+-        vld1.8   {q0, q1}, [r12]  // offset table
+-        ldr      r12, [sp, #4]    // height
++        vld1.8   {q0, q1}, [r2]  // offset table
++        ldr       r2, [sp, #0]   // stride_dst
++        ldr      r12, [sp, #4]   // height
+         vmov.u8  q3, #128
+ .endm
+ 
+ // 128 in q3
+ // input q8 - q11
+-// 32 cycles
+ .macro sao_band_64
+-        vshr.u8  q12, q8, #3
+-        vshr.u8  q13, q9, #3
+-        vshr.u8  q14, q10, #3
+-        vshr.u8  q15, q11, #3
+         vtbl.8   d24, {d0, d1, d2, d3}, d24
+         vadd.s8  q8, q3
+         vtbl.8   d25, {d0, d1, d2, d3}, d25
+@@ -52,8 +47,8 @@
+         vtbl.8   d30, {d0, d1, d2, d3}, d30
+         vqadd.s8 q10, q14
+         vtbl.8   d31, {d0, d1, d2, d3}, d31
+-        vqadd.s8 q11, q15
+         vsub.s8  q8, q3
++        vqadd.s8 q11, q15
+         vsub.s8  q9, q3
+         vsub.s8  q10, q3
+         vsub.s8  q11, q3
+@@ -64,12 +59,16 @@ function ff_hevc_sao_band_w8_neon_8, export=1
+ 1:      subs     r12, #8
+         vld1.8   {d16}, [r1, :64], r3
+         vld1.8   {d17}, [r1, :64], r3
++        vshr.u8  q12, q8, #3
+         vld1.8   {d18}, [r1, :64], r3
+         vld1.8   {d19}, [r1, :64], r3
++        vshr.u8  q13, q9, #3
+         vld1.8   {d20}, [r1, :64], r3
+         vld1.8   {d21}, [r1, :64], r3
++        vshr.u8  q14, q10, #3
+         vld1.8   {d22}, [r1, :64], r3
+         vld1.8   {d23}, [r1, :64], r3
++        vshr.u8  q15, q11, #3
+         sao_band_64
+         vst1.8  {d16}, [r0, :64], r2
+         vst1.8  {d17}, [r0, :64], r2
+@@ -88,9 +87,13 @@ function ff_hevc_sao_band_w16_neon_8, export=1
+         init_sao_band
+ 1:      subs     r12, #4
+         vld1.8  {q8}, [r1, :128], r3
++        vshr.u8  q12, q8, #3
+         vld1.8  {q9}, [r1, :128], r3
++        vshr.u8  q13, q9, #3
+         vld1.8  {q10}, [r1, :128], r3
++        vshr.u8  q14, q10, #3
+         vld1.8  {q11}, [r1, :128], r3
++        vshr.u8  q15, q11, #3
+         sao_band_64
+         vst1.8   {q8}, [r0, :128], r2
+         vst1.8   {q9}, [r0, :128], r2
+@@ -105,7 +108,11 @@ function ff_hevc_sao_band_w32_neon_8, export=1
+         init_sao_band
+ 1:      subs     r12, #2
+         vld1.8   {q8-q9}, [r1, :128], r3
++        vshr.u8  q12, q8, #3
++        vshr.u8  q13, q9, #3
+         vld1.8   {q10-q11}, [r1, :128], r3
++        vshr.u8  q14, q10, #3
++        vshr.u8  q15, q11, #3
+         sao_band_64
+         vst1.8   {q8-q9}, [r0, :128], r2
+         vst1.8   {q10-q11}, [r0, :128], r2
+@@ -119,7 +126,11 @@ function ff_hevc_sao_band_w64_neon_8, export=1
+ 1:      subs      r12, #1
+         pld       [r1, r3]
+         vld1.8    {q8-q9}, [r1, :128]!
++        vshr.u8  q12, q8, #3
++        vshr.u8  q13, q9, #3
+         vld1.8    {q10-q11}, [r1, :128], r3
++        vshr.u8  q14, q10, #3
++        vshr.u8  q15, q11, #3
+         sub       r1, #32
+         sao_band_64
+         vst1.8    {q8-q9}, [r0, :128]!
+@@ -129,51 +140,18 @@ function ff_hevc_sao_band_w64_neon_8, export=1
+ 
+         bx lr
+ endfunc
+-// input
+-// a in q0 - q3
+-// c in q4 - q7
+-// b in q8 - q11
+-// offset table in r7 and r5
+-// output in q0 - q3
+-// clobbers q12 - q15
+-.macro edge_w64_body
+-        vcgt.u8 q12,  q4, q0 // c > a -> -1 , otherwise 0
+-        vcgt.u8  q0,  q0, q4 // a > c -> -1 , otherwise 0
+-        vcgt.u8 q13,  q5, q1
+-        vcgt.u8  q1,  q1, q5
+-        vsub.s8 q12,  q0, q12 // diff0
+-        vcgt.u8  q0,  q4, q8 // c > b
+-        vsub.s8 q13,  q1, q13
+-
+-        vcgt.u8 q14,  q8, q4 // b > c
+-        vcgt.u8  q1,  q5, q9
+-        vcgt.u8 q15,  q9, q5
+-        vsub.s8  q0, q14, q0 // diff1
+-        vsub.s8  q1, q15, q1
+ 
+-        vadd.s8  q0, q12 //diff0 + diff1
+-        vadd.s8  q1, q13
+-
+-        vcgt.u8 q14,  q6, q2
+-        vcgt.u8  q2,  q2, q6
+-        vcgt.u8 q15,  q7, q3
+-        vcgt.u8  q3,  q3, q7
+-
+-        vsub.s8 q14,  q2, q14
+-        vcgt.u8  q2,  q6, q10
+-        vsub.s8 q15,  q3, q15
+-
+-        vcgt.u8 q12, q10, q6
+-        vcgt.u8  q3,  q7, q11
+-        vcgt.u8 q13, q11, q7
+-        vsub.s8  q2, q12, q2
+-        vsub.s8  q3, q13, q3
++.macro diff32 out0, out1, tmp0, tmp1, in0, in1, in2, in3
++        vcgt.u8 \out0, \in2, \in0  // c > a -> -1 , otherwise 0
++        vcgt.u8 \tmp0,  \in0, \in2  // a > c -> -1 , otherwise 0
++        vcgt.u8 \out1, \in3, \in1  // c > a -> -1 , otherwise 0 part 2
++        vcgt.u8 \tmp1,  \in1, \in3  // a > c -> -1 , otherwise 0 part 2
++        vsub.s8 \out0, \tmp0, \out0 // diff0
++        vsub.s8 \out1, \tmp1, \out1 // diff0 part 2
++.endm
+ 
++.macro table64
+         vmov.s8 q13, #2 // 2 to all elements
+-
+-        vadd.s8  q2, q14
+-        vadd.s8  q3, q15
+-
+         vmov.32  d24[0], r4  // load offset table from general registers
+         vmov.32  d24[1], r5  // load rest of offset table
+ 
+@@ -208,6 +186,28 @@ endfunc
+         sub     r0, #32
+ .endm
+ 
++// input
++// a in q0 - q3
++// c in q4 - q7
++// b in q8 - q11
++// offset table in r7 and r5
++// output in q0 - q3
++// clobbers q12 - q15
++.macro edge_w64_body
++        diff32 q12, q13, q0, q1, q0, q1, q4, q5
++        diff32 q0, q1, q14, q15, q8, q9, q4, q5
++
++        vadd.s8  q0, q12 //diff0 + diff1
++        vadd.s8  q1, q13
++
++        diff32  q14, q15, q2, q3, q2, q3, q6, q7
++        diff32  q2, q3, q12, q13, q10, q11, q6, q7
++
++        vadd.s8  q2, q14
++        vadd.s8  q3, q15
++        table64
++.endm
++
+ .macro init_edge_64
+         push   {r4-r5}
+         ldr    r12, [sp, #8] // height
+@@ -334,38 +334,23 @@ function ff_hevc_sao_edge_eo3_w64_neon_8, export=1
+         bx lr
+ endfunc
+ 
+-// inputs:
+-// a in q0, q1
+-// c in q2, q3
+-// b in q8, q9
+-// offset table in d31
+-// clobbered registers q0, q1, q10, q11, q12, q13
+-// output q0, q1
+-.macro edge_w32_body
+-        vcgt.u8 q12, q2, q0 // c > a -> -1 , otherwise 0
+-        vcgt.u8 q0,  q0, q2 // a > c -> -1 , otherwise 0
+-        vcgt.u8 q13, q3, q1
+-        vcgt.u8 q1,  q1, q3
+-
+-        vsub.s8 q12, q0, q12 // diff0
+-        vcgt.u8  q0,  q2, q8 // c > b
+-        vsub.s8 q13, q1, q13 // diff0 part 2
+-
+-        vcgt.u8  q10,  q8, q2 // b > c
+-        vcgt.u8  q1,  q3, q9
+-        vcgt.u8  q11,  q9, q3
+-
+-        vsub.s8 q0, q10, q0 // diff1
+-
+-        vmov.s8 q10, #2 // 2 to all elements
+-        vsub.s8 q1, q11, q1 // diff1 part 2
+-        vadd.s8 q0, q12 //diff0 + diff1
+-        vadd.s8 q1, q13
++.macro init_edge_32
++        ldr     r12, [sp, #4] // sao_offset_val_table
++        vld1.32 {d31}, [r12]
++        ldr     r12, [sp] // height
++.endm
+ 
+-        vadd.s8 q0, q10
+-        vadd.s8 q1, q10
++.macro diff out0, tmp0, in0, in1
++        vcgt.u8 \out0, \in1, \in0  // c > a -> -1 , otherwise 0
++        vcgt.u8 \tmp0,  \in0, \in1  // a > c -> -1 , otherwise 0
++        vsub.s8 \out0, \tmp0, \out0 // diff0
++.endm
+ 
+-        vmov.u8  q10, #128
++.macro table32
++        vmov.s8  q10, #2
++        vadd.s8  q0, q10
++        vadd.s8  q1, q10
++        vmov.s8  q10, #128
+         vtbl.8   d0, {d31}, d0
+         vadd.s8  q11, q2, q10
+         vtbl.8   d1, {d31}, d1
+@@ -373,56 +358,68 @@ endfunc
+         vtbl.8   d2, {d31}, d2
+         vqadd.s8 q11, q0
+         vtbl.8   d3, {d31}, d3
+-        vqadd.s8   q12, q1
+-        vsub.s8    q0, q11, q10
+-        vsub.s8    q1, q12, q10
++        vqadd.s8 q12, q1
++        vsub.s8  q0, q11, q10
++        vsub.s8  q1, q12, q10
+         vst1.8   {q0-q1}, [r0, :128], r2
+ .endm
+ 
+-.macro init_edge_32
+-        ldr     r12, [sp, #4] // sao_offset_val_table
+-        vld1.32 {d31}, [r12]
+-        ldr     r12, [sp] // height
+-.endm
+-
+ function ff_hevc_sao_edge_eo0_w32_neon_8, export=1
+         init_edge_32
+-        sub     r1, #4 // load 4 extra bytes
++        vpush {q4-q7}
++        sub     r1, #4
+ 1:      subs    r12, #1
+-        vld1.32 d3[1], [r1]!
+-        vld1.8  {q2-q3}, [r1, :128]! // c
+-        vld1.32 d20[0], [r1], r3
+-        sub     r1, #36
++        vld1.8  {q13-q14}, [r1]!
++        vld1.32 d30, [r1], r3
++        sub     r1, #32
+         // a
+-        vext.8  q0, q1, q2, #15
+-        vext.8  q1, q2, q3, #15
+-        // b
+-        vext.8  q8, q2, q3, #1
+-        vext.8  q9, q3, q10, #1
+-        edge_w32_body
++        vext.8   q0, q13, q14, #3
++        vext.8   q1, q14, q15, #3
++        vshr.u64 d24, d30, #24
++        // c
++        vext.8   q2, q13, q14, #4
++        vext.8   q3, q14, q15, #4
++        vshr.u64 d16, d30, #32
++        // diff0
++        diff32 q13, q14, q4, q5, q0, q1, q2, q3
++        diff   d18, d25, d24, d16
++        // -diff1
++        vext.s8 q0, q13, q14, #1
++        vext.s8 q1, q14, q9, #1
++
++        vsub.s8 q0, q13, q0 //diff0 + diff1
++        vsub.s8 q1, q14, q1
++        table32
+         bne     1b
++        vpop {q4-q7}
++
+         bx      lr
+ endfunc
+ 
+ function ff_hevc_sao_edge_eo1_w32_neon_8, export=1
+         init_edge_32
++        vpush {q4-q7}
+         // load a
+         sub     r1, r3
+         vld1.8  {q0-q1}, [r1, :128], r3
+         // load c
+         vld1.8  {q2-q3}, [r1, :128], r3
++        diff32 q12, q13, q0, q1, q0, q1, q2, q3 // CMP ( c, a )
+ 1:      subs    r12, #1
+         // load b
+         vld1.8  {q8-q9}, [r1, :128], r3
+-        edge_w32_body
+-        // inputs for next loop iteration
+-        // a
+-        vmov.64 q0, q2
+-        vmov.64 q1, q3
++        diff32 q4, q5, q10, q11, q8, q9, q2, q3 // CMP ( c, b )
++        vadd.s8 q0, q4, q12 //diff0 + diff1
++        vadd.s8 q1, q5, q13
++        table32
++        // CMP ( c, a )
++        vneg.s8 q12, q4
++        vneg.s8 q13, q5
+         // c
+         vmov.64 q2, q8
+         vmov.64 q3, q9
+         bne     1b
++        vpop {q4-q7}
+         bx      lr
+ endfunc
+ 
+@@ -452,7 +449,11 @@ function ff_hevc_sao_edge_eo2_w32_neon_8, export=1
+         vext.8  q6, q10, q11, #8
+         vext.8  q7, q11, q12, #8
+         vext.8  q5, q10, q11, #7
+-        edge_w32_body
++        diff32 q12, q13, q0, q1, q0, q1, q2, q3
++        diff32 q0, q1, q10, q11, q8, q9, q2, q3
++        vadd.s8 q0, q12 //diff0 + diff1
++        vadd.s8 q1, q13
++        table32
+         // inputs for next loop iteration
+         // a
+         vmov.8  q0, q4
+@@ -487,7 +488,14 @@ function ff_hevc_sao_edge_eo3_w32_neon_8, export=1
+         vext.8  q8, q10, q11, #7
+         vext.8  q9, q11, q12, #7
+         vext.8  q14, q12, q10, #7
+-        edge_w32_body
++
++        diff32 q12, q13, q0, q1, q0, q1, q2, q3
++        diff32 q0, q1, q10, q11, q8, q9, q2, q3
++
++        vadd.s8 q0, q12 //diff0 + diff1
++        vadd.s8 q1, q13
++        table32
++
+         // inputs for next loop iteration
+         // a
+         vext.8  q0, q2, q3, #1
+-- 
+2.5.0
+
diff --git a/tools/depends/target/ffmpeg/autobuild.sh b/tools/depends/target/ffmpeg/autobuild.sh
index e491c78..1a16999 100755
--- a/tools/depends/target/ffmpeg/autobuild.sh
+++ b/tools/depends/target/ffmpeg/autobuild.sh
@@ -128,6 +128,8 @@ cd "ffmpeg-${VERSION}" || exit 2
 tar --strip-components=1 -xf $MYDIR/${ARCHIVE}
 
 patch -p1 < ../0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
+patch -p1 < ../hevcdsp_ARM_NEON_optimized_epel_functions.patch
+patch -p1 < ../added_ARM_NEON_optimized_SAO_patches.patch
 
 CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
 ./configure --prefix=$FFMPEG_PREFIX \
diff --git a/tools/depends/target/ffmpeg/hevcdsp_ARM_NEON_optimized_epel_functions.patch b/tools/depends/target/ffmpeg/hevcdsp_ARM_NEON_optimized_epel_functions.patch
new file mode 100644
index 0000000..5e8e07d
--- /dev/null
+++ b/tools/depends/target/ffmpeg/hevcdsp_ARM_NEON_optimized_epel_functions.patch
@@ -0,0 +1,409 @@
+From 29c3327a0d72a7e872ff170363cfe5ed13bca5d0 Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Tue, 22 Dec 2015 18:10:24 +0000
+Subject: [PATCH] hevcdsp: ARM NEON optimized epel functions
+
+---
+ libavcodec/arm/Makefile            |   1 +
+ libavcodec/arm/hevcdsp_epel_neon.S | 334 +++++++++++++++++++++++++++++++++++++
+ libavcodec/arm/hevcdsp_init_neon.c |  23 +++
+ 3 files changed, 358 insertions(+)
+ create mode 100644 libavcodec/arm/hevcdsp_epel_neon.S
+
+diff --git a/libavcodec/arm/Makefile b/libavcodec/arm/Makefile
+index cdd35b0..6051ec8 100644
+--- a/libavcodec/arm/Makefile
++++ b/libavcodec/arm/Makefile
+@@ -131,6 +131,7 @@ NEON-OBJS-$(CONFIG_DCA_DECODER)        += arm/dcadsp_neon.o             \
+                                           arm/synth_filter_neon.o
+ NEON-OBJS-$(CONFIG_HEVC_DECODER)       += arm/hevcdsp_init_neon.o       \
+                                           arm/hevcdsp_deblock_neon.o    \
++                                          arm/hevcdsp_epel_neon.o       \
+                                           arm/hevcdsp_idct_neon.o       \
+                                           arm/hevcdsp_qpel_neon.o
+ NEON-OBJS-$(CONFIG_RV30_DECODER)       += arm/rv34dsp_neon.o
+diff --git a/libavcodec/arm/hevcdsp_epel_neon.S b/libavcodec/arm/hevcdsp_epel_neon.S
+new file mode 100644
+index 0000000..516ae5b
+--- /dev/null
++++ b/libavcodec/arm/hevcdsp_epel_neon.S
+@@ -0,0 +1,334 @@
++/*
++ * Copyright (c) 2014 - 2015 Seppo Tomperi <seppo.tomperi@vtt.fi>
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++#include "libavutil/arm/asm.S"
++#include "neon.S"
++
++#define MAX_PB_SIZE #64
++
++.macro vextin_d4
++    vld1.8    {q10}, [r1], r2
++    vmov      d16, d20
++    vext.8    d17, d20, d21, #1
++    vext.8    d18, d20, d21, #2
++    vext.8    d19, d20, d21, #3
++.endm
++
++.macro vextin_d4_8
++    vld1.8    d16, [r1], r2
++    vext.8    d17, d16, d16, #1
++    vext.8    d18, d16, d16, #2
++    vext.8    d19, d16, d16, #3
++.endm
++
++.macro load_coeffs_16b coeffs
++    ldr      \coeffs, [\coeffs]
++    vdup.i8  d0, \coeffs
++    lsr      \coeffs, #8
++    vdup.i8  d1, \coeffs
++    lsr      \coeffs, #8
++    vdup.i8  d2, \coeffs
++    lsr      \coeffs, #8
++    vdup.i8  d3, \coeffs
++.endm
++
++.macro epel_filter_16b out=q12
++    vmull.u8 q3, d16, d0
++    vmull.u8 q11, d19, d3
++    vmull.u8 \out, d17, d1
++    vmull.u8 q10, d18, d2
++    vadd.s16 q3, q11
++    vadd.s16 \out, q10
++    vsub.s16 \out, q3
++.endm
++
++.macro load_coeffs_32b coeffs
++    ldr      \coeffs, [\coeffs]
++    vmov.i64 d4, #0
++    vmov.8   d4[0], \coeffs
++    lsr      \coeffs, #8
++    vmov.8   d4[2], \coeffs
++    lsr      \coeffs, #8
++    vmov.8   d4[4], \coeffs
++    lsr      \coeffs, #8
++    vmov.8   d4[6], \coeffs
++.endm
++
++.macro epel_filter_32b
++    vmull.s16 q3, d24, d4[0] //q12
++    vmull.s16 q4, d25, d4[0]
++    vmull.s16 q5, d30, d4[3] //q15
++    vmull.s16 q6, d31, d4[3]
++
++    vmull.s16 q7, d26, d4[1] // q13
++    vmull.s16 q8, d27, d4[1]
++    vmull.s16 q9, d28, d4[2] // q14
++    vmull.s16 q10, d29, d4[2]
++    vadd.s32 q3, q5
++    vadd.s32 q4, q6
++    vadd.s32 q7, q9
++    vadd.s32 q8, q10
++    vsub.s32 q7, q3
++    vsub.s32 q8, q4
++    vqshrn.s32  d6, q7, #6
++    vqshrn.s32  d7, q8, #6
++.endm
++
++.macro epel_filter_32b_4
++    vmull.s16 q3, d24, d4[0] //q12
++    vmull.s16 q5, d30, d4[3] //q15
++    vmull.s16 q7, d26, d4[1] // q13
++    vmull.s16 q9, d28, d4[2] // q14
++    vadd.s32 q3, q5
++    vadd.s32 q7, q9
++    vsub.s32 q7, q3
++    vqshrn.s32  d6, q7, #6
++.endm
++
++function ff_hevc_put_epel_h_neon_8, export=1
++        push   {r4-r7}
++        mov    r4, MAX_PB_SIZE
++        ldr    r7, [sp, #16] // mx
++        ldr    r5, [sp, #24] // width
++        sub    r7, #1
++        lsl    r7, #2
++        vpush {d8-d15}
++        adrl   r12, epel_coeffs
++        add    r7, r12
++        sub       r1, #1
++        lsl       r4, #1
++        load_coeffs_16b r7
++        mov   r12, r3
++        mov   r6, r0
++        mov   r7, r1
++        cmp       r5, #6
++        bgt       8f
++        cmp       r5, #4
++        blt       2f
++        b         4f
++8:      subs r3, #1
++        pld [r1]
++        vextin_d4
++        epel_filter_16b
++        vst1.16    {q12}, [r0], r4
++        bne 8b
++        subs    r5, #8
++        beq  99f
++        mov       r3, r12
++        add       r6, #16
++        mov       r0, r6
++        add       r7, #8
++        mov       r1, r7
++        cmp       r5, #4
++        bgt       8b
++4:      subs r3, #1
++        pld [r1]
++        vextin_d4_8
++        epel_filter_16b
++        vst1.16    d24, [r0], r4
++        bne 4b
++        subs      r5, #4
++        beq       99f
++        mov       r3, r12
++        add       r6, #8
++        mov       r0, r6
++        add       r7, #4
++        mov       r1, r7
++2:      subs r3, #1
++        pld [r1]
++        vextin_d4_8
++        epel_filter_16b
++        vst1.32    d24[0], [r0], r4
++        bne 2b
++99:     vpop {d8-d15}
++        pop {r4-r7}
++        bx lr
++endfunc
++
++function ff_hevc_put_epel_v_neon_8, export=1
++        push   {r4-r7}
++        mov    r4, MAX_PB_SIZE
++        ldr    r7, [sp, #20] // my
++        ldr    r5, [sp, #24] // width
++        sub    r7, #1
++        lsl    r7, #2
++        vpush {d8-d15}
++        adrl   r12, epel_coeffs
++        add    r7, r12
++        load_coeffs_16b r7
++        sub       r1, r2
++        lsl       r4, #1
++        mov   r12, r3
++        mov   r6, r0
++        mov   r7, r1
++0:      pld [r1]
++        vld1.8    {d16}, [r1], r2
++        pld [r1]
++        vld1.8    {d17}, [r1], r2
++        pld [r1]
++        vld1.8    {d18}, [r1], r2
++        cmp       r5, #6
++        bgt       8f
++        cmp       r5, #4
++        blt       2f
++        b         4f
++8:      pld [r1]
++        vld1.8    {d19}, [r1], r2
++        subs r3, #1
++        epel_filter_16b
++        vst1.16    {q12}, [r0], r4
++        vmov d16, d17
++        vmov d17, d18
++        vmov d18, d19
++        bne 8b
++        subs    r5, #8
++        beq  99f
++        mov       r3, r12
++        add       r6, #16
++        mov       r0, r6
++        add       r7, #8
++        mov       r1, r7
++        b         0b
++4:      pld       [r1]
++        vld1.8    {d19}, [r1], r2
++        subs r3, #1
++        epel_filter_16b
++        vst1.16    d24, [r0], r4
++        vmov d16, d17
++        vmov d17, d18
++        vmov d18, d19
++        bne 4b
++        subs      r5, #4
++        beq       99f
++        mov       r3, r12
++        add       r6, #8
++        mov       r0, r6
++        add       r7, #4
++        mov       r1, r7
++        b         0b
++2:      pld [r1]
++        vld1.8    {d19}, [r1], r2
++        subs r3, #1
++        epel_filter_16b
++        vst1.32    d24[0], [r0], r4
++        vmov d16, d17
++        vmov d17, d18
++        vmov d18, d19
++        bne 2b
++99:     vpop {d8-d15}
++        pop {r4-r7}
++        bx lr
++endfunc
++
++function ff_hevc_put_epel_hv_neon_8, export=1
++        push   {r4-r7}
++        mov    r4, MAX_PB_SIZE
++        ldr    r6, [sp, #16] // mx
++        ldr    r7, [sp, #20] // my
++        ldr    r5, [sp, #24] // width
++        sub    r7, #1
++        lsl    r7, #2
++        vpush {d8-d15}
++        adrl   r12, epel_coeffs
++        sub    r6, #1
++        lsl    r6, #2
++        add    r6, r12 // mx epel coeff offset
++        add    r7, r12
++        sub       r1, #1
++        sub       r1, r2
++        lsl       r4, #1
++        load_coeffs_16b r6
++        load_coeffs_32b r7
++        mov   r12, r3
++        mov   r6, r0
++        mov   r7, r1
++0:      pld   [r1]
++        vextin_d4
++        epel_filter_16b q12
++        pld   [r1]
++        vextin_d4
++        epel_filter_16b q13
++        pld   [r1]
++        vextin_d4
++        epel_filter_16b q14
++        cmp       r5, #6
++        bgt       8f
++        cmp       r5, #4
++        blt       2f
++        b         4f
++8:      pld     [r1]
++        vextin_d4
++        epel_filter_16b q15
++        subs r3, #1
++        epel_filter_32b
++        vst1.16    {q3}, [r0], r4
++        vmov q12, q13
++        vmov q13, q14
++        vmov q14, q15
++        bne 8b
++        subs    r5, #8
++        beq  99f
++        mov       r3, r12
++        add       r6, #16
++        mov       r0, r6
++        add       r7, #8
++        mov       r1, r7
++        b         0b
++4:      pld      [r1]
++        vextin_d4_8
++        epel_filter_16b q15
++        subs r3, #1
++        epel_filter_32b_4
++        vst1.16    d6, [r0], r4
++        vmov q12, q13
++        vmov q13, q14
++        vmov q14, q15
++        bne 4b
++        subs      r5, #4
++        beq       99f
++        mov       r3, r12
++        add       r6, #8
++        mov       r0, r6
++        add       r7, #4
++        mov       r1, r7
++        b         0b
++2:      pld      [r1]
++        vextin_d4_8
++        epel_filter_16b q15
++        subs r3, #1
++        epel_filter_32b_4
++        vst1.32    d6[0], [r0], r4
++        vmov q12, q13
++        vmov q13, q14
++        vmov q14, q15
++        bne 2b
++99:     vpop {d8-d15}
++        pop {r4-r7}
++        bx lr
++endfunc
++
++epel_coeffs:
++       .byte 2, 58, 10, 2
++       .byte 4, 54, 16, 2
++       .byte 6, 46, 28, 4
++       .byte 4, 36, 36, 4
++       .byte 4, 28, 46, 6
++       .byte 2, 16, 54, 4
++       .byte 2, 10, 58, 2
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index 5591807..733ff08 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -58,6 +58,15 @@ PUT_PIXELS(ff_hevc_put_pixels_w32_neon_8);
+ PUT_PIXELS(ff_hevc_put_pixels_w48_neon_8);
+ PUT_PIXELS(ff_hevc_put_pixels_w64_neon_8);
+ #undef PUT_PIXELS
++void ff_hevc_put_epel_h_neon_8(int16_t *dst, uint8_t *src,
++                                ptrdiff_t srcstride, int height,
++                                intptr_t mx, intptr_t my, int width);
++void ff_hevc_put_epel_v_neon_8(int16_t *dst, uint8_t *src,
++                                ptrdiff_t srcstride, int height,
++                                intptr_t mx, intptr_t my, int width);
++void ff_hevc_put_epel_hv_neon_8(int16_t *dst, uint8_t *src,
++                                ptrdiff_t srcstride, int height,
++                                intptr_t mx, intptr_t my, int width);
+ 
+ static void (*put_hevc_qpel_neon[4][4])(int16_t *dst, ptrdiff_t dststride, uint8_t *src, ptrdiff_t srcstride,
+                                    int height, int width);
+@@ -201,7 +210,21 @@ av_cold void ff_hevcdsp_init_neon(HEVCDSPContext *c, const int bit_depth)
+             c->put_hevc_qpel_bi[x][1][0]      = ff_hevc_put_qpel_bi_neon_wrapper;
+             c->put_hevc_qpel_bi[x][0][1]      = ff_hevc_put_qpel_bi_neon_wrapper;
+             c->put_hevc_qpel_bi[x][1][1]      = ff_hevc_put_qpel_bi_neon_wrapper;
++            c->put_hevc_epel[x][1][0]         = ff_hevc_put_epel_v_neon_8;
++            c->put_hevc_epel[x][0][1]         = ff_hevc_put_epel_h_neon_8;
++            c->put_hevc_epel[x][1][1]         = ff_hevc_put_epel_hv_neon_8;
+         }
++        c->put_hevc_epel[0][0][0]  = ff_hevc_put_pixels_w2_neon_8;
++        c->put_hevc_epel[1][0][0]  = ff_hevc_put_pixels_w4_neon_8;
++        c->put_hevc_epel[2][0][0]  = ff_hevc_put_pixels_w6_neon_8;
++        c->put_hevc_epel[3][0][0]  = ff_hevc_put_pixels_w8_neon_8;
++        c->put_hevc_epel[4][0][0]  = ff_hevc_put_pixels_w12_neon_8;
++        c->put_hevc_epel[5][0][0]  = ff_hevc_put_pixels_w16_neon_8;
++        c->put_hevc_epel[6][0][0]  = ff_hevc_put_pixels_w24_neon_8;
++        c->put_hevc_epel[7][0][0]  = ff_hevc_put_pixels_w32_neon_8;
++        c->put_hevc_epel[8][0][0]  = ff_hevc_put_pixels_w48_neon_8;
++        c->put_hevc_epel[9][0][0]  = ff_hevc_put_pixels_w64_neon_8;
++
+         c->put_hevc_qpel[0][0][0]  = ff_hevc_put_pixels_w2_neon_8;
+         c->put_hevc_qpel[1][0][0]  = ff_hevc_put_pixels_w4_neon_8;
+         c->put_hevc_qpel[2][0][0]  = ff_hevc_put_pixels_w6_neon_8;
+-- 
+2.5.0
+
-- 
2.7.4


From 844bbfa005ab5db099591eb5b42b81fce32813a6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 7 May 2015 14:04:18 +0100
Subject: [PATCH 128/175] Add GPU acceleration to hevc

---
 tools/depends/target/ffmpeg/Makefile               |     4 +-
 tools/depends/target/ffmpeg/autobuild.sh           |     1 +
 .../target/ffmpeg/pfcd_hevc_optimisations.patch    | 38136 +++++++++++++++++++
 3 files changed, 38140 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/pfcd_hevc_optimisations.patch

diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index c46b533..48f8d56 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -2,7 +2,8 @@ include ../../Makefile.include
 include FFMPEG-VERSION
 DEPS= ../../Makefile.include FFMPEG-VERSION Makefile \
   0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch \
-  hevcdsp_ARM_NEON_optimized_epel_functions.patch added_ARM_NEON_optimized_SAO_patches.patch
+  hevcdsp_ARM_NEON_optimized_epel_functions.patch added_ARM_NEON_optimized_SAO_patches.patch \
+  pfcd_hevc_optimisations.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -85,6 +86,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); patch -p1 < ../0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
 	cd $(PLATFORM); patch -p1 < ../hevcdsp_ARM_NEON_optimized_epel_functions.patch
 	cd $(PLATFORM); patch -p1 < ../added_ARM_NEON_optimized_SAO_patches.patch
+	cd $(PLATFORM); patch -p1 < ../pfcd_hevc_optimisations.patch
 
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
diff --git a/tools/depends/target/ffmpeg/autobuild.sh b/tools/depends/target/ffmpeg/autobuild.sh
index 1a16999..e264109 100755
--- a/tools/depends/target/ffmpeg/autobuild.sh
+++ b/tools/depends/target/ffmpeg/autobuild.sh
@@ -130,6 +130,7 @@ tar --strip-components=1 -xf $MYDIR/${ARCHIVE}
 patch -p1 < ../0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
 patch -p1 < ../hevcdsp_ARM_NEON_optimized_epel_functions.patch
 patch -p1 < ../added_ARM_NEON_optimized_SAO_patches.patch
+patch -p1 < ../pfcd_hevc_optimisations.patch
 
 CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
 ./configure --prefix=$FFMPEG_PREFIX \
diff --git a/tools/depends/target/ffmpeg/pfcd_hevc_optimisations.patch b/tools/depends/target/ffmpeg/pfcd_hevc_optimisations.patch
new file mode 100644
index 0000000..e172ebf
--- /dev/null
+++ b/tools/depends/target/ffmpeg/pfcd_hevc_optimisations.patch
@@ -0,0 +1,38136 @@
+From b9b5434c61afd492a54dad5158b4d56ecbf7f01d Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Tue, 28 Apr 2015 16:18:40 +0100
+Subject: [PATCH 01/68] Added display output
+
+---
+ ffmpeg.c | 159 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 159 insertions(+)
+
+diff --git a/ffmpeg.c b/ffmpeg.c
+index 9ffd833..50c6e86 100644
+--- a/ffmpeg.c
++++ b/ffmpeg.c
+@@ -23,6 +23,11 @@
+  * multimedia converter based on the FFmpeg libraries
+  */
+ 
++#ifdef RPI
++#define RPI_DISPLAY
++//#define RPI_ZERO_COPY
++#endif
++
+ #include "config.h"
+ #include <ctype.h>
+ #include <string.h>
+@@ -66,6 +71,20 @@
+ # include "libavfilter/buffersrc.h"
+ # include "libavfilter/buffersink.h"
+ 
++#ifdef RPI_DISPLAY
++#include <bcm_host.h>
++#include <interface/mmal/mmal.h>
++#include <interface/mmal/mmal_parameters_camera.h>
++#include <interface/mmal/mmal_buffer.h>
++#include <interface/mmal/util/mmal_util.h>
++#include <interface/mmal/util/mmal_default_components.h>
++#include <interface/mmal/util/mmal_connection.h>
++#include <interface/mmal/util/mmal_util_params.h>
++#ifdef RPI_ZERO_COPY
++#include "libavcodec/rpi_qpu.h"
++#endif
++#endif
++
+ #if HAVE_SYS_RESOURCE_H
+ #include <sys/time.h>
+ #include <sys/types.h>
+@@ -158,6 +177,134 @@ static int restore_tty;
+ static void free_input_threads(void);
+ #endif
+ 
++#ifdef RPI_DISPLAY
++
++#define NUM_BUFFERS 4
++
++static MMAL_COMPONENT_T* rpi_display = NULL;
++static MMAL_POOL_T *rpi_pool = NULL;
++
++#ifdef RPI_ZERO_COPY
++static uint8_t *get_vc_handle(AVBufferRef *bref) {
++  GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
++  return (uint8_t *)p->vc_handle;
++}
++#endif
++
++static MMAL_POOL_T* display_alloc_pool(MMAL_PORT_T* port, size_t w, size_t h)
++{
++    MMAL_POOL_T* pool;
++    size_t i;
++    size_t size = (w*h*3)/2;
++#ifdef RPI_ZERO_COPY
++    mmal_port_parameter_set_boolean(port, MMAL_PARAMETER_ZERO_COPY, MMAL_TRUE); // Does this mark that the buffer contains a vc_handle?  Would have expected a vc_image?
++    pool = mmal_port_pool_create(port, NUM_BUFFERS, 0);
++    assert(pool);
++#else
++    pool = mmal_port_pool_create(port, NUM_BUFFERS, size);
++
++    for (i = 0; i < NUM_BUFFERS; ++i)
++    {
++       MMAL_BUFFER_HEADER_T* buffer = pool->header[i];
++       void* bufPtr = buffer->data;
++       memset(bufPtr, i*30, w*h);
++       memset(bufPtr+w*h, 128, (w*h)/2);
++    }
++#endif
++
++    return pool;
++}
++
++static void display_cb_input(MMAL_PORT_T *port,MMAL_BUFFER_HEADER_T *buffer) {
++  mmal_buffer_header_release(buffer);
++}
++
++static MMAL_COMPONENT_T* display_init(size_t x, size_t y, size_t w, size_t h)
++{
++    MMAL_COMPONENT_T* display;
++    int w2 = (w+31)&~31;
++    int h2 = (h+15)&~15;
++    MMAL_DISPLAYREGION_T region =
++    {
++        {MMAL_PARAMETER_DISPLAYREGION, sizeof(region)},
++        .set = MMAL_DISPLAY_SET_LAYER | MMAL_DISPLAY_SET_FULLSCREEN | MMAL_DISPLAY_SET_DEST_RECT,
++        .layer = 2,
++        .fullscreen = 0,
++        .dest_rect = {x, y, w, h}
++    };
++    bcm_host_init();  // TODO is this needed?
++    mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER, &display);
++    assert(display);
++
++    mmal_port_parameter_set(display->input[0], &region.hdr);
++
++    MMAL_ES_FORMAT_T* format = display->input[0]->format;
++    format->encoding = MMAL_ENCODING_I420;
++    format->es->video.width = w2;
++    format->es->video.height = h2;
++    format->es->video.crop.x = 0;
++    format->es->video.crop.y = 0;
++    format->es->video.crop.width = w;
++    format->es->video.crop.height = h;
++    mmal_port_format_commit(display->input[0]);
++
++    mmal_component_enable(display);
++
++    rpi_pool = display_alloc_pool(display->input[0], w2, h2);
++
++    mmal_port_enable(display->input[0],display_cb_input);
++    mmal_port_enable(display->control,display_cb_input);
++
++    printf("Allocated display %d %d\n",w,h);
++
++    return display;
++}
++
++static void display_frame(MMAL_COMPONENT_T* display,AVFrame* fr)
++{
++    int w = fr->width;
++    int h = fr->height;
++    int w2 = (w+31)&~31;
++    int h2 = (h+15)&~15;
++    if (!display || !rpi_pool)
++        return;
++    MMAL_BUFFER_HEADER_T* buf = mmal_queue_get(rpi_pool->queue);
++    if (!buf) {
++      // Running too fast so drop the frame
++      return;
++    }
++    assert(buf);
++    buf->cmd = 0;
++    buf->length = (w2 * h2 * 3)/2;
++    buf->offset = 0; // Offset to valid data
++    buf->flags = 0;
++#ifdef RPI_ZERO_COPY
++    buf->data = get_vc_handle(fr->buf[0]);
++    buf->alloc_size = (w2*h2*3)/2;
++#else
++    //mmal_buffer_header_mem_lock(buf);
++    memcpy(buf->data, fr->data[0], w2 * h);
++    memcpy(buf->data+w2*h2, fr->data[1], w2 * h / 4);
++    memcpy(buf->data+w2*h2*5/4, fr->data[2], w2 * h / 4);
++    //mmal_buffer_header_mem_unlock(buf);
++#endif
++
++    mmal_port_send_buffer(display->input[0], buf);  // I assume this will automatically get released
++}
++
++static void display_exit(MMAL_COMPONENT_T* display)
++{
++    if (display) {
++        mmal_component_destroy(display);
++    }
++    if (rpi_pool) {
++        mmal_port_pool_destroy(display->input[0], rpi_pool);
++    }
++}
++
++#endif
++
++
+ /* sub2video hack:
+    Convert subtitles to video with alpha to insert them in filter graphs.
+    This is a temporary solution until libavfilter gets real subtitles support.
+@@ -581,6 +728,10 @@ static void ffmpeg_cleanup(int ret)
+     }
+     term_exit();
+     ffmpeg_exited = 1;
++
++#ifdef RPI_DISPLAY
++    display_exit(rpi_display);
++#endif
+ }
+ 
+ void remove_avoptions(AVDictionary **a, AVDictionary *b)
+@@ -940,6 +1091,14 @@ static void do_video_out(AVFormatContext *s,
+     int frame_size = 0;
+     InputStream *ist = NULL;
+     AVFilterContext *filter = ost->filter->filter;
++#ifdef RPI_DISPLAY
++    if (next_picture)
++    {
++	if (!rpi_display)
++           rpi_display = display_init(0,0,next_picture->width,next_picture->height);
++        display_frame(rpi_display,next_picture);
++    }
++#endif
+ 
+     if (ost->source_index >= 0)
+         ist = input_streams[ost->source_index];
+-- 
+2.7.4
+
+
+From b90a5aff7bf9112ebd2a07949c8d79a49fcafe48 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 29 Apr 2015 16:49:43 +0100
+Subject: [PATCH 02/68] Split transform and intra prediction into commands
+
+---
+ libavcodec/hevc.c       | 119 +++++++++++++++++++++++++++++++++++++++++++++++-
+ libavcodec/hevc.h       |  58 +++++++++++++++++++++++
+ libavcodec/hevc_cabac.c |  15 ++++++
+ 3 files changed, 191 insertions(+), 1 deletion(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index b478065..aa45dd6 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -931,6 +931,25 @@ static int hls_cross_component_pred(HEVCContext *s, int idx) {
+     return 0;
+ }
+ 
++#ifdef RPI
++static void rpi_intra_pred(HEVCContext *s, int log2_trafo_size, int x0, int y0, int c_idx)
++{
++    if (s->enable_rpi) {
++        HEVCLocalContext *lc = s->HEVClc;
++        HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
++        cmd->type = RPI_PRED_INTRA;
++        cmd->size = log2_trafo_size;
++        cmd->c_idx = c_idx;
++        cmd->x = x0;
++        cmd->y = y0;
++        cmd->na = (lc->na.cand_bottom_left<<4) + (lc->na.cand_left<<3) + (lc->na.cand_up_left<<2) + (lc->na.cand_up<<1) + lc->na.cand_up_right;
++        cmd->mode = c_idx ? lc->tu.intra_pred_mode_c :  lc->tu.intra_pred_mode;
++    } else {
++        s->hpc.intra_pred[log2_trafo_size - 2](s, x0, y0, c_idx);
++    }
++}
++#endif
++
+ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+                               int xBase, int yBase, int cb_xBase, int cb_yBase,
+                               int log2_cb_size, int log2_trafo_size,
+@@ -943,8 +962,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+     if (lc->cu.pred_mode == MODE_INTRA) {
+         int trafo_size = 1 << log2_trafo_size;
+         ff_hevc_set_neighbour_available(s, x0, y0, trafo_size, trafo_size);
+-
++#ifdef RPI
++        rpi_intra_pred(s, log2_trafo_size, x0, y0, 0);
++#else
+         s->hpc.intra_pred[log2_trafo_size - 2](s, x0, y0, 0);
++#endif
+     }
+ 
+     if (cbf_luma || cbf_cb[0] || cbf_cr[0] ||
+@@ -1030,7 +1052,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+             for (i = 0; i < (s->ps.sps->chroma_format_idc == 2 ? 2 : 1); i++) {
+                 if (lc->cu.pred_mode == MODE_INTRA) {
+                     ff_hevc_set_neighbour_available(s, x0, y0 + (i << log2_trafo_size_c), trafo_size_h, trafo_size_v);
++#ifdef RPI
++                    rpi_intra_pred(s, log2_trafo_size_c, x0, y0 + (i << log2_trafo_size_c), 1);
++#else
+                     s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (i << log2_trafo_size_c), 1);
++#endif
+                 }
+                 if (cbf_cb[i])
+                     ff_hevc_hls_residual_coding(s, x0, y0 + (i << log2_trafo_size_c),
+@@ -1059,7 +1085,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+             for (i = 0; i < (s->ps.sps->chroma_format_idc == 2 ? 2 : 1); i++) {
+                 if (lc->cu.pred_mode == MODE_INTRA) {
+                     ff_hevc_set_neighbour_available(s, x0, y0 + (i << log2_trafo_size_c), trafo_size_h, trafo_size_v);
++#ifdef RPI
++                    rpi_intra_pred(s, log2_trafo_size_c, x0, y0 + (i << log2_trafo_size_c), 2);
++#else
+                     s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (i << log2_trafo_size_c), 2);
++#endif
+                 }
+                 if (cbf_cr[i])
+                     ff_hevc_hls_residual_coding(s, x0, y0 + (i << log2_trafo_size_c),
+@@ -1088,7 +1118,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+                 if (lc->cu.pred_mode == MODE_INTRA) {
+                     ff_hevc_set_neighbour_available(s, xBase, yBase + (i << log2_trafo_size),
+                                                     trafo_size_h, trafo_size_v);
++#ifdef RPI
++                    rpi_intra_pred(s, log2_trafo_size, xBase, yBase + (i << log2_trafo_size), 1);
++#else
+                     s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (i << log2_trafo_size), 1);
++#endif
+                 }
+                 if (cbf_cb[i])
+                     ff_hevc_hls_residual_coding(s, xBase, yBase + (i << log2_trafo_size),
+@@ -1098,7 +1132,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+                 if (lc->cu.pred_mode == MODE_INTRA) {
+                     ff_hevc_set_neighbour_available(s, xBase, yBase + (i << log2_trafo_size),
+                                                 trafo_size_h, trafo_size_v);
++#ifdef RPI
++                    rpi_intra_pred(s, log2_trafo_size, xBase, yBase + (i << log2_trafo_size), 2);
++#else
+                     s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (i << log2_trafo_size), 2);
++#endif
+                 }
+                 if (cbf_cr[i])
+                     ff_hevc_hls_residual_coding(s, xBase, yBase + (i << log2_trafo_size),
+@@ -1110,26 +1148,46 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+             int trafo_size_h = 1 << (log2_trafo_size_c + s->ps.sps->hshift[1]);
+             int trafo_size_v = 1 << (log2_trafo_size_c + s->ps.sps->vshift[1]);
+             ff_hevc_set_neighbour_available(s, x0, y0, trafo_size_h, trafo_size_v);
++#ifdef RPI
++            rpi_intra_pred(s, log2_trafo_size_c, x0, y0, 1);
++            rpi_intra_pred(s, log2_trafo_size_c, x0, y0, 2);
++#else
+             s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0, 1);
+             s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0, 2);
++#endif
+             if (s->ps.sps->chroma_format_idc == 2) {
+                 ff_hevc_set_neighbour_available(s, x0, y0 + (1 << log2_trafo_size_c),
+                                                 trafo_size_h, trafo_size_v);
++#ifdef RPI
++                rpi_intra_pred(s, log2_trafo_size_c, x0, y0 + (1 << log2_trafo_size_c), 1);
++                rpi_intra_pred(s, log2_trafo_size_c, x0, y0 + (1 << log2_trafo_size_c), 2);
++#else
+                 s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (1 << log2_trafo_size_c), 1);
+                 s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (1 << log2_trafo_size_c), 2);
++#endif
+             }
+         } else if (blk_idx == 3) {
+             int trafo_size_h = 1 << (log2_trafo_size + 1);
+             int trafo_size_v = 1 << (log2_trafo_size + s->ps.sps->vshift[1]);
+             ff_hevc_set_neighbour_available(s, xBase, yBase,
+                                             trafo_size_h, trafo_size_v);
++#ifdef RPI
++            rpi_intra_pred(s, log2_trafo_size, xBase, yBase, 1);
++            rpi_intra_pred(s, log2_trafo_size, xBase, yBase, 2);
++#else
+             s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase, 1);
+             s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase, 2);
++#endif
+             if (s->ps.sps->chroma_format_idc == 2) {
+                 ff_hevc_set_neighbour_available(s, xBase, yBase + (1 << (log2_trafo_size)),
+                                                 trafo_size_h, trafo_size_v);
++#ifdef RPI
++                rpi_intra_pred(s, log2_trafo_size, xBase, yBase + (1 << (log2_trafo_size)), 1);
++                rpi_intra_pred(s, log2_trafo_size, xBase, yBase + (1 << (log2_trafo_size)), 2);
++#else
+                 s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (1 << (log2_trafo_size)), 1);
+                 s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (1 << (log2_trafo_size)), 2);
++#endif
+             }
+         }
+     }
+@@ -2304,6 +2362,31 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
+     lc->ctb_up_left_flag = ((x_ctb > 0) && (y_ctb > 0)  && (ctb_addr_in_slice-1 >= s->ps.sps->ctb_width) && (s->ps.pps->tile_id[ctb_addr_ts] == s->ps.pps->tile_id[s->ps.pps->ctb_addr_rs_to_ts[ctb_addr_rs-1 - s->ps.sps->ctb_width]]));
+ }
+ 
++#ifdef RPI
++static void rpi_execute_pred_cmds(HEVCContext *s)
++{
++  int i;
++  HEVCPredCmd *cmd = s->univ_pred_cmds;
++  HEVCLocalContext *lc = s->HEVClc;
++
++  for(i = s->num_pred_cmds; i > 0; i--, cmd++) {
++      if (cmd->type == RPI_PRED_INTRA) {
++          lc->tu.intra_pred_mode_c = lc->tu.intra_pred_mode = cmd->mode;
++          lc->na.cand_bottom_left  = (cmd->na >> 4) & 1;
++          lc->na.cand_left         = (cmd->na >> 3) & 1;
++          lc->na.cand_up_left      = (cmd->na >> 2) & 1;
++          lc->na.cand_up           = (cmd->na >> 1) & 1;
++          lc->na.cand_up_right     = (cmd->na >> 0) & 1;
++          s->hpc.intra_pred[cmd->size - 2](s, cmd->x, cmd->y, cmd->c_idx);
++      } else {
++          s->hevcdsp.transform_add[cmd->size-2](cmd->dst, cmd->buf, cmd->stride);
++      }
++  }
++  s->num_pred_cmds = 0;
++  s->num_coeffs = 0;
++}
++#endif
++
+ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ {
+     HEVCContext *s  = avctxt->priv_data;
+@@ -2313,6 +2396,10 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     int y_ctb       = 0;
+     int ctb_addr_ts = s->ps.pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
+ 
++#ifdef RPI
++    s->enable_rpi = 1; // TODO this should depend on cross component and frame width etc.
++#endif
++
+     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
+         av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n");
+         return AVERROR_INVALIDDATA;
+@@ -2342,6 +2429,9 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;
+ 
+         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
++#ifdef RPI
++        rpi_execute_pred_cmds(s);
++#endif
+         if (more_data < 0) {
+             s->tab_slice_address[ctb_addr_rs] = -1;
+             return more_data;
+@@ -2387,6 +2477,10 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
+     s = s1->sList[self_id];
+     lc = s->HEVClc;
+ 
++#ifdef RPI
++    s->enable_rpi = 0;
++#endif
++
+     if(ctb_row) {
+         ret = init_get_bits8(&lc->gb, s->data + s->sh.offset[ctb_row - 1], s->sh.size[ctb_row - 1]);
+ 
+@@ -3075,6 +3169,13 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+ 
+     av_freep(&s->cabac_state);
+ 
++#ifdef RPI
++    av_freep(&s->unif_mv_cmds);
++    av_freep(&s->unif_xfm_cmds);
++    av_freep(&s->univ_pred_cmds);
++    av_freep(&s->coeffs_buf);
++#endif
++
+     for (i = 0; i < 3; i++) {
+         av_freep(&s->sao_pixel_buffer_h[i]);
+         av_freep(&s->sao_pixel_buffer_v[i]);
+@@ -3129,6 +3230,22 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     s->HEVClcList[0] = s->HEVClc;
+     s->sList[0] = s;
+ 
++#ifdef RPI
++    s->unif_mv_cmds = av_mallocz(sizeof(HEVCMvCmd)*RPI_MAX_MV_CMDS);
++    if (!s->unif_mv_cmds)
++        goto fail;
++    s->unif_xfm_cmds = av_mallocz(sizeof(HEVCXfmCmd)*RPI_MAX_XFM_CMDS);
++    if (!s->unif_xfm_cmds)
++        goto fail;
++    s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
++    if (!s->univ_pred_cmds)
++        goto fail;
++    s->coeffs_buf = av_mallocz(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16);
++    if (!s->coeffs_buf)
++        goto fail;
++    s->enable_rpi = 0;
++#endif
++
+     s->cabac_state = av_malloc(HEVC_CONTEXTS);
+     if (!s->cabac_state)
+         goto fail;
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index be91010..7a1c35f 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -23,6 +23,9 @@
+ #ifndef AVCODEC_HEVC_H
+ #define AVCODEC_HEVC_H
+ 
++// define RPI to split the CABAC/prediction/transform into separate stages
++#include "config.h"
++
+ #include "libavutil/buffer.h"
+ #include "libavutil/md5.h"
+ 
+@@ -790,6 +793,49 @@ typedef struct HEVCLocalContext {
+     int boundary_flags;
+ } HEVCLocalContext;
+ 
++#ifdef RPI
++
++// RPI_MAX_WIDTH is maximum width in pixels supported by the accelerated code
++#define RPI_MAX_WIDTH 2048
++
++// Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane
++#define RPI_MAX_MV_CMDS   (16*3*(RPI_MAX_WIDTH/4))
++#define RPI_MAX_XFM_CMDS  (16*3*(RPI_MAX_WIDTH/4))
++// Each block can have an intra prediction and a transform_add command
++#define RPI_MAX_PRED_CMDS (2*16*3*(RPI_MAX_WIDTH/4))
++
++// Command for inter prediction
++typedef struct HEVCMvCmd {
++} HEVCMvCmd;
++
++// Command for transform to process a block of coefficients
++typedef struct HEVCXfmCmd {
++} HEVCXfmCmd;
++
++// Command for intra prediction and transform_add of predictions to coefficients
++#define RPI_PRED_TRANSFORM_ADD 0
++#define RPI_PRED_INTRA 1
++typedef struct HEVCPredCmd {
++    uint8_t size;
++    uint8_t type;
++    uint8_t na;
++    uint8_t c_idx;
++    union {
++        uint8_t *dst; // RPI_PRED_TRANSFORM_ADD
++        uint32_t x;   // RPI_PRED_INTRA
++    };
++    union {
++        int16_t *buf; // RPI_PRED_TRANSFORM_ADD
++        uint32_t y;   // RPI_PRED_INTRA
++    };
++    union {
++        enum IntraPredMode mode; // RPI_PRED_TRANSFORM_ADD
++        uint32_t stride;         // RPI_PRED_INTRA
++    };
++} HEVCPredCmd;
++
++#endif
++
+ typedef struct HEVCContext {
+     const AVClass *c;  // needed by private avoptions
+     AVCodecContext *avctx;
+@@ -805,6 +851,18 @@ typedef struct HEVCContext {
+     int                 width;
+     int                 height;
+ 
++#ifdef RPI
++    int enable_rpi;
++    HEVCMvCmd *unif_mv_cmds;
++    HEVCXfmCmd *unif_xfm_cmds;
++    HEVCPredCmd *univ_pred_cmds;
++    int16_t *coeffs_buf;
++    int num_mv_cmds;
++    int num_xfm_cmds;
++    int num_pred_cmds;
++    int num_coeffs;
++#endif
++
+     uint8_t *cabac_state;
+ 
+     /** 1 if the independent slice segment header was successfully parsed */
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index 05b2821..4e97f06 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -1510,6 +1510,21 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+             coeffs[i] = coeffs[i] + ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
+         }
+     }
++#ifdef RPI
++    if (s->enable_rpi) {
++        int16_t *c = s->coeffs_buf + s->num_coeffs;
++        int n = trafo_size * trafo_size;
++        HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
++        memcpy(c, coeffs, n * sizeof(int16_t));  // TODO change pointer earlier and we can avoid this copy
++        s->num_coeffs += n;
++        cmd->type = RPI_PRED_TRANSFORM_ADD;
++        cmd->size = log2_trafo_size;
++        cmd->buf = c;
++        cmd->dst = dst;
++        cmd->stride = stride;
++        return;
++    }
++#endif
+     s->hevcdsp.transform_add[log2_trafo_size-2](dst, coeffs, stride);
+ }
+ 
+-- 
+2.7.4
+
+
+From f8293de11dc040d9fa2a558762a357c0c353d2c9 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 30 Apr 2015 15:23:22 +0100
+Subject: [PATCH 03/68] Added simple VPU test code
+
+---
+ libavcodec/Makefile             |    7 +
+ libavcodec/hevc.c               |   33 +-
+ libavcodec/rpi_hevc_transform.h |  212 ++++++
+ libavcodec/rpi_hevc_transform.s |  147 ++++
+ libavcodec/rpi_mailbox.c        |  293 ++++++++
+ libavcodec/rpi_mailbox.h        |   20 +
+ libavcodec/rpi_qpu.c            |  652 ++++++++++++++++++
+ libavcodec/rpi_qpu.h            |   45 ++
+ libavcodec/rpi_shader.c         |  818 ++++++++++++++++++++++
+ libavcodec/rpi_shader.h         |   20 +
+ libavcodec/rpi_shader.qasm      | 1413 +++++++++++++++++++++++++++++++++++++++
+ libavcodec/rpi_user_vcsm.h      |  425 ++++++++++++
+ 12 files changed, 4084 insertions(+), 1 deletion(-)
+ create mode 100644 libavcodec/rpi_hevc_transform.h
+ create mode 100644 libavcodec/rpi_hevc_transform.s
+ create mode 100644 libavcodec/rpi_mailbox.c
+ create mode 100644 libavcodec/rpi_mailbox.h
+ create mode 100644 libavcodec/rpi_qpu.c
+ create mode 100644 libavcodec/rpi_qpu.h
+ create mode 100644 libavcodec/rpi_shader.c
+ create mode 100644 libavcodec/rpi_shader.h
+ create mode 100644 libavcodec/rpi_shader.qasm
+ create mode 100644 libavcodec/rpi_user_vcsm.h
+
+diff --git a/libavcodec/Makefile b/libavcodec/Makefile
+index fd0d1f0..03065cd 100644
+--- a/libavcodec/Makefile
++++ b/libavcodec/Makefile
+@@ -5,6 +5,10 @@ NAME = avcodec
+ HEADERS = avcodec.h                                                     \
+           avdct.h                                                       \
+           avfft.h                                                       \
++          rpi_qpu.h                                                     \
++          rpi_shader.h                                                  \
++          rpi_mailbox.h                                                 \
++          rpi_hevc_transform.h                                          \
+           d3d11va.h                                                     \
+           dirac.h                                                       \
+           dv_profile.h                                                  \
+@@ -43,6 +47,9 @@ OBJS = allcodecs.o                                                      \
+        resample.o                                                       \
+        resample2.o                                                      \
+        utils.o                                                          \
++       rpi_qpu.o                                                        \
++       rpi_shader.o                                                     \
++       rpi_mailbox.o                                                    \
+        vorbis_parser.o                                                  \
+        xiph.o                                                           \
+ 
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index aa45dd6..ab55df1 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -41,6 +41,10 @@
+ #include "hevc.h"
+ #include "profiles.h"
+ 
++#ifdef RPI
++#include "rpi_qpu.h"
++#endif
++
+ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12] = 4, [16] = 5, [24] = 6, [32] = 7, [48] = 8, [64] = 9 };
+ 
+ /**
+@@ -2430,7 +2434,9 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ 
+         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
+ #ifdef RPI
+-        rpi_execute_pred_cmds(s);
++        if (x_ctb + ctb_size >= s->ps.sps->width) {
++            rpi_execute_pred_cmds(s);
++        }
+ #endif
+         if (more_data < 0) {
+             s->tab_slice_address[ctb_addr_rs] = -1;
+@@ -3244,6 +3250,31 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     if (!s->coeffs_buf)
+         goto fail;
+     s->enable_rpi = 0;
++
++    // A little test program
++    {
++      GPU_MEM_PTR_T p;
++      int err = gpu_malloc_cached(16, &p);
++      short *q = (short *)p.arm;
++      int i;
++      int r;
++      printf("Allocated memory %d ARM 0x%x, VC 0x%x, Code 0x%x\n",err,(int)p.arm,p.vc,(int)vpu_get_fn());
++      printf("Allocated memory %d ARM 0x%x, VC 0x%x\n",err,(int)p.arm,p.vc);
++      printf("Preparing data %p\n",q);
++      for(i=0;i<16;i++)
++        q[i] = i;
++      printf("Flush cache\n");
++      gpu_cache_flush(&p);
++      printf("Executing code\n");
++      r = vpu_execute_code( vpu_get_fn(), p.vc, 0, 0, 0, 0, 0);
++      printf("Return value %d (",r);
++      for(i=0;i<16;i++)
++        printf("%d ",q[i]);
++      printf(")\n");
++      gpu_free(&p);
++      goto fail; // Early out
++    }
++
+ #endif
+ 
+     s->cabac_state = av_malloc(HEVC_CONTEXTS);
+diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
+new file mode 100644
+index 0000000..85a9102
+--- /dev/null
++++ b/libavcodec/rpi_hevc_transform.h
+@@ -0,0 +1,212 @@
++unsigned char rpi_hevc_transform [] = {
++169,
++3,
++3,
++232,
++128,
++0,
++0,
++0,
++20,
++248,
++0,
++136,
++0,
++0,
++192,
++248,
++0,
++0,
++0,
++96,
++3,
++232,
++32,
++0,
++0,
++0,
++7,
++232,
++0,
++2,
++0,
++0,
++8,
++232,
++0,
++4,
++0,
++0,
++12,
++248,
++0,
++128,
++0,
++0,
++192,
++8,
++4,
++0,
++4,
++232,
++64,
++0,
++0,
++0,
++5,
++232,
++0,
++0,
++8,
++0,
++128,
++69,
++113,
++66,
++12,
++248,
++0,
++128,
++0,
++0,
++192,
++8,
++4,
++0,
++128,
++69,
++113,
++70,
++128,
++144,
++39,
++0,
++4,
++255,
++48,
++192,
++128,
++3,
++32,
++8,
++16,
++0,
++76,
++254,
++48,
++192,
++9,
++4,
++32,
++8,
++0,
++0,
++4,
++254,
++0,
++144,
++128,
++2,
++0,
++248,
++62,
++0,
++128,
++144,
++22,
++0,
++4,
++255,
++48,
++192,
++128,
++3,
++32,
++8,
++16,
++0,
++76,
++254,
++48,
++192,
++9,
++4,
++32,
++8,
++0,
++0,
++140,
++248,
++44,
++0,
++0,
++0,
++32,
++48,
++4,
++0,
++128,
++69,
++113,
++66,
++242,
++140,
++211,
++192,
++41,
++3,
++68,
++192,
++80,
++7,
++164,
++255,
++36,
++220,
++96,
++2,
++0,
++248,
++62,
++0,
++3,
++255,
++55,
++208,
++120,
++3,
++224,
++3,
++190,
++11,
++16,
++139,
++246,
++83,
++0,
++103,
++90,
++0,
++8,
++240,
++0,
++128,
++128,
++3,
++0,
++247,
++32,
++128,
++10,
++4,
++136,
++240,
++32,
++0,
++128,
++3,
++112,
++96,
++90,
++0,
++};
+diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
+new file mode 100644
+index 0000000..5e2728d
+--- /dev/null
++++ b/libavcodec/rpi_hevc_transform.s
+@@ -0,0 +1,147 @@
++# ******************************************************************************
++# Argon Design Ltd.
++# (c) Copyright 2015 Argon Design Ltd. All rights reserved.
++#
++# Module : HEVC
++# Author : Peter de Rivaz
++# ******************************************************************************
++
++# HEVC VPU Transform
++#
++# Transform matrix can be thought of as
++#   output row vector = input row vector * transMatrix2
++#
++# The even rows of the matrix are symmetric
++# The odd rows of the matrix are antisymmetric
++#
++# So only need to compute the first half of the results, then can compute the remainder with a butterfly
++#
++# EXAMPLE
++#   (a b c d) (1 2  2  1)
++#             (3 4 -4 -3)
++#             (5 6  6  5)
++#             (7 8 -8 -7)
++#
++#  x=(a c)(1 2) = 1a+5c 2a+6c
++#         (5 6)
++#
++#  y=(b d)(3 4) = 3b+7d 4b+8d
++#         (7 8)
++#
++#  u=x+y = 1a+5c+3b+7d 2a+4b+6c+8d
++#  v=x-y = 1a+5c-3b-7d 2a+6c-4b-8d
++#
++#  Final results are (u , v[::-1])
++#
++#
++#  For 32x1 input, load even rows into HX(0++,0), odd rows into HX(16++,0)
++#  Apply the even matrix first and stop before rounding
++#  Then apply the odd matrix in a full manner:
++#
++#   First step is to compute partial products with the first input (16 cycles)
++#   1a 3b 5c 7d   16x1 input coefficients produce 16x16 output
++#   2a 4b 6c 8d
++#   2a -4b 6c -8d
++#   1a -3b 5c -7d
++#
++#   Second step is to sum partial products into final position (8 cycles)
++#   1a+3b+5c+7d
++#   2a+4b+6c+8d
++#   2a-4b+6c-8d
++#   1a-3b+5c-7d
++#
++#   Then can apply butterfly to combine even results and odd results + rounding to produce 16 rows of output at a time (need to save in transposed format)
++#
++#   For 16x16 no butterfly is required and can store final results in original location  (Could do 2 16x16s in parallel to make use of the trick - saves on the adds)
++#
++#   For 8x8 we could compute two in parallel.
++#
++#
++
++test_add:
++  vldh HX(0,0),(r0)
++  vadd HX(0,0),HX(0,0),10
++  vsth HX(0,0),(r0)
++  mov r0,7 # return value
++  b lr
++
++# Columns are transformed first
++#
++# Store top left half of transMatrix2 in
++# Store bottom left half of transMatrix2 in HX(32,32)
++#
++# For 16x16
++# HX(0:15,0) contains input data before transform
++# HY(0:15,0) contains 32bit output data after transform
++# HX(32,0) contains even rows of left half of transMatrix2
++# HX(32,32) contains odd rows of left half of transMatrix2
++# HY(48,0) contains partial products ready for summing
++#
++
++
++# hevc_trans_16x16(short *transMatrix2, short *coeffs, int num)
++# transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory)
++# coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
++# num: number of 16x16 transforms to be done
++#
++hevc_trans_16x16:
++  push r6-r15, lr # TODO cut down number of used registers
++
++  mov r3, 2*32*2 # Twice Stride of transMatrix2 in bytes
++  vld HX(32++,0),(r0 += r3) REP 16 # This is the 16x16 matrix, a transform is equivalent to multiplying input row vector * matrix
++  # Now use r0 to describe which matrix we are working on.
++  # Allows us to prefetch the next block of coefficients for efficiency.
++  mov r0,0 # This describes the location where we read our coefficients from
++  mov r3,16*2 # Stride of coefficients in bytes
++  mov r7,16*16*2 # Total block size
++  mov r8,64*16 # Value used to swap from current to next VRF location
++  vldh HX(0++,0)+r0,(r1 += r3) REP 16
++  mov r4,64 # Constant used for rounding first pass
++  mov r5,1<<19 # Constant used for rounding second pass
++
++  # At start of block r0,r1 point to the current block (that has already been loaded)
++block_loop:
++  eor r0,r8
++  add r1,r7
++  # Prefetch the next block
++  vldh HX(0++,0)+r0,(r1 += r3) REP 16
++  eor r0,r8
++  sub r1,r7
++
++  # Transform the current block
++  bl col_trans_16
++  vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
++  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
++  vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
++  vmov VX(0,0++), HX(0++,32) REP 16          # For simplicity transpose this back to the original position
++
++  bl col_trans_16
++  vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
++  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
++  vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
++
++  # Save results - note there has been a transposition during the processing so we save columns
++  vsth VX(0,32++)+r0, (r1 += r3) REP 16
++
++  # Move onto next block
++  eor r0,r8
++  add r1,r7
++
++  addcmpbgt r2,-1,0,block_loop
++  pop r6-r15, pc
++
++# r1,r2,r3 r7,r8 should be preserved
++# HX(0++,0)+r0 is the block to be transformed
++# HX(32++,0) is the 16x16 matrix of transform coefficients
++# Use HY(48,0) for intermediate results
++# r0 can be used, but should be returned to its original value at the end
++col_trans_16:
++  add r4,r0,16 # Final value for this loop
++col_trans_16_loop:
++  # First compute partial products for a single column
++  vmul32s VY(48,0++), VX(0,0)+r0, VX(32,0++) REP 16
++  # Then sum up the results and place back
++  vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
++  addcmpblt r0,1,r4,col_trans_16_loop
++  sub r0,16  # but r0 back to its original value
++  b lr
+diff --git a/libavcodec/rpi_mailbox.c b/libavcodec/rpi_mailbox.c
+new file mode 100644
+index 0000000..536896f
+--- /dev/null
++++ b/libavcodec/rpi_mailbox.c
+@@ -0,0 +1,293 @@
++/*
++Copyright (c) 2012, Broadcom Europe Ltd.
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without
++modification, are permitted provided that the following conditions are met:
++    * Redistributions of source code must retain the above copyright
++      notice, this list of conditions and the following disclaimer.
++    * Redistributions in binary form must reproduce the above copyright
++      notice, this list of conditions and the following disclaimer in the
++      documentation and/or other materials provided with the distribution.
++    * Neither the name of the copyright holder nor the
++      names of its contributors may be used to endorse or promote products
++      derived from this software without specific prior written permission.
++
++THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
++ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
++WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
++DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
++(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
++LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
++ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
++(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
++SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++*/
++
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++#include <fcntl.h>
++#include <unistd.h>
++#include <assert.h>
++#include <stdint.h>
++#include <sys/mman.h>
++#include <sys/ioctl.h>
++
++#include <linux/ioctl.h>
++
++#define MAJOR_NUM 100
++#define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
++#define DEVICE_FILE_NAME "/dev/char_dev"
++
++#include "rpi_mailbox.h"
++
++#define PAGE_SIZE (4*1024)
++
++// Shared memory will not be cached in ARM cache
++void *mapmem_shared(unsigned base, unsigned size)
++{
++   int mem_fd;
++   unsigned offset = base % PAGE_SIZE;
++   base = base - offset;
++   /* open /dev/mem */
++   if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
++      printf("can't open /dev/mem\nThis program should be run as root. Try prefixing command with: sudo\n");
++      return NULL;
++   }
++   void *mem = mmap(
++      0,
++      size,
++      PROT_READ|PROT_WRITE,
++      MAP_SHARED/*|MAP_FIXED*/,
++      mem_fd,
++      base);
++#ifdef DEBUG
++   printf("base=0x%x, mem=%p\n", base, mem);
++#endif
++   if (mem == MAP_FAILED) {
++      printf("mmap error %d\n", (int)mem);
++      return NULL;
++   }
++   close(mem_fd);
++   return (char *)mem + offset;
++}
++
++// Unshared memory will be faster as lives in ARM cache, but requires cache flushing
++void *mapmem_private(unsigned base, unsigned size)
++{
++   int mem_fd;
++   unsigned offset = base % PAGE_SIZE;
++   base = base - offset;
++   /* open /dev/mem */
++   if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
++      printf("can't open /dev/mem\nThis program should be run as root. Try prefixing command with: sudo\n");
++      return NULL;
++   }
++   void *mem = mmap(
++      0,
++      size,
++      PROT_READ|PROT_WRITE,
++      MAP_PRIVATE/*|MAP_FIXED*/,
++      mem_fd,
++      base);
++#ifdef DEBUG
++   printf("base=0x%x, mem=%p\n", base, mem);
++#endif
++   if (mem == MAP_FAILED) {
++      printf("mmap error %d\n", (int)mem);
++      return NULL;
++   }
++   close(mem_fd);
++   return (char *)mem + offset;
++}
++
++void unmapmem(void *addr, unsigned size)
++{
++   int s = munmap(addr, size);
++   if (s != 0) {
++      printf("munmap error %d\n", s);
++      exit (-1);
++   }
++}
++
++/*
++ * use ioctl to send mbox property message
++ */
++
++static int mbox_property(int file_desc, void *buf)
++{
++   int ret_val = ioctl(file_desc, IOCTL_MBOX_PROPERTY, buf);
++
++   if (ret_val < 0) {
++      printf("ioctl_set_msg failed:%d\n", ret_val);
++   }
++
++#ifdef DEBUG
++   unsigned *p = buf; int i; unsigned size = *(unsigned *)buf;
++   for (i=0; i<size/4; i++)
++      printf("%04x: 0x%08x\n", i*sizeof *p, p[i]);
++#endif
++   return ret_val;
++}
++
++unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags)
++{
++   int i=0;
++   unsigned p[32];
++   p[i++] = 0; // size
++   p[i++] = 0x00000000; // process request
++
++   p[i++] = 0x3000c; // (the tag id)
++   p[i++] = 12; // (size of the buffer)
++   p[i++] = 12; // (size of the data)
++   p[i++] = size; // (num bytes? or pages?)
++   p[i++] = align; // (alignment)
++   p[i++] = flags; // (MEM_FLAG_L1_NONALLOCATING)
++
++   p[i++] = 0x00000000; // end tag
++   p[0] = i*sizeof *p; // actual size
++
++   mbox_property(file_desc, p);
++   return p[5];
++}
++
++unsigned mem_free(int file_desc, unsigned handle)
++{
++   int i=0;
++   unsigned p[32];
++   p[i++] = 0; // size
++   p[i++] = 0x00000000; // process request
++
++   p[i++] = 0x3000f; // (the tag id)
++   p[i++] = 4; // (size of the buffer)
++   p[i++] = 4; // (size of the data)
++   p[i++] = handle;
++
++   p[i++] = 0x00000000; // end tag
++   p[0] = i*sizeof *p; // actual size
++
++   mbox_property(file_desc, p);
++   return p[5];
++}
++
++unsigned mem_lock(int file_desc, unsigned handle)
++{
++   int i=0;
++   unsigned p[32];
++   p[i++] = 0; // size
++   p[i++] = 0x00000000; // process request
++
++   p[i++] = 0x3000d; // (the tag id)
++   p[i++] = 4; // (size of the buffer)
++   p[i++] = 4; // (size of the data)
++   p[i++] = handle;
++
++   p[i++] = 0x00000000; // end tag
++   p[0] = i*sizeof *p; // actual size
++
++   mbox_property(file_desc, p);
++   return p[5];
++}
++
++unsigned mem_unlock(int file_desc, unsigned handle)
++{
++   int i=0;
++   unsigned p[32];
++   p[i++] = 0; // size
++   p[i++] = 0x00000000; // process request
++
++   p[i++] = 0x3000e; // (the tag id)
++   p[i++] = 4; // (size of the buffer)
++   p[i++] = 4; // (size of the data)
++   p[i++] = handle;
++
++   p[i++] = 0x00000000; // end tag
++   p[0] = i*sizeof *p; // actual size
++
++   mbox_property(file_desc, p);
++   return p[5];
++}
++
++unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
++{
++   int i=0;
++   unsigned p[32];
++   p[i++] = 0; // size
++   p[i++] = 0x00000000; // process request
++
++   p[i++] = 0x30010; // (the tag id)
++   p[i++] = 28; // (size of the buffer)
++   p[i++] = 28; // (size of the data)
++   p[i++] = code;
++   p[i++] = r0;
++   p[i++] = r1;
++   p[i++] = r2;
++   p[i++] = r3;
++   p[i++] = r4;
++   p[i++] = r5;
++
++   p[i++] = 0x00000000; // end tag
++   p[0] = i*sizeof *p; // actual size
++
++   mbox_property(file_desc, p);
++   return p[5];
++}
++
++unsigned qpu_enable(int file_desc, unsigned enable)
++{
++   int i=0;
++   unsigned p[32];
++
++   p[i++] = 0; // size
++   p[i++] = 0x00000000; // process request
++
++   p[i++] = 0x30012; // (the tag id)
++   p[i++] = 4; // (size of the buffer)
++   p[i++] = 4; // (size of the data)
++   p[i++] = enable;
++
++   p[i++] = 0x00000000; // end tag
++   p[0] = i*sizeof *p; // actual size
++
++   mbox_property(file_desc, p);
++   return p[5];
++}
++
++unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout) {
++   int i=0;
++   unsigned p[32];
++
++   p[i++] = 0; // size
++   p[i++] = 0x00000000; // process request
++   p[i++] = 0x30011; // (the tag id)
++   p[i++] = 16; // (size of the buffer)
++   p[i++] = 16; // (size of the data)
++   p[i++] = num_qpus;
++   p[i++] = control;
++   p[i++] = noflush;
++   p[i++] = timeout; // ms
++
++   p[i++] = 0x00000000; // end tag
++   p[0] = i*sizeof *p; // actual size
++
++   mbox_property(file_desc, p);
++   return p[5];
++}
++
++int mbox_open() {
++   int file_desc;
++
++   // open a char device file used for communicating with kernel mbox driver
++   file_desc = open(DEVICE_FILE_NAME, 0);
++   if (file_desc < 0) {
++      printf("Can't open device file: %s\n", DEVICE_FILE_NAME);
++      printf("Try creating a device file with: sudo mknod %s c %d 0\n", DEVICE_FILE_NAME, MAJOR_NUM);
++   }
++   return file_desc;
++}
++
++void mbox_close(int file_desc) {
++  close(file_desc);
++}
+diff --git a/libavcodec/rpi_mailbox.h b/libavcodec/rpi_mailbox.h
+new file mode 100644
+index 0000000..c264d2e
+--- /dev/null
++++ b/libavcodec/rpi_mailbox.h
+@@ -0,0 +1,20 @@
++#ifndef RPI_MAILBOX_H
++#define RPI_MAILBOX_H
++
++extern int mbox_open(void);
++extern void mbox_close(int file_desc);
++
++extern unsigned get_version(int file_desc);
++extern unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags);
++extern unsigned mem_free(int file_desc, unsigned handle);
++extern unsigned mem_lock(int file_desc, unsigned handle);
++extern unsigned mem_unlock(int file_desc, unsigned handle);
++extern void *mapmem_shared(unsigned base, unsigned size);
++extern void *mapmem_private(unsigned base, unsigned size);
++extern void unmapmem(void *addr, unsigned size);
++
++extern unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
++extern unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout);
++extern unsigned qpu_enable(int file_desc, unsigned enable);
++
++#endif
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+new file mode 100644
+index 0000000..b1f50ee
+--- /dev/null
++++ b/libavcodec/rpi_qpu.c
+@@ -0,0 +1,652 @@
++#ifdef RPI
++// Use the vcsm device for shared memory
++// This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
++#define RPI_USE_VCSM
++#define RPI_TIME_TOTAL_QPU
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <stddef.h>
++#include <assert.h>
++
++#include "config.h"
++
++#include <pthread.h>
++#include <time.h>
++
++#include "rpi_mailbox.h"
++#include "rpi_qpu.h"
++#include "rpi_shader.h"
++#include "rpi_hevc_transform.h"
++
++#ifdef RPI_USE_VCSM
++#include "rpi_user_vcsm.h"
++#endif
++
++// On Pi2 there is no way to access the VPU L2 cache
++// GPU_MEM_FLG should be 4 for uncached memory.
++// However, if using VCSM allocated buffers, need to use C at the moment because VCSM does not allocate uncached memory correctly
++// The QPU crashes if we mix L2 cached and L2 uncached accesses due to a HW bug.
++#define GPU_MEM_FLG 0xC
++#define GPU_MEM_MAP 0x0
++
++#define vcos_verify(x) ((x)>=0)
++
++typedef unsigned char uint8_t;
++typedef signed char int8_t;
++typedef unsigned short uint16_t;
++typedef unsigned int uint32_t;
++typedef int int32_t;
++
++/*static const unsigned code[] =
++{
++  #include "rpi_shader.hex"
++};*/
++
++// Size in 32bit words
++#define QPU_CODE_SIZE 2048
++#define VPU_CODE_SIZE 2048
++
++struct GPU
++{
++  unsigned int qpu_code[QPU_CODE_SIZE];
++  unsigned int vpu_code[VPU_CODE_SIZE];
++  int open_count; // Number of allocated video buffers
++  unsigned int vc_handle; // Handle of this memory
++  int      mb; // Mailbox handle
++  int      vc; // Address in GPU memory
++  int mail[12]; // These are used to pass pairs of code/unifs to the QPUs
++};
++
++// Stop more than one thread trying to allocate memory or use the processing resources at once
++static pthread_mutex_t gpu_mutex = PTHREAD_MUTEX_INITIALIZER;
++static volatile struct GPU* gpu = NULL;
++
++#ifdef RPI_TIME_TOTAL_QPU
++static unsigned int Microseconds(void) {
++    struct timespec ts;
++    unsigned int x;
++    static unsigned int base = 0;
++    clock_gettime(CLOCK_REALTIME, &ts);
++    x = ts.tv_sec*1000000 + ts.tv_nsec/1000;
++    if (base==0) base=x;
++    return x-base;
++}
++#endif
++
++// Connect to QPU, returns 0 on success.
++static int gpu_init(volatile struct GPU **gpu) {
++  int mb = mbox_open();
++  int vc;
++  int handle;
++  volatile struct GPU* ptr;
++	if (mb < 0)
++		return -1;
++
++	if (qpu_enable(mb, 1)) return -2;
++
++#ifdef RPI_USE_VCSM
++  vcsm_init();
++#endif
++
++  handle = mem_alloc(mb, sizeof(struct GPU), 4096, GPU_MEM_FLG);
++  if (!handle)
++  {
++    qpu_enable(mb, 0);
++    return -3;
++  }
++	vc = mem_lock(mb, handle);
++	ptr = mapmem_shared((vc+GPU_MEM_MAP)&~0xc0000000, sizeof(struct GPU));
++	if (ptr == NULL)
++	{	mem_free(mb, handle);
++		mem_unlock(mb, handle);
++		qpu_enable(mb, 0);
++		return -4;
++	}
++
++	ptr->mb = mb;
++	ptr->vc_handle = handle;
++	ptr->vc = vc;
++
++  *gpu = ptr;
++
++  // Now copy over the QPU code into GPU memory
++  {
++    int num_bytes = qpu_get_fn(QPU_MC_END) - qpu_get_fn(QPU_MC_SETUP);
++    assert(num_bytes<=QPU_CODE_SIZE*sizeof(unsigned int));
++    memcpy((void*)ptr->qpu_code, rpi_shader, num_bytes);
++  }
++  // And the VPU code
++  {
++    int num_bytes = sizeof(rpi_hevc_transform);
++    assert(num_bytes<=VPU_CODE_SIZE*sizeof(unsigned int));
++    memcpy((void*)ptr->vpu_code, rpi_hevc_transform, num_bytes);
++  }
++
++  return 0;
++}
++
++// Make sure we have exclusive access to the mailbox, and enable qpu if necessary.
++static void gpu_lock(void) {
++  pthread_mutex_lock(&gpu_mutex);
++  if (gpu==NULL) {
++    gpu_init(&gpu);
++  }
++}
++
++static void gpu_unlock(void) {
++  pthread_mutex_unlock(&gpu_mutex);
++}
++
++// Allocate memory on GPU
++// Fills in structure <p> containing ARM pointer, videocore handle, videocore memory address, numbytes
++// Returns 0 on success.
++// This allocates memory that will not be cached in ARM's data cache.
++// Therefore safe to use without data cache flushing.
++int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p) {
++  gpu_lock();
++  p->vc_handle = mem_alloc(gpu->mb, numbytes, 4096, GPU_MEM_FLG);
++  p->vcsm_handle = 0;
++  if (!p->vc_handle)
++  {
++    qpu_enable(gpu->mb, 0);
++    return -3;
++  }
++  p->vc = mem_lock(gpu->mb, p->vc_handle);
++  p->arm = mapmem_shared((p->vc+GPU_MEM_MAP)&~0xc0000000,numbytes);
++  p->numbytes = numbytes;
++  if (p->arm == NULL)
++  {
++    mem_free(gpu->mb, p->vc_handle);
++    mem_unlock(gpu->mb, p->vc_handle);
++    gpu_unlock();
++    qpu_enable(gpu->mb, 0);
++    return -4;
++  }
++  gpu->open_count++;
++  gpu_unlock();
++  return 0;
++}
++
++void gpu_cache_flush(GPU_MEM_PTR_T *p)
++{
++  // This only works when using RPI_USE_VCSM
++  void *tmp = vcsm_lock(p->vcsm_handle);
++  vcsm_unlock_ptr(tmp);
++}
++
++// This allocates data that will be
++//    Cached in ARM L2
++//    Uncached in VPU L2
++int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p) {
++  gpu_lock();
++#ifdef RPI_USE_VCSM
++  {
++      p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" ); // f....... locks up for VP9 - retest this?
++      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" ); // 3b...... works
++      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" ); //fb...... locks up
++      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST_AND_VC, (char *)"Video Frame" ); // 3b works (but corrupted due to caching)
++      p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
++      p->arm = vcsm_lock(p->vcsm_handle);
++      p->vc = mem_lock(gpu->mb, p->vc_handle);
++  }
++#else
++  p->vc_handle = mem_alloc(gpu->mb, numbytes, 4096, GPU_MEM_FLG);
++  p->vcsm_handle = 0;
++  if (!p->handle)
++  {
++    qpu_enable(gpu->mb, 0);
++    return -3;
++  }
++  p->vc = mem_lock(gpu->mb, p->vc_handle);
++  printf("This mapmem_private does not seem to work\n");
++  exit(-1);
++  p->arm = mapmem_private((p->vc+GPU_MEM_MAP)&~0xc0000000,numbytes);
++  p->numbytes = numbytes;
++  if (p->arm == NULL)
++  {
++    mem_free(gpu->mb, p->handle);
++    mem_unlock(gpu->mb, p->handle);
++    gpu_unlock();
++    qpu_enable(gpu->mb, 0);
++    return -4;
++  }
++#endif
++  gpu->open_count++;
++  gpu_unlock();
++  return 0;
++}
++
++static void gpu_term(void)
++{
++	int mb = gpu->mb;
++	unsigned handle = gpu->vc_handle;
++  if (gpu==NULL)
++    return;
++	unmapmem((void*)gpu, sizeof(struct GPU));
++	mem_unlock(mb, handle);
++	mem_free(mb, handle);
++	qpu_enable(mb, 0);
++#ifdef RPI_USE_VCSM
++  vcsm_exit();
++#endif
++	mbox_close(mb);
++  gpu = NULL;
++}
++
++void gpu_free(GPU_MEM_PTR_T *p) {
++  int mb = gpu->mb;
++	unsigned handle = p->vc_handle;
++  gpu_lock();
++#ifdef RPI_USE_VCSM
++  if (p->vcsm_handle) {
++      mem_unlock(mb,p->vc_handle);
++      vcsm_unlock_ptr(p->arm);
++      vcsm_free(p->vcsm_handle);
++  } else {
++	unmapmem((void*)p->arm, sizeof(struct GPU));
++      mem_unlock(mb, handle);
++      mem_free(mb, handle);
++  }
++#else
++	unmapmem((void*)p->arm, sizeof(struct GPU));
++	mem_unlock(mb, handle);
++	mem_free(mb, handle);
++#endif
++
++  gpu->open_count--;
++  if (gpu->open_count==0) {
++      printf("Closing GPU\n");
++      gpu_term();
++      gpu = NULL;
++  }
++  gpu_unlock();
++}
++
++unsigned int vpu_get_fn(void) {
++  // Make sure that the gpu is initialized
++  if (gpu==NULL) {
++    printf("Preparing gpu\n");
++    gpu_lock();
++    gpu_unlock();
++  }
++  return gpu->vc + offsetof(struct GPU,vpu_code);
++}
++
++unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
++{
++  unsigned r;
++  gpu_lock();
++  r = execute_code(gpu->mb, code, r0, r1, r2, r3, r4, r5);
++  gpu_unlock();
++  return r;
++}
++
++// Run a program on a QPU with the given code and uniform stream (given in GPU addresses)
++// The first num QPUs will start at code, the next num2 QPUs will start at code2
++void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8, int unifs9, int unifs10, int unifs11, int unifs12)
++{
++  int i;
++#ifdef RPI_TIME_TOTAL_QPU
++  static int last_time=0;
++  static long long on_time=0;
++  static long long off_time=0;
++  int start_time;
++  int end_time;
++  static int count=0;
++#endif
++
++  gpu_lock();
++#ifdef RPI_TIME_TOTAL_QPU
++  start_time = Microseconds();
++  if (last_time==0)
++    last_time = start_time;
++  off_time += start_time-last_time;
++#endif
++  for(i=0;i<num;i++) {
++    gpu->mail[i*2 + 1] = code;
++  }
++  for(;i<num+num2;i++) {
++    gpu->mail[i*2 + 1] = code2;
++  }
++  gpu->mail[0 ] = unifs1;
++  gpu->mail[2 ] = unifs2;
++  gpu->mail[4 ] = unifs3;
++  gpu->mail[6 ] = unifs4;
++  gpu->mail[8 ] = unifs5;
++  gpu->mail[10] = unifs6;
++	gpu->mail[12] = unifs7;
++	gpu->mail[14] = unifs8;
++	gpu->mail[16] = unifs9;
++	gpu->mail[18] = unifs10;
++	gpu->mail[20] = unifs11;
++	gpu->mail[22] = unifs12;
++	execute_qpu(
++		gpu->mb,
++		12 /* Number of QPUs */,
++		gpu->vc + offsetof(struct GPU, mail),
++		1 /* no flush */,  // Don't flush VPU L1 cache
++		5000 /* timeout ms */);
++#ifdef RPI_TIME_TOTAL_QPU
++  end_time = Microseconds();
++  last_time = end_time;
++  on_time += end_time - start_time;
++  count++;
++  if ((count&0x7f)==0)
++    printf("On=%dms, Off=%dms\n",(int)(on_time/1000),(int)(off_time/1000));
++#endif
++  gpu_unlock();
++}
++
++unsigned int qpu_get_fn(int num) {
++    // Make sure that the gpu is initialized
++    unsigned int *fn;
++    if (gpu==NULL) {
++      printf("Preparing gpu\n");
++      gpu_lock();
++      gpu_unlock();
++    }
++    switch(num) {
++    case QPU_MC_SETUP:
++      fn = mc_setup;
++      break;
++    case QPU_MC_FILTER:
++      fn = mc_filter;
++      break;
++    case QPU_MC_EXIT:
++      fn = mc_exit;
++      break;
++    case QPU_MC_INTERRUPT_EXIT:
++      fn = mc_interrupt_exit;
++      break;
++    case QPU_MC_FILTER_B:
++      fn = mc_filter_b;
++      break;
++    case QPU_MC_FILTER_HONLY:
++      fn = mc_filter_honly;
++      break;
++    case QPU_MC_SETUP_UV:
++      fn = mc_setup_uv;
++      break;
++    case QPU_MC_FILTER_UV:
++      fn = mc_filter_uv;
++      break;
++    case QPU_MC_FILTER_UV_B:
++      fn = mc_filter_uv_b;
++      break;
++    case QPU_MC_END:
++      fn = mc_end;
++      break;
++    default:
++      printf("Unknown function\n");
++      exit(-1);
++    }
++    return gpu->vc + 4*(int)(fn-rpi_shader);
++    //return code[num] + gpu->vc;
++}
++
++#if 0
++
++int32_t hcoeffs[] = {-4, 10, -21, 70, 90, -24, 11, -4};
++//int32_t hcoeffs[] = {1, 1, 1, 1, 1, 1, 1, 1};
++int32_t vcoeffs[] = {-2, 6, -13, 37, 115, -20, 9, -4};
++//int32_t vcoeffs[] = {1, 1, 1, 1, 1, 1, 1, 1};
++
++#define ENCODE_COEFFS(c0, c1, c2, c3) (((c0-1) & 0xff) | ((c1-1) & 0xff) << 8 | ((c2-1) & 0xff) << 16 | ((c3-1) & 0xff) << 24);
++
++static uint8_t av_clip_uint8(int32_t a)
++{
++    if (a&(~255)) return (-a)>>31;
++    else          return a;
++}
++
++static int32_t filter8(const uint8_t *data, int pitch)
++{
++   int32_t vsum = 0;
++   int x, y;
++
++   for (y = 0; y < 8; y++) {
++      int32_t hsum = 0;
++
++      for (x = 0; x < 8; x++)
++         hsum += hcoeffs[x]*data[x + y * pitch];
++
++      vsum += vcoeffs[y]*av_clip_uint8( (hsum + 64) >> 7); // Added brackets to stop compiler warning
++   }
++
++   return av_clip_uint8( (vsum + 64) >> 7);
++}
++
++// Note regression changes coefficients so is not thread safe
++//#define REGRESSION
++#ifdef REGRESSION
++#define CMAX 100
++#else
++#define CMAX 2
++#endif
++#define YMAX 16
++
++int rpi_test_shader(void)
++{
++   int i, c;
++
++   uint32_t *unifs;
++
++   uint8_t *in_buffer;
++   uint8_t *out_buffer[2];
++
++   GPU_MEM_PTR_T unifs_ptr;
++   GPU_MEM_PTR_T in_buffer_ptr;
++   GPU_MEM_PTR_T out_buffer_ptr[2];
++
++   // Addresses in GPU memory of filter programs
++   uint32_t mc_setup = 0;
++   uint32_t mc_filter = 0;
++   uint32_t mc_exit = 0;
++
++   int pitch = 0x500;
++
++   if (gpu==NULL) {
++      gpu_lock();
++      gpu_unlock();
++   }
++
++   printf("This needs to change to reflect new assembler\n");
++   // Use table to compute locations of program start points
++   mc_setup = code[0] + gpu->vc;
++   mc_filter = code[1] + gpu->vc;
++   mc_exit = code[2] + gpu->vc;
++
++   if (!vcos_verify(gpu_malloc_uncached(4*64,&unifs_ptr))) {
++      return -2;
++   }
++   unifs = (uint32_t*)unifs_ptr.arm;
++
++   if (!vcos_verify(gpu_malloc_uncached(64*23,&in_buffer_ptr))) {
++      return -3;
++   }
++   in_buffer = (uint8_t*)in_buffer_ptr.arm;
++
++   if (!vcos_verify(gpu_malloc_uncached(16*pitch,&out_buffer_ptr[0])) || !vcos_verify(gpu_malloc_uncached(16*pitch,&out_buffer_ptr[1]))) {
++      return -4;
++   }
++   out_buffer[0] = (uint8_t*)out_buffer_ptr[0].arm;
++   out_buffer[1] = (uint8_t*)out_buffer_ptr[1].arm;
++
++   for (c = 0; c < CMAX; c++) {
++      int xo[] = {rand()&31, rand()&31};
++
++#ifdef REGRESSION
++      for (i = 0; i < 8; i++) {
++         hcoeffs[i] = (int8_t)rand();
++         vcoeffs[i] = (int8_t)rand();
++         if (hcoeffs[i]==-128)
++           hcoeffs[i]++;
++         if (vcoeffs[i]==-128)
++           vcoeffs[i]++;
++      }
++#endif
++
++      for (i = 0; i < 64*23; i++) {
++         //printf("%d %d %p\n",i,gpu->mb,&in_buffer[i]);
++         in_buffer[i] = rand();
++      }
++
++      // Clear output array
++      {
++        int b;
++        for(b=0;b<2;b++) {
++          for(i=0;i<16*16;i++) {
++            out_buffer[b][i] = 3;
++          }
++        }
++      }
++
++      unifs[0] = mc_filter;
++      unifs[1] = in_buffer_ptr.vc+xo[0]+16;
++      unifs[2] = 64; // src pitch
++      unifs[3] = pitch; // dst pitch
++      unifs[4] = 0; // Padding
++      unifs[5] = 0;
++      unifs[6] = 0;
++      unifs[7 ] = mc_filter;
++      unifs[8 ] = in_buffer_ptr.vc+xo[1]+16;
++      unifs[9 ] = ENCODE_COEFFS(hcoeffs[0], hcoeffs[1], hcoeffs[2], hcoeffs[3]);
++      unifs[10] = ENCODE_COEFFS(hcoeffs[4], hcoeffs[5], hcoeffs[6], hcoeffs[7]);
++      unifs[11] = ENCODE_COEFFS(vcoeffs[0], vcoeffs[1], vcoeffs[2], vcoeffs[3]);
++      unifs[12] = ENCODE_COEFFS(vcoeffs[4], vcoeffs[5], vcoeffs[6], vcoeffs[7]);
++      unifs[13] = out_buffer_ptr[0].vc;
++      unifs[14] = mc_exit;
++      unifs[15] = in_buffer_ptr.vc+xo[1]+16;        // dummy
++      unifs[16] = ENCODE_COEFFS(hcoeffs[0], hcoeffs[1], hcoeffs[2], hcoeffs[3]);
++      unifs[17] = ENCODE_COEFFS(hcoeffs[4], hcoeffs[5], hcoeffs[6], hcoeffs[7]);
++      unifs[18] = ENCODE_COEFFS(vcoeffs[0], vcoeffs[1], vcoeffs[2], vcoeffs[3]);
++      unifs[19] = ENCODE_COEFFS(vcoeffs[4], vcoeffs[5], vcoeffs[6], vcoeffs[7]);
++      unifs[20] = out_buffer_ptr[1].vc;
++
++      printf("Gpu->vc=%x Code=%x dst=%x\n",gpu->vc, mc_filter,out_buffer_ptr[1].vc);
++
++      // flush_dcache(); TODO is this needed on ARM side? - tried to use the direct alias to avoid this problem
++
++      //qpu_run_shader(mc_setup, unifs_ptr.vc);
++      //qpu_run_shader(gpu, gpu->vc, unifs_ptr.vc);
++      rpi_do_block(in_buffer_ptr.vc+xo[0]+16, 64, out_buffer_ptr[0].vc, pitch,out_buffer[0]);
++      rpi_do_block(in_buffer_ptr.vc+xo[1]+16, 64, out_buffer_ptr[1].vc, pitch,out_buffer[1]);
++
++      if (1)
++      {
++         int x, y, b;
++         int bad = 0;
++
++         for (b=0; b<2; ++b)
++            for (y=0; y<YMAX; ++y)
++               for (x=0; x<16; ++x) {
++                  int32_t ref = filter8(in_buffer+x+y*64+xo[b], 64);
++
++                  if (out_buffer[b][x+y*pitch] != ref) {
++                      bad = 1;
++//                     printf("%d, %d, %d, %d\n", c, b, x, y);
++                  }
++#ifndef REGRESSION
++                  //printf("%08x %08x\n", out_buffer[b][x+y*pitch], ref);
++#endif
++               }
++          if (bad)
++            printf("Failed dst=%x test=%d\n",out_buffer_ptr[1].vc,c);
++          else
++            printf("Passed dst=%x test=%d\n",out_buffer_ptr[1].vc,c);
++      }
++      //printf("%d\n", simpenrose_get_qpu_tick_count());
++   }
++
++   gpu_free(&out_buffer_ptr[0]);
++   gpu_free(&out_buffer_ptr[1]);
++   gpu_free(&in_buffer_ptr);
++   gpu_free(&unifs_ptr);
++
++   return 0;
++}
++
++void rpi_do_block_arm(const uint8_t *in_buffer, int src_pitch, uint8_t *dst, int dst_pitch)
++{
++  int x,y;
++  for (y=0; y<16; ++y) {
++    for (x=0; x<16; ++x) {
++       dst[x+y*dst_pitch] = filter8(in_buffer+x+y*src_pitch, src_pitch);
++    }
++  }
++}
++
++void rpi_do_block(const uint8_t *in_buffer_vc, int src_pitch, uint8_t *dst_vc, int dst_pitch, uint8_t *dst)
++{
++   uint32_t *unifs;
++
++   GPU_MEM_PTR_T unifs_ptr;
++   //uint8_t *out_buffer;
++   //GPU_MEM_PTR_T out_buffer_ptr;
++
++   // Addresses in GPU memory of filter programs
++   uint32_t mc_setup = 0;
++   uint32_t mc_filter = 0;
++   uint32_t mc_exit = 0;
++   //int x,y;
++
++   if (gpu==NULL) {
++      gpu_lock();
++      gpu_unlock();
++   }
++
++   // Use table to compute locations of program start points
++   mc_setup = code[0] + gpu->vc;
++   mc_filter = code[1] + gpu->vc;
++   mc_exit = code[2] + gpu->vc;
++
++   if (!vcos_verify(gpu_malloc_uncached(4*64,&unifs_ptr))) {
++      return;
++   }
++   //gpu_malloc_uncached(16*dst_pitch,&out_buffer_ptr);
++   //out_buffer = (uint8_t*)out_buffer_ptr.arm;
++
++   /*for (y=0; y<16; ++y) {
++      for (x=0; x<16; ++x) {
++         out_buffer[x+y*dst_pitch] = 7;
++      }
++    }*/
++
++   unifs = (uint32_t*)unifs_ptr.arm;
++
++    unifs[0] = mc_filter;
++    unifs[1] = (int)in_buffer_vc;
++    unifs[2] = src_pitch; // src pitch
++    unifs[3] = dst_pitch; // dst pitch
++    unifs[4] = 0; // Padding
++    unifs[5] = 0;
++    unifs[6] = 0;
++    unifs[7 ] = mc_exit;
++    unifs[8 ] = (int)in_buffer_vc;
++    unifs[9 ] = ENCODE_COEFFS(hcoeffs[0], hcoeffs[1], hcoeffs[2], hcoeffs[3]);
++    unifs[10] = ENCODE_COEFFS(hcoeffs[4], hcoeffs[5], hcoeffs[6], hcoeffs[7]);
++    unifs[11] = ENCODE_COEFFS(vcoeffs[0], vcoeffs[1], vcoeffs[2], vcoeffs[3]);
++    unifs[12] = ENCODE_COEFFS(vcoeffs[4], vcoeffs[5], vcoeffs[6], vcoeffs[7]);
++    unifs[13] = (int)dst_vc;
++    //unifs[13] = (int)out_buffer_ptr.vc;
++
++    //printf("Gpu->vc=%x Code=%x dst=%x\n",gpu->vc, mc_filter,out_buffer_ptr[1].vc);
++
++    qpu_run_shader(mc_setup, unifs_ptr.vc);
++
++    /*for (y=0; y<16; ++y) {
++      for (x=0; x<16; ++x) {
++         dst[x+y*dst_pitch] = out_buffer[x+y*dst_pitch];
++      }
++    }*/
++
++    gpu_free(&unifs_ptr);
++    //gpu_free(&out_buffer_ptr);
++}
++
++
++#endif
++
++#endif // RPI
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+new file mode 100644
+index 0000000..4e3c35c
+--- /dev/null
++++ b/libavcodec/rpi_qpu.h
+@@ -0,0 +1,45 @@
++#ifndef RPI_QPU_H
++#define RPI_QPU_H
++
++typedef struct gpu_mem_ptr_s {
++  unsigned char *arm; // Pointer to memory mapped on ARM side
++  int vc_handle;   // Videocore handle of relocatable memory
++  int vcsm_handle; // Handle for use by VCSM
++  int vc;       // Address for use in GPU code
++  int numbytes; // Size of memory block
++} GPU_MEM_PTR_T;
++
++// General GPU functions
++extern int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p);
++extern int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p);
++extern void gpu_free(GPU_MEM_PTR_T *p);
++extern void gpu_cache_flush(GPU_MEM_PTR_T *p);
++
++// QPU specific functions
++extern void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8, int unifs9, int unifs10, int unifs11, int unifs12);
++
++enum {
++  QPU_MC_SETUP,
++  QPU_MC_FILTER,
++  QPU_MC_EXIT,
++  QPU_MC_INTERRUPT_EXIT,
++  QPU_MC_FILTER_B,
++  QPU_MC_FILTER_HONLY,
++  QPU_MC_SETUP_UV,
++  QPU_MC_FILTER_UV,
++  QPU_MC_FILTER_UV_B,
++  QPU_MC_END
++  };
++extern unsigned int qpu_get_fn(int num);
++
++// VPU specific functions
++extern unsigned int vpu_get_fn(void);
++extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
++
++// Simple test of shader code
++extern int rpi_test_shader(void);
++
++extern void rpi_do_block(const unsigned char *in_buffer_vc, int src_pitch, unsigned char *dst_vc, int dst_pitch, unsigned char *dst);
++extern void rpi_do_block_arm(const unsigned char *in_buffer, int src_pitch, unsigned char *dst, int dst_pitch);
++
++#endif
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+new file mode 100644
+index 0000000..41cc2e1
+--- /dev/null
++++ b/libavcodec/rpi_shader.c
+@@ -0,0 +1,818 @@
++#include "rpi_shader.h"
++
++#ifdef _MSC_VER
++   #include <stdint.h>
++   /* cast through uintptr_t to avoid warnings */
++   #define POINTER_TO_UINT(X) ((unsigned int)(uintptr_t)(X))
++#else
++   #define POINTER_TO_UINT(X) ((unsigned int)(X))
++#endif
++
++#ifdef __cplusplus
++extern "C" { /* the types are probably wrong... */
++#endif
++#ifdef __cplusplus
++}
++#endif
++
++#ifdef _MSC_VER
++__declspec(align(8))
++#elif defined(__GNUC__)
++__attribute__((aligned(8)))
++#endif
++unsigned int rpi_shader[] = {
++// ::mc_setup
++/* [0x00000000] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000008] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
++/* [0x00000010] */ 0x15827d80, 0x10020767, // mov ra_y, unif
++/* [0x00000018] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
++/* [0x00000020] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
++/* [0x00000028] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
++/* [0x00000030] */ 0x15827d80, 0x10021427, // mov rb16, unif
++/* [0x00000038] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000040] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
++/* [0x00000048] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
++/* [0x00000050] */ 0x00000001, 0xe0020527, // mov ra20, 1
++/* [0x00000058] */ 0x00000040, 0xe0020567, // mov ra21, 64
++/* [0x00000060] */ 0x00000100, 0xe00205a7, // mov ra22, 256
++/* [0x00000068] */ 0x00000008, 0xe00205e7, // mov ra23, 8
++/* [0x00000070] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
++/* [0x00000078] */ 0x00000040, 0xe0021567, // mov rb21, 64
++/* [0x00000080] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x00000088] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x00000090] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x00000098] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x000000a0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x000000a8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x000000b0] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x000000d0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x000000d8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x000000e0] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x000000e8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x000000f0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x000000f8] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000100] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000108] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000110] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x00000118] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x00000120] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x00000128] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000130] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00000138] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000140] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000148] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000150] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000158] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000160] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000168] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000170] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x00000178] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
++/* [0x00000180] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
++/* [0x00000188] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
++/* [0x00000190] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
++/* [0x00000198] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000001a0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
++/* [0x000001a8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x000001b0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
++/* [0x000001b8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
++/* [0x000001c0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x000001c8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x000001d0] */ 0x4c9d00cf, 0x10024821, // add r0, r0, r3; mul24 r1, r1, rb_pitch
++/* [0x000001d8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
++/* [0x000001e0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x000001e8] */ 0x949dc5c0, 0xd0025890, // and r2, r2, ~3; mov ra_x_base, r0
++/* [0x000001f0] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
++/* [0x000001f8] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
++/* [0x00000200] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000208] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000210] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000218] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000220] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000228] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000230] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000238] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
++/* [0x00000240] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++// ::mc_filter_uv
++/* [0x00000248] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000250] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000258] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000260] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000268] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000270] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000278] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000280] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000288] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000290] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000298] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000002a0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000002a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000002b0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000002b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000002c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000002c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000002d0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x000002d8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x000002e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000002e8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000002f0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000002f8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000300] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000330] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000338] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000340] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000348] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000350] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000358] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000360] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000368] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000370] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000378] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000380] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000388] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000390] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000398] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000003a0] */ 0x00000000, 0xe00208e7, // mov r3, 0
++// :uvloop
++/* [0x000003a8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000003b0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x000003b8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x000003c0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000003c8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000003d0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000003d8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003e0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000400] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00000408] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
++/* [0x00000410] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000420] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000430] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000440] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000448] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000450] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000458] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000460] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000468] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000470] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000478] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000480] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x00000488] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000490] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000498] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x000004a0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x000004a8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x000004b0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x000004b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000004c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x000004c8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x000004d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x000004d8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x000004e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x000004e8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x000004f0] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x000004f8] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000500] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000508] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000510] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000518] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000520] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000528] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x00000530] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000538] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000540] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000560] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000568] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000570] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000578] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000580] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000588] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000590] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000598] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_filter
++/* [0x000005a0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000005a8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000005b0] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
++/* [0x000005b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000005c0] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
++/* [0x000005c8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000005d0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
++/* [0x000005d8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000005e0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
++/* [0x000005e8] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
++/* [0x000005f0] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
++/* [0x000005f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000600] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
++/* [0x00000608] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000610] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
++/* [0x00000618] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000620] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000628] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000630] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000638] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000640] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000648] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000650] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000658] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000660] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000668] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000670] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000678] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000680] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000688] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000690] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000698] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000006b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x000006d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000006f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000700] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000708] */ 0x000001d0, 0xf07809e7, // brr.anynn -, r:fast_path
++/* [0x00000710] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000718] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000720] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000728] */ 0x00000000, 0xe00208e7, // mov r3, 0
++// :loop
++/* [0x00000730] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000738] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000740] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000748] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000750] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
++/* [0x00000758] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000760] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000768] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000770] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000778] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000780] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000788] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00000790] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000798] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000007a0] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000007a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000007b0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000007b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000007c0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x000007c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x000007d0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x000007d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x000007e0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x000007e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x000007f0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x000007f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000800] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x00000808] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000810] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000818] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000820] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000828] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000830] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000838] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000840] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000848] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:loop
++/* [0x00000850] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x00000858] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x00000860] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x00000868] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x00000870] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x00000878] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000880] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000888] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000890] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000898] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x000008a0] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x000008a8] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x000008b0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000008b8] */ 0xfffffe58, 0xf06809e7, // brr.anyn -, r:loop
++/* [0x000008c0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x000008c8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000008d0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000008d8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000008e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000008e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000008f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// :fast_path
++/* [0x000008f8] */ 0x00000000, 0xe00208e7, // mov r3, 0
++// :fast_loop
++/* [0x00000900] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000908] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000910] */ 0x95727d9b, 0x1004475f, // mov.ifz ra_y, ra_y_next   ; mov rb31, r3
++/* [0x00000918] */ 0x95690dbf, 0x10044623, // mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
++/* [0x00000920] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000928] */ 0x929de5e4, 0x100248a1, // min r2, r2, rb_frame_height_minus_1 ; mov r1, r4
++/* [0x00000930] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000938] */ 0xec414c87, 0x10024e20, // add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
++/* [0x00000940] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000948] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00000950] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
++/* [0x00000958] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
++/* [0x00000960] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
++/* [0x00000968] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
++/* [0x00000970] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
++/* [0x00000978] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
++/* [0x00000980] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
++/* [0x00000988] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
++/* [0x00000990] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000998] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x000009a0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x000009a8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x000009b0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x000009b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000009c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8       ; mov r1, ra22
++/* [0x000009c8] */ 0xffffff18, 0xf06809e7, // brr.anyn -, r:fast_loop
++/* [0x000009d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x000009d8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x000009e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x000009e8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x000009f0] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x000009f8] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000a00] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000a08] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000a10] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000a18] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000a20] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000a28] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x00000a30] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000a38] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:fast_loop
++/* [0x00000a40] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x00000a48] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000a50] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000a60] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_filter_b
++/* [0x00000a78] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000a80] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000a88] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
++/* [0x00000a90] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000a98] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
++/* [0x00000aa0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000aa8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
++/* [0x00000ab0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000ab8] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
++/* [0x00000ac0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
++/* [0x00000ac8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
++/* [0x00000ad0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000ad8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
++/* [0x00000ae0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000ae8] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
++/* [0x00000af0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000af8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000b00] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000b08] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000b10] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000b18] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000b20] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000b28] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000b30] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000b38] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000b40] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000b48] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000b50] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000b58] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000b60] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000b68] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000b70] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
++/* [0x00000b78] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000b80] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000b88] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000b90] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000b98] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000ba0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ba8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000bb0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000bb8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000bc0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000bc8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000bd0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000bd8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000be0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000be8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000bf0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000bf8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000c00] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000c08] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000c10] */ 0x00000000, 0xe00208e7, // mov r3, 0
++// :bloop
++/* [0x00000c18] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000c20] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000c28] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000c30] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000c38] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
++/* [0x00000c40] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000c48] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000c50] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000c58] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000c60] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000c68] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000c70] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00000c78] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000c80] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000c88] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000c90] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000c98] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000ca0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000ca8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000cb0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000cb8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000cc0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000cc8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000cd0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000cd8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000ce0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000ce8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x00000cf0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000cf8] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000d00] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000d08] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000d10] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000d18] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000d20] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000d28] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000d30] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:bloop
++/* [0x00000d38] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x00000d40] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x00000d48] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x00000d50] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x00000d58] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x00000d60] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000d68] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000d70] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000d78] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000d80] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000d88] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000d90] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x00000d98] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000da0] */ 0x8fc8f3f6, 0xd0020867, // asr r1, r1, 15          ; mov -, vr_wait
++/* [0x00000da8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000db0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
++/* [0x00000db8] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:bloop
++/* [0x00000dc0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x00000dc8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x00000dd0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
++/* [0x00000dd8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000de0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000de8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000df0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_filter_honly
++/* [0x00000df8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000e00] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000e08] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
++/* [0x00000e10] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000e18] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
++/* [0x00000e20] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000e28] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
++/* [0x00000e30] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000e38] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
++/* [0x00000e40] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
++/* [0x00000e48] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
++/* [0x00000e50] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000e58] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
++/* [0x00000e60] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000e68] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
++/* [0x00000e70] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000e78] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000e80] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000e88] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000e90] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000e98] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000ea0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000ea8] */ 0x0c9de1c0, 0xd0021467, // add rb17, r0, -2
++/* [0x00000eb0] */ 0x919c71c0, 0xd0024812, // shl r0, r0, 7 ; mov rb18,r0
++/* [0x00000eb8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000ec0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000ec8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000ed0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000ed8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ee0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ee8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ef0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000ef8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f00] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f08] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f10] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000f18] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000f20] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000f28] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000f30] */ 0x00000000, 0xe00208e7, // mov r3, 0
++// :loop_honly
++/* [0x00000f38] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000f40] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000f48] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000f50] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000f58] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
++/* [0x00000f60] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000f68] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000f70] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000f78] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000f80] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000f88] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000f90] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00000f98] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000fa0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000fa8] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000fb0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000fb8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000fc0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000fc8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000fd0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000fd8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000fe0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000fe8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000ff0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000ff8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00001000] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00001008] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
++/* [0x00001010] */ 0x8d5927f6, 0x100269e1, // sub.setf -, r3, rb18 ; mov r1, ra22
++/* [0x00001018] */ 0x559f2fc1, 0x100049e0, // mov -, vw_wait   ; mul24 r0, r0, r1
++/* [0x00001020] */ 0xfffffef8, 0xf06809e7, // brr.anyn -, r:loop_honly
++/* [0x00001028] */ 0x0f9cf1c0, 0xd0020827, // asr r0, r0, 15
++/* [0x00001030] */ 0x129d61c0, 0x10020827, // min r0, r0, rb22
++/* [0x00001038] */ 0x139c01c0, 0xd0020c27, // max vpm, r0, 0
++/* [0x00001040] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001048] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00001050] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001058] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_exit
++/* [0x00001060] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00001068] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00001070] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001078] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001080] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001088] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001090] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00001098] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x000010a0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++// ::mc_exit1
++/* [0x000010a8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x000010b0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010b8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010c0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010c8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000010d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x000010e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++// ::mc_interrupt_exit
++/* [0x000010e8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x000010f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001100] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001108] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001110] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001118] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001120] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001128] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001130] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001138] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001140] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001148] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001150] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001158] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001160] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001168] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00001170] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00001178] */ 0x009e7000, 0x100009e7, // nop        ; nop
++// ::mc_interrupt_exit4
++/* [0x00001180] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00001188] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001190] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001198] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000011a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000011a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000011b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000011b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000011c0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000011c8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x000011d0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++// ::mc_interrupt_exit8
++/* [0x000011d8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x000011e0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000011e8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000011f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000011f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001200] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001208] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001210] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001218] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001220] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001228] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001230] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001238] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00001240] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00001248] */ 0x009e7000, 0x100009e7, // nop        ; nop
++// ::mc_setup_uv
++/* [0x00001250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00001258] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
++/* [0x00001260] */ 0x15827d80, 0x10020767, // mov ra_y, unif
++/* [0x00001268] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
++/* [0x00001270] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00001278] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
++/* [0x00001280] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
++/* [0x00001288] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
++/* [0x00001290] */ 0x15827d80, 0x10021427, // mov rb16, unif
++/* [0x00001298] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000012a0] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
++/* [0x000012a8] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
++/* [0x000012b0] */ 0x00000001, 0xe0020527, // mov ra20, 1
++/* [0x000012b8] */ 0x00000040, 0xe0020567, // mov ra21, 64
++/* [0x000012c0] */ 0x00000100, 0xe00205a7, // mov ra22, 256
++/* [0x000012c8] */ 0x00000008, 0xe00205e7, // mov ra23, 8
++/* [0x000012d0] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
++/* [0x000012d8] */ 0x00000040, 0xe0021567, // mov rb21, 64
++/* [0x000012e0] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x000012e8] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x000012f0] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x000012f8] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x00001300] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x00001308] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x00001310] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x00001318] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x00001320] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x00001328] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x00001330] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00001338] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00001340] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00001348] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00001350] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00001358] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00001360] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00001368] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00001370] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x00001378] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x00001380] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x00001388] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00001390] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00001398] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x000013a0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x000013a8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x000013b0] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x000013b8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x000013c0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000013c8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x000013d0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x000013d8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
++/* [0x000013e0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
++/* [0x000013e8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
++/* [0x000013f0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
++/* [0x000013f8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x00001400] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00001408] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00001410] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
++/* [0x00001418] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00001420] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
++/* [0x00001428] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
++/* [0x00001430] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
++/* [0x00001438] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001440] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001448] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001450] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00001458] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00001460] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00001468] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001470] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00001478] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
++/* [0x00001480] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++// ::mc_filter_uv_b
++/* [0x00001488] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00001490] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00001498] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000014a0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000014a8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000014b0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000014b8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000014c0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000014c8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000014d0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000014d8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000014e0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000014e8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000014f0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000014f8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00001500] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00001508] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00001510] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00001518] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00001520] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00001528] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00001530] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00001538] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00001540] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00001548] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00001550] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00001558] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
++/* [0x00001560] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00001568] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001570] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001578] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001580] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001588] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00001590] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001598] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000015a0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000015a8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x000015b0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015b8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015c0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000015c8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000015d0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015d8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015e0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015e8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x000015f0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000015f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00001600] */ 0x00000000, 0xe00208e7, // mov r3, 0
++// :uvloop_b
++/* [0x00001608] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00001610] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00001618] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00001620] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00001628] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00001630] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00001638] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00001640] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00001648] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00001650] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00001658] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00001660] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00001668] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
++/* [0x00001670] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00001678] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00001680] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00001688] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00001690] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00001698] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000016a0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x000016a8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x000016b0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x000016b8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x000016c0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x000016c8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x000016d0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x000016d8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x000016e0] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x000016e8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x000016f0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x000016f8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00001700] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00001708] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00001710] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00001718] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00001720] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00001728] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00001730] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x00001738] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x00001740] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x00001748] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x00001750] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x00001758] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00001760] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00001768] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00001770] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00001778] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00001780] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00001788] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x00001790] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00001798] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x000017a0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000017a8] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
++/* [0x000017b0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000017b8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x000017c0] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x000017c8] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
++/* [0x000017d0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000017d8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000017e0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000017e8] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000017f0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000017f8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001800] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00001808] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001810] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_end
++};
++#ifdef __HIGHC__
++#pragma Align_to(8, rpi_shader)
++#endif
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+new file mode 100644
+index 0000000..db971f4
+--- /dev/null
++++ b/libavcodec/rpi_shader.h
+@@ -0,0 +1,20 @@
++#ifndef rpi_shader_H
++#define rpi_shader_H
++
++extern unsigned int rpi_shader[];
++
++#define mc_setup (rpi_shader + 0)
++#define mc_filter_uv (rpi_shader + 146)
++#define mc_filter (rpi_shader + 360)
++#define mc_filter_b (rpi_shader + 670)
++#define mc_filter_honly (rpi_shader + 894)
++#define mc_exit (rpi_shader + 1048)
++#define mc_exit1 (rpi_shader + 1066)
++#define mc_interrupt_exit (rpi_shader + 1082)
++#define mc_interrupt_exit4 (rpi_shader + 1120)
++#define mc_interrupt_exit8 (rpi_shader + 1142)
++#define mc_setup_uv (rpi_shader + 1172)
++#define mc_filter_uv_b (rpi_shader + 1314)
++#define mc_end (rpi_shader + 1542)
++
++#endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+new file mode 100644
+index 0000000..6851e83
+--- /dev/null
++++ b/libavcodec/rpi_shader.qasm
+@@ -0,0 +1,1413 @@
++# register allocation
++#
++# ra0...ra7                                     eight horizontal filter coefficients
++#
++# rb1...rb7                                     seven shifted copies of the current unfiltered row
++#
++# ra8...ra15                                    eight filtered rows of context (rb15 == most recent)
++#
++#                                               (ra15 isn't clamped to zero - this happens during the
++#                                                copy to ra14, and during its use in the vertical filter)
++#
++# rb8...rb15                                    eight vertical filter coefficients
++#
++# ra16                                          clipped(row start address+elem_num)&~3
++# ra17                                          per-channel shifts
++# ra19                                          next ra17
++#
++# rb16                                          pitch
++# rb17                                          height + 5
++# rb18                                          height + 7
++# rb19                                          next ra16
++#
++# ra20                                          1
++# ra21                                          64
++# ra22                                          256
++# ra23                                          8
++#
++# rb20                                          0xffffff00
++# rb21                                          64
++# rb22                                          255
++# rb23                                          24
++#
++# rb24                                          vdw_setup_1(dst_pitch)
++# rb25                                          frame width-1
++# rb26                                          height<<23 + width<<16 + vdw_setup_0
++# rb27                                          vdw_setup_0 (depends on QPU number)
++# rb28                                          vpm_setup (depends on QPU number)
++# rb29                                          vdw_setup_1(dst_pitch-width)
++# rb30                                          frame height-1
++# rb31                                          used as temp to count loop iterations
++#
++# ra24...ra30                                   15, 14, 13, 12, 11, 10, 9
++# ra24                                          clipped(row start address+8+elem_num)&~3
++# ra25                                          per-channel shifts 2
++# ra26                                          next ra24
++# ra27                                          next ra25
++# ra28                                          next y
++# ra29                                          y for next texture access
++#
++# ra31                                          next kernel address
++
++.set rb_frame_width_minus_1,       rb25
++.set rb_frame_height_minus_1,      rb30
++.set rb_pitch,                     rb16
++.set ra_x_base,                    ra16
++.set rb_x_base_next,               rb19
++.set ra_x2_base,                   ra24
++.set ra_x2_base_next,              ra26
++.set ra_xshift,                    ra17
++
++.set ra_x2shift,                   ra25
++.set ra_u2v_ref_offset,            ra25
++
++.set ra_xshift_next,               ra19
++
++.set ra_x2shift_next,              ra27
++.set ra_u2v_dst_offset,            ra27
++
++.set ra_y_next,                    ra28
++.set ra_y,                         ra29
++
++.set rb_const_64,                  rb21
++
++# mc_setup(next_kernel, x, y, ref_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1)
++::mc_setup
++
++# Read starting kernel
++mov ra31, unif
++
++# Load first request location
++add ra_x_base, unif, elem_num # Store x
++mov ra_y, unif # Store y
++mov ra_x2_base, unif # Store frame base
++
++# Read image dimensions
++sub rb25,unif,1
++sub rb30,unif,1
++
++# get source pitch
++mov rb16, unif
++
++# get destination pitch
++mov r0, unif
++mov r1, vdw_setup_1(0)
++add rb24, r1, r0
++
++# load constants
++
++mov ra20, 1
++mov ra21, 64
++mov ra22, 256
++mov ra23, 8
++
++mov rb20, 0xffffff00
++mov rb21, 64
++mov rb22, 255
++mov rb23, 24
++
++# touch vertical context to keep simulator happy
++
++mov ra8, 0
++mov ra9, 0
++mov ra10, 0
++mov ra11, 0
++mov ra12, 0
++mov ra13, 0
++mov ra14, 0
++mov ra15, 0
++
++# Compute part of VPM to use for DMA output
++mov r2, qpu_num
++and r2, r2, 15
++mov r1, r2
++asr r1, r1, 2
++shl r1, r1, 6
++mov r0, r2
++and r0, r0, 3
++add r0, r0, r1
++mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
++shl r0, r0, 5
++add rb27, r0, r1
++
++# Compute part of VPM to save data into
++mov r2, qpu_num
++and r2, r2, 15
++mov r1, r2
++asr r1, r1, 2
++shl r1, r1, 6
++mov r0, r2
++and r0, r0, 3
++add r0, r0, r1
++mov r1, vpm_setup(0, 4, h8p(0, 0))
++add rb28, r0, r1
++
++# Compute base address for first and second access
++#add r0, unif, elem_num     # x
++mov r0, ra_x_base           # Load x
++add r2, r0, 8               # x+8
++max r0, r0, 0; mov r1, ra_y # Load y
++min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
++shl ra_xshift_next, r0, 3
++max r2, r2, 0
++add ra_y, r1, 1
++min r2, r2, rb_frame_width_minus_1
++shl ra_x2shift_next, r2, 3
++max r1, r1, 0  # y
++min r1, r1, rb_frame_height_minus_1
++add r0, r0, r3; mul24 r1, r1, rb_pitch
++add r2, r2, r3
++and r0, r0, ~3
++and r2, r2, ~3; mov ra_x_base, r0
++# submit texture requests for first line
++add t0s, r0, r1 ; mov ra_x2_base, r2
++add t0s, r2, r1
++
++# Dump padding words
++mov r0, unif
++mov r0, unif
++
++# submit texture requests for second line
++max r1, ra_y, 0
++min r1, r1, rb_frame_height_minus_1
++add ra_y, ra_y, 1
++bra -, ra31
++nop ; mul24 r1, r1, rb_pitch
++add t0s, r1, ra_x_base
++add t0s, r1, ra_x2_base
++
++################################################################################
++
++# mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
++
++# At this point we have already issued two pairs of texture requests for the current block
++# ra_x_base, ra_x16_base point to the current coordinates for this block
++::mc_filter_uv
++mov ra31, unif
++
++# per-channel shifts were calculated on the *previous* invocation
++
++mov ra_xshift, ra_xshift_next
++
++# get base addresses and per-channel shifts for *next* invocation
++add r0, unif, elem_num    # x
++max r0, r0, 0; mov r1, unif # y
++min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
++shl ra_xshift_next, r0, 3
++sub r2, unif, r3 # compute offset from frame base u to frame base v
++add r0, r0, r3
++and rb_x_base_next, r0, ~3
++mov ra_y_next, r1
++add ra_x2_base_next, rb_x_base_next, r2
++
++# set up VPM write
++mov vw_setup, rb28
++
++# get width,height of block
++mov r2, 16
++mov r0, unif
++shr r1, r0, r2 # Extract width
++sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
++and r0, r0, rb22 # Extract height
++add rb17, r0, 5
++add rb18, r0, 7
++shl r0, r0, 7
++add r0, r0, r1 # Combine width and height of destination area
++shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
++add rb26, r0, rb27
++
++sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
++
++# get filter coefficients
++
++mov r0, unif
++asr ra3, r0, rb23;      mul24 r0, r0, ra22
++asr ra2, r0, rb23;      mul24 r0, r0, ra22
++asr ra1, r0, rb23;      mul24 r0, r0, ra22
++asr ra0, r0, rb23;      mov r0, unif
++asr ra7, r0, rb23;      mul24 r0, r0, ra22
++asr ra6, r0, rb23;      mul24 r0, r0, ra22
++asr ra5, r0, rb23;      mul24 r0, r0, ra22
++asr ra4, r0, rb23;      mov r0, unif
++asr rb11, r0, rb23;     mul24 r0, r0, ra22
++asr rb10, r0, rb23;     mul24 r0, r0, ra22
++asr rb9, r0, rb23;      mul24 r0, r0, ra22
++asr rb8, r0, rb23;      mov r0, unif
++asr rb15, r0, rb23;     mul24 r0, r0, ra22
++asr rb14, r0, rb23;     mul24 r0, r0, ra22
++asr rb13, r0, rb23;     mul24 r0, r0, ra22
++asr rb12, r0, rb23
++
++# r2 is elem_num
++# r3 is loop counter
++
++mov r5rep, -8
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++mov r3, 0
++
++:uvloop
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
++shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
++
++max r2, ra_y, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++add t0s, ra_x2_base, r2
++
++# generate seven shifted versions
++# interleave with scroll of vertical context
++
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++mov r2, rb21         ; mul24 r3, r0, ra0
++nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
++sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++sub r0, r2, r3
++
++mov r3, rb31
++
++mov ra8, ra9
++mov ra9, ra10
++mov ra10, ra11
++mov ra11, ra12
++mov ra12, ra13
++mov ra13, ra14
++
++sub.setf -, r3, 8 ; mov r1, ra22
++
++# apply horizontal filter
++brr.anyn -, r:uvloop
++max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
++asr r0, r0, 15          ; mov r1, ra21
++min.setf ra15, r0, rb22
++
++# apply vertical filter and write to VPM
++
++nop                     ; mul24 r0, ra14, rb14
++sub r1, r1, r0          ; mul24 r0, ra13, rb13
++sub r1, r1, r0          ; mul24 r0, ra12, rb12
++sub r1, r1, r0          ; mul24 r0, ra11, rb11
++sub r1, r1, r0          ; mul24 r0, ra10, rb10
++sub r1, r1, r0          ; mul24 r0, ra9, rb9
++sub r1, r1, r0          ; mul24 r0, ra8, rb8
++sub r1, r1, r0          ; mul24 r0, ra15, rb15
++sub.ifnn r1, r1, r0     ; mov -, vw_wait
++sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++brr.anyn -, r:uvloop
++asr r1, r1, 15
++min r1, r1, rb22
++max vpm, r1, 0
++
++# DMA out for U
++
++mov vw_setup, rb26 # VDW setup 0
++mov vw_setup, rb29 # Stride
++mov vw_addr, unif # start the VDW
++
++# DMA out for V
++# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
++# Could potentially push this write into the start of the next pipeline stage.
++mov r0, 16
++mov -, vw_wait
++
++bra -, ra31
++add vw_setup, rb26, r0 # VDW setup 0
++mov vw_setup, rb29 # Stride
++mov vw_addr, unif # start the VDW
++
++################################################################################
++
++
++# mc_filter(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
++
++# At this point we have already issued two pairs of texture requests for the current block
++# ra_x_base, ra_x16_base point to the current coordinates for this block
++::mc_filter
++mov ra31, unif
++
++# per-channel shifts were calculated on the *previous* invocation
++
++mov ra_xshift, ra_xshift_next
++mov ra_x2shift, ra_x2shift_next
++
++# get base addresses and per-channel shifts for *next* invocation
++add r0, unif, elem_num    # x
++add r2, r0, 8 # x+8
++max r0, r0, 0; mov r1, unif # y
++min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
++shl ra_xshift_next, r0, 3
++max r2, r2, 0
++min r2, r2, rb_frame_width_minus_1
++shl ra_x2shift_next, r2, 3
++add r0, r0, r3
++add r2, r2, r3
++and rb_x_base_next, r0, ~3
++and ra_x2_base_next, r2, ~3
++mov ra_y_next, r1
++
++# set up VPM write
++mov vw_setup, rb28
++
++# get width,height of block
++mov r2, 16
++mov r0, unif
++shr r1, r0, r2 # Extract width
++sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
++and r0, r0, rb22 # Extract height
++add rb17, r0, 5
++add rb18, r0, 7
++shl r0, r0, 7
++add r0, r0, r1 # Combine width and height of destination area
++shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
++add rb26, r0, rb27
++
++sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
++
++# get filter coefficients
++
++mov r0, unif
++asr ra3, r0, rb23;      mul24 r0, r0, ra22
++asr ra2, r0, rb23;      mul24 r0, r0, ra22
++asr ra1, r0, rb23;      mul24 r0, r0, ra22
++asr ra0, r0, rb23;      mov r0, unif
++asr ra7, r0, rb23;      mul24 r0, r0, ra22
++asr ra6, r0, rb23;      mul24 r0, r0, ra22
++asr ra5, r0, rb23;      mul24 r0, r0, ra22
++asr ra4, r0, rb23;      mov r0, unif
++asr rb11, r0, rb23;     mul24 r0, r0, ra22
++asr rb10, r0, rb23;     mul24 r0, r0, ra22
++asr rb9, r0, rb23;      mul24 r0, r0, ra22
++asr rb8, r0, rb23;      mov r0, unif
++asr rb15, r0, rb23;     mul24 r0, r0, ra22
++asr rb14, r0, rb23;     mul24 r0, r0, ra22
++asr rb13, r0, rb23;     mul24 r0, r0, ra22
++brr.anynn -, r:fast_path
++asr rb12, r0, rb23  # delay slot 1
++
++# r2 is elem_num
++# r3 is loop counter
++
++mov r5rep, -8 # delay slot 2
++
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
++
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++## nop                                                                 ; ldtmu0     # loop counter increment
++## shr r0, r4, ra17                                                    ; ldtmu0
++## shr r1, r4, ra17     ; v8subs r0, r0, rb20
++## add t0s, ra16, r5    ; v8subs r1, r1, rb20
++## add ra16, ra16, rb16 ; mov t0s, ra16
++##
++## # generate seven shifted versions
++## # interleave with scroll of vertical context
++##
++## mov r2, rb21         ; mul24 r3, r0, ra0
++## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++## sub r2, r2, r3                                                    ; ldtmu0
++##
++## mov r0, ra22
++## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0
++## shr r1, r4, ra17     ; v8subs r0, r0, rb20
++## add t0s, ra16, r5    ; v8subs r1, r1, rb20
++## add ra16, ra16, rb16 ; mov t0s, ra16
++##
++## # apply horizontal filter
++##
++## asr r2, r2, 15    ; mul24 r3, r0, ra0
++## min r2, r2, rb22
++## max ra13, r2, 0
++##
++## # generate seven shifted versions
++## # interleave with scroll of vertical context
++##
++## mov r2, rb21
++## sub r2, r2, r3 ; mul24      r3, ra1 << 1, r0 << 1
++## nop            ; mul24.ifnz r3, ra1 << 9, r1 << 9
++## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
++## nop            ; mul24.ifnz r3, ra2 << 10, r1 << 10
++## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
++## nop            ; mul24.ifnz r3, ra3 << 11, r1 << 11
++## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
++## nop            ; mul24.ifnz r3, ra4 << 12, r1 << 12
++## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
++## nop            ; mul24.ifnz r3, ra5 << 13, r1 << 13
++## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
++## nop            ; mul24.ifnz r3, ra6 << 14, r1 << 14
++## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
++## nop            ; mul24.ifnz r3, ra7 << 15, r1 << 15
++## sub r0, r2, r3
++##
++## # apply horizontal filter
++##
++## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
++## asr r0, r0, 15
++## min r0, r0, rb22
++## max ra14, r0, 0
++##
++##
++##
++##
++## nop                                                                 ; ldtmu0     # loop counter increment
++## shr r0, r4, ra17                                                    ; ldtmu0
++## shr r1, r4, ra17     ; v8subs r0, r0, rb20
++## add t0s, ra16, r5    ; v8subs r1, r1, rb20
++## add ra16, ra16, rb16 ; mov t0s, ra16
++##
++## # generate seven shifted versions
++## # interleave with scroll of vertical context
++##
++## mov r2, rb21         ; mul24 r3, r0, ra0
++## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++## sub r0, r2, r3
++##
++## # apply horizontal filter
++##
++## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
++## asr r0, r0, 15
++## min r0, r0, rb22
++## max ra15, r0, 0
++
++
++
++
++mov r3, 0
++
++:loop
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
++shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
++
++max r2, ra_y, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++add t0s, ra_x2_base, r2
++
++# generate seven shifted versions
++# interleave with scroll of vertical context
++
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++mov r2, rb21         ; mul24 r3, r0, ra0
++sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++sub r0, r2, r3
++
++mov r3, rb31
++
++mov ra8, ra9
++mov ra9, ra10
++mov ra10, ra11
++mov ra11, ra12
++mov ra12, ra13
++mov ra13, ra14
++
++sub.setf -, r3, 8 ; mov r1, ra22
++
++# apply horizontal filter
++brr.anyn -, r:loop
++max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
++asr r0, r0, 15          ; mov r1, ra21
++min.setf ra15, r0, rb22
++
++# apply vertical filter and write to VPM
++
++nop                     ; mul24 r0, ra14, rb14
++sub r1, r1, r0          ; mul24 r0, ra13, rb13
++sub r1, r1, r0          ; mul24 r0, ra12, rb12
++sub r1, r1, r0          ; mul24 r0, ra11, rb11
++sub r1, r1, r0          ; mul24 r0, ra10, rb10
++sub r1, r1, r0          ; mul24 r0, ra9, rb9
++sub r1, r1, r0          ; mul24 r0, ra8, rb8
++sub r1, r1, r0          ; mul24 r0, ra15, rb15
++sub.ifnn r1, r1, r0     ; mov -, vw_wait
++sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++brr.anyn -, r:loop
++asr r1, r1, 15
++min r1, r1, rb22
++max vpm, r1, 0
++
++# DMA out
++
++bra -, ra31
++mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
++mov vw_setup, rb29
++mov vw_addr, unif # start the VDW
++
++####################################################
++
++:fast_path
++## nop                                                                 ; ldtmu0     # loop counter increment
++## shr r0, r4, ra17                                                    ; ldtmu0
++## shr r1, r4, ra17     ; v8subs r0, r0, rb20
++## add t0s, ra16, r5    ; v8subs r1, r1, rb20
++## add ra16, ra16, rb16 ; mov t0s, ra16
++##
++## # generate seven shifted versions
++## # interleave with scroll of vertical context
++##
++## mov r2, rb21         ; mul24 r3, r0, ra0
++## sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
++## sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
++## sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
++## sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
++## sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
++## sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
++## sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
++## sub r2, r2, r3                                                    ; ldtmu0
++##
++## mov r0, ra22
++## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0
++## shr r1, r4, ra17     ; v8subs r0, r0, rb20
++## add t0s, ra16, r5    ; v8subs r1, r1, rb20
++## add ra16, ra16, rb16 ; mov t0s, ra16
++##
++## # apply horizontal filter
++##
++## asr r2, r2, 15    ; mul24 r3, r0, ra0
++## min r2, r2, rb22
++## max ra13, r2, 0
++##
++## # generate seven shifted versions
++## # interleave with scroll of vertical context
++##
++## mov r2, rb21
++## sub r2, r2, r3 ; mul24    r3, ra1 << 1, r0 << 1
++## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
++## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
++## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
++## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
++## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
++## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
++## sub r0, r2, r3
++##
++## # apply horizontal filter
++##
++## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
++## asr r0, r0, 15
++## min r0, r0, rb22
++## max ra14, r0, 0
++##
++##
++##
++##
++## nop                                                                 ; ldtmu0     # loop counter increment
++## shr r0, r4, ra17                                                    ; ldtmu0
++## shr r1, r4, ra17     ; v8subs r0, r0, rb20
++## add t0s, ra16, r5    ; v8subs r1, r1, rb20
++## add ra16, ra16, rb16 ; mov t0s, ra16
++##
++## # generate seven shifted versions
++## # interleave with scroll of vertical context
++##
++## mov r2, rb21   ; mul24    r3, r0, ra0
++## sub r2, r2, r3 ; mul24    r3, ra1 << 1, r0 << 1
++## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
++## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
++## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
++## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
++## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
++## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
++## sub r0, r2, r3
++##
++## # apply horizontal filter
++##
++## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
++## asr r0, r0, 15
++## min r0, r0, rb22
++## max ra15, r0, 0
++
++
++mov r3, 0  # This signifies the amount of unrolling
++
++:fast_loop
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++# Due to pipelining we can only skip second pipeline instructions related to the fetched pixels
++sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
++shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++mov.ifz ra_y, ra_y_next   ; mov rb31, r3
++mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
++
++max r2, ra_y, 0
++min r2, r2, rb_frame_height_minus_1 ; mov r1, r4  # discard texture read
++add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
++add t0s, ra_x2_base, r2
++
++# generate seven shifted versions
++# interleave with scroll of vertical context
++
++mov r2, rb21         ; mul24 r3, r0, ra0
++sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
++sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
++sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
++sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
++sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
++sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
++sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
++sub r0, r2, r3       ; mov r3, rb31
++
++mov ra8, ra9
++mov ra9, ra10
++mov ra10, ra11
++mov ra11, ra12
++mov ra12, ra13
++mov ra13, ra14
++
++sub.setf -, r3, 8       ; mov r1, ra22
++
++# apply horizontal filter
++
++brr.anyn -, r:fast_loop
++max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
++asr r0, r0, 15          ; mov r1, ra21
++min.setf ra15, r0, rb22
++
++# apply vertical filter and write to VPM
++
++nop                     ; mul24 r0, ra14, rb14
++sub r1, r1, r0          ; mul24 r0, ra13, rb13
++sub r1, r1, r0          ; mul24 r0, ra12, rb12
++sub r1, r1, r0          ; mul24 r0, ra11, rb11
++sub r1, r1, r0          ; mul24 r0, ra10, rb10
++sub r1, r1, r0          ; mul24 r0, ra9, rb9
++sub r1, r1, r0          ; mul24 r0, ra8, rb8
++sub r1, r1, r0          ; mul24 r0, ra15, rb15
++sub.ifnn r1, r1, r0     ; mov -, vw_wait
++sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++brr.anyn -, r:fast_loop
++asr r1, r1, 15
++min r1, r1, rb22
++max vpm, r1, 0
++
++# DMA out
++
++bra -, ra31
++mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
++mov vw_setup, rb29
++mov vw_addr, unif # start the VDW
++
++################################################################################
++
++# mc_filter_b(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
++
++# At this point we have already issued two pairs of texture requests for the current block
++# ra_x_base, ra_x16_base point to the current coordinates for this block
++::mc_filter_b
++mov ra31, unif
++
++# per-channel shifts were calculated on the *previous* invocation
++
++mov ra_xshift, ra_xshift_next
++mov ra_x2shift, ra_x2shift_next
++
++# get base addresses and per-channel shifts for *next* invocation
++add r0, unif, elem_num    # x
++add r2, r0, 8 # x+8
++max r0, r0, 0; mov r1, unif # y
++min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
++shl ra_xshift_next, r0, 3
++max r2, r2, 0
++min r2, r2, rb_frame_width_minus_1
++shl ra_x2shift_next, r2, 3
++add r0, r0, r3
++add r2, r2, r3
++and rb_x_base_next, r0, ~3
++and ra_x2_base_next, r2, ~3
++mov ra_y_next, r1
++
++# set up VPM write
++mov vw_setup, rb28
++
++# get width,height of block
++mov r2, 16
++mov r0, unif
++shr r1, r0, r2 # Extract width
++sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
++and r0, r0, rb22 # Extract height
++add rb17, r0, 5
++add rb18, r0, 7
++shl r0, r0, 7
++# r0 is currently height<<7
++# For vr_setup we want height<<20 (so 20-7=13 additional bits)
++shl r3, r0, 13
++shl r3, r3, 8 # Mask off top 8 bits
++shr r3, r3, 8
++add r0, r0, r1 # Combine width and height of destination area
++shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
++add rb26, r0, rb27
++# In a B frame, so also set up VPM read
++add vr_setup, r3, rb28
++
++# get filter coefficients
++
++mov r0, unif
++asr ra3, r0, rb23;      mul24 r0, r0, ra22
++asr ra2, r0, rb23;      mul24 r0, r0, ra22
++asr ra1, r0, rb23;      mul24 r0, r0, ra22
++asr ra0, r0, rb23;      mov r0, unif
++asr ra7, r0, rb23;      mul24 r0, r0, ra22
++asr ra6, r0, rb23;      mul24 r0, r0, ra22
++asr ra5, r0, rb23;      mul24 r0, r0, ra22
++asr ra4, r0, rb23;      mov r0, unif
++asr rb11, r0, rb23;     mul24 r0, r0, ra22
++asr rb10, r0, rb23;     mul24 r0, r0, ra22
++asr rb9, r0, rb23;      mul24 r0, r0, ra22
++asr rb8, r0, rb23;      mov r0, unif
++asr rb15, r0, rb23;     mul24 r0, r0, ra22
++asr rb14, r0, rb23;     mul24 r0, r0, ra22
++asr rb13, r0, rb23;     mul24 r0, r0, ra22
++asr rb12, r0, rb23
++
++# r2 is elem_num
++# r3 is loop counter
++
++mov r5rep, -8
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++mov r3, 0
++
++:bloop
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
++shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
++
++max r2, ra_y, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++add t0s, ra_x2_base, r2
++
++# generate seven shifted versions
++# interleave with scroll of vertical context
++
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++mov r2, rb21         ; mul24 r3, r0, ra0
++sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++sub r0, r2, r3
++
++mov r3, rb31
++
++mov ra8, ra9
++mov ra9, ra10
++mov ra10, ra11
++mov ra11, ra12
++mov ra12, ra13
++mov ra13, ra14
++
++sub.setf -, r3, 8 ; mov r1, ra22
++
++# apply horizontal filter
++brr.anyn -, r:bloop
++max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
++asr r0, r0, 15          ; mov r1, ra21
++min.setf ra15, r0, rb22
++
++# apply vertical filter and write to VPM
++
++nop                     ; mul24 r0, ra14, rb14
++sub r1, r1, r0          ; mul24 r0, ra13, rb13
++sub r1, r1, r0          ; mul24 r0, ra12, rb12
++sub r1, r1, r0          ; mul24 r0, ra11, rb11
++sub r1, r1, r0          ; mul24 r0, ra10, rb10
++sub r1, r1, r0          ; mul24 r0, ra9, rb9
++sub r1, r1, r0          ; mul24 r0, ra8, rb8
++sub r1, r1, r0          ; mul24 r0, ra15, rb15
++sub.ifnn r1, r1, r0     ; mov -, vw_wait
++sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++asr r1, r1, 15          ; mov -, vr_wait
++min r1, r1, rb22
++add r0, vpm, 1          # Blend in previous VPM contents at this location
++brr.anyn -, r:bloop
++max r1, r1, 0
++add r1, r1, r0
++shr vpm, r1, 1
++
++# DMA out
++
++bra -, ra31
++mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
++mov vw_setup, rb29
++mov vw_addr, unif # start the VDW
++
++################################################################################
++
++# mc_filter_honly(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
++# This filter only does horizontal filtering.
++# It is assumed that the region to fetch does not include extra rows above.
++
++# At this point we have already issued two pairs of texture requests for the current block
++# ra_x_base, ra_x16_base point to the current coordinates for this block
++::mc_filter_honly
++mov ra31, unif
++
++# per-channel shifts were calculated on the *previous* invocation
++
++mov ra_xshift, ra_xshift_next
++mov ra_x2shift, ra_x2shift_next
++
++# get base addresses and per-channel shifts for *next* invocation
++add r0, unif, elem_num    # x
++add r2, r0, 8 # x+8
++max r0, r0, 0; mov r1, unif # y
++min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
++shl ra_xshift_next, r0, 3
++max r2, r2, 0
++min r2, r2, rb_frame_width_minus_1
++shl ra_x2shift_next, r2, 3
++add r0, r0, r3
++add r2, r2, r3
++and rb_x_base_next, r0, ~3
++and ra_x2_base_next, r2, ~3
++mov ra_y_next, r1
++
++# set up VPM write
++mov vw_setup, rb28
++
++# get width,height of block
++mov r2, 16
++mov r0, unif
++shr r1, r0, r2 # Extract width
++sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
++and r0, r0, rb22 # Extract height
++add rb17, r0, -2 # Pipelining means we move data across 2 iterations early
++shl r0, r0, 7 ; mov rb18,r0
++add r0, r0, r1 # Combine width and height of destination area
++shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
++add rb26, r0, rb27
++
++# get filter coefficients
++
++mov r0, unif
++asr ra3, r0, rb23;      mul24 r0, r0, ra22
++asr ra2, r0, rb23;      mul24 r0, r0, ra22
++asr ra1, r0, rb23;      mul24 r0, r0, ra22
++asr ra0, r0, rb23;      mov r0, unif
++asr ra7, r0, rb23;      mul24 r0, r0, ra22
++asr ra6, r0, rb23;      mul24 r0, r0, ra22
++asr ra5, r0, rb23;      mul24 r0, r0, ra22
++asr ra4, r0, rb23;      mov r0, unif
++mov r0, unif
++
++# r2 is elem_num
++# r3 is loop counter
++mov r5rep, -8
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
++mov r3, 0
++
++:loop_honly
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
++shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
++
++max r2, ra_y, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++add t0s, ra_x2_base, r2
++
++# generate seven shifted versions
++# interleave with scroll of vertical context
++
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++mov r2, rb21         ; mul24 r3, r0, ra0
++sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++sub r0, r2, r3       ; mov r3, rb31
++
++sub.setf -, r3, rb18 ; mov r1, ra22
++
++mov -, vw_wait   ; mul24 r0, r0, r1
++brr.anyn -, r:loop_honly
++asr r0, r0, 15          # delay 1
++min r0, r0, rb22        # delay 2
++max vpm, r0, 0          # delay 3
++
++# DMA out
++bra -, ra31
++mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
++mov vw_setup, rb29
++mov vw_addr, unif # start the VDW
++
++
++################################################################################
++
++# mc_exit()
++
++::mc_exit
++mov  -, vw_wait # wait on the VDW
++
++mov -,srel(0)
++
++ldtmu0
++ldtmu0
++ldtmu0
++ldtmu0
++
++nop        ; nop ; thrend
++nop        ; nop # delay slot 1
++nop        ; nop # delay slot 2
++
++::mc_exit1
++mov  -, vw_wait # wait on the VDW
++
++#mov -,srel(1)
++
++ldtmu0
++ldtmu0
++ldtmu0
++ldtmu0
++
++nop        ; nop ; thrend
++mov interrupt, 1; nop # delay slot 1
++nop        ; nop # delay slot 2
++
++# mc_interrupt_exit()
++::mc_interrupt_exit
++mov  -, vw_wait # wait on the VDW
++
++ldtmu0
++ldtmu0
++ldtmu0
++ldtmu0
++
++mov -,sacq(0) # 1
++mov -,sacq(0) # 2
++mov -,sacq(0) # 3
++mov -,sacq(0) # 4
++mov -,sacq(0) # 5
++mov -,sacq(0) # 6
++mov -,sacq(0) # 7
++mov -,sacq(0) # 8
++mov -,sacq(0) # 9
++mov -,sacq(0) # 10
++mov -,sacq(0) # 11
++
++nop        ; nop ; thrend
++mov interrupt, 1; nop # delay slot 1
++nop        ; nop # delay slot 2
++
++# mc_interrupt_exit4()
++::mc_interrupt_exit4
++mov  -, vw_wait # wait on the VDW
++
++ldtmu0
++ldtmu0
++ldtmu0
++ldtmu0
++
++mov -,sacq(0) # 1
++mov -,sacq(0) # 2
++mov -,sacq(0) # 3
++
++nop        ; nop ; thrend
++mov interrupt, 1; nop # delay slot 1
++nop        ; nop # delay slot 2
++
++# mc_interrupt_exit8()
++::mc_interrupt_exit8
++mov  -, vw_wait # wait on the VDW
++
++ldtmu0
++ldtmu0
++ldtmu0
++ldtmu0
++
++mov -,sacq(0) # 1
++mov -,sacq(0) # 2
++mov -,sacq(0) # 3
++mov -,sacq(0) # 4
++mov -,sacq(0) # 5
++mov -,sacq(0) # 6
++mov -,sacq(0) # 7
++
++nop        ; nop ; thrend
++mov interrupt, 1; nop # delay slot 1
++nop        ; nop # delay slot 2
++
++################################################################################
++# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
++::mc_setup_uv
++
++# Read starting kernel
++mov ra31, unif
++
++# Load first request location
++add ra_x_base, unif, elem_num # Store x
++mov ra_y, unif # Store y
++mov ra_x2_base, unif # Store frame u base
++nop
++sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
++
++# Read image dimensions
++sub rb25,unif,1
++sub rb30,unif,1
++
++# get source pitch
++mov rb16, unif
++
++# get destination pitch
++mov r0, unif
++mov r1, vdw_setup_1(0)
++add rb24, r1, r0
++
++# load constants
++
++mov ra20, 1
++mov ra21, 64
++mov ra22, 256
++mov ra23, 8
++
++mov rb20, 0xffffff00
++mov rb21, 64
++mov rb22, 255
++mov rb23, 24
++
++# touch vertical context to keep simulator happy
++
++mov ra8, 0
++mov ra9, 0
++mov ra10, 0
++mov ra11, 0
++mov ra12, 0
++mov ra13, 0
++mov ra14, 0
++mov ra15, 0
++
++# Compute part of VPM to use for DMA output
++mov r2, qpu_num
++and r2, r2, 15
++mov r1, r2
++asr r1, r1, 2
++shl r1, r1, 6
++mov r0, r2
++and r0, r0, 3
++add r0, r0, r1
++mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
++shl r0, r0, 5
++add rb27, r0, r1
++
++# Compute part of VPM to save data into
++mov r2, qpu_num
++and r2, r2, 15
++mov r1, r2
++asr r1, r1, 2
++shl r1, r1, 6
++mov r0, r2
++and r0, r0, 3
++add r0, r0, r1
++mov r1, vpm_setup(0, 4, h8p(0, 0))
++add rb28, r0, r1
++
++# Compute base address for first and second access
++mov r0, ra_x_base           # Load x
++max r0, r0, 0; mov r1, ra_y # Load y
++min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
++shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
++add ra_y, r1, 1
++add r0, r0, r3
++and r0, r0, ~3
++max r1, r1, 0 ; mov ra_x_base, r0 # y
++min r1, r1, rb_frame_height_minus_1
++# submit texture requests for first line
++add r2, r2, r0 ; mul24 r1, r1, rb_pitch
++add t0s, r0, r1 ; mov ra_x2_base, r2
++add t0s, r2, r1
++
++# Dump padding words
++mov r0, unif
++mov r0, unif
++mov r0, unif
++
++# submit texture requests for second line
++max r1, ra_y, 0
++min r1, r1, rb_frame_height_minus_1
++add ra_y, ra_y, 1
++bra -, ra31
++nop ; mul24 r1, r1, rb_pitch
++add t0s, r1, ra_x_base
++add t0s, r1, ra_x2_base
++
++
++
++################################################################################
++
++::mc_filter_uv_b
++mov ra31, unif
++
++# per-channel shifts were calculated on the *previous* invocation
++
++mov ra_xshift, ra_xshift_next
++
++# get base addresses and per-channel shifts for *next* invocation
++add r0, unif, elem_num    # x
++max r0, r0, 0; mov r1, unif # y
++min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
++shl ra_xshift_next, r0, 3
++sub r2, unif, r3 # compute offset from frame base u to frame base v
++add r0, r0, r3
++and rb_x_base_next, r0, ~3
++mov ra_y_next, r1
++add ra_x2_base_next, rb_x_base_next, r2
++
++# set up VPM write
++mov vw_setup, rb28
++
++# get width,height of block
++mov r2, 16
++mov r0, unif
++shr r1, r0, r2 # Extract width
++sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
++and r0, r0, rb22 # Extract height
++add rb17, r0, 5
++add rb18, r0, 7
++shl r0, r0, 7
++
++# r0 is currently height<<7
++# For vr_setup we want height<<20 (so 20-7=13 additional bits)
++shl r3, r0, 13
++shl r3, r3, 8 # Mask off top 8 bits
++shr r3, r3, 8
++
++add r0, r0, r1 # Combine width and height of destination area
++shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
++add rb26, r0, rb27
++
++# In a B frame, so also set up VPM read
++add vr_setup, r3, rb28
++
++sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
++
++# get filter coefficients
++
++mov r0, unif
++asr ra3, r0, rb23;      mul24 r0, r0, ra22
++asr ra2, r0, rb23;      mul24 r0, r0, ra22
++asr ra1, r0, rb23;      mul24 r0, r0, ra22
++asr ra0, r0, rb23;      mov r0, unif
++asr ra7, r0, rb23;      mul24 r0, r0, ra22
++asr ra6, r0, rb23;      mul24 r0, r0, ra22
++asr ra5, r0, rb23;      mul24 r0, r0, ra22
++asr ra4, r0, rb23;      mov r0, unif
++asr rb11, r0, rb23;     mul24 r0, r0, ra22
++asr rb10, r0, rb23;     mul24 r0, r0, ra22
++asr rb9, r0, rb23;      mul24 r0, r0, ra22
++asr rb8, r0, rb23;      mov r0, unif
++asr rb15, r0, rb23;     mul24 r0, r0, ra22
++asr rb14, r0, rb23;     mul24 r0, r0, ra22
++asr rb13, r0, rb23;     mul24 r0, r0, ra22
++asr rb12, r0, rb23
++
++# r2 is elem_num
++# r3 is loop counter
++
++mov r5rep, -8
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++mov r3, 0
++
++:uvloop_b
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
++shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
++
++max r2, ra_y, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++add t0s, ra_x2_base, r2
++
++# generate seven shifted versions
++# interleave with scroll of vertical context
++
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++mov r2, rb21         ; mul24 r3, r0, ra0
++nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
++sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++sub r0, r2, r3
++
++mov r3, rb31
++
++mov ra8, ra9
++mov ra9, ra10
++mov ra10, ra11
++mov ra11, ra12
++mov ra12, ra13
++mov ra13, ra14
++
++sub.setf -, r3, 8 ; mov r1, ra22
++
++# apply horizontal filter
++brr.anyn -, r:uvloop_b
++max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
++asr r0, r0, 15          ; mov r1, ra21
++min.setf ra15, r0, rb22
++
++# apply vertical filter and write to VPM
++
++nop                     ; mul24 r0, ra14, rb14
++sub r1, r1, r0          ; mul24 r0, ra13, rb13
++sub r1, r1, r0          ; mul24 r0, ra12, rb12
++sub r1, r1, r0          ; mul24 r0, ra11, rb11
++sub r1, r1, r0          ; mul24 r0, ra10, rb10
++sub r1, r1, r0          ; mul24 r0, ra9, rb9
++sub r1, r1, r0          ; mul24 r0, ra8, rb8
++sub r1, r1, r0          ; mul24 r0, ra15, rb15
++sub.ifnn r1, r1, r0     ; mov -, vw_wait
++sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++asr r1, r1, 15
++min r1, r1, rb22
++add r0, vpm, 1          # Blend in previous VPM contents at this location
++brr.anyn -, r:uvloop_b
++max r1, r1, 0
++add r1, r1, r0
++shr vpm, r1, 1
++
++
++# DMA out for U
++
++mov vw_setup, rb26 # VDW setup 0
++mov vw_setup, rb29 # Stride
++mov vw_addr, unif # start the VDW
++
++# DMA out for V
++# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
++# Could potentially push this write into the start of the next pipeline stage.
++mov r0, 16
++mov -, vw_wait
++
++bra -, ra31
++add vw_setup, rb26, r0 # VDW setup 0
++mov vw_setup, rb29 # Stride
++mov vw_addr, unif # start the VDW
++
++::mc_end
+diff --git a/libavcodec/rpi_user_vcsm.h b/libavcodec/rpi_user_vcsm.h
+new file mode 100644
+index 0000000..fbebbbe
+--- /dev/null
++++ b/libavcodec/rpi_user_vcsm.h
+@@ -0,0 +1,425 @@
++/*
++Copyright (c) 2012, Broadcom Europe Ltd
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without
++modification, are permitted provided that the following conditions are met:
++    * Redistributions of source code must retain the above copyright
++      notice, this list of conditions and the following disclaimer.
++    * Redistributions in binary form must reproduce the above copyright
++      notice, this list of conditions and the following disclaimer in the
++      documentation and/or other materials provided with the distribution.
++    * Neither the name of the copyright holder nor the
++      names of its contributors may be used to endorse or promote products
++      derived from this software without specific prior written permission.
++
++THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
++ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
++WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
++DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
++(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
++LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
++ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
++(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
++SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++*/
++
++#ifndef __USER_VCSM__H__INCLUDED__
++#define __USER_VCSM__H__INCLUDED__
++
++/* VideoCore Shared Memory - user interface library.
++**
++** This library provides all the necessary abstraction for any application to
++** make use of the shared memory service which is distributed accross a kernel
++** driver and a videocore service.
++**
++** It is an application design decision to choose or not to use this service.
++**
++** The logical flow of operations that a user application needs to follow when
++** using this service is:
++**
++**       1) Initialize the service.
++**       2) Allocate shared memory blocks.
++**       3) Start using the allocated blocks.
++**          - In order to gain ownership on a block, lock the allocated block,
++**            locking a block returns a valid address that the user application
++**            can access.
++**          - When finished with using the block for the current execution cycle
++**            or function, and so when giving up the ownership, unlock the block.
++**       4) A block can be locked/unlocked as many times required - within or outside
++**          of - a specific execution context.
++**       5) To completely release an allocated block, free it.
++**       6) If the service is no longer required, terminate it.
++**
++**
++** Some generic considerations:
++
++** Allocating memory blocks.
++**
++**   Memory blocks can be allocated in different manners depending on the cache
++**   behavior desired.  A given block can either be:
++
++**       - Allocated in a non cached fashion all the way through host and videocore.
++**       - Allocated in a cached fashion on host OR videocore.
++**       - Allocated in a cached fashion on host AND videocore.
++**
++**   It is an application decision to determine how to allocate a block.  Evidently
++**   if the application will be doing substantial read/write accesses to a given block,
++**   it is recommended to allocate the block at least in a 'host cached' fashion for
++**   better results.
++**
++**
++** Locking memory blocks.
++**
++**   When the memory block has been allocated in a host cached fashion, locking the
++**   memory block (and so taking ownership of it) will trigger a cache invalidation.
++**
++**   For the above reason and when using host cached allocation, it is important that
++**   an application properly implements the lock/unlock mechanism to ensure cache will
++**   stay coherent, otherwise there is no guarantee it will at all be.
++**
++**   It is possible to dynamically change the host cache behavior (ie cached or non
++**   cached) of a given allocation without needing to free and re-allocate the block.
++**   This feature can be useful for such application which requires access to the block
++**   only at certain times and not otherwise.  By changing the cache behavior dynamically
++**   the application can optimize performances for a given duration of use.
++**   Such dynamic cache behavior remapping only applies to host cache and not videocore
++**   cache.  If one requires to change the videocore cache behavior, then a new block
++**   must be created to replace the old one.
++**
++**   On successful locking, a valid pointer is returned that the application can use
++**   to access to data inside the block.  There is no guarantee that the pointer will
++**   stay valid following the unlock action corresponding to this lock.
++**
++**
++** Unocking memory blocks.
++**
++**   When the memory block has been allocated in a host cached fashion, unlocking the
++**   memory block (and so forgiving its ownership) will trigger a cache flush unless
++**   explicitely asked not to flush the cache for performances reasons.
++**
++**   For the above reason and when using host cached allocation, it is important that
++**   an application properly implements the lock/unlock mechanism to ensure cache will
++**   stay coherent, otherwise there is no guarantee it will at all be.
++**
++**
++** A complete API is defined below.
++*/
++
++#ifdef __cplusplus
++extern "C"
++{
++#endif
++
++/* Different status that can be dumped.
++*/
++typedef enum
++{
++   VCSM_STATUS_VC_WALK_ALLOC = 0,   // Walks *all* the allocation on videocore.
++                                    // Result of the walk is seen in the videocore
++                                    // log.
++   VCSM_STATUS_HOST_WALK_MAP,       // Walks the *full* mapping allocation on host
++                                    // driver (ie for all processes).  Result of
++                                    // the walk is seen in the kernel log.
++   VCSM_STATUS_HOST_WALK_PID_MAP,   // Walks the per process mapping allocation on host
++                                    // driver (for current process).  Result of
++                                    // the walk is seen in the kernel log.
++   VCSM_STATUS_HOST_WALK_PID_ALLOC, // Walks the per process host allocation on host
++                                    // driver (for current process).  Result of
++                                    // the walk is seen in the kernel log.
++   VCSM_STATUS_VC_MAP_ALL,          // Equivalent to both VCSM_STATUS_VC_WALK_ALLOC and
++                                    // VCSM_STATUS_HOST_WALK_MAP.
++                                    //
++   VCSM_STATUS_NONE,                // Must be last - invalid.
++
++} VCSM_STATUS_T;
++
++/* Different kind of cache behavior.
++*/
++typedef enum
++{
++   VCSM_CACHE_TYPE_NONE = 0,        // No caching applies.
++   VCSM_CACHE_TYPE_HOST,            // Allocation is cached on host (user space).
++   VCSM_CACHE_TYPE_VC,              // Allocation is cached on videocore.
++   VCSM_CACHE_TYPE_HOST_AND_VC,     // Allocation is cached on both host and videocore.
++
++} VCSM_CACHE_TYPE_T;
++
++/* Initialize the vcsm processing.
++**
++** Must be called once before attempting to do anything else.
++**
++** Returns 0 on success, -1 on error.
++*/
++int vcsm_init( void );
++
++
++/* Terminates the vcsm processing.
++**
++** Must be called vcsm services are no longer needed, it will
++** take care of removing any allocation under the current process
++** control if deemed necessary.
++*/
++void vcsm_exit( void );
++
++
++/* Queries the status of the the vcsm.
++**
++** Triggers dump of various kind of information, see the
++** different variants specified in VCSM_STATUS_T.
++**
++** Pid is optional.
++*/
++void vcsm_status( VCSM_STATUS_T status, int pid );
++
++
++/* Allocates a non-cached block of memory of size 'size' via the vcsm memory
++** allocator.
++**
++** Returns:        0 on error
++**                 a non-zero opaque handle on success.
++**
++** On success, the user must invoke vcsm_lock with the returned opaque
++** handle to gain access to the memory associated with the opaque handle.
++** When finished using the memory, the user calls vcsm_unlock_xx (see those
++** function definition for more details on the one that can be used).
++**
++** A well behaved application should make every attempt to lock/unlock
++** only for the duration it needs to access the memory data associated with
++** the opaque handle.
++*/
++unsigned int vcsm_malloc( unsigned int size, char *name );
++
++
++/* Allocates a cached block of memory of size 'size' via the vcsm memory
++** allocator, the type of caching requested is passed as argument of the
++** function call.
++**
++** Returns:        0 on error
++**                 a non-zero opaque handle on success.
++**
++** On success, the user must invoke vcsm_lock with the returned opaque
++** handle to gain access to the memory associated with the opaque handle.
++** When finished using the memory, the user calls vcsm_unlock_xx (see those
++** function definition for more details on the one that can be used).
++**
++** A well behaved application should make every attempt to lock/unlock
++** only for the duration it needs to access the memory data associated with
++** the opaque handle.
++*/
++unsigned int vcsm_malloc_cache( unsigned int size, VCSM_CACHE_TYPE_T cache, char *name );
++
++
++/* Shares an allocated block of memory via the vcsm memory allocator.
++**
++** Returns:        0 on error
++**                 a non-zero opaque handle on success.
++**
++** On success, the user must invoke vcsm_lock with the returned opaque
++** handle to gain access to the memory associated with the opaque handle.
++** When finished using the memory, the user calls vcsm_unlock_xx (see those
++** function definition for more details on the one that can be used).
++**
++** A well behaved application should make every attempt to lock/unlock
++** only for the duration it needs to access the memory data associated with
++** the opaque handle.
++*/
++unsigned int vcsm_malloc_share( unsigned int handle );
++
++
++/* Resizes a block of memory allocated previously by vcsm_alloc.
++**
++** Returns:        0 on success
++**                 -errno on error.
++**
++** The handle must be unlocked by user prior to attempting any
++** resize action.
++**
++** On error, the original size allocated against the handle
++** remains available the same way it would be following a
++** successful vcsm_malloc.
++*/
++int vcsm_resize( unsigned int handle, unsigned int new_size );
++
++
++/* Frees a block of memory that was successfully allocated by
++** a prior call the vcms_alloc.
++**
++** The handle should be considered invalid upon return from this
++** call.
++**
++** Whether any memory is actually freed up or not as the result of
++** this call will depends on many factors, if all goes well it will
++** be freed.  If something goes wrong, the memory will likely end up
++** being freed up as part of the vcsm_exit process.  In the end the
++** memory is guaranteed to be freed one way or another.
++*/
++void vcsm_free( unsigned int handle );
++
++
++/* Retrieves a videocore opaque handle from a mapped user address
++** pointer.  The videocore handle will correspond to the actual
++** memory mapped in videocore.
++**
++** Returns:        0 on error
++**                 a non-zero opaque handle on success.
++**
++** Note: the videocore opaque handle is distinct from the user
++**       opaque handle (allocated via vcsm_malloc) and it is only
++**       significant for such application which knows what to do
++**       with it, for the others it is just a number with little
++**       use since nothing can be done with it (in particular
++**       for safety reason it cannot be used to map anything).
++*/
++unsigned int vcsm_vc_hdl_from_ptr( void *usr_ptr );
++
++
++/* Retrieves a videocore opaque handle from a opaque handle
++** pointer.  The videocore handle will correspond to the actual
++** memory mapped in videocore.
++**
++** Returns:        0 on error
++**                 a non-zero opaque handle on success.
++**
++** Note: the videocore opaque handle is distinct from the user
++**       opaque handle (allocated via vcsm_malloc) and it is only
++**       significant for such application which knows what to do
++**       with it, for the others it is just a number with little
++**       use since nothing can be done with it (in particular
++**       for safety reason it cannot be used to map anything).
++*/
++unsigned int vcsm_vc_hdl_from_hdl( unsigned int handle );
++
++
++/* Retrieves a user opaque handle from a mapped user address
++** pointer.
++**
++** Returns:        0 on error
++**                 a non-zero opaque handle on success.
++*/
++unsigned int vcsm_usr_handle( void *usr_ptr );
++
++
++/* Retrieves a mapped user address from an opaque user
++** handle.
++**
++** Returns:        0 on error
++**                 a non-zero address on success.
++**
++** On success, the address corresponds to the pointer
++** which can access the data allocated via the vcsm_malloc
++** call.
++*/
++void *vcsm_usr_address( unsigned int handle );
++
++
++/* Locks the memory associated with this opaque handle.
++**
++** Returns:        NULL on error
++**                 a valid pointer on success.
++**
++** A user MUST lock the handle received from vcsm_malloc
++** in order to be able to use the memory associated with it.
++**
++** On success, the pointer returned is only valid within
++** the lock content (ie until a corresponding vcsm_unlock_xx
++** is invoked).
++*/
++void *vcsm_lock( unsigned int handle );
++
++
++/* Locks the memory associated with this opaque handle.  The lock
++** also gives a chance to update the *host* cache behavior of the
++** allocated buffer if so desired.  The *videocore* cache behavior
++** of the allocated buffer cannot be changed by this call and such
++** attempt will be ignored.
++**
++** The system will attempt to honour the cache_update mode request,
++** the cache_result mode will provide the final answer on which cache
++** mode is really in use.  Failing to change the cache mode will not
++** result in a failure to lock the buffer as it is an application
++** decision to choose what to do if (cache_result != cache_update)
++**
++** The value returned in cache_result can only be considered valid if
++** the returned pointer is non NULL.  The cache_result pointer may be
++** NULL if the application does not care about the actual outcome of
++** its action with regards to the cache behavior change.
++**
++** Returns:        NULL on error
++**                 a valid pointer on success.
++**
++** A user MUST lock the handle received from vcsm_malloc
++** in order to be able to use the memory associated with it.
++**
++** On success, the pointer returned is only valid within
++** the lock content (ie until a corresponding vcsm_unlock_xx
++** is invoked).
++*/
++void *vcsm_lock_cache( unsigned int handle,
++                       VCSM_CACHE_TYPE_T cache_update,
++                       VCSM_CACHE_TYPE_T *cache_result );
++
++
++/* Unlocks the memory associated with this user mapped address.
++**
++** Returns:        0 on success
++**                 -errno on error.
++**
++** After unlocking a mapped address, the user should no longer
++** attempt to reference it.
++*/
++int vcsm_unlock_ptr( void *usr_ptr );
++
++
++/* Unlocks the memory associated with this user mapped address.
++** Apply special processing that would override the otherwise
++** default behavior.
++**
++** If 'cache_no_flush' is specified:
++**    Do not flush cache as the result of the unlock (if cache
++**    flush was otherwise applicable in this case).
++**
++** Returns:        0 on success
++**                 -errno on error.
++**
++** After unlocking a mapped address, the user should no longer
++** attempt to reference it.
++*/
++int vcsm_unlock_ptr_sp( void *usr_ptr, int cache_no_flush );
++
++
++/* Unlocks the memory associated with this user opaque handle.
++**
++** Returns:        0 on success
++**                 -errno on error.
++**
++** After unlocking an opaque handle, the user should no longer
++** attempt to reference the mapped addressed once associated
++** with it.
++*/
++int vcsm_unlock_hdl( unsigned int handle );
++
++
++/* Unlocks the memory associated with this user opaque handle.
++** Apply special processing that would override the otherwise
++** default behavior.
++**
++** If 'cache_no_flush' is specified:
++**    Do not flush cache as the result of the unlock (if cache
++**    flush was otherwise applicable in this case).
++**
++** Returns:        0 on success
++**                 -errno on error.
++**
++** After unlocking an opaque handle, the user should no longer
++** attempt to reference the mapped addressed once associated
++** with it.
++*/
++int vcsm_unlock_hdl_sp( unsigned int handle, int cache_no_flush );
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* __USER_VCSM__H__INCLUDED__ */
+-- 
+2.7.4
+
+
+From 6cfa5910be47865aaaf58c185587189c332765a6 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@argondesign.com>
+Date: Sat, 2 May 2015 21:15:37 +0100
+Subject: [PATCH 04/68] First working version with uncached memory
+
+---
+ libavcodec/hevc.c               |  61 +++++-
+ libavcodec/hevc.h               |  12 +-
+ libavcodec/hevc_cabac.c         |  39 +++-
+ libavcodec/hevc_filter.c        |  16 ++
+ libavcodec/hevcpred_template.c  |   6 +
+ libavcodec/rpi_hevc_transform.h | 422 +++++++++++++++++++++++++++++++++++++++-
+ libavcodec/rpi_hevc_transform.s | 153 +++++++++++++--
+ libavcodec/rpi_qpu.c            |  72 +++++++
+ libavcodec/rpi_qpu.h            |   1 +
+ 9 files changed, 736 insertions(+), 46 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index ab55df1..94ff709 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -45,6 +45,8 @@
+ #include "rpi_qpu.h"
+ #endif
+ 
++// #define DISABLE_MC
++
+ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12] = 4, [16] = 5, [24] = 6, [32] = 7, [48] = 8, [64] = 9 };
+ 
+ /**
+@@ -1079,11 +1081,15 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+                         for (i = 0; i < (size * size); i++) {
+                             coeffs[i] = ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
+                         }
++                        printf("Cross component not supported\n"); // TODO
++                        exit(-1);
+                         s->hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
+                     }
+             }
+ 
+             if (lc->tu.cross_pf) {
++                printf("Cross component not supported\n"); // TODO
++                exit(-1);
+                 hls_cross_component_pred(s, 1);
+             }
+             for (i = 0; i < (s->ps.sps->chroma_format_idc == 2 ? 2 : 1); i++) {
+@@ -1112,6 +1118,8 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+                         for (i = 0; i < (size * size); i++) {
+                             coeffs[i] = ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
+                         }
++                        printf("Cross component not supported\n"); // TODO
++                        exit(-1);
+                         s->hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
+                     }
+             }
+@@ -1409,6 +1417,10 @@ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                            (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+     int idx              = ff_hevc_pel_weight[block_w];
+ 
++#ifdef DISABLE_MC
++    return;
++#endif
++
+     x_off += mv->x >> 2;
+     y_off += mv->y >> 2;
+     src   += y_off * srcstride + (x_off * (1 << s->ps.sps->pixel_shift));
+@@ -1479,6 +1491,10 @@ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+     uint8_t *src0  = ref0->data[0] + y_off0 * src0stride + (int)((unsigned)x_off0 << s->ps.sps->pixel_shift);
+     uint8_t *src1  = ref1->data[0] + y_off1 * src1stride + (int)((unsigned)x_off1 << s->ps.sps->pixel_shift);
+ 
++#ifdef DISABLE_MC
++    return;
++#endif
++
+     if (x_off0 < QPEL_EXTRA_BEFORE || y_off0 < QPEL_EXTRA_AFTER ||
+         x_off0 >= pic_width - block_w - QPEL_EXTRA_AFTER ||
+         y_off0 >= pic_height - block_h - QPEL_EXTRA_AFTER) {
+@@ -1564,6 +1580,10 @@ static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
+     intptr_t _mx         = mx << (1 - hshift);
+     intptr_t _my         = my << (1 - vshift);
+ 
++#ifdef DISABLE_MC
++    return;
++#endif
++
+     x_off += mv->x >> (2 + hshift);
+     y_off += mv->y >> (2 + vshift);
+     src0  += y_off * srcstride + (x_off * (1 << s->ps.sps->pixel_shift));
+@@ -1628,6 +1648,10 @@ static void chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVF
+     int hshift = s->ps.sps->hshift[1];
+     int vshift = s->ps.sps->vshift[1];
+ 
++#ifdef DISABLE_MC
++    return;
++#endif
++
+     intptr_t mx0 = av_mod_uintp2(mv0->x, 2 + hshift);
+     intptr_t my0 = av_mod_uintp2(mv0->y, 2 + vshift);
+     intptr_t mx1 = av_mod_uintp2(mv1->x, 2 + hshift);
+@@ -2367,6 +2391,22 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
+ }
+ 
+ #ifdef RPI
++static void rpi_execute_transform(HEVCContext *s)
++{
++    int i=2;
++    //int j;
++    //int16_t *coeffs = s->coeffs_buf_arm[i];
++    //for(j=s->num_coeffs[i]; j > 0; j-= 16*16, coeffs+=16*16) {
++    //    s->hevcdsp.idct[4-2](coeffs, 16);
++    //}
++
++    //gpu_cache_flush(&s->coeffs_buf[i]);
++    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[i].vc, s->num_coeffs[i] >> 8, 0, 0, 0);
++
++    for(i=0;i<4;i++)
++        s->num_coeffs[i] = 0;
++}
++
+ static void rpi_execute_pred_cmds(HEVCContext *s)
+ {
+   int i;
+@@ -2387,7 +2427,6 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
+       }
+   }
+   s->num_pred_cmds = 0;
+-  s->num_coeffs = 0;
+ }
+ #endif
+ 
+@@ -2434,7 +2473,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ 
+         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
+ #ifdef RPI
+-        if (x_ctb + ctb_size >= s->ps.sps->width) {
++        if (1 || x_ctb + ctb_size >= s->ps.sps->width) { // TODO watch out for deblocking!
++            rpi_execute_transform(s);
+             rpi_execute_pred_cmds(s);
+         }
+ #endif
+@@ -3179,7 +3219,9 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+     av_freep(&s->unif_mv_cmds);
+     av_freep(&s->unif_xfm_cmds);
+     av_freep(&s->univ_pred_cmds);
+-    av_freep(&s->coeffs_buf);
++    for(i = 0; i < 4; i++) {
++        gpu_free(&s->coeffs_buf[i]);
++    }
+ #endif
+ 
+     for (i = 0; i < 3; i++) {
+@@ -3246,13 +3288,16 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
+     if (!s->univ_pred_cmds)
+         goto fail;
+-    s->coeffs_buf = av_mallocz(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16);
+-    if (!s->coeffs_buf)
+-        goto fail;
++    for(i = 0; i < 4; i++) {
++        gpu_malloc_uncached(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16, &s->coeffs_buf[i]); // TODO slim this down and share across sizes
++        s->coeffs_buf_arm[i] = (int16_t*) s->coeffs_buf[i].arm;
++        if (!s->coeffs_buf_arm[i])
++            goto fail;
++    }
+     s->enable_rpi = 0;
+ 
+     // A little test program
+-    {
++    /*{
+       GPU_MEM_PTR_T p;
+       int err = gpu_malloc_cached(16, &p);
+       short *q = (short *)p.arm;
+@@ -3273,7 +3318,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+       printf(")\n");
+       gpu_free(&p);
+       goto fail; // Early out
+-    }
++    }*/
+ 
+ #endif
+ 
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 7a1c35f..4167985 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -40,6 +40,11 @@
+ #include "thread.h"
+ #include "videodsp.h"
+ 
++// define RPI to split the CABAC/prediction/transform into separate stages
++#ifdef RPI
++#include "rpi_qpu.h"
++#endif
++
+ #define MAX_DPB_SIZE 16 // A.4.1
+ #define MAX_REFS 16
+ 
+@@ -856,11 +861,12 @@ typedef struct HEVCContext {
+     HEVCMvCmd *unif_mv_cmds;
+     HEVCXfmCmd *unif_xfm_cmds;
+     HEVCPredCmd *univ_pred_cmds;
+-    int16_t *coeffs_buf;
+-    int num_mv_cmds;
++    GPU_MEM_PTR_T coeffs_buf[4];
++    int16_t *coeffs_buf_arm[4];
++    int num_coeffs[4];
+     int num_xfm_cmds;
++    int num_mv_cmds;
+     int num_pred_cmds;
+-    int num_coeffs;
+ #endif
+ 
+     uint8_t *cabac_state;
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index 4e97f06..d1cba86 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -1031,6 +1031,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+     int vshift = s->ps.sps->vshift[c_idx];
+     uint8_t *dst = &s->frame->data[c_idx][(y0 >> vshift) * stride +
+                                           ((x0 >> hshift) << s->ps.sps->pixel_shift)];
++    int use_vpu = s->enable_rpi && !lc->cu.cu_transquant_bypass_flag && !transform_skip_flag && !lc->tu.cross_pf && log2_trafo_size==4;
+     int16_t *coeffs = (int16_t*)(c_idx ? lc->edge_emu_buffer2 : lc->edge_emu_buffer);
+     uint8_t significant_coeff_group_flag[8][8] = {{0}};
+     int explicit_rdpcm_flag = 0;
+@@ -1044,6 +1045,18 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+     uint8_t dc_scale;
+     int pred_mode_intra = (c_idx == 0) ? lc->tu.intra_pred_mode :
+                                          lc->tu.intra_pred_mode_c;
++#ifdef RPI
++    if (s->enable_rpi) {
++        int n = trafo_size * trafo_size;
++        if (use_vpu) {
++            coeffs = s->coeffs_buf_arm[log2_trafo_size - 2] + s->num_coeffs[log2_trafo_size - 2];
++            s->num_coeffs[log2_trafo_size - 2] += n;
++        } else {
++            coeffs = s->coeffs_buf_arm[0] + s->num_coeffs[0];
++            s->num_coeffs[0] += n;
++        }
++    }
++#endif
+ 
+     memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
+ 
+@@ -1488,6 +1501,24 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+         } else if (lc->cu.pred_mode == MODE_INTRA && c_idx == 0 && log2_trafo_size == 2) {
+             s->hevcdsp.idct_4x4_luma(coeffs);
+         } else {
++#ifdef RPI
++            if (!use_vpu) {
++              int max_xy = FFMAX(last_significant_coeff_x, last_significant_coeff_y);
++              if (max_xy == 0)
++                  s->hevcdsp.idct_dc[log2_trafo_size-2](coeffs);
++              else {
++                  int col_limit = last_significant_coeff_x + last_significant_coeff_y + 4;
++                  if (max_xy < 4)
++                      col_limit = FFMIN(4, col_limit);
++                  else if (max_xy < 8)
++                      col_limit = FFMIN(8, col_limit);
++                  else if (max_xy < 12)
++                      col_limit = FFMIN(24, col_limit);
++
++                  s->hevcdsp.idct[log2_trafo_size-2](coeffs, col_limit);
++              }
++            }
++#else
+             int max_xy = FFMAX(last_significant_coeff_x, last_significant_coeff_y);
+             if (max_xy == 0)
+                 s->hevcdsp.idct_dc[log2_trafo_size-2](coeffs);
+@@ -1501,6 +1532,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+                     col_limit = FFMIN(24, col_limit);
+                 s->hevcdsp.idct[log2_trafo_size-2](coeffs, col_limit);
+             }
++#endif
+         }
+     }
+     if (lc->tu.cross_pf) {
+@@ -1512,14 +1544,11 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+     }
+ #ifdef RPI
+     if (s->enable_rpi) {
+-        int16_t *c = s->coeffs_buf + s->num_coeffs;
+-        int n = trafo_size * trafo_size;
+         HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
+-        memcpy(c, coeffs, n * sizeof(int16_t));  // TODO change pointer earlier and we can avoid this copy
+-        s->num_coeffs += n;
++        //memcpy(coeffs2, coeffs, sizeof(int16_t) * trafo_size * trafo_size); // TODO
+         cmd->type = RPI_PRED_TRANSFORM_ADD;
+         cmd->size = log2_trafo_size;
+-        cmd->buf = c;
++        cmd->buf = coeffs;
+         cmd->dst = dst;
+         cmd->stride = stride;
+         return;
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 1f33b0c..e4c3da7 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -22,6 +22,10 @@
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+  */
+ 
++//#define DISABLE_SAO
++//#define DISABLE_DEBLOCK
++//#define DISABLE_STRENGTHS
++
+ #include "libavutil/common.h"
+ #include "libavutil/internal.h"
+ 
+@@ -273,6 +277,10 @@ static void sao_filter_CTB(HEVCContext *s, int x, int y)
+     edges[2]   = x_ctb == s->ps.sps->ctb_width  - 1;
+     edges[3]   = y_ctb == s->ps.sps->ctb_height - 1;
+ 
++#ifdef DISABLE_SAO
++    return;
++#endif
++
+     if (restore) {
+         if (!edges[0]) {
+             left_tile_edge  = no_tile_filter && s->ps.pps->tile_id[ctb_addr_ts] != s->ps.pps->tile_id[s->ps.pps->ctb_addr_rs_to_ts[ctb_addr_rs-1]];
+@@ -496,6 +504,10 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
+                 s->ps.sps->pcm.loop_filter_disable_flag) ||
+                s->ps.pps->transquant_bypass_enable_flag;
+ 
++#ifdef DISABLE_DEBLOCK
++    return;
++#endif
++
+     if (x0) {
+         left_tc_offset   = s->deblock[ctb - 1].tc_offset;
+         left_beta_offset = s->deblock[ctb - 1].beta_offset;
+@@ -726,6 +738,10 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
+     int boundary_upper, boundary_left;
+     int i, j, bs;
+ 
++#ifdef DISABLE_STRENGTHS
++    return;
++#endif
++
+     boundary_upper = y0 > 0 && !(y0 & 7);
+     if (boundary_upper &&
+         ((!s->sh.slice_loop_filter_across_slices_enabled_flag &&
+diff --git a/libavcodec/hevcpred_template.c b/libavcodec/hevcpred_template.c
+index 6ae87cc..71c6d52 100644
+--- a/libavcodec/hevcpred_template.c
++++ b/libavcodec/hevcpred_template.c
+@@ -20,6 +20,8 @@
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+  */
+ 
++//#define DISABLE_INTRA
++
+ #include "libavutil/pixdesc.h"
+ 
+ #include "bit_depth_template.c"
+@@ -114,6 +116,10 @@ do {                                  \
+     int top_right_size   = (FFMIN(x0 + 2 * size_in_luma_h, s->ps.sps->width) -
+                            (x0 + size_in_luma_h)) >> hshift;
+ 
++#ifdef DISABLE_INTRA
++    return;
++#endif
++
+     if (s->ps.pps->constrained_intra_pred_flag == 1) {
+         int size_in_luma_pu_v = PU(size_in_luma_v);
+         int size_in_luma_pu_h = PU(size_in_luma_h);
+diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
+index 85a9102..c0c279f 100644
+--- a/libavcodec/rpi_hevc_transform.h
++++ b/libavcodec/rpi_hevc_transform.h
+@@ -3,11 +3,11 @@ unsigned char rpi_hevc_transform [] = {
+ 3,
+ 3,
+ 232,
+-128,
++32,
+ 0,
+ 0,
+ 0,
+-20,
++12,
+ 248,
+ 0,
+ 136,
+@@ -56,9 +56,9 @@ unsigned char rpi_hevc_transform [] = {
+ 5,
+ 232,
+ 0,
+-0,
+ 8,
+ 0,
++0,
+ 128,
+ 69,
+ 113,
+@@ -108,8 +108,8 @@ unsigned char rpi_hevc_transform [] = {
+ 128,
+ 2,
+ 0,
+-248,
+-62,
++8,
++2,
+ 0,
+ 128,
+ 144,
+@@ -123,13 +123,13 @@ unsigned char rpi_hevc_transform [] = {
+ 3,
+ 32,
+ 8,
+-16,
++20,
+ 0,
+ 76,
+ 254,
+ 48,
+ 192,
+-9,
++4,
+ 4,
+ 32,
+ 8,
+@@ -155,14 +155,46 @@ unsigned char rpi_hevc_transform [] = {
+ 192,
+ 41,
+ 3,
+-68,
++70,
++192,
++80,
++7,
++164,
++255,
++36,
++204,
++96,
++2,
++0,
++248,
++62,
++0,
++3,
++255,
++55,
++208,
++120,
++3,
++224,
++3,
++190,
++11,
++16,
++139,
++246,
++91,
++0,
++103,
++90,
++0,
++70,
+ 192,
+ 80,
+ 7,
+ 164,
+ 255,
+ 36,
+-220,
++204,
+ 96,
+ 2,
+ 0,
+@@ -182,7 +214,7 @@ unsigned char rpi_hevc_transform [] = {
+ 16,
+ 139,
+ 246,
+-83,
++91,
+ 0,
+ 103,
+ 90,
+@@ -209,4 +241,374 @@ unsigned char rpi_hevc_transform [] = {
+ 96,
+ 90,
+ 0,
++169,
++3,
++3,
++232,
++32,
++0,
++0,
++0,
++12,
++248,
++0,
++136,
++0,
++0,
++192,
++248,
++0,
++0,
++64,
++232,
++0,
++2,
++0,
++0,
++12,
++248,
++0,
++168,
++0,
++0,
++192,
++248,
++0,
++0,
++3,
++232,
++128,
++0,
++0,
++0,
++7,
++232,
++0,
++2,
++0,
++0,
++4,
++232,
++64,
++0,
++0,
++0,
++5,
++232,
++0,
++8,
++0,
++0,
++57,
++239,
++224,
++247,
++255,
++255,
++72,
++192,
++95,
++207,
++88,
++122,
++88,
++124,
++137,
++64,
++26,
++64,
++161,
++64,
++152,
++64,
++128,
++144,
++31,
++0,
++72,
++232,
++32,
++0,
++0,
++0,
++65,
++232,
++32,
++0,
++0,
++0,
++128,
++144,
++23,
++0,
++145,
++64,
++168,
++64,
++128,
++144,
++19,
++0,
++72,
++232,
++32,
++0,
++0,
++0,
++65,
++232,
++32,
++0,
++0,
++0,
++128,
++144,
++11,
++0,
++74,
++232,
++0,
++8,
++0,
++0,
++242,
++140,
++229,
++192,
++57,
++239,
++32,
++8,
++0,
++0,
++41,
++3,
++12,
++248,
++0,
++128,
++0,
++0,
++192,
++8,
++4,
++0,
++12,
++248,
++0,
++132,
++64,
++0,
++192,
++8,
++4,
++0,
++0,
++96,
++255,
++159,
++131,
++255,
++0,
++232,
++0,
++4,
++0,
++0,
++255,
++159,
++142,
++255,
++4,
++255,
++48,
++204,
++16,
++3,
++224,
++251,
++62,
++0,
++5,
++255,
++51,
++204,
++128,
++3,
++224,
++251,
++16,
++0,
++77,
++254,
++51,
++204,
++9,
++4,
++224,
++251,
++0,
++0,
++128,
++64,
++6,
++232,
++64,
++0,
++0,
++0,
++140,
++248,
++47,
++0,
++0,
++0,
++224,
++99,
++0,
++0,
++4,
++254,
++0,
++144,
++128,
++2,
++0,
++8,
++2,
++0,
++32,
++247,
++240,
++207,
++16,
++3,
++32,
++247,
++176,
++207,
++17,
++3,
++32,
++247,
++112,
++207,
++18,
++3,
++32,
++247,
++48,
++207,
++19,
++3,
++32,
++247,
++240,
++206,
++20,
++3,
++32,
++247,
++176,
++206,
++21,
++3,
++32,
++247,
++112,
++206,
++22,
++3,
++32,
++247,
++48,
++206,
++23,
++3,
++32,
++247,
++240,
++205,
++24,
++3,
++32,
++247,
++176,
++205,
++25,
++3,
++32,
++247,
++112,
++205,
++26,
++3,
++32,
++247,
++48,
++205,
++27,
++3,
++32,
++247,
++240,
++204,
++28,
++3,
++32,
++247,
++176,
++204,
++29,
++3,
++32,
++247,
++112,
++204,
++30,
++3,
++32,
++247,
++48,
++204,
++31,
++3,
++5,
++255,
++51,
++204,
++128,
++3,
++224,
++251,
++16,
++0,
++77,
++254,
++51,
++204,
++9,
++4,
++224,
++251,
++0,
++0,
++0,
++237,
++0,
++4,
++0,
++0,
++140,
++248,
++47,
++0,
++0,
++0,
++224,
++99,
++0,
++0,
++90,
++0,
+ };
+diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
+index 5e2728d..1e389c7 100644
+--- a/libavcodec/rpi_hevc_transform.s
++++ b/libavcodec/rpi_hevc_transform.s
+@@ -58,13 +58,6 @@
+ #
+ #
+ 
+-test_add:
+-  vldh HX(0,0),(r0)
+-  vadd HX(0,0),HX(0,0),10
+-  vsth HX(0,0),(r0)
+-  mov r0,7 # return value
+-  b lr
+-
+ # Columns are transformed first
+ #
+ # Store top left half of transMatrix2 in
+@@ -79,7 +72,7 @@ test_add:
+ #
+ 
+ 
+-# hevc_trans_16x16(short *transMatrix2, short *coeffs, int num)
++# hevc_trans_16x16(short *transMatrix2, short *coeffs, int num) # TODO add size so we can branch to correct implementation (or perhaps have coeffs32 and num32 as secondary inputs!)
+ # transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory)
+ # coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
+ # num: number of 16x16 transforms to be done
+@@ -87,17 +80,17 @@ test_add:
+ hevc_trans_16x16:
+   push r6-r15, lr # TODO cut down number of used registers
+ 
+-  mov r3, 2*32*2 # Twice Stride of transMatrix2 in bytes
+-  vld HX(32++,0),(r0 += r3) REP 16 # This is the 16x16 matrix, a transform is equivalent to multiplying input row vector * matrix
++  mov r3, 16*2 # Stride of transMatrix2 in bytes
++  vldh HX(32++,0),(r0 += r3) REP 16 # This is the 16x16 matrix, a transform is equivalent to multiplying input row vector * matrix
+   # Now use r0 to describe which matrix we are working on.
+   # Allows us to prefetch the next block of coefficients for efficiency.
+   mov r0,0 # This describes the location where we read our coefficients from
+-  mov r3,16*2 # Stride of coefficients in bytes
++  mov r3,16*2 # Stride of coefficients in bytes (TODO remove)
+   mov r7,16*16*2 # Total block size
+   mov r8,64*16 # Value used to swap from current to next VRF location
+   vldh HX(0++,0)+r0,(r1 += r3) REP 16
+   mov r4,64 # Constant used for rounding first pass
+-  mov r5,1<<19 # Constant used for rounding second pass
++  mov r5,1<<11 # Constant used for rounding second pass
+ 
+   # At start of block r0,r1 point to the current block (that has already been loaded)
+ block_loop:
+@@ -113,12 +106,12 @@ block_loop:
+   vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
+   #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
+   vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
+-  vmov VX(0,0++), HX(0++,32) REP 16          # For simplicity transpose this back to the original position
++  vmov VX(0,0++)+r0, HX(0++,32)+r0 REP 16    # For simplicity transpose this back to the original position
+ 
+   bl col_trans_16
+-  vadd HY(0++,0)+r0,HY(0++,0)+r0,r4 REP 16   # Now add on rounding, shift down by 7, and saturate
+-  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16 # 9+7=16 so this ends up with the output saturated and in the top half of the word.
+-  vasl HY(0++,0)+r0,HY(0++,0)+r0,9 REP 16    # This should be saturating, but the instruction above does not assemble?
++  vadd HY(0++,0)+r0,HY(0++,0)+r0,r5 REP 16   # Now add on rounding, shift down by 7, and saturate
++  #vsasls HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16 # 4+12=16 so this ends up with the output saturated and in the top half of the word.
++  vasl HY(0++,0)+r0,HY(0++,0)+r0,4 REP 16    # This should be saturating, but the instruction above does not assemble?  (Probably because it ends with ls which is interpreted as a condition flag)
+ 
+   # Save results - note there has been a transposition during the processing so we save columns
+   vsth VX(0,32++)+r0, (r1 += r3) REP 16
+@@ -132,16 +125,136 @@ block_loop:
+ 
+ # r1,r2,r3 r7,r8 should be preserved
+ # HX(0++,0)+r0 is the block to be transformed
+-# HX(32++,0) is the 16x16 matrix of transform coefficients
++# HX(32++,0)+r6 is the 16x16 matrix of transform coefficients
+ # Use HY(48,0) for intermediate results
+ # r0 can be used, but should be returned to its original value at the end
+ col_trans_16:
+-  add r4,r0,16 # Final value for this loop
++  add r6,r0,16 # Final value for this loop
+ col_trans_16_loop:
+   # First compute partial products for a single column
+-  vmul32s VY(48,0++), VX(0,0)+r0, VX(32,0++) REP 16
++  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,0++) REP 16
+   # Then sum up the results and place back
+   vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
+-  addcmpblt r0,1,r4,col_trans_16_loop
++  addcmpblt r0,1,r6,col_trans_16_loop
+   sub r0,16  # but r0 back to its original value
+   b lr
++
++col_trans_odd_16:
++  add r6,r0,16 # Final value for this loop
++col_trans_odd_16_loop:
++  # First compute partial products for a single column
++  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,0++) REP 16
++  # Then sum up the results and place back
++  vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
++  addcmpblt r0,1,r6,col_trans_odd_16_loop
++  sub r0,16  # but r0 back to its original value
++  b lr
++
++
++test_add:
++  vldh HX(0,0),(r0)
++  vadd HX(0,0),HX(0,0),10
++  vsth HX(0,0),(r0)
++  mov r0,7 # return value
++  b lr
++
++# hevc_trans_32x32(short *transMatrix2, short *coeffs, int num)
++# transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory) Even followed by odd
++# coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
++# num: number of 16x16 transforms to be done
++#
++hevc_trans_32x32:
++  push r6-r15, lr # TODO cut down number of used registers
++
++  # Fetch transform matrices
++  mov r3, 16*2 # Stride of transMatrix2 in bytes (and of coefficients)
++  vldh HX(32++,0),(r0 += r3) REP 16 # This is the even 16x16 matrix
++  add r0, 16*16*2
++  vldh HX(32++,32),(r0 += r3) REP 16 # This is the odd 16x16 matrix
++
++  mov r3, 32*2*2 # Stride used to fetch alternate rows of our input coefficient buffer
++  mov r7, 16*16*2 # Total block size
++  mov r4, 64 # Constant used for rounding first pass
++  mov r5, 1<<11 # Constant used for rounding second pass
++  sub sp,sp,32*32*2+32 # Allocate some space on the stack for us to store 32*32 shorts as temporary results (needs to be aligned)
++  # set r8 to 32byte aligned stack pointer
++  add r8,sp,31
++  lsr r8,5
++  lsl r8,5
++  mov r9,r8  # Backup of the temporary storage
++  mov r10,r1 # Backup of the coefficient buffer
++block_loop32:
++
++  # COLUMN TRANSFORM
++  # Transform the first 16 columns
++  mov r1,r10  # Input Coefficient buffer
++  mov r8,r9   # Output temporary storage
++  bl trans32
++  # Transform the second 16 columns
++  add r8,32
++  add r1,32
++  bl trans32
++
++  # ROW TRANSFORM
++  mov r1,r9  # Input temporary storage
++  mov r8,r10   # Output Coefficient buffer
++  bl trans32
++  # Transform the second 16 columns
++  add r8,32
++  add r1,32
++  bl trans32
++
++  add r10, 32*32*2 # move onto next block of coefficients
++  addcmpbgt r2,-1,0,block_loop32
++
++  add sp,sp,32*32*2+32 # Restore stack
++
++  pop r6-r15, pc
++
++trans32:
++  # We can no longer afford the VRF space to do prefetching when doing 32x32
++  # Fetch the even rows
++  vldh HX(0++,0)+r0,(r1 += r3) REP 16
++  # Fetch the odd rows
++  vldh HX(16++,0)+r0,64(r1 += r3) REP 16 # First odd row is 32 shorts ahead of r1
++
++  # Transform the even rows using even matrix
++  mov r0, 0 # Even rows
++  bl col_trans_16
++
++  # Now transform the odd rows using odd matrix
++  mov r0, 64*16 # Odd rows
++  bl col_trans_odd_16
++
++  # Now apply butterfly to compute the first 16 results
++  vadd HY(48++,0),HY(0++,0),HY(16++,0) REP 16
++  vadd HY(48++,0),HY(48++,0),r4 REP 32   # add on rounding,
++  vasl HY(48++,0),HY(48++,0),9 REP 32    # shift down by 7, and saturate
++  # 16bit results now in HX(48,32)
++  mov r0,r8
++  mov r6,32*2
++  vsth VX(48,32++),(r0+=r6) REP 16
++  vmov VX(0,0++)+r0, HX(0++,32)+r0 REP 16    # Store transposed
++
++  # Now apply butterfly to compute the second 16 results (in reverse order)
++  vsub HY(63,0),HY(0,0),HY(16,0)
++  vsub HY(62,0),HY(0,0),HY(17,0)
++  vsub HY(61,0),HY(0,0),HY(18,0)
++  vsub HY(60,0),HY(0,0),HY(19,0)
++  vsub HY(59,0),HY(0,0),HY(20,0)
++  vsub HY(58,0),HY(0,0),HY(21,0)
++  vsub HY(57,0),HY(0,0),HY(22,0)
++  vsub HY(56,0),HY(0,0),HY(23,0)
++  vsub HY(55,0),HY(0,0),HY(24,0)
++  vsub HY(54,0),HY(0,0),HY(25,0)
++  vsub HY(53,0),HY(0,0),HY(26,0)
++  vsub HY(52,0),HY(0,0),HY(27,0)
++  vsub HY(51,0),HY(0,0),HY(28,0)
++  vsub HY(50,0),HY(0,0),HY(29,0)
++  vsub HY(49,0),HY(0,0),HY(30,0)
++  vsub HY(48,0),HY(0,0),HY(31,0)
++  vadd HY(48++,0),HY(48++,0),r4 REP 32   # add on rounding,
++  vasl HY(48++,0),HY(48++,0),9 REP 32    # shift down by 7, and saturate
++  add r0,r8,16*32*2 # Move to 16th row
++  vsth VX(48,32++),(r0+=r6) REP 16
++  b lr
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index b1f50ee..d720546 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -3,6 +3,7 @@
+ // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
+ #define RPI_USE_VCSM
+ #define RPI_TIME_TOTAL_QPU
++#define RPI_TIME_TOTAL_VPU
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+@@ -48,10 +49,47 @@ typedef int int32_t;
+ #define QPU_CODE_SIZE 2048
+ #define VPU_CODE_SIZE 2048
+ 
++const short rpi_transMatrix2even[32][16] = { // Even rows first
++{64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64},
++{90,  87,  80,  70,  57,  43,  25,   9,  -9, -25, -43, -57, -70, -80, -87, -90},
++{89,  75,  50,  18, -18, -50, -75, -89, -89, -75, -50, -18,  18,  50,  75,  89},
++{87,  57,   9, -43, -80, -90, -70, -25,  25,  70,  90,  80,  43,  -9, -57, -87},
++{83,  36, -36, -83, -83, -36,  36,  83,  83,  36, -36, -83, -83, -36,  36,  83},
++{80,   9, -70, -87, -25,  57,  90,  43, -43, -90, -57,  25,  87,  70,  -9, -80},
++{75, -18, -89, -50,  50,  89,  18, -75, -75,  18,  89,  50, -50, -89, -18,  75},
++{70, -43, -87,   9,  90,  25, -80, -57,  57,  80, -25, -90,  -9,  87,  43, -70},
++{64, -64, -64,  64,  64, -64, -64,  64,  64, -64, -64,  64,  64, -64, -64,  64},
++{57, -80, -25,  90,  -9, -87,  43,  70, -70, -43,  87,   9, -90,  25,  80, -57},
++{50, -89,  18,  75, -75, -18,  89, -50, -50,  89, -18, -75,  75,  18, -89,  50},
++{43, -90,  57,  25, -87,  70,   9, -80,  80,  -9, -70,  87, -25, -57,  90, -43},
++{36, -83,  83, -36, -36,  83, -83,  36,  36, -83,  83, -36, -36,  83, -83,  36},
++{25, -70,  90, -80,  43,   9, -57,  87, -87,  57,  -9, -43,  80, -90,  70, -25},
++{18, -50,  75, -89,  89, -75,  50, -18, -18,  50, -75,  89, -89,  75, -50,  18},
++{ 9, -25,  43, -57,  70, -80,  87, -90,  90, -87,  80, -70,  57, -43,  25,  -9},
++// Odd rows
++{90,  90,  88,  85,  82,  78,  73,  67,  61,  54,  46,  38,  31,  22,  13,   4},
++{90,  82,  67,  46,  22,  -4, -31, -54, -73, -85, -90, -88, -78, -61, -38, -13},
++{88,  67,  31, -13, -54, -82, -90, -78, -46,  -4,  38,  73,  90,  85,  61,  22},
++{85,  46, -13, -67, -90, -73, -22,  38,  82,  88,  54,  -4, -61, -90, -78, -31},
++{82,  22, -54, -90, -61,  13,  78,  85,  31, -46, -90, -67,   4,  73,  88,  38},
++{78,  -4, -82, -73,  13,  85,  67, -22, -88, -61,  31,  90,  54, -38, -90, -46},
++{73, -31, -90, -22,  78,  67, -38, -90, -13,  82,  61, -46, -88,  -4,  85,  54},
++{67, -54, -78,  38,  85, -22, -90,   4,  90,  13, -88, -31,  82,  46, -73, -61},
++{61, -73, -46,  82,  31, -88, -13,  90,  -4, -90,  22,  85, -38, -78,  54,  67},
++{54, -85,  -4,  88, -46, -61,  82,  13, -90,  38,  67, -78, -22,  90, -31, -73},
++{46, -90,  38,  54, -90,  31,  61, -88,  22,  67, -85,  13,  73, -82,   4,  78},
++{38, -88,  73,  -4, -67,  90, -46, -31,  85, -78,  13,  61, -90,  54,  22, -82},
++{31, -78,  90, -61,   4,  54, -88,  82, -38, -22,  73, -90,  67, -13, -46,  85},
++{22, -61,  85, -90,  73, -38,  -4,  46, -78,  90, -82,  54, -13, -31,  67, -88},
++{13, -38,  61, -78,  88, -90,  85, -73,  54, -31,   4,  22, -46,  67, -82,  90},
++{ 4, -13,  22, -31,  38, -46,  54, -61,  67, -73,  78, -82,  85, -88,  90, -90}
++};
++
+ struct GPU
+ {
+   unsigned int qpu_code[QPU_CODE_SIZE];
+   unsigned int vpu_code[VPU_CODE_SIZE];
++  short transMatrix2even[16*16];
+   int open_count; // Number of allocated video buffers
+   unsigned int vc_handle; // Handle of this memory
+   int      mb; // Mailbox handle
+@@ -123,6 +161,8 @@ static int gpu_init(volatile struct GPU **gpu) {
+     assert(num_bytes<=VPU_CODE_SIZE*sizeof(unsigned int));
+     memcpy((void*)ptr->vpu_code, rpi_hevc_transform, num_bytes);
+   }
++  // And the transform coefficients
++  memcpy((void*)ptr->transMatrix2even, rpi_transMatrix2even, 16*16*sizeof(short));
+ 
+   return 0;
+ }
+@@ -274,11 +314,43 @@ unsigned int vpu_get_fn(void) {
+   return gpu->vc + offsetof(struct GPU,vpu_code);
+ }
+ 
++unsigned int vpu_get_constants(void) {
++  if (gpu==NULL) {
++    gpu_lock();
++    gpu_unlock();
++  }
++  return gpu->vc + offsetof(struct GPU,transMatrix2even);
++}
++
+ unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
+ {
+   unsigned r;
++#ifdef RPI_TIME_TOTAL_VPU
++  static int last_time=0;
++  static long long on_time=0;
++  static long long off_time=0;
++  int start_time;
++  int end_time;
++  static int count=0;
++  static long long countr2=0;
++#endif
+   gpu_lock();
++#ifdef RPI_TIME_TOTAL_VPU
++  start_time = Microseconds();
++  if (last_time==0)
++    last_time = start_time;
++  off_time += start_time-last_time;
++#endif
+   r = execute_code(gpu->mb, code, r0, r1, r2, r3, r4, r5);
++#ifdef RPI_TIME_TOTAL_VPU
++  end_time = Microseconds();
++  last_time = end_time;
++  on_time += end_time - start_time;
++  count++;
++  countr2 += r2;
++  if ((count&0x7f)==0)
++    printf("VPU %d %lld On=%dms, Off=%dms\n",count,countr2,(int)(on_time/1000),(int)(off_time/1000));
++#endif
+   gpu_unlock();
+   return r;
+ }
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index 4e3c35c..814fc3c 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -34,6 +34,7 @@ extern unsigned int qpu_get_fn(int num);
+ 
+ // VPU specific functions
+ extern unsigned int vpu_get_fn(void);
++extern unsigned int vpu_get_constants(void);
+ extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+ 
+ // Simple test of shader code
+-- 
+2.7.4
+
+
+From 4bb0a7ba6723650e74d63cec2123f76da4c3eb0e Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Tue, 5 May 2015 09:41:23 +0100
+Subject: [PATCH 05/68] Fixed deblocking
+
+---
+ libavcodec/hevc.c | 20 +++++++++++++++++---
+ 1 file changed, 17 insertions(+), 3 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 94ff709..391c57a 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2400,8 +2400,9 @@ static void rpi_execute_transform(HEVCContext *s)
+     //    s->hevcdsp.idct[4-2](coeffs, 16);
+     //}
+ 
+-    //gpu_cache_flush(&s->coeffs_buf[i]);
++    gpu_cache_flush(&s->coeffs_buf[i]);
+     vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[i].vc, s->num_coeffs[i] >> 8, 0, 0, 0);
++    gpu_cache_flush(&s->coeffs_buf[i]);
+ 
+     for(i=0;i<4;i++)
+         s->num_coeffs[i] = 0;
+@@ -2440,6 +2441,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     int ctb_addr_ts = s->ps.pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
+ 
+ #ifdef RPI
++    int start_ctb_x = (s->sh.slice_ctb_addr_rs % ((s->ps.sps->width + ctb_size - 1) >> s->ps.sps->log2_ctb_size)) << s->ps.sps->log2_ctb_size;
+     s->enable_rpi = 1; // TODO this should depend on cross component and frame width etc.
+ #endif
+ 
+@@ -2473,9 +2475,17 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ 
+         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
+ #ifdef RPI
+-        if (1 || x_ctb + ctb_size >= s->ps.sps->width) { // TODO watch out for deblocking!
++        if (s->enable_rpi && x_ctb + ctb_size >= s->ps.sps->width) {
++            int x;
++            // Transform all blocks
+             rpi_execute_transform(s);
++            // Perform intra prediction and residual reconstruction
+             rpi_execute_pred_cmds(s);
++            // Perform deblocking for CTBs in this row
++            for(x = start_ctb_x; x <= x_ctb; x += ctb_size) {  // TODO this will fail for tiles
++                ff_hevc_hls_filters(s, x, y_ctb, ctb_size);
++            }
++            start_ctb_x = 0;
+         }
+ #endif
+         if (more_data < 0) {
+@@ -2486,6 +2496,10 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ 
+         ctb_addr_ts++;
+         ff_hevc_save_states(s, ctb_addr_ts);
++#ifdef RPI
++        if (s->enable_rpi)
++            continue;
++#endif
+         ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);
+     }
+ 
+@@ -3289,7 +3303,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     if (!s->univ_pred_cmds)
+         goto fail;
+     for(i = 0; i < 4; i++) {
+-        gpu_malloc_uncached(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16, &s->coeffs_buf[i]); // TODO slim this down and share across sizes
++        gpu_malloc_cached(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16, &s->coeffs_buf[i]); // TODO slim this down and share across sizes
+         s->coeffs_buf_arm[i] = (int16_t*) s->coeffs_buf[i].arm;
+         if (!s->coeffs_buf_arm[i])
+             goto fail;
+-- 
+2.7.4
+
+
+From 9079ef888e3d81a69f3c802ddc3c5134679e74a6 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Tue, 5 May 2015 11:32:30 +0100
+Subject: [PATCH 06/68] Added 32x32 transform
+
+---
+ libavcodec/hevc.c               |   8 +-
+ libavcodec/hevc_cabac.c         |   4 +-
+ libavcodec/rpi_hevc_transform.h | 200 +++++++++++++++++-----------------------
+ libavcodec/rpi_hevc_transform.s | 102 ++++++++++----------
+ libavcodec/rpi_qpu.c            |   4 +-
+ 5 files changed, 148 insertions(+), 170 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 391c57a..0dde6f2 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2400,9 +2400,11 @@ static void rpi_execute_transform(HEVCContext *s)
+     //    s->hevcdsp.idct[4-2](coeffs, 16);
+     //}
+ 
+-    gpu_cache_flush(&s->coeffs_buf[i]);
+-    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[i].vc, s->num_coeffs[i] >> 8, 0, 0, 0);
+-    gpu_cache_flush(&s->coeffs_buf[i]);
++    gpu_cache_flush(&s->coeffs_buf[2]);
++    gpu_cache_flush(&s->coeffs_buf[3]);
++    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[2].vc, s->num_coeffs[2] >> 8, s->coeffs_buf[3].vc, s->num_coeffs[3] >> 10, 0);
++    gpu_cache_flush(&s->coeffs_buf[2]);
++    gpu_cache_flush(&s->coeffs_buf[3]);
+ 
+     for(i=0;i<4;i++)
+         s->num_coeffs[i] = 0;
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index d1cba86..88aa959 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -1031,7 +1031,9 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+     int vshift = s->ps.sps->vshift[c_idx];
+     uint8_t *dst = &s->frame->data[c_idx][(y0 >> vshift) * stride +
+                                           ((x0 >> hshift) << s->ps.sps->pixel_shift)];
+-    int use_vpu = s->enable_rpi && !lc->cu.cu_transquant_bypass_flag && !transform_skip_flag && !lc->tu.cross_pf && log2_trafo_size==4;
++#ifdef RPI
++    int use_vpu = s->enable_rpi && !lc->cu.cu_transquant_bypass_flag && !transform_skip_flag && !lc->tu.cross_pf && log2_trafo_size>=4;
++#endif
+     int16_t *coeffs = (int16_t*)(c_idx ? lc->edge_emu_buffer2 : lc->edge_emu_buffer);
+     uint8_t significant_coeff_group_flag[8][8] = {{0}};
+     int explicit_rdpcm_flag = 0;
+diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
+index c0c279f..6d772d7 100644
+--- a/libavcodec/rpi_hevc_transform.h
++++ b/libavcodec/rpi_hevc_transform.h
+@@ -1,6 +1,10 @@
+ unsigned char rpi_hevc_transform [] = {
+ 169,
+ 3,
++62,
++64,
++79,
++64,
+ 3,
+ 232,
+ 32,
+@@ -17,6 +21,22 @@ unsigned char rpi_hevc_transform [] = {
+ 248,
+ 0,
+ 0,
++64,
++232,
++0,
++2,
++0,
++0,
++12,
++248,
++0,
++168,
++0,
++0,
++192,
++248,
++0,
++0,
+ 0,
+ 96,
+ 3,
+@@ -79,7 +99,7 @@ unsigned char rpi_hevc_transform [] = {
+ 70,
+ 128,
+ 144,
+-39,
++40,
+ 0,
+ 4,
+ 255,
+@@ -113,7 +133,7 @@ unsigned char rpi_hevc_transform [] = {
+ 0,
+ 128,
+ 144,
+-22,
++23,
+ 0,
+ 4,
+ 255,
+@@ -153,6 +173,8 @@ unsigned char rpi_hevc_transform [] = {
+ 140,
+ 211,
+ 192,
++34,
++31,
+ 41,
+ 3,
+ 70,
+@@ -195,7 +217,7 @@ unsigned char rpi_hevc_transform [] = {
+ 255,
+ 36,
+ 204,
+-96,
++224,
+ 2,
+ 0,
+ 248,
+@@ -219,62 +241,10 @@ unsigned char rpi_hevc_transform [] = {
+ 103,
+ 90,
+ 0,
+-8,
+-240,
+-0,
+-128,
+-128,
+-3,
+-0,
+-247,
+-32,
+-128,
+-10,
+-4,
+-136,
+-240,
+-32,
+-0,
+-128,
+-3,
+-112,
+-96,
+-90,
+-0,
+-169,
+-3,
+-3,
+-232,
+-32,
+-0,
+-0,
+-0,
+-12,
+-248,
+-0,
+-136,
+-0,
+-0,
+-192,
+-248,
+-0,
+-0,
++225,
++64,
++242,
+ 64,
+-232,
+-0,
+-2,
+-0,
+-0,
+-12,
+-248,
+-0,
+-168,
+-0,
+-0,
+-192,
+-248,
+-0,
+-0,
+ 3,
+ 232,
+ 128,
+@@ -287,18 +257,6 @@ unsigned char rpi_hevc_transform [] = {
+ 2,
+ 0,
+ 0,
+-4,
+-232,
+-64,
+-0,
+-0,
+-0,
+-5,
+-232,
+-0,
+-8,
+-0,
+-0,
+ 57,
+ 239,
+ 224,
+@@ -317,18 +275,26 @@ unsigned char rpi_hevc_transform [] = {
+ 64,
+ 26,
+ 64,
++4,
++232,
++64,
++0,
++0,
++0,
++149,
++96,
+ 161,
+ 64,
+ 152,
+ 64,
+ 128,
+ 144,
+-31,
++35,
+ 0,
+ 72,
+ 232,
+-32,
+ 0,
++4,
+ 0,
+ 0,
+ 65,
+@@ -339,8 +305,16 @@ unsigned char rpi_hevc_transform [] = {
+ 0,
+ 128,
+ 144,
+-23,
++27,
++0,
++4,
++232,
++0,
++8,
+ 0,
++0,
++69,
++96,
+ 145,
+ 64,
+ 168,
+@@ -351,8 +325,8 @@ unsigned char rpi_hevc_transform [] = {
+ 0,
+ 72,
+ 232,
+-32,
+ 0,
++4,
+ 0,
+ 0,
+ 65,
+@@ -373,7 +347,7 @@ unsigned char rpi_hevc_transform [] = {
+ 0,
+ 242,
+ 140,
+-229,
++221,
+ 192,
+ 57,
+ 239,
+@@ -383,6 +357,8 @@ unsigned char rpi_hevc_transform [] = {
+ 0,
+ 41,
+ 3,
++239,
++3,
+ 12,
+ 248,
+ 0,
+@@ -390,7 +366,7 @@ unsigned char rpi_hevc_transform [] = {
+ 0,
+ 0,
+ 192,
+-8,
++248,
+ 4,
+ 0,
+ 12,
+@@ -400,14 +376,14 @@ unsigned char rpi_hevc_transform [] = {
+ 64,
+ 0,
+ 192,
+-8,
++248,
+ 4,
+ 0,
+ 0,
+ 96,
+ 255,
+ 159,
+-131,
++154,
+ 255,
+ 0,
+ 232,
+@@ -417,7 +393,7 @@ unsigned char rpi_hevc_transform [] = {
+ 0,
+ 255,
+ 159,
+-142,
++165,
+ 255,
+ 4,
+ 255,
+@@ -429,7 +405,7 @@ unsigned char rpi_hevc_transform [] = {
+ 251,
+ 62,
+ 0,
+-5,
++4,
+ 255,
+ 51,
+ 204,
+@@ -439,15 +415,15 @@ unsigned char rpi_hevc_transform [] = {
+ 251,
+ 16,
+ 0,
+-77,
++76,
+ 254,
+ 51,
+ 204,
+-9,
+-4,
++128,
++3,
+ 224,
+ 251,
+-0,
++20,
+ 0,
+ 128,
+ 64,
+@@ -467,16 +443,6 @@ unsigned char rpi_hevc_transform [] = {
+ 99,
+ 0,
+ 0,
+-4,
+-254,
+-0,
+-144,
+-128,
+-2,
+-0,
+-8,
+-2,
+-0,
+ 32,
+ 247,
+ 240,
+@@ -488,92 +454,92 @@ unsigned char rpi_hevc_transform [] = {
+ 176,
+ 207,
+ 17,
+-3,
++19,
+ 32,
+ 247,
+ 112,
+ 207,
+ 18,
+-3,
++35,
+ 32,
+ 247,
+ 48,
+ 207,
+ 19,
+-3,
++51,
+ 32,
+ 247,
+ 240,
+ 206,
+ 20,
+-3,
++67,
+ 32,
+ 247,
+ 176,
+ 206,
+ 21,
+-3,
++83,
+ 32,
+ 247,
+ 112,
+ 206,
+ 22,
+-3,
++99,
+ 32,
+ 247,
+ 48,
+ 206,
+ 23,
+-3,
++115,
+ 32,
+ 247,
+ 240,
+ 205,
+ 24,
+-3,
++131,
+ 32,
+ 247,
+ 176,
+ 205,
+ 25,
+-3,
++147,
+ 32,
+ 247,
+ 112,
+ 205,
+ 26,
+-3,
++163,
+ 32,
+ 247,
+ 48,
+ 205,
+ 27,
+-3,
++179,
+ 32,
+ 247,
+ 240,
+ 204,
+ 28,
+-3,
++195,
+ 32,
+ 247,
+ 176,
+ 204,
+ 29,
+-3,
++211,
+ 32,
+ 247,
+ 112,
+ 204,
+ 30,
+-3,
++227,
+ 32,
+ 247,
+ 48,
+ 204,
+ 31,
+-3,
+-5,
++243,
++4,
+ 255,
+ 51,
+ 204,
+@@ -583,20 +549,20 @@ unsigned char rpi_hevc_transform [] = {
+ 251,
+ 16,
+ 0,
+-77,
++76,
+ 254,
+ 51,
+ 204,
+-9,
+-4,
++128,
++3,
+ 224,
+ 251,
+-0,
++20,
+ 0,
+ 0,
+ 237,
++32,
+ 0,
+-4,
+ 0,
+ 0,
+ 140,
+@@ -609,6 +575,6 @@ unsigned char rpi_hevc_transform [] = {
+ 99,
+ 0,
+ 0,
+-90,
+-0,
++111,
++3,
+ };
+diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
+index 1e389c7..afdb32a 100644
+--- a/libavcodec/rpi_hevc_transform.s
++++ b/libavcodec/rpi_hevc_transform.s
+@@ -76,12 +76,19 @@
+ # transMatrix2: address of the constant matrix (must be at 32 byte aligned address in Videocore memory)
+ # coeffs: address of the transform coefficients (must be at 32 byte aligned address in Videocore memory)
+ # num: number of 16x16 transforms to be done
++# coeffs32
++# num32: number of 32x32 transforms
+ #
+ hevc_trans_16x16:
+   push r6-r15, lr # TODO cut down number of used registers
+-
++  mov r14,r3 # coeffs32
++  mov r15,r4 # num32
+   mov r3, 16*2 # Stride of transMatrix2 in bytes
+   vldh HX(32++,0),(r0 += r3) REP 16 # This is the 16x16 matrix, a transform is equivalent to multiplying input row vector * matrix
++
++  add r0, 16*16*2 # For 32x32 transforms we also need this matrix
++  vldh HX(32++,32),(r0 += r3) REP 16 # This is the odd 16x16 matrix
++
+   # Now use r0 to describe which matrix we are working on.
+   # Allows us to prefetch the next block of coefficients for efficiency.
+   mov r0,0 # This describes the location where we read our coefficients from
+@@ -121,6 +128,10 @@ block_loop:
+   add r1,r7
+ 
+   addcmpbgt r2,-1,0,block_loop
++
++  # Now go and do any 32x32 transforms
++  b hevc_trans_32x32
++
+   pop r6-r15, pc
+ 
+ # r1,r2,r3 r7,r8 should be preserved
+@@ -136,26 +147,18 @@ col_trans_16_loop:
+   # Then sum up the results and place back
+   vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
+   addcmpblt r0,1,r6,col_trans_16_loop
+-  sub r0,16  # but r0 back to its original value
++  sub r0,16  # put r0 back to its original value
+   b lr
+ 
+ col_trans_odd_16:
+   add r6,r0,16 # Final value for this loop
+ col_trans_odd_16_loop:
+   # First compute partial products for a single column
+-  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,0++) REP 16
++  vmul32s HY(48++,0), VX(0,0)+r0, VX(32,32++) REP 16
+   # Then sum up the results and place back
+   vadd VY(0,0)+r0, VY(48,0++), VY(48,8++) REP 8 CLRA SACC
+   addcmpblt r0,1,r6,col_trans_odd_16_loop
+-  sub r0,16  # but r0 back to its original value
+-  b lr
+-
+-
+-test_add:
+-  vldh HX(0,0),(r0)
+-  vadd HX(0,0),HX(0,0),10
+-  vsth HX(0,0),(r0)
+-  mov r0,7 # return value
++  sub r0,16  # put r0 back to its original value
+   b lr
+ 
+ # hevc_trans_32x32(short *transMatrix2, short *coeffs, int num)
+@@ -164,18 +167,17 @@ test_add:
+ # num: number of 16x16 transforms to be done
+ #
+ hevc_trans_32x32:
+-  push r6-r15, lr # TODO cut down number of used registers
++  mov r1,r14 # coeffs
++  mov r2,r15 # num
+ 
+-  # Fetch transform matrices
+-  mov r3, 16*2 # Stride of transMatrix2 in bytes (and of coefficients)
+-  vldh HX(32++,0),(r0 += r3) REP 16 # This is the even 16x16 matrix
+-  add r0, 16*16*2
+-  vldh HX(32++,32),(r0 += r3) REP 16 # This is the odd 16x16 matrix
++  # Fetch odd transform matrix
++  #mov r3, 16*2 # Stride of transMatrix2 in bytes (and of coefficients)
++  #vldh HX(32++,0),(r0 += r3) REP 16 # This is the even 16x16 matrix
++  #add r0, 16*16*2
++  #vldh HX(32++,32),(r0 += r3) REP 16 # This is the odd 16x16 matrix
+ 
+   mov r3, 32*2*2 # Stride used to fetch alternate rows of our input coefficient buffer
+   mov r7, 16*16*2 # Total block size
+-  mov r4, 64 # Constant used for rounding first pass
+-  mov r5, 1<<11 # Constant used for rounding second pass
+   sub sp,sp,32*32*2+32 # Allocate some space on the stack for us to store 32*32 shorts as temporary results (needs to be aligned)
+   # set r8 to 32byte aligned stack pointer
+   add r8,sp,31
+@@ -186,21 +188,27 @@ hevc_trans_32x32:
+ block_loop32:
+ 
+   # COLUMN TRANSFORM
++  mov r4, 64 # Constant used for rounding first pass
++  mov r5, 9 # left shift used for rounding first pass
++
+   # Transform the first 16 columns
+   mov r1,r10  # Input Coefficient buffer
+   mov r8,r9   # Output temporary storage
+   bl trans32
+   # Transform the second 16 columns
+-  add r8,32
++  add r8,32*16*2
+   add r1,32
+   bl trans32
+ 
+   # ROW TRANSFORM
++  mov r4, 1<<11 # Constant used for rounding second pass
++  mov r5, 4 # left shift used for rounding second pass
++
+   mov r1,r9  # Input temporary storage
+   mov r8,r10   # Output Coefficient buffer
+   bl trans32
+   # Transform the second 16 columns
+-  add r8,32
++  add r8,32*16*2
+   add r1,32
+   bl trans32
+ 
+@@ -212,11 +220,12 @@ block_loop32:
+   pop r6-r15, pc
+ 
+ trans32:
++  push lr
+   # We can no longer afford the VRF space to do prefetching when doing 32x32
+   # Fetch the even rows
+-  vldh HX(0++,0)+r0,(r1 += r3) REP 16
++  vldh HX(0++,0),(r1 += r3) REP 16
+   # Fetch the odd rows
+-  vldh HX(16++,0)+r0,64(r1 += r3) REP 16 # First odd row is 32 shorts ahead of r1
++  vldh HX(16++,0),64(r1 += r3) REP 16 # First odd row is 32 shorts ahead of r1
+ 
+   # Transform the even rows using even matrix
+   mov r0, 0 # Even rows
+@@ -228,33 +237,32 @@ trans32:
+ 
+   # Now apply butterfly to compute the first 16 results
+   vadd HY(48++,0),HY(0++,0),HY(16++,0) REP 16
+-  vadd HY(48++,0),HY(48++,0),r4 REP 32   # add on rounding,
+-  vasl HY(48++,0),HY(48++,0),9 REP 32    # shift down by 7, and saturate
++  vadd HY(48++,0),HY(48++,0),r4 REP 16   # add on rounding,
++  vasl HY(48++,0),HY(48++,0),r5 REP 16    # shift down by 7, and saturate
+   # 16bit results now in HX(48,32)
+   mov r0,r8
+   mov r6,32*2
+   vsth VX(48,32++),(r0+=r6) REP 16
+-  vmov VX(0,0++)+r0, HX(0++,32)+r0 REP 16    # Store transposed
+ 
+   # Now apply butterfly to compute the second 16 results (in reverse order)
+-  vsub HY(63,0),HY(0,0),HY(16,0)
+-  vsub HY(62,0),HY(0,0),HY(17,0)
+-  vsub HY(61,0),HY(0,0),HY(18,0)
+-  vsub HY(60,0),HY(0,0),HY(19,0)
+-  vsub HY(59,0),HY(0,0),HY(20,0)
+-  vsub HY(58,0),HY(0,0),HY(21,0)
+-  vsub HY(57,0),HY(0,0),HY(22,0)
+-  vsub HY(56,0),HY(0,0),HY(23,0)
+-  vsub HY(55,0),HY(0,0),HY(24,0)
+-  vsub HY(54,0),HY(0,0),HY(25,0)
+-  vsub HY(53,0),HY(0,0),HY(26,0)
+-  vsub HY(52,0),HY(0,0),HY(27,0)
+-  vsub HY(51,0),HY(0,0),HY(28,0)
+-  vsub HY(50,0),HY(0,0),HY(29,0)
+-  vsub HY(49,0),HY(0,0),HY(30,0)
+-  vsub HY(48,0),HY(0,0),HY(31,0)
+-  vadd HY(48++,0),HY(48++,0),r4 REP 32   # add on rounding,
+-  vasl HY(48++,0),HY(48++,0),9 REP 32    # shift down by 7, and saturate
+-  add r0,r8,16*32*2 # Move to 16th row
++  vsub HY(63,0),HY(0 ,0),HY(16,0)
++  vsub HY(62,0),HY(1 ,0),HY(17,0)
++  vsub HY(61,0),HY(2 ,0),HY(18,0)
++  vsub HY(60,0),HY(3 ,0),HY(19,0)
++  vsub HY(59,0),HY(4 ,0),HY(20,0)
++  vsub HY(58,0),HY(5 ,0),HY(21,0)
++  vsub HY(57,0),HY(6 ,0),HY(22,0)
++  vsub HY(56,0),HY(7 ,0),HY(23,0)
++  vsub HY(55,0),HY(8 ,0),HY(24,0)
++  vsub HY(54,0),HY(9 ,0),HY(25,0)
++  vsub HY(53,0),HY(10,0),HY(26,0)
++  vsub HY(52,0),HY(11,0),HY(27,0)
++  vsub HY(51,0),HY(12,0),HY(28,0)
++  vsub HY(50,0),HY(13,0),HY(29,0)
++  vsub HY(49,0),HY(14,0),HY(30,0)
++  vsub HY(48,0),HY(15,0),HY(31,0)
++  vadd HY(48++,0),HY(48++,0),r4 REP 16   # add on rounding,
++  vasl HY(48++,0),HY(48++,0),r5 REP 16    # shift down by 7, and saturate
++  add r0,r8,32
+   vsth VX(48,32++),(r0+=r6) REP 16
+-  b lr
++  pop pc
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index d720546..12ad5fb 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -89,7 +89,7 @@ struct GPU
+ {
+   unsigned int qpu_code[QPU_CODE_SIZE];
+   unsigned int vpu_code[VPU_CODE_SIZE];
+-  short transMatrix2even[16*16];
++  short transMatrix2even[16*16*2];
+   int open_count; // Number of allocated video buffers
+   unsigned int vc_handle; // Handle of this memory
+   int      mb; // Mailbox handle
+@@ -162,7 +162,7 @@ static int gpu_init(volatile struct GPU **gpu) {
+     memcpy((void*)ptr->vpu_code, rpi_hevc_transform, num_bytes);
+   }
+   // And the transform coefficients
+-  memcpy((void*)ptr->transMatrix2even, rpi_transMatrix2even, 16*16*sizeof(short));
++  memcpy((void*)ptr->transMatrix2even, rpi_transMatrix2even, sizeof(rpi_transMatrix2even));
+ 
+   return 0;
+ }
+-- 
+2.7.4
+
+
+From 6c2ed6109c4dd5c8ab16bf16e0ae3be6ae166e50 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Tue, 5 May 2015 16:57:03 +0100
+Subject: [PATCH 07/68] Clear coefficients in advance
+
+---
+ libavcodec/hevc.c               | 129 ++++++++++++++++++++++++++++------------
+ libavcodec/hevc.h               |   6 +-
+ libavcodec/hevc_cabac.c         |   7 ++-
+ libavcodec/rpi_hevc_transform.h |  50 ++++++++++++++++
+ libavcodec/rpi_hevc_transform.s |  16 +++++
+ 5 files changed, 168 insertions(+), 40 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 0dde6f2..1424007 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -43,6 +43,8 @@
+ 
+ #ifdef RPI
+ #include "rpi_qpu.h"
++// For some unknown reason, the code seems to crash if I do a late malloc
++#define EARLY_MALLOC
+ #endif
+ 
+ // #define DISABLE_MC
+@@ -61,6 +63,20 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ /* free everything allocated  by pic_arrays_init() */
+ static void pic_arrays_free(HEVCContext *s)
+ {
++#ifdef RPI
++#ifdef EARLY_MALLOC
++#else
++    printf("pic_arrays_free\n");
++    if (s->coeffs_buf_arm[0]) {
++      gpu_free(&s->coeffs_buf_default);
++      s->coeffs_buf_arm[0] = 0;
++    }
++    if (s->coeffs_buf_arm[2]) {
++      gpu_free(&s->coeffs_buf_accelerated);
++      s->coeffs_buf_arm[2] = 0;
++    }
++#endif
++#endif
+     av_freep(&s->sao);
+     av_freep(&s->deblock);
+ 
+@@ -97,6 +113,28 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
+     int ctb_count        = sps->ctb_width * sps->ctb_height;
+     int min_pu_size      = sps->min_pu_width * sps->min_pu_height;
+ 
++#ifdef RPI
++#ifdef EARLY_MALLOC
++#else
++    int coeffs_in_ctb = (1 << s->ps.sps->log2_ctb_size) * (1 << s->ps.sps->log2_ctb_size);
++    int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
++    printf("pic_arrays_init\n");
++    printf("Allocated %d\n",coefs_per_row);
++    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
++    s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
++    if (!s->coeffs_buf_arm[0])
++        goto fail;
++    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
++    s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
++    s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
++    if (!s->coeffs_buf_arm[2])
++        goto fail;
++    s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
++    s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
++    printf("Done\n");
++#endif
++#endif
++
+     s->bs_width  = (width  >> 2) + 1;
+     s->bs_height = (height >> 2) + 1;
+ 
+@@ -2400,11 +2438,10 @@ static void rpi_execute_transform(HEVCContext *s)
+     //    s->hevcdsp.idct[4-2](coeffs, 16);
+     //}
+ 
+-    gpu_cache_flush(&s->coeffs_buf[2]);
+-    gpu_cache_flush(&s->coeffs_buf[3]);
+-    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf[2].vc, s->num_coeffs[2] >> 8, s->coeffs_buf[3].vc, s->num_coeffs[3] >> 10, 0);
+-    gpu_cache_flush(&s->coeffs_buf[2]);
+-    gpu_cache_flush(&s->coeffs_buf[3]);
++
++    gpu_cache_flush(&s->coeffs_buf_accelerated);
++    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
++    //gpu_cache_flush(&s->coeffs_buf_accelerated);
+ 
+     for(i=0;i<4;i++)
+         s->num_coeffs[i] = 0;
+@@ -2426,7 +2463,9 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
+           lc->na.cand_up_right     = (cmd->na >> 0) & 1;
+           s->hpc.intra_pred[cmd->size - 2](s, cmd->x, cmd->y, cmd->c_idx);
+       } else {
++          int trafo_size = 1 << cmd->size;
+           s->hevcdsp.transform_add[cmd->size-2](cmd->dst, cmd->buf, cmd->stride);
++          memset(cmd->buf, 0, trafo_size * trafo_size * sizeof(int16_t)); // Clear coefficients here while they are in the cache
+       }
+   }
+   s->num_pred_cmds = 0;
+@@ -3235,10 +3274,18 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+     av_freep(&s->unif_mv_cmds);
+     av_freep(&s->unif_xfm_cmds);
+     av_freep(&s->univ_pred_cmds);
+-    for(i = 0; i < 4; i++) {
+-        gpu_free(&s->coeffs_buf[i]);
++
++#ifdef EARLY_MALLOC
++    if (s->coeffs_buf_arm[0]) {
++      gpu_free(&s->coeffs_buf_default);
++      s->coeffs_buf_arm[0] = 0;
++    }
++    if (s->coeffs_buf_arm[2]) {
++      gpu_free(&s->coeffs_buf_accelerated);
++      s->coeffs_buf_arm[2] = 0;
+     }
+ #endif
++#endif
+ 
+     for (i = 0; i < 3; i++) {
+         av_freep(&s->sao_pixel_buffer_h[i]);
+@@ -3281,6 +3328,16 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+     return 0;
+ }
+ 
++#ifdef RPI
++static av_cold void memclear16(int16_t *p, int n)
++{
++  vpu_execute_code( vpu_get_fn(), p, n, 0, 0, 0, 1);
++  //int i;
++  //for(i=0;i<n;i++)
++  //  p[i] = 0;
++}
++#endif
++
+ static av_cold int hevc_init_context(AVCodecContext *avctx)
+ {
+     HEVCContext *s = avctx->priv_data;
+@@ -3304,37 +3361,35 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
+     if (!s->univ_pred_cmds)
+         goto fail;
+-    for(i = 0; i < 4; i++) {
+-        gpu_malloc_cached(sizeof(int16_t)*RPI_MAX_XFM_CMDS*16, &s->coeffs_buf[i]); // TODO slim this down and share across sizes
+-        s->coeffs_buf_arm[i] = (int16_t*) s->coeffs_buf[i].arm;
+-        if (!s->coeffs_buf_arm[i])
+-            goto fail;
+-    }
+-    s->enable_rpi = 0;
+ 
+-    // A little test program
+-    /*{
+-      GPU_MEM_PTR_T p;
+-      int err = gpu_malloc_cached(16, &p);
+-      short *q = (short *)p.arm;
+-      int i;
+-      int r;
+-      printf("Allocated memory %d ARM 0x%x, VC 0x%x, Code 0x%x\n",err,(int)p.arm,p.vc,(int)vpu_get_fn());
+-      printf("Allocated memory %d ARM 0x%x, VC 0x%x\n",err,(int)p.arm,p.vc);
+-      printf("Preparing data %p\n",q);
+-      for(i=0;i<16;i++)
+-        q[i] = i;
+-      printf("Flush cache\n");
+-      gpu_cache_flush(&p);
+-      printf("Executing code\n");
+-      r = vpu_execute_code( vpu_get_fn(), p.vc, 0, 0, 0, 0, 0);
+-      printf("Return value %d (",r);
+-      for(i=0;i<16;i++)
+-        printf("%d ",q[i]);
+-      printf(")\n");
+-      gpu_free(&p);
+-      goto fail; // Early out
+-    }*/
++    s->coeffs_buf_arm[0] = 0;
++    s->coeffs_buf_arm[2] = 0;
++
++#ifdef EARLY_MALLOC
++    int coeffs_in_ctb = 64*64;
++    int coefs_per_row = (2048/64) * coeffs_in_ctb * 3;  // Allow space for chroma
++    printf("Allocated %d\n",coefs_per_row);
++    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
++    s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
++    if (!s->coeffs_buf_arm[0])
++        goto fail;
++    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
++    s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
++    s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
++    if (!s->coeffs_buf_arm[2])
++        goto fail;
++    s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
++    s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
++    printf("Done\n");
++    //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
++    memclear16(s->coeffs_buf_arm[0], coefs_per_row);
++    //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
++    memclear16(s->coeffs_buf_arm[2], coefs_per_row);
++    //memset(s->coeffs_buf_arm[3],0, sizeof(int16_t) * coefs_per_row);
++    memclear16(s->coeffs_buf_arm[3], coefs_per_row);
++#endif
++
++    s->enable_rpi = 0;
+ 
+ #endif
+ 
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 4167985..9a228f6 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -861,8 +861,12 @@ typedef struct HEVCContext {
+     HEVCMvCmd *unif_mv_cmds;
+     HEVCXfmCmd *unif_xfm_cmds;
+     HEVCPredCmd *univ_pred_cmds;
+-    GPU_MEM_PTR_T coeffs_buf[4];
++    int buf_width;
++    GPU_MEM_PTR_T coeffs_buf_default;
++    GPU_MEM_PTR_T coeffs_buf_accelerated;
+     int16_t *coeffs_buf_arm[4];
++    unsigned int coeffs_buf_vc[4];
++
+     int num_coeffs[4];
+     int num_xfm_cmds;
+     int num_mv_cmds;
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index 88aa959..dbfee85 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -1058,9 +1058,13 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+             s->num_coeffs[0] += n;
+         }
+     }
++    // We now do the memset after transform_add while we know the data is cached.
++    //memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
++#else
++    memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
+ #endif
+ 
+-    memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
++
+ 
+     // Derive QP for dequant
+     if (!lc->cu.cu_transquant_bypass_flag) {
+@@ -1547,7 +1551,6 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+ #ifdef RPI
+     if (s->enable_rpi) {
+         HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
+-        //memcpy(coeffs2, coeffs, sizeof(int16_t) * trafo_size * trafo_size); // TODO
+         cmd->type = RPI_PRED_TRANSFORM_ADD;
+         cmd->size = log2_trafo_size;
+         cmd->buf = coeffs;
+diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
+index 6d772d7..4f13622 100644
+--- a/libavcodec/rpi_hevc_transform.h
++++ b/libavcodec/rpi_hevc_transform.h
+@@ -1,4 +1,10 @@
+ unsigned char rpi_hevc_transform [] = {
++21,
++106,
++0,
++144,
++35,
++1,
+ 169,
+ 3,
+ 62,
+@@ -577,4 +583,48 @@ unsigned char rpi_hevc_transform [] = {
+ 0,
+ 111,
+ 3,
++4,
++254,
++0,
++128,
++0,
++4,
++0,
++248,
++0,
++0,
++2,
++232,
++32,
++0,
++0,
++0,
++140,
++248,
++32,
++0,
++0,
++0,
++224,
++35,
++0,
++0,
++64,
++232,
++0,
++2,
++0,
++0,
++193,
++232,
++0,
++1,
++0,
++0,
++1,
++106,
++116,
++30,
++90,
++0,
+ };
+diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
+index afdb32a..fd159bc 100644
+--- a/libavcodec/rpi_hevc_transform.s
++++ b/libavcodec/rpi_hevc_transform.s
+@@ -78,8 +78,11 @@
+ # num: number of 16x16 transforms to be done
+ # coeffs32
+ # num32: number of 32x32 transforms
++# command 0 for transform, 1 for memclear16(int16_t *dst,num16)
+ #
+ hevc_trans_16x16:
++  cmp r5,1
++  beq memclear16
+   push r6-r15, lr # TODO cut down number of used registers
+   mov r14,r3 # coeffs32
+   mov r15,r4 # num32
+@@ -266,3 +269,16 @@ trans32:
+   add r0,r8,32
+   vsth VX(48,32++),(r0+=r6) REP 16
+   pop pc
++
++memclear16:
++  # r0 is address
++  # r1 is number of 16bits values to set to 0 (may overrun past end and clear more than specified)
++  vmov HX(0++,0),0 REP 16
++  mov r2,32
++loop:
++  vsth HX(0++,0),(r0+=r2) REP 16
++  add r0,16*16*2
++  sub r1,16*16
++  cmp r1,0
++  bgt loop
++  b lr
+-- 
+2.7.4
+
+
+From 48282c2fb55c0d9a72222f384c03c432f78a3016 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 6 May 2015 09:56:43 +0100
+Subject: [PATCH 08/68] Prepared inter offload
+
+---
+ libavcodec/hevc.c       | 116 +++++++++++++++++++++++++++++++++++++++++++-----
+ libavcodec/hevc.h       |  29 +++++++++++-
+ libavcodec/hevc_cabac.c |   5 ++-
+ 3 files changed, 137 insertions(+), 13 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 1424007..8215201 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -45,6 +45,8 @@
+ #include "rpi_qpu.h"
+ // For some unknown reason, the code seems to crash if I do a late malloc
+ #define EARLY_MALLOC
++// Move Inter prediction into separate pass
++//#define RPI_INTER
+ #endif
+ 
+ // #define DISABLE_MC
+@@ -1440,6 +1442,95 @@ static int hls_pcm_sample(HEVCContext *s, int x0, int y0, int log2_cb_size)
+  * @param luma_offset additive offset applied to the luma prediction value
+  */
+ 
++#ifdef RPI_INTER
++#define RPI_REDIRECT(fn) rpi_ ## fn
++static void rpi_luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
++                        AVFrame *ref, const Mv *mv, int x_off, int y_off,
++                        int block_w, int block_h, int luma_weight, int luma_offset)
++{
++    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
++    cmd->cmd = RPI_CMD_LUMA_UNI;
++    cmd->dst = dst;
++    cmd->dststride = dststride;
++    cmd->src = ref->data[0];
++    cmd->srcstride = ref->linesize[0];
++    cmd->mv = *mv;
++    cmd->x_off = x_off;
++    cmd->y_off = y_off;
++    cmd->block_w = block_w;
++    cmd->block_h = block_h;
++    cmd->weight = luma_weight;
++    cmd->offset = luma_offset;
++}
++
++static void rpi_luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
++                       AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
++                       int block_w, int block_h, AVFrame *ref1, const Mv *mv1, struct MvField *current_mv)
++{
++    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
++    cmd->cmd = RPI_CMD_LUMA_BI;
++    cmd->dst = dst;
++    cmd->dststride = dststride;
++    cmd->src = ref->data[0];
++    cmd->srcstride = ref->linesize[0];
++    cmd->mv = *mv;
++    cmd->x_off = x_off;
++    cmd->y_off = y_off;
++    cmd->block_w = block_w;
++    cmd->block_h = block_h;
++    cmd->weight = luma_weight;
++    cmd->offset = luma_offset;
++    cmd->src1 = ref1->data[];
++    cmd->srcstride1 = ref1->linesize[0];
++    cmd->mv1 = *mv1;
++    cmd->ref_idx[0] = current_mv->ref_idx[0];
++    cmd->ref_idx[1] = current_mv->ref_idx[1];
++}
++
++static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
++                          ptrdiff_t dststride, uint8_t *src0, ptrdiff_t srcstride, int reflist,
++                          int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int chroma_weight, int chroma_offset)
++{
++    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
++    cmd->cmd = RPI_CMD_CHROMA_UNI;
++    cmd->dst = dst0;
++    cmd->dststride = dststride;
++    cmd->src = src0;
++    cmd->srcstride = srcstride;
++    cmd->mv = current_mv->mv[reflist];
++    cmd->x_off = x_off;
++    cmd->y_off = y_off;
++    cmd->block_w = block_w;
++    cmd->block_h = block_h;
++    cmd->weight = chroma_weight;
++    cmd->offset = chroma_offset;
++}
++
++static void chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVFrame *ref0, AVFrame *ref1,
++                         int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int cidx)
++{
++    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
++    cmd->cmd = RPI_CMD_CHROMA_BI+cidx;
++    cmd->dst = dst0;
++    cmd->dststride = dststride;
++    cmd->src = ref0->data[cidx+1];
++    cmd->srcstride = ref0->linesize[cidx+1];
++    cmd->mv = current_mv->mv[reflist];
++    cmd->x_off = x_off;
++    cmd->y_off = y_off;
++    cmd->block_w = block_w;
++    cmd->block_h = block_h;
++    cmd->weight = chroma_weight;
++    cmd->offset = chroma_offset;
++    cmd->src = ref1->data[cidx+1];
++    cmd->srcstride1 = ref1->linesize[cidx+1];
++    cmd->ref_idx[0] = current_mv->ref_idx[0];
++    cmd->ref_idx[1] = current_mv->ref_idx[1];
++}
++#else
++#define RPI_REDIRECT(fn) fn
++#endif
++
+ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                         AVFrame *ref, const Mv *mv, int x_off, int y_off,
+                         int block_w, int block_h, int luma_weight, int luma_offset)
+@@ -1505,7 +1596,7 @@ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+  * @param mv1 motion vector1 (relative to block position) to get pixel data from
+  * @param current_mv current motion vector structure
+  */
+- static void luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
++static void luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                        AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
+                        int block_w, int block_h, AVFrame *ref1, const Mv *mv1, struct MvField *current_mv)
+ {
+@@ -1887,16 +1978,16 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+         int nPbW_c = nPbW >> s->ps.sps->hshift[1];
+         int nPbH_c = nPbH >> s->ps.sps->vshift[1];
+ 
+-        luma_mc_uni(s, dst0, s->frame->linesize[0], ref0->frame,
++        RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref0->frame,
+                     &current_mv.mv[0], x0, y0, nPbW, nPbH,
+                     s->sh.luma_weight_l0[current_mv.ref_idx[0]],
+                     s->sh.luma_offset_l0[current_mv.ref_idx[0]]);
+ 
+         if (s->ps.sps->chroma_format_idc) {
+-            chroma_mc_uni(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],
++            RPI_REDIRECT(chroma_mc_uni)(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],
+                           0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
+                           s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]);
+-            chroma_mc_uni(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],
++            RPI_REDIRECT(chroma_mc_uni)(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],
+                           0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
+                           s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1]);
+         }
+@@ -1906,17 +1997,17 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+         int nPbW_c = nPbW >> s->ps.sps->hshift[1];
+         int nPbH_c = nPbH >> s->ps.sps->vshift[1];
+ 
+-        luma_mc_uni(s, dst0, s->frame->linesize[0], ref1->frame,
++        RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref1->frame,
+                     &current_mv.mv[1], x0, y0, nPbW, nPbH,
+                     s->sh.luma_weight_l1[current_mv.ref_idx[1]],
+                     s->sh.luma_offset_l1[current_mv.ref_idx[1]]);
+ 
+         if (s->ps.sps->chroma_format_idc) {
+-            chroma_mc_uni(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],
++            RPI_REDIRECT(chroma_mc_uni)(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],
+                           1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
+                           s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);
+ 
+-            chroma_mc_uni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],
++            RPI_REDIRECT(chroma_mc_uni)(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],
+                           1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
+                           s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1]);
+         }
+@@ -1926,15 +2017,15 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+         int nPbW_c = nPbW >> s->ps.sps->hshift[1];
+         int nPbH_c = nPbH >> s->ps.sps->vshift[1];
+ 
+-        luma_mc_bi(s, dst0, s->frame->linesize[0], ref0->frame,
++        RPI_REDIRECT(luma_mc_bi)(s, dst0, s->frame->linesize[0], ref0->frame,
+                    &current_mv.mv[0], x0, y0, nPbW, nPbH,
+                    ref1->frame, &current_mv.mv[1], &current_mv);
+ 
+         if (s->ps.sps->chroma_format_idc) {
+-            chroma_mc_bi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,
++            RPI_REDIRECT(chroma_mc_bi)(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,
+                          x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);
+ 
+-            chroma_mc_bi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,
++            RPI_REDIRECT(chroma_mc_bi)(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,
+                          x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 1);
+         }
+     }
+@@ -2465,7 +2556,9 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
+       } else {
+           int trafo_size = 1 << cmd->size;
+           s->hevcdsp.transform_add[cmd->size-2](cmd->dst, cmd->buf, cmd->stride);
++#ifdef RPI_PRECLEAR
+           memset(cmd->buf, 0, trafo_size * trafo_size * sizeof(int16_t)); // Clear coefficients here while they are in the cache
++#endif
+       }
+   }
+   s->num_pred_cmds = 0;
+@@ -3381,6 +3474,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
+     s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
+     printf("Done\n");
++#ifdef RPI_PRECLEAR
+     //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
+     memclear16(s->coeffs_buf_arm[0], coefs_per_row);
+     //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
+@@ -3389,6 +3483,8 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     memclear16(s->coeffs_buf_arm[3], coefs_per_row);
+ #endif
+ 
++#endif
++
+     s->enable_rpi = 0;
+ 
+ #endif
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 9a228f6..1ac119a 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -803,14 +803,39 @@ typedef struct HEVCLocalContext {
+ // RPI_MAX_WIDTH is maximum width in pixels supported by the accelerated code
+ #define RPI_MAX_WIDTH 2048
+ 
+-// Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane
+-#define RPI_MAX_MV_CMDS   (16*3*(RPI_MAX_WIDTH/4))
++// Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane, * 2 for bi
++#define RPI_MAX_MV_CMDS   (2*16*3*(RPI_MAX_WIDTH/4))
+ #define RPI_MAX_XFM_CMDS  (16*3*(RPI_MAX_WIDTH/4))
+ // Each block can have an intra prediction and a transform_add command
+ #define RPI_MAX_PRED_CMDS (2*16*3*(RPI_MAX_WIDTH/4))
+ 
++#define RPI_CMD_LUMA_UNI 0
++#define RPI_CMD_CHROMA_UNI 1
++#define RPI_CMD_LUMA_BI 2
++#define RPI_CMD_U_BI 3
++#define RPI_CMD_V_BI 4
++
++// RPI_PRECLEAR is not working yet - perhaps clearing on VPUs is flawed?
++// #define RPI_PRECLEAR
++
+ // Command for inter prediction
+ typedef struct HEVCMvCmd {
++    int cmd;
++    uint8_t *dst;
++    ptrdiff_t dststride;
++    uint8_t *src;
++    ptrdiff_t srcstride;
++    Mv mv;
++    int x_off;
++    int y_off;
++    int block_w;
++    int block_h;
++    int weight;
++    int offset;
++    uint8_t *src1;
++    ptrdiff_t srcstride1;
++    Mv mv1;
++    int8_t ref_idx[2];
+ } HEVCMvCmd;
+ 
+ // Command for transform to process a block of coefficients
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index dbfee85..4f072be 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -1059,7 +1059,10 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+         }
+     }
+     // We now do the memset after transform_add while we know the data is cached.
+-    //memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
++    #ifdef RPI_PRECLEAR
++    #else
++    memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
++    #endif
+ #else
+     memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));
+ #endif
+-- 
+2.7.4
+
+
+From 25d3b4e876febe08302a01abd85d5009160ead3e Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 6 May 2015 11:08:50 +0100
+Subject: [PATCH 09/68] Inter prediction in separate pass
+
+---
+ libavcodec/hevc.c | 93 +++++++++++++++++++++++++++++++++++++++++++++----------
+ libavcodec/hevc.h |  2 +-
+ 2 files changed, 77 insertions(+), 18 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 8215201..b7bc6ad 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -46,7 +46,7 @@
+ // For some unknown reason, the code seems to crash if I do a late malloc
+ #define EARLY_MALLOC
+ // Move Inter prediction into separate pass
+-//#define RPI_INTER
++#define RPI_INTER
+ #endif
+ 
+ // #define DISABLE_MC
+@@ -1448,7 +1448,7 @@ static void rpi_luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                         AVFrame *ref, const Mv *mv, int x_off, int y_off,
+                         int block_w, int block_h, int luma_weight, int luma_offset)
+ {
+-    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
++    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
+     cmd->cmd = RPI_CMD_LUMA_UNI;
+     cmd->dst = dst;
+     cmd->dststride = dststride;
+@@ -1467,31 +1467,29 @@ static void rpi_luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                        AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
+                        int block_w, int block_h, AVFrame *ref1, const Mv *mv1, struct MvField *current_mv)
+ {
+-    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
++    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
+     cmd->cmd = RPI_CMD_LUMA_BI;
+     cmd->dst = dst;
+     cmd->dststride = dststride;
+-    cmd->src = ref->data[0];
+-    cmd->srcstride = ref->linesize[0];
+-    cmd->mv = *mv;
++    cmd->src = ref0->data[0];
++    cmd->srcstride = ref0->linesize[0];
++    cmd->mv = *mv0;
+     cmd->x_off = x_off;
+     cmd->y_off = y_off;
+     cmd->block_w = block_w;
+     cmd->block_h = block_h;
+-    cmd->weight = luma_weight;
+-    cmd->offset = luma_offset;
+-    cmd->src1 = ref1->data[];
++    cmd->src1 = ref1->data[0];
+     cmd->srcstride1 = ref1->linesize[0];
+     cmd->mv1 = *mv1;
+     cmd->ref_idx[0] = current_mv->ref_idx[0];
+     cmd->ref_idx[1] = current_mv->ref_idx[1];
+ }
+ 
+-static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
++static void rpi_chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
+                           ptrdiff_t dststride, uint8_t *src0, ptrdiff_t srcstride, int reflist,
+                           int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int chroma_weight, int chroma_offset)
+ {
+-    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
++    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
+     cmd->cmd = RPI_CMD_CHROMA_UNI;
+     cmd->dst = dst0;
+     cmd->dststride = dststride;
+@@ -1506,27 +1504,27 @@ static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
+     cmd->offset = chroma_offset;
+ }
+ 
+-static void chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVFrame *ref0, AVFrame *ref1,
++static void rpi_chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVFrame *ref0, AVFrame *ref1,
+                          int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int cidx)
+ {
+-    HEVCMvCmd *cmd = unif_mv_cmds + s->num_mv_cmds++;
++    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
+     cmd->cmd = RPI_CMD_CHROMA_BI+cidx;
+     cmd->dst = dst0;
+     cmd->dststride = dststride;
+     cmd->src = ref0->data[cidx+1];
+     cmd->srcstride = ref0->linesize[cidx+1];
+-    cmd->mv = current_mv->mv[reflist];
++    cmd->mv = current_mv->mv[0];
++    cmd->mv1 = current_mv->mv[1];
+     cmd->x_off = x_off;
+     cmd->y_off = y_off;
+     cmd->block_w = block_w;
+     cmd->block_h = block_h;
+-    cmd->weight = chroma_weight;
+-    cmd->offset = chroma_offset;
+-    cmd->src = ref1->data[cidx+1];
++    cmd->src1 = ref1->data[cidx+1];
+     cmd->srcstride1 = ref1->linesize[cidx+1];
+     cmd->ref_idx[0] = current_mv->ref_idx[0];
+     cmd->ref_idx[1] = current_mv->ref_idx[1];
+ }
++
+ #else
+ #define RPI_REDIRECT(fn) fn
+ #endif
+@@ -2554,7 +2552,9 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
+           lc->na.cand_up_right     = (cmd->na >> 0) & 1;
+           s->hpc.intra_pred[cmd->size - 2](s, cmd->x, cmd->y, cmd->c_idx);
+       } else {
++#ifdef RPI_PRECLEAR
+           int trafo_size = 1 << cmd->size;
++#endif
+           s->hevcdsp.transform_add[cmd->size-2](cmd->dst, cmd->buf, cmd->stride);
+ #ifdef RPI_PRECLEAR
+           memset(cmd->buf, 0, trafo_size * trafo_size * sizeof(int16_t)); // Clear coefficients here while they are in the cache
+@@ -2563,6 +2563,61 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
+   }
+   s->num_pred_cmds = 0;
+ }
++
++static void rpi_execute_inter_cmds(HEVCContext *s)
++{
++    HEVCMvCmd *cmd = s->unif_mv_cmds;
++    int n,cidx;
++    AVFrame myref;
++    AVFrame myref1;
++    struct MvField mymv;
++    if (s->num_mv_cmds > RPI_MAX_MV_CMDS) {
++        printf("Overflow inter_cmds\n");
++        exit(-1);
++    }
++    for(n = s->num_mv_cmds; n>0 ; n--, cmd++) {
++        switch(cmd->cmd) {
++        case RPI_CMD_LUMA_UNI:
++            myref.data[0] = cmd->src;
++            myref.linesize[0] = cmd->srcstride;
++            luma_mc_uni(s, cmd->dst, cmd->dststride, &myref, &cmd->mv, cmd->x_off, cmd->y_off, cmd->block_w, cmd->block_h, cmd->weight, cmd->offset);
++            break;
++        case RPI_CMD_LUMA_BI:
++            myref.data[0] = cmd->src;
++            myref.linesize[0] = cmd->srcstride;
++            myref1.data[0] = cmd->src1;
++            myref1.linesize[0] = cmd->srcstride1;
++            mymv.ref_idx[0] = cmd->ref_idx[0];
++            mymv.ref_idx[1] = cmd->ref_idx[1];
++            luma_mc_bi(s, cmd->dst, cmd->dststride,
++                       &myref, &cmd->mv, cmd->x_off, cmd->y_off, cmd->block_w, cmd->block_h,
++                       &myref1, &cmd->mv1, &mymv);
++            break;
++        case RPI_CMD_CHROMA_UNI:
++            mymv.mv[0] = cmd->mv;
++            chroma_mc_uni(s, cmd->dst,
++                          cmd->dststride, cmd->src, cmd->srcstride, 0,
++                          cmd->x_off, cmd->y_off, cmd->block_w, cmd->block_h, &mymv, cmd->weight, cmd->offset);
++            break;
++        case RPI_CMD_CHROMA_BI:
++        case RPI_CMD_CHROMA_BI+1:
++            cidx = cmd->cmd - RPI_CMD_CHROMA_BI;
++            myref.data[cidx+1] = cmd->src;
++            myref.linesize[cidx+1] = cmd->srcstride;
++            myref1.data[cidx+1] = cmd->src1;
++            myref1.linesize[cidx+1] = cmd->srcstride1;
++            mymv.ref_idx[0] = cmd->ref_idx[0];
++            mymv.ref_idx[1] = cmd->ref_idx[1];
++            mymv.mv[0] = cmd->mv;
++            mymv.mv[1] = cmd->mv1;
++            chroma_mc_bi(s, cmd->dst, cmd->dststride, &myref, &myref1,
++                         cmd->x_off, cmd->y_off, cmd->block_w, cmd->block_h, &mymv, cidx);
++            break;
++        }
++    }
++    s->num_mv_cmds = 0;
++}
++
+ #endif
+ 
+ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+@@ -2611,6 +2666,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ #ifdef RPI
+         if (s->enable_rpi && x_ctb + ctb_size >= s->ps.sps->width) {
+             int x;
++            // Perform inter prediction
++            rpi_execute_inter_cmds(s);
+             // Transform all blocks
+             rpi_execute_transform(s);
+             // Perform intra prediction and residual reconstruction
+@@ -3422,6 +3479,7 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+ }
+ 
+ #ifdef RPI
++#ifdef RPI_PRECLEAR
+ static av_cold void memclear16(int16_t *p, int n)
+ {
+   vpu_execute_code( vpu_get_fn(), p, n, 0, 0, 0, 1);
+@@ -3430,6 +3488,7 @@ static av_cold void memclear16(int16_t *p, int n)
+   //  p[i] = 0;
+ }
+ #endif
++#endif
+ 
+ static av_cold int hevc_init_context(AVCodecContext *avctx)
+ {
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 1ac119a..a0eb71b 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -812,7 +812,7 @@ typedef struct HEVCLocalContext {
+ #define RPI_CMD_LUMA_UNI 0
+ #define RPI_CMD_CHROMA_UNI 1
+ #define RPI_CMD_LUMA_BI 2
+-#define RPI_CMD_U_BI 3
++#define RPI_CMD_CHROMA_BI 3
+ #define RPI_CMD_V_BI 4
+ 
+ // RPI_PRECLEAR is not working yet - perhaps clearing on VPUs is flawed?
+-- 
+2.7.4
+
+
+From 8af0a0a036e4bb3883f144d0567bc527772dd65b Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 6 May 2015 13:03:50 +0100
+Subject: [PATCH 10/68] Added VPU thread
+
+---
+ libavcodec/hevc.c    |  11 +++--
+ libavcodec/hevc.h    |   1 +
+ libavcodec/rpi_qpu.c | 125 +++++++++++++++++++++++++++++++++++++++++++++++++--
+ libavcodec/rpi_qpu.h |   2 +
+ 4 files changed, 133 insertions(+), 6 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index b7bc6ad..98dbd69 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2529,8 +2529,10 @@ static void rpi_execute_transform(HEVCContext *s)
+ 
+ 
+     gpu_cache_flush(&s->coeffs_buf_accelerated);
+-    vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
++    s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0, &s->coeffs_buf_accelerated);
++    //vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
+     //gpu_cache_flush(&s->coeffs_buf_accelerated);
++    //vpu_wait(s->vpu_id);
+ 
+     for(i=0;i<4;i++)
+         s->num_coeffs[i] = 0;
+@@ -2666,10 +2668,12 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ #ifdef RPI
+         if (s->enable_rpi && x_ctb + ctb_size >= s->ps.sps->width) {
+             int x;
+-            // Perform inter prediction
+-            rpi_execute_inter_cmds(s);
+             // Transform all blocks
+             rpi_execute_transform(s);
++            // Perform inter prediction
++            rpi_execute_inter_cmds(s);
++            // Wait for transform completion
++            vpu_wait(s->vpu_id);
+             // Perform intra prediction and residual reconstruction
+             rpi_execute_pred_cmds(s);
+             // Perform deblocking for CTBs in this row
+@@ -3426,6 +3430,7 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+     av_freep(&s->univ_pred_cmds);
+ 
+ #ifdef EARLY_MALLOC
++    printf("hevc_decode_free\n");
+     if (s->coeffs_buf_arm[0]) {
+       gpu_free(&s->coeffs_buf_default);
+       s->coeffs_buf_arm[0] = 0;
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index a0eb71b..0d8dfe9 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -896,6 +896,7 @@ typedef struct HEVCContext {
+     int num_xfm_cmds;
+     int num_mv_cmds;
+     int num_pred_cmds;
++    int vpu_id;
+ #endif
+ 
+     uint8_t *cabac_state;
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 12ad5fb..378dd74 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -1,9 +1,13 @@
+ #ifdef RPI
+-// Use the vcsm device for shared memory
++// define RPI_USE_VCSM to use the vcsm device for shared memory
+ // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
+ #define RPI_USE_VCSM
+-#define RPI_TIME_TOTAL_QPU
+-#define RPI_TIME_TOTAL_VPU
++// define RPI_TIME_TOTAL_QPU to print out how much time is spent in the QPU code
++//#define RPI_TIME_TOTAL_QPU
++// define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
++//#define RPI_TIME_TOTAL_VPU
++// define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
++#define RPI_ASYNC
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+@@ -113,6 +117,19 @@ static unsigned int Microseconds(void) {
+ }
+ #endif
+ 
++#ifdef RPI_ASYNC
++pthread_t vpu_thread;
++static void *vpu_start(void *arg);
++
++#define MAXCMDS 128
++static pthread_cond_t post_cond = PTHREAD_COND_INITIALIZER;
++static pthread_mutex_t post_mutex = PTHREAD_MUTEX_INITIALIZER;
++
++static int vpu_cmds[MAXCMDS][8];
++static volatile int vpu_async_tail=0; // Contains the number of posted jobs
++static volatile int vpu_async_head=0;
++#endif
++
+ // Connect to QPU, returns 0 on success.
+ static int gpu_init(volatile struct GPU **gpu) {
+   int mb = mbox_open();
+@@ -164,12 +181,27 @@ static int gpu_init(volatile struct GPU **gpu) {
+   // And the transform coefficients
+   memcpy((void*)ptr->transMatrix2even, rpi_transMatrix2even, sizeof(rpi_transMatrix2even));
+ 
++#ifdef RPI_ASYNC
++  {
++    int err;
++    vpu_async_tail = 0;
++    vpu_async_head = 0;
++    err = pthread_create(&vpu_thread, NULL, vpu_start, NULL);
++    //printf("Created thread\n");
++    if (err) {
++        printf("Failed to create vpu thread\n");
++        return -4;
++    }
++  }
++#endif
++
+   return 0;
+ }
+ 
+ // Make sure we have exclusive access to the mailbox, and enable qpu if necessary.
+ static void gpu_lock(void) {
+   pthread_mutex_lock(&gpu_mutex);
++
+   if (gpu==NULL) {
+     gpu_init(&gpu);
+   }
+@@ -264,6 +296,16 @@ static void gpu_term(void)
+ 	unsigned handle = gpu->vc_handle;
+   if (gpu==NULL)
+     return;
++
++#ifdef RPI_ASYNC
++  {
++    void *res;
++    vpu_post_code(0, 0, 0, 0, 0, 0, -1, NULL);
++    pthread_join(vpu_thread, &res);
++  }
++#endif
++
++
+ 	unmapmem((void*)gpu, sizeof(struct GPU));
+ 	mem_unlock(mb, handle);
+ 	mem_free(mb, handle);
+@@ -322,6 +364,79 @@ unsigned int vpu_get_constants(void) {
+   return gpu->vc + offsetof(struct GPU,transMatrix2even);
+ }
+ 
++#ifdef RPI_ASYNC
++
++static void *vpu_start(void *arg) {
++  while(1) {
++    pthread_mutex_lock(&post_mutex);
++    while( vpu_async_tail - vpu_async_head <= 0)
++    {
++      //printf("Checking number %d %d\n",vpu_async_head,vpu_async_tail);
++      pthread_cond_wait(&post_cond, &post_mutex);
++    }
++    int *p = vpu_cmds[vpu_async_head%MAXCMDS];
++    pthread_mutex_unlock(&post_mutex);
++
++    if (p[6] == -1) {
++      break; // Last job
++    }
++    if (p[7]) {
++        GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
++        //gpu_cache_flush(buf);
++    }
++    vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
++
++    pthread_mutex_lock(&post_mutex);
++    vpu_async_head++;
++    pthread_cond_broadcast(&post_cond);
++    pthread_mutex_unlock(&post_mutex);
++  }
++
++  return NULL;
++}
++
++// Post a command to the queue
++// Returns an id which we can use to wait for completion
++int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf)
++{
++  pthread_mutex_lock(&post_mutex);
++  {
++    int id = vpu_async_tail++;
++    int *p = vpu_cmds[id%MAXCMDS];
++    int num = vpu_async_tail - vpu_async_head;
++    if (num>MAXCMDS) {
++      printf("Too many commands submitted\n");
++      exit(-1);
++    }
++    p[0] = code;
++    p[1] = r0;
++    p[2] = r1;
++    p[3] = r2;
++    p[4] = r3;
++    p[5] = r4;
++    p[6] = r5;
++    p[7] = (int) buf;
++    if (num<=1)
++      pthread_cond_broadcast(&post_cond); // Otherwise the vpu thread must already be awake
++    pthread_mutex_unlock(&post_mutex);
++    return id;
++  }
++}
++
++// Wait for completion of the given command
++void vpu_wait(int id)
++{
++  pthread_mutex_lock(&post_mutex);
++  while( id + 1 - vpu_async_head > 0)
++  {
++    pthread_cond_wait(&post_cond, &post_mutex);
++  }
++  pthread_mutex_unlock(&post_mutex);
++}
++
++#endif
++
++
+ unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
+ {
+   unsigned r;
+@@ -334,7 +449,9 @@ unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2,
+   static int count=0;
+   static long long countr2=0;
+ #endif
++#ifndef RPI_ASYNC
+   gpu_lock();
++#endif
+ #ifdef RPI_TIME_TOTAL_VPU
+   start_time = Microseconds();
+   if (last_time==0)
+@@ -351,7 +468,9 @@ unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2,
+   if ((count&0x7f)==0)
+     printf("VPU %d %lld On=%dms, Off=%dms\n",count,countr2,(int)(on_time/1000),(int)(off_time/1000));
+ #endif
++#ifndef RPI_ASYNC
+   gpu_unlock();
++#endif
+   return r;
+ }
+ 
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index 814fc3c..3526fce 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -36,6 +36,8 @@ extern unsigned int qpu_get_fn(int num);
+ extern unsigned int vpu_get_fn(void);
+ extern unsigned int vpu_get_constants(void);
+ extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
++extern int vpu_post_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf);
++extern void vpu_wait( int id);
+ 
+ // Simple test of shader code
+ extern int rpi_test_shader(void);
+-- 
+2.7.4
+
+
+From 016d3db644e60fbe272bfcf1d7c3670c82422317 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 6 May 2015 15:03:37 +0100
+Subject: [PATCH 11/68] Added different signal when tail moves
+
+---
+ libavcodec/rpi_qpu.c | 11 ++++++-----
+ 1 file changed, 6 insertions(+), 5 deletions(-)
+
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 378dd74..d1c3e20 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -122,7 +122,8 @@ pthread_t vpu_thread;
+ static void *vpu_start(void *arg);
+ 
+ #define MAXCMDS 128
+-static pthread_cond_t post_cond = PTHREAD_COND_INITIALIZER;
++static pthread_cond_t post_cond_head = PTHREAD_COND_INITIALIZER;
++static pthread_cond_t post_cond_tail = PTHREAD_COND_INITIALIZER;
+ static pthread_mutex_t post_mutex = PTHREAD_MUTEX_INITIALIZER;
+ 
+ static int vpu_cmds[MAXCMDS][8];
+@@ -372,7 +373,7 @@ static void *vpu_start(void *arg) {
+     while( vpu_async_tail - vpu_async_head <= 0)
+     {
+       //printf("Checking number %d %d\n",vpu_async_head,vpu_async_tail);
+-      pthread_cond_wait(&post_cond, &post_mutex);
++      pthread_cond_wait(&post_cond_tail, &post_mutex);
+     }
+     int *p = vpu_cmds[vpu_async_head%MAXCMDS];
+     pthread_mutex_unlock(&post_mutex);
+@@ -388,7 +389,7 @@ static void *vpu_start(void *arg) {
+ 
+     pthread_mutex_lock(&post_mutex);
+     vpu_async_head++;
+-    pthread_cond_broadcast(&post_cond);
++    pthread_cond_broadcast(&post_cond_head);
+     pthread_mutex_unlock(&post_mutex);
+   }
+ 
+@@ -417,7 +418,7 @@ int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned
+     p[6] = r5;
+     p[7] = (int) buf;
+     if (num<=1)
+-      pthread_cond_broadcast(&post_cond); // Otherwise the vpu thread must already be awake
++      pthread_cond_broadcast(&post_cond_tail); // Otherwise the vpu thread must already be awake
+     pthread_mutex_unlock(&post_mutex);
+     return id;
+   }
+@@ -429,7 +430,7 @@ void vpu_wait(int id)
+   pthread_mutex_lock(&post_mutex);
+   while( id + 1 - vpu_async_head > 0)
+   {
+-    pthread_cond_wait(&post_cond, &post_mutex);
++    pthread_cond_wait(&post_cond_head, &post_mutex);
+   }
+   pthread_mutex_unlock(&post_mutex);
+ }
+-- 
+2.7.4
+
+
+From b04a72641253dc89fd1ec688035c3e2a946aa370 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 7 May 2015 08:57:11 +0100
+Subject: [PATCH 12/68] Add option to test for gpu_idle
+
+---
+ libavcodec/hevc.c    |  3 ++-
+ libavcodec/rpi_qpu.c | 18 ++++++++++++++++++
+ 2 files changed, 20 insertions(+), 1 deletion(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 98dbd69..2e269b6 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2527,7 +2527,6 @@ static void rpi_execute_transform(HEVCContext *s)
+     //    s->hevcdsp.idct[4-2](coeffs, 16);
+     //}
+ 
+-
+     gpu_cache_flush(&s->coeffs_buf_accelerated);
+     s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0, &s->coeffs_buf_accelerated);
+     //vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
+@@ -2669,6 +2668,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         if (s->enable_rpi && x_ctb + ctb_size >= s->ps.sps->width) {
+             int x;
+             // Transform all blocks
++            //printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
++
+             rpi_execute_transform(s);
+             // Perform inter prediction
+             rpi_execute_inter_cmds(s);
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index d1c3e20..85f49db 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -199,6 +199,17 @@ static int gpu_init(volatile struct GPU **gpu) {
+   return 0;
+ }
+ 
++// Returns 1 if the gpu is currently idle
++static int gpu_idle(void)
++{
++  int ret = pthread_mutex_trylock(&gpu_mutex);
++  if (ret==0) {
++    pthread_mutex_unlock(&gpu_mutex);
++    return 1;
++  }
++  return 0;
++}
++
+ // Make sure we have exclusive access to the mailbox, and enable qpu if necessary.
+ static void gpu_lock(void) {
+   pthread_mutex_lock(&gpu_mutex);
+@@ -400,6 +411,13 @@ static void *vpu_start(void *arg) {
+ // Returns an id which we can use to wait for completion
+ int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf)
+ {
++  // If the gpu is idle then just run the command immediately
++  // This works, but doesn't seem to give any benefit
++  // if (gpu_idle()) {
++  //   vpu_execute_code( code,  r0,  r1,  r2,  r3,  r4,  r5);
++  //   return -1; // TODO perhaps a wraparound bug here?
++  // }
++
+   pthread_mutex_lock(&post_mutex);
+   {
+     int id = vpu_async_tail++;
+-- 
+2.7.4
+
+
+From e7b457e683d4ca92bf2677b69708fbfc3849847b Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 7 May 2015 11:01:35 +0100
+Subject: [PATCH 13/68] Added deblocking pass
+
+---
+ libavcodec/hevc.c        | 33 +++++++++++++++++++++++++++------
+ libavcodec/hevc.h        |  7 ++++++-
+ libavcodec/hevc_filter.c |  6 +++++-
+ libavcodec/rpi_qpu.c     |  2 +-
+ 4 files changed, 39 insertions(+), 9 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 2e269b6..29f8415 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2518,6 +2518,17 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
+ }
+ 
+ #ifdef RPI
++static void rpi_execute_dblk_cmds(HEVCContext *s)
++{
++    int n;
++    int ctb_size    = 1 << s->ps.sps->log2_ctb_size;
++    int (*p)[2] = s->dblk_cmds;
++    for(n = s->num_dblk_cmds; n>0 ;n--,p++) {
++        ff_hevc_hls_filters(s, (*p)[0], (*p)[1], ctb_size);
++    }
++    s->num_dblk_cmds = 0;
++}
++
+ static void rpi_execute_transform(HEVCContext *s)
+ {
+     int i=2;
+@@ -2631,7 +2642,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     int ctb_addr_ts = s->ps.pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
+ 
+ #ifdef RPI
+-    int start_ctb_x = (s->sh.slice_ctb_addr_rs % ((s->ps.sps->width + ctb_size - 1) >> s->ps.sps->log2_ctb_size)) << s->ps.sps->log2_ctb_size;
+     s->enable_rpi = 1; // TODO this should depend on cross component and frame width etc.
+ #endif
+ 
+@@ -2665,7 +2675,10 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ 
+         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
+ #ifdef RPI
+-        if (s->enable_rpi && x_ctb + ctb_size >= s->ps.sps->width) {
++        if (s->enable_rpi) {
++          s->dblk_cmds[s->num_dblk_cmds][0] = x_ctb;
++          s->dblk_cmds[s->num_dblk_cmds++][1] = y_ctb;
++          if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->ps.sps->width) {
+             int x;
+             // Transform all blocks
+             //printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+@@ -2678,10 +2691,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+             // Perform intra prediction and residual reconstruction
+             rpi_execute_pred_cmds(s);
+             // Perform deblocking for CTBs in this row
+-            for(x = start_ctb_x; x <= x_ctb; x += ctb_size) {  // TODO this will fail for tiles
+-                ff_hevc_hls_filters(s, x, y_ctb, ctb_size);
+-            }
+-            start_ctb_x = 0;
++            rpi_execute_dblk_cmds(s);
++          }
+         }
+ #endif
+         if (more_data < 0) {
+@@ -2699,6 +2710,16 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);
+     }
+ 
++#ifdef RPI
++    if (s->enable_rpi && s->num_dblk_cmds) {
++        rpi_execute_transform(s);
++        rpi_execute_inter_cmds(s);
++        vpu_wait(s->vpu_id);
++        rpi_execute_pred_cmds(s);
++        rpi_execute_dblk_cmds(s);
++    }
++#endif
++
+     if (x_ctb + ctb_size >= s->ps.sps->width &&
+         y_ctb + ctb_size >= s->ps.sps->height)
+         ff_hevc_hls_filter(s, x_ctb, y_ctb, ctb_size);
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 0d8dfe9..990bd8c 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -808,6 +808,8 @@ typedef struct HEVCLocalContext {
+ #define RPI_MAX_XFM_CMDS  (16*3*(RPI_MAX_WIDTH/4))
+ // Each block can have an intra prediction and a transform_add command
+ #define RPI_MAX_PRED_CMDS (2*16*3*(RPI_MAX_WIDTH/4))
++// Worst case is 16x16 CTUs
++#define RPI_MAX_DEBLOCK_CMDS (RPI_MAX_WIDTH*4/16)
+ 
+ #define RPI_CMD_LUMA_UNI 0
+ #define RPI_CMD_CHROMA_UNI 1
+@@ -867,6 +869,9 @@ typedef struct HEVCPredCmd {
+ #endif
+ 
+ typedef struct HEVCContext {
++#ifdef RPI
++    int dblk_cmds[RPI_MAX_DEBLOCK_CMDS][2];
++#endif
+     const AVClass *c;  // needed by private avoptions
+     AVCodecContext *avctx;
+ 
+@@ -891,11 +896,11 @@ typedef struct HEVCContext {
+     GPU_MEM_PTR_T coeffs_buf_accelerated;
+     int16_t *coeffs_buf_arm[4];
+     unsigned int coeffs_buf_vc[4];
+-
+     int num_coeffs[4];
+     int num_xfm_cmds;
+     int num_mv_cmds;
+     int num_pred_cmds;
++    int num_dblk_cmds;
+     int vpu_id;
+ #endif
+ 
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index e4c3da7..ea0af91 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -877,8 +877,12 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+             if (s->threads_type & FF_THREAD_FRAME )
+                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
+         }
+-    } else if (s->threads_type & FF_THREAD_FRAME && x_end)
++    } else if (s->threads_type & FF_THREAD_FRAME && x_end) {
++        int newh = y + ctb_size - 4;
++        //int currh = s->ref->tf.progress->data[0];
++        //if (((y + ctb_size)&63)==0)
+         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
++    }
+ }
+ 
+ void ff_hevc_hls_filters(HEVCContext *s, int x_ctb, int y_ctb, int ctb_size)
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 85f49db..3b6dae7 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -105,7 +105,7 @@ struct GPU
+ static pthread_mutex_t gpu_mutex = PTHREAD_MUTEX_INITIALIZER;
+ static volatile struct GPU* gpu = NULL;
+ 
+-#ifdef RPI_TIME_TOTAL_QPU
++#if defined(RPI_TIME_TOTAL_QPU) || defined(RPI_TIME_TOTAL_VPU)
+ static unsigned int Microseconds(void) {
+     struct timespec ts;
+     unsigned int x;
+-- 
+2.7.4
+
+
+From 7a443df9115f21b4428de378bd146dcdba3dd42a Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 7 May 2015 16:47:47 +0100
+Subject: [PATCH 14/68] Added option to disable deblocking for non-ref frames
+
+---
+ libavcodec/hevc_filter.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index ea0af91..2cdd621 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -25,6 +25,8 @@
+ //#define DISABLE_SAO
+ //#define DISABLE_DEBLOCK
+ //#define DISABLE_STRENGTHS
++// define DISABLE_DEBLOCK_NONREF for a 6% speed boost (by skipping deblocking on unimportant frames)
++//#define DISABLE_DEBLOCK_NONREF
+ 
+ #include "libavutil/common.h"
+ #include "libavutil/internal.h"
+@@ -504,6 +506,14 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
+                 s->ps.sps->pcm.loop_filter_disable_flag) ||
+                s->ps.pps->transquant_bypass_enable_flag;
+ 
++#ifdef DISABLE_DEBLOCK_NONREF
++    if (    s->nal_unit_type == NAL_TRAIL_N ||
++            s->nal_unit_type == NAL_TSA_N   ||
++            s->nal_unit_type == NAL_STSA_N  ||
++            s->nal_unit_type == NAL_RADL_N  ||
++            s->nal_unit_type == NAL_RASL_N )
++      return; // Don't deblock non-reference frames
++#endif
+ #ifdef DISABLE_DEBLOCK
+     return;
+ #endif
+-- 
+2.7.4
+
+
+From 9606e160a582db64ccf981d971cdc258d8cc02f7 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Mon, 11 May 2015 10:00:27 +0100
+Subject: [PATCH 15/68] Moved buffers to VPU memory
+
+---
+ libavcodec/hevc_filter.c | 17 +++++++++++++-
+ libavcodec/utils.c       | 59 ++++++++++++++++++++++++++++++++++++++++++++++++
+ libavutil/buffer.c       |  6 +++++
+ libavutil/buffer.h       |  3 +++
+ 4 files changed, 84 insertions(+), 1 deletion(-)
+
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 2cdd621..e1b32d4 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -866,6 +866,13 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
+ #undef CB
+ #undef CR
+ 
++#ifdef RPI_INTER_QPU
++static void flush_buffer(AVBufferRef *bref) {
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
++    gpu_cache_flush(p);
++}
++#endif
++
+ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+ {
+     int x_end = x >= s->ps.sps->width  - ctb_size;
+@@ -888,9 +895,17 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
+         }
+     } else if (s->threads_type & FF_THREAD_FRAME && x_end) {
+-        int newh = y + ctb_size - 4;
++        //int newh = y + ctb_size - 4;
+         //int currh = s->ref->tf.progress->data[0];
+         //if (((y + ctb_size)&63)==0)
++        if (!(  s->nal_unit_type == NAL_TRAIL_N ||
++            s->nal_unit_type == NAL_TSA_N   ||
++            s->nal_unit_type == NAL_STSA_N  ||
++            s->nal_unit_type == NAL_RADL_N  ||
++            s->nal_unit_type == NAL_RASL_N )) {
++            flush_buffer(s->frame->buf[1]);
++            flush_buffer(s->frame->buf[2]);
++        }
+         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
+     }
+ }
+diff --git a/libavcodec/utils.c b/libavcodec/utils.c
+index f7adb52..708526e 100644
+--- a/libavcodec/utils.c
++++ b/libavcodec/utils.c
+@@ -26,6 +26,12 @@
+  */
+ 
+ #include "config.h"
++
++#ifdef RPI
++// Move video buffers to GPU memory
++#define RPI_GPU_BUFFERS
++#endif
++
+ #include "libavutil/atomic.h"
+ #include "libavutil/attributes.h"
+ #include "libavutil/avassert.h"
+@@ -64,6 +70,10 @@
+ #include "libavutil/ffversion.h"
+ const char av_codec_ffversion[] = "FFmpeg version " FFMPEG_VERSION;
+ 
++#ifdef RPI_GPU_BUFFERS
++#include "rpi_qpu.h"
++#endif
++
+ #if HAVE_PTHREADS || HAVE_W32THREADS || HAVE_OS2THREADS
+ static int default_lockmgr_cb(void **arg, enum AVLockOp op)
+ {
+@@ -503,6 +513,47 @@ int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,
+     return ret;
+ }
+ 
++#ifdef RPI_GPU_BUFFERS
++static void rpi_buffer_default_free(void *opaque, uint8_t *data)
++{
++    GPU_MEM_PTR_T *p = opaque;
++    gpu_free(p);
++    av_free(p);
++}
++
++static AVBufferRef *rpi_buffer_alloc(int size)
++{
++    AVBufferRef *ret = NULL;
++    uint8_t    *data = NULL;
++    GPU_MEM_PTR_T *p;
++
++    static int total=0;
++    total+=size;
++
++    p = av_malloc(sizeof *p);
++    if (!p)
++        return NULL;
++
++    if (gpu_malloc_cached(size,p)<0)  // Change this line to choose cached or uncached memory.  The caching here refers to the ARM data cache.
++        return NULL;
++
++    data = p->arm;
++    printf("Rpi alloc %d/%d ARM=%p VC=%x->%x\n",size,total,p->arm,p->vc,p->vc+size);
++    //memset(data, 64, size);
++
++    if (!data)
++        return NULL;
++
++    ret = av_buffer_create(data, size, rpi_buffer_default_free, p, 0);
++    if (!ret) {
++        gpu_free(p);
++        av_freep(&p);
++    }
++
++    return ret;
++}
++#endif
++
+ static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame)
+ {
+     FramePool *pool = avctx->internal->pool;
+@@ -550,6 +601,14 @@ static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame)
+             av_buffer_pool_uninit(&pool->pools[i]);
+             pool->linesize[i] = linesize[i];
+             if (size[i]) {
++#ifdef RPI_GPU_BUFFERS
++                if (avctx->codec_id == AV_CODEC_ID_HEVC)
++                    pool->pools[i] = av_buffer_pool_init(size[i] + 16 + STRIDE_ALIGN - 1,
++                                                     CONFIG_MEMORY_POISONING ?
++                                                        NULL :
++                                                        rpi_buffer_alloc);
++                else
++#endif
+                 pool->pools[i] = av_buffer_pool_init(size[i] + 16 + STRIDE_ALIGN - 1,
+                                                      CONFIG_MEMORY_POISONING ?
+                                                         NULL :
+diff --git a/libavutil/buffer.c b/libavutil/buffer.c
+index 694e116..203ca7b 100644
+--- a/libavutil/buffer.c
++++ b/libavutil/buffer.c
+@@ -425,3 +425,9 @@ AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
+ 
+     return ret;
+ }
++
++// Return the opaque for the underlying frame (gives us a GPU_MEM_PTR_T)
++void *av_buffer_pool_opaque(AVBufferRef *ref) {
++  BufferPoolEntry *buf = av_buffer_get_opaque(ref);
++  return buf->opaque;
++}
+diff --git a/libavutil/buffer.h b/libavutil/buffer.h
+index 0c0ce12..82e0bc3 100644
+--- a/libavutil/buffer.h
++++ b/libavutil/buffer.h
+@@ -283,6 +283,9 @@ void av_buffer_pool_uninit(AVBufferPool **pool);
+  */
+ AVBufferRef *av_buffer_pool_get(AVBufferPool *pool);
+ 
++// Return the opaque for the underlying frame
++void *av_buffer_pool_opaque(AVBufferRef *ref);
++
+ /**
+  * @}
+  */
+-- 
+2.7.4
+
+
+From f56515b9a720c829ba3ddf6da4232a91b13e0f03 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Mon, 11 May 2015 14:04:37 +0100
+Subject: [PATCH 16/68] Prepared QPU execute code
+
+---
+ libavcodec/hevc.c        | 227 ++++++++++++++++++++++++++++++++++++++++-------
+ libavcodec/hevc.h        |  22 ++++-
+ libavcodec/hevc_filter.c |   7 +-
+ libavcodec/rpi_qpu.c     |  55 +++++++++++-
+ libavcodec/rpi_qpu.h     |   2 +
+ 5 files changed, 276 insertions(+), 37 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 29f8415..66ed37a 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -42,17 +42,45 @@
+ #include "profiles.h"
+ 
+ #ifdef RPI
+-#include "rpi_qpu.h"
+-// For some unknown reason, the code seems to crash if I do a late malloc
+-#define EARLY_MALLOC
+-// Move Inter prediction into separate pass
+-#define RPI_INTER
++  #include "rpi_qpu.h"
++  // For some unknown reason, the code seems to crash if I do a late malloc
++  #define EARLY_MALLOC
++  // Move Inter prediction into separate pass
++  #define RPI_INTER
+ #endif
+ 
+ // #define DISABLE_MC
+ 
+ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12] = 4, [16] = 5, [24] = 6, [32] = 7, [48] = 8, [64] = 9 };
+ 
++
++#ifdef RPI_INTER_QPU
++
++#define RPI_CHROMA_COMMAND_WORDS 12
++// The QPU code for UV blocks only works up to a block width of 8
++#define RPI_CHROMA_BLOCK_WIDTH 8
++
++#define ENCODE_COEFFS(c0, c1, c2, c3) (((-c0) & 0xff) | ((-c1) & 0xff) << 8 | ((-c2) & 0xff) << 16 | ((-c3) & 0xff) << 24)
++
++// TODO Chroma only needs 4 taps
++static uint32_t rpi_filter_coefs[8][2] = {
++        { ENCODE_COEFFS(  0,  0,  0, 128), ENCODE_COEFFS(   0,   0,  0,  0 ) },
++        { ENCODE_COEFFS(  0,  0, -2,  58), ENCODE_COEFFS(  10,  -2,  0,  0 ) },
++        { ENCODE_COEFFS(  0,  0, -4,  54), ENCODE_COEFFS(  16,  -2,  0,  0 ) },
++        { ENCODE_COEFFS(  0,  0, -6,  46), ENCODE_COEFFS(  28,  -4,  0,  0 ) },
++        { ENCODE_COEFFS(  0,  0, -4,  36), ENCODE_COEFFS(  36,  -4,  0,  0 ) },
++        { ENCODE_COEFFS(  0,  0, -4,  28), ENCODE_COEFFS(  46,  -6,  0,  0 ) },
++        { ENCODE_COEFFS(  0,  0, -2,  16), ENCODE_COEFFS(  54,  -4,  0,  0 ) },
++        { ENCODE_COEFFS(  0,  0, -2,  10), ENCODE_COEFFS(  58,  -2,  0,  0 ) }
++};
++
++static uint32_t get_vc_address(AVBufferRef *bref) {
++  GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
++  return p->vc;
++}
++
++#endif
++
+ /**
+  * NOTE: Each function hls_foo correspond to the function foo in the
+  * specification (HLS stands for High Level Syntax).
+@@ -66,6 +94,7 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ static void pic_arrays_free(HEVCContext *s)
+ {
+ #ifdef RPI
++
+ #ifdef EARLY_MALLOC
+ #else
+     printf("pic_arrays_free\n");
+@@ -1982,6 +2011,43 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                     s->sh.luma_offset_l0[current_mv.ref_idx[0]]);
+ 
+         if (s->ps.sps->chroma_format_idc) {
++#ifdef RPI_INTER_QPU
++            if (s->enable_rpi) {
++                int reflist = 0;
++                int hshift           = s->ps.sps->hshift[1];
++                int vshift           = s->ps.sps->vshift[1];
++                const Mv *mv         = &current_mv.mv[reflist];
++                intptr_t mx          = av_mod_uintp2(mv->x, 2 + hshift);
++                intptr_t my          = av_mod_uintp2(mv->y, 2 + vshift);
++                intptr_t _mx         = mx << (1 - hshift);
++                intptr_t _my         = my << (1 - vshift); // Fractional part of motion vector
++
++                int x1_c = x0_c + (mv->x >> (2 + hshift));
++                int y1_c = y0_c + (mv->y >> (2 + hshift));
++                int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
++
++                uint32_t *u = s->u_mvs[chan & 7];
++                for(int start_y=0;start_y < nPbH_c;start_y+=16) {
++                  for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
++                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
++                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
++                      *u++ = rpi_filter_coefs[_mx][0];
++                      *u++ = rpi_filter_coefs[_mx][1];
++                      *u++ = rpi_filter_coefs[_my][0];
++                      *u++ = rpi_filter_coefs[_my][1];
++                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
++                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
++                    }
++                }
++                s->u_mvs[chan & 7] = u;
++                return;
++            }
++#endif
+             RPI_REDIRECT(chroma_mc_uni)(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],
+                           0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
+                           s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]);
+@@ -2632,6 +2698,54 @@ static void rpi_execute_inter_cmds(HEVCContext *s)
+ 
+ #endif
+ 
++#ifdef RPI_INTER_QPU
++static void rpi_inter_clear(HEVCContext *s)
++{
++    int i;
++    int pic_width        = s->ps.sps->width >> s->ps.sps->hshift[1];
++    int pic_height       = s->ps.sps->height >> s->ps.sps->vshift[1];
++    for(i=0;i<8;i++) {
++        s->u_mvs[i] = s->mvs_base[i];
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = pic_width;
++        *s->u_mvs[i]++ = pic_height;
++        *s->u_mvs[i]++ = s->frame->linesize[1];
++        *s->u_mvs[i]++ = s->frame->linesize[2];
++        s->u_mvs[i] += 3;  // Padding words
++    }
++}
++
++static void rpi_execute_inter_qpu(HEVCContext *s)
++{
++    int k;
++    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;
++
++    if (s->sh.slice_type == I_SLICE)
++        return;
++    for(k=0;k<8;k++) {
++        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
++        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
++    }
++
++    s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
++
++    qpu_run_shader8(qpu_get_fn(QPU_MC_SETUP_UV),
++      (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
++      );
++}
++#endif
++
+ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ {
+     HEVCContext *s  = avctxt->priv_data;
+@@ -2658,6 +2772,10 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         }
+     }
+ 
++#ifdef RPI_INTER_QPU
++    rpi_inter_clear(s);
++#endif
++
+     while (more_data && ctb_addr_ts < s->ps.sps->ctb_size) {
+         int ctb_addr_rs = s->ps.pps->ctb_addr_ts_to_rs[ctb_addr_ts];
+ 
+@@ -2679,19 +2797,30 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+           s->dblk_cmds[s->num_dblk_cmds][0] = x_ctb;
+           s->dblk_cmds[s->num_dblk_cmds++][1] = y_ctb;
+           if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->ps.sps->width) {
+-            int x;
++#ifdef RPI_INTER_QPU
++            // Kick off inter prediction on QPUs
++            rpi_execute_inter_qpu(s);
++#endif
+             // Transform all blocks
+             //printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+-
+             rpi_execute_transform(s);
+             // Perform inter prediction
+             rpi_execute_inter_cmds(s);
+             // Wait for transform completion
+             vpu_wait(s->vpu_id);
++
++            // Copy back reconstructed data
++            //memcpy(s->frame->data[0],s->dummy.arm,2048*64);
++            //memcpy(s->frame->data[1],s->dummy.arm,1024*32);
++            //memcpy(s->frame->data[2],s->dummy.arm,1024*32);
++
+             // Perform intra prediction and residual reconstruction
+             rpi_execute_pred_cmds(s);
+             // Perform deblocking for CTBs in this row
+             rpi_execute_dblk_cmds(s);
++#ifdef RPI_INTER_QPU
++            rpi_inter_clear(s);
++#endif
+           }
+         }
+ #endif
+@@ -2712,6 +2841,9 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ 
+ #ifdef RPI
+     if (s->enable_rpi && s->num_dblk_cmds) {
++#ifdef RPI_INTER_QPU
++        rpi_execute_inter_qpu(s);
++#endif
+         rpi_execute_transform(s);
+         rpi_execute_inter_cmds(s);
+         vpu_wait(s->vpu_id);
+@@ -3451,6 +3583,14 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+     av_freep(&s->unif_xfm_cmds);
+     av_freep(&s->univ_pred_cmds);
+ 
++#ifdef RPI_INTER_QPU
++    if (s->unif_mvs) {
++        gpu_free( &s->unif_mvs_ptr );
++        s->unif_mvs = 0;
++    }
++#endif
++    //gpu_free(&s->dummy);
++
+ #ifdef EARLY_MALLOC
+     printf("hevc_decode_free\n");
+     if (s->coeffs_buf_arm[0]) {
+@@ -3541,34 +3681,59 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     if (!s->univ_pred_cmds)
+         goto fail;
+ 
+-    s->coeffs_buf_arm[0] = 0;
+-    s->coeffs_buf_arm[2] = 0;
++#ifdef RPI_INTER_QPU
++    // We divide the image into blocks 256 wide and 64 high
++    // We support up to 2048 widths
++    // We compute the number of chroma motion vector commands for 4:4:4 format and 4x4 chroma blocks - assuming all blocks are B predicted
++    // Also add space for the startup command for each stream.
++
++    {
++        int uv_commands_per_qpu = (1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS;
++        uint32_t *p;
++        gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
++        s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
++
++        // Set up initial locations for uniform streams
++        p = s->unif_mvs;
++        for(i = 0; i < 8; i++) {
++            s->mvs_base[i] = p;
++            p += uv_commands_per_qpu;
++        }
++        s->mc_filter_uv = qpu_get_fn(QPU_MC_FILTER_UV);
++        s->mc_filter_uv_b = qpu_get_fn(QPU_MC_FILTER_UV_B);
++
++    }
++#endif
++    //gpu_malloc_uncached(2048*64,&s->dummy);
+ 
+ #ifdef EARLY_MALLOC
+-    int coeffs_in_ctb = 64*64;
+-    int coefs_per_row = (2048/64) * coeffs_in_ctb * 3;  // Allow space for chroma
+-    printf("Allocated %d\n",coefs_per_row);
+-    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
+-    s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
+-    if (!s->coeffs_buf_arm[0])
+-        goto fail;
+-    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
+-    s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
+-    s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
+-    if (!s->coeffs_buf_arm[2])
+-        goto fail;
+-    s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
+-    s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
+-    printf("Done\n");
++    {
++        int coeffs_in_ctb = 64*64;
++        int coefs_per_row = (2048/64) * coeffs_in_ctb * 3;  // Allow space for chroma
++        s->coeffs_buf_arm[0] = 0;
++        s->coeffs_buf_arm[2] = 0;
++        printf("Allocated %d\n",coefs_per_row);
++        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
++        s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
++        if (!s->coeffs_buf_arm[0])
++            goto fail;
++        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
++        s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
++        s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
++        if (!s->coeffs_buf_arm[2])
++            goto fail;
++        s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
++        s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
++        printf("Done\n");
+ #ifdef RPI_PRECLEAR
+-    //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
+-    memclear16(s->coeffs_buf_arm[0], coefs_per_row);
+-    //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
+-    memclear16(s->coeffs_buf_arm[2], coefs_per_row);
+-    //memset(s->coeffs_buf_arm[3],0, sizeof(int16_t) * coefs_per_row);
+-    memclear16(s->coeffs_buf_arm[3], coefs_per_row);
++        //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
++        memclear16(s->coeffs_buf_arm[0], coefs_per_row);
++        //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
++        memclear16(s->coeffs_buf_arm[2], coefs_per_row);
++        //memset(s->coeffs_buf_arm[3],0, sizeof(int16_t) * coefs_per_row);
++        memclear16(s->coeffs_buf_arm[3], coefs_per_row);
+ #endif
+-
++    }
+ #endif
+ 
+     s->enable_rpi = 0;
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 990bd8c..da345f6 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -42,7 +42,11 @@
+ 
+ // define RPI to split the CABAC/prediction/transform into separate stages
+ #ifdef RPI
+-#include "rpi_qpu.h"
++
++  #include "rpi_qpu.h"
++  // Use QPU for inter prediction
++  //#define RPI_INTER_QPU
++
+ #endif
+ 
+ #define MAX_DPB_SIZE 16 // A.4.1
+@@ -888,7 +892,7 @@ typedef struct HEVCContext {
+ 
+ #ifdef RPI
+     int enable_rpi;
+-    HEVCMvCmd *unif_mv_cmds;
++    HEVCMvCmd *unif_mv_cmds;  // TODO rename
+     HEVCXfmCmd *unif_xfm_cmds;
+     HEVCPredCmd *univ_pred_cmds;
+     int buf_width;
+@@ -902,6 +906,20 @@ typedef struct HEVCContext {
+     int num_pred_cmds;
+     int num_dblk_cmds;
+     int vpu_id;
++    //GPU_MEM_PTR_T dummy;
++#ifdef RPI_INTER_QPU
++    GPU_MEM_PTR_T unif_mvs_ptr;
++    uint32_t *unif_mvs; // Base of memory for motion vector commands
++
++    // _base pointers are to the start of the row
++    uint32_t *mvs_base[8];
++    // these pointers are to the next free space
++    uint32_t *u_mvs[8];
++    // Function pointers
++    uint32_t mc_filter_uv;
++    uint32_t mc_filter_uv_b;
++#endif
++
+ #endif
+ 
+     uint8_t *cabac_state;
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index e1b32d4..5b3d759 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -903,8 +903,11 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+             s->nal_unit_type == NAL_STSA_N  ||
+             s->nal_unit_type == NAL_RADL_N  ||
+             s->nal_unit_type == NAL_RASL_N )) {
+-            flush_buffer(s->frame->buf[1]);
+-            flush_buffer(s->frame->buf[2]);
++            //flush_buffer(s->frame->buf[1]);
++            //flush_buffer(s->frame->buf[2]);
++            //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
++            //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
++            //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
+         }
+         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
+     }
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 3b6dae7..e4dd58a 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -3,7 +3,7 @@
+ // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
+ #define RPI_USE_VCSM
+ // define RPI_TIME_TOTAL_QPU to print out how much time is spent in the QPU code
+-//#define RPI_TIME_TOTAL_QPU
++#define RPI_TIME_TOTAL_QPU
+ // define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
+ //#define RPI_TIME_TOTAL_VPU
+ // define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
+@@ -30,7 +30,7 @@
+ #endif
+ 
+ // On Pi2 there is no way to access the VPU L2 cache
+-// GPU_MEM_FLG should be 4 for uncached memory.
++// GPU_MEM_FLG should be 4 for uncached memory.  (Or C for alias to allocate in the VPU L2 cache)
+ // However, if using VCSM allocated buffers, need to use C at the moment because VCSM does not allocate uncached memory correctly
+ // The QPU crashes if we mix L2 cached and L2 uncached accesses due to a HW bug.
+ #define GPU_MEM_FLG 0xC
+@@ -549,6 +549,54 @@ void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int un
+   gpu_unlock();
+ }
+ 
++// Run a program on 8 QPUs with the given code and uniform stream (given in GPU addresses)
++void qpu_run_shader8(int code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8)
++{
++  int i;
++#ifdef RPI_TIME_TOTAL_QPU
++  static int last_time=0;
++  static long long on_time=0;
++  static long long off_time=0;
++  int start_time;
++  int end_time;
++  static int count=0;
++#endif
++
++  gpu_lock();
++#ifdef RPI_TIME_TOTAL_QPU
++  start_time = Microseconds();
++  if (last_time==0)
++    last_time = start_time;
++  off_time += start_time-last_time;
++#endif
++  for(i=0;i<8;i++) {
++    gpu->mail[i*2 + 1] = code;
++  }
++  gpu->mail[0 ] = unifs1;
++  gpu->mail[2 ] = unifs2;
++  gpu->mail[4 ] = unifs3;
++  gpu->mail[6 ] = unifs4;
++  gpu->mail[8 ] = unifs5;
++  gpu->mail[10] = unifs6;
++	gpu->mail[12] = unifs7;
++	gpu->mail[14] = unifs8;
++	execute_qpu(
++		gpu->mb,
++		8 /* Number of QPUs */,
++		gpu->vc + offsetof(struct GPU, mail),
++		1 /* no flush */,  // Don't flush VPU L1 cache
++		5000 /* timeout ms */);
++#ifdef RPI_TIME_TOTAL_QPU
++  end_time = Microseconds();
++  last_time = end_time;
++  on_time += end_time - start_time;
++  count++;
++  if ((count&0x7f)==0)
++    printf("On=%dms, Off=%dms\n",(int)(on_time/1000),(int)(off_time/1000));
++#endif
++  gpu_unlock();
++}
++
+ unsigned int qpu_get_fn(int num) {
+     // Make sure that the gpu is initialized
+     unsigned int *fn;
+@@ -585,6 +633,9 @@ unsigned int qpu_get_fn(int num) {
+     case QPU_MC_FILTER_UV_B:
+       fn = mc_filter_uv_b;
+       break;
++    case QPU_MC_INTERRUPT_EXIT8:
++      fn = mc_interrupt_exit8;
++      break;
+     case QPU_MC_END:
+       fn = mc_end;
+       break;
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index 3526fce..2b22d98 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -16,6 +16,7 @@ extern void gpu_free(GPU_MEM_PTR_T *p);
+ extern void gpu_cache_flush(GPU_MEM_PTR_T *p);
+ 
+ // QPU specific functions
++extern void qpu_run_shader8(int code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
+ extern void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8, int unifs9, int unifs10, int unifs11, int unifs12);
+ 
+ enum {
+@@ -28,6 +29,7 @@ enum {
+   QPU_MC_SETUP_UV,
+   QPU_MC_FILTER_UV,
+   QPU_MC_FILTER_UV_B,
++  QPU_MC_INTERRUPT_EXIT8,
+   QPU_MC_END
+   };
+ extern unsigned int qpu_get_fn(int num);
+-- 
+2.7.4
+
+
+From bd651e1569ebe0cdc41a6be169e139758cce069d Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 13 May 2015 11:47:23 +0100
+Subject: [PATCH 17/68] Drafted chroma interpolation on QPUs
+
+---
+ libavcodec/hevc.c          |   5 ++-
+ libavcodec/hevc.h          |   2 +-
+ libavcodec/hevc_filter.c   |   6 ++-
+ libavcodec/rpi_qpu.c       | 101 +++++++++++++++++++++++++++++++++++++++++++--
+ libavcodec/rpi_qpu.h       |   1 +
+ libavcodec/rpi_shader.c    |  42 +++++++++----------
+ libavcodec/rpi_shader.qasm |  42 +++++++++----------
+ 7 files changed, 149 insertions(+), 50 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 66ed37a..d5ea45e 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -60,11 +60,11 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ // The QPU code for UV blocks only works up to a block width of 8
+ #define RPI_CHROMA_BLOCK_WIDTH 8
+ 
+-#define ENCODE_COEFFS(c0, c1, c2, c3) (((-c0) & 0xff) | ((-c1) & 0xff) << 8 | ((-c2) & 0xff) << 16 | ((-c3) & 0xff) << 24)
++#define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
+ 
+ // TODO Chroma only needs 4 taps
+ static uint32_t rpi_filter_coefs[8][2] = {
+-        { ENCODE_COEFFS(  0,  0,  0, 128), ENCODE_COEFFS(   0,   0,  0,  0 ) },
++        { ENCODE_COEFFS(  0,  0,  0,  64), ENCODE_COEFFS(   0,   0,  0,  0 ) },
+         { ENCODE_COEFFS(  0,  0, -2,  58), ENCODE_COEFFS(  10,  -2,  0,  0 ) },
+         { ENCODE_COEFFS(  0,  0, -4,  54), ENCODE_COEFFS(  16,  -2,  0,  0 ) },
+         { ENCODE_COEFFS(  0,  0, -6,  46), ENCODE_COEFFS(  28,  -4,  0,  0 ) },
+@@ -2729,6 +2729,7 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+     for(k=0;k<8;k++) {
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
++        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP); // Also need a dummy for V
+     }
+ 
+     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index da345f6..2497c47 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -45,7 +45,7 @@
+ 
+   #include "rpi_qpu.h"
+   // Use QPU for inter prediction
+-  //#define RPI_INTER_QPU
++  // #define RPI_INTER_QPU
+ 
+ #endif
+ 
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 5b3d759..9b6e26d 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -903,8 +903,10 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+             s->nal_unit_type == NAL_STSA_N  ||
+             s->nal_unit_type == NAL_RADL_N  ||
+             s->nal_unit_type == NAL_RASL_N )) {
+-            //flush_buffer(s->frame->buf[1]);
+-            //flush_buffer(s->frame->buf[2]);
++#ifdef RPI_INTER_QPU
++            flush_buffer(s->frame->buf[1]);
++            flush_buffer(s->frame->buf[2]);
++#endif
+             //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
+             //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
+             //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index e4dd58a..4d9eda8 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -33,7 +33,8 @@
+ // GPU_MEM_FLG should be 4 for uncached memory.  (Or C for alias to allocate in the VPU L2 cache)
+ // However, if using VCSM allocated buffers, need to use C at the moment because VCSM does not allocate uncached memory correctly
+ // The QPU crashes if we mix L2 cached and L2 uncached accesses due to a HW bug.
+-#define GPU_MEM_FLG 0xC
++#define GPU_MEM_FLG 0x4
++// GPU_MEM_MAP is meaningless on the Pi2 and should be left at 0  (On Pi1 it allows ARM to access VPU L2 cache)
+ #define GPU_MEM_MAP 0x0
+ 
+ #define vcos_verify(x) ((x)>=0)
+@@ -165,6 +166,8 @@ static int gpu_init(volatile struct GPU **gpu) {
+ 	ptr->vc_handle = handle;
+ 	ptr->vc = vc;
+ 
++  printf("GPU allocated at 0x%x\n",vc);
++
+   *gpu = ptr;
+ 
+   // Now copy over the QPU code into GPU memory
+@@ -304,10 +307,13 @@ int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p) {
+ 
+ static void gpu_term(void)
+ {
+-	int mb = gpu->mb;
+-	unsigned handle = gpu->vc_handle;
++	int mb;
++	unsigned handle;
++
+   if (gpu==NULL)
+     return;
++  mb = gpu->mb;
++  handle = gpu->vc_handle;
+ 
+ #ifdef RPI_ASYNC
+   {
+@@ -648,6 +654,95 @@ unsigned int qpu_get_fn(int num) {
+ }
+ 
+ #if 0
++typedef unsigned int uint32_t;
++
++typedef struct mvs_s {
++    GPU_MEM_PTR_T unif_mvs_ptr;
++    uint32_t *unif_mvs; // Base of memory for motion vector commands
++
++    // _base pointers are to the start of the row
++    uint32_t *mvs_base[8];
++    // these pointers are to the next free space
++    uint32_t *u_mvs[8];
++
++} HEVCContext;
++
++#define RPI_CHROMA_COMMAND_WORDS 12
++
++static void rpi_inter_clear(HEVCContext *s)
++{
++    int i;
++    for(i=0;i<8;i++) {
++        s->u_mvs[i] = s->mvs_base[i];
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = 0;
++        *s->u_mvs[i]++ = 128;  // w
++        *s->u_mvs[i]++ = 128;  // h
++        *s->u_mvs[i]++ = 128;  // stride u
++        *s->u_mvs[i]++ = 128;  // stride v
++        s->u_mvs[i] += 3;  // Padding words
++    }
++}
++
++static void rpi_execute_inter_qpu(HEVCContext *s)
++{
++    int k;
++    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;
++
++    for(k=0;k<8;k++) {
++        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
++        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
++        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP); //  dummy location for V
++    }
++
++    s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
++
++    qpu_run_shader8(qpu_get_fn(QPU_MC_SETUP_UV),
++      (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
++      );
++}
++
++void rpi_test_qpu(void)
++{
++    HEVCContext mvs;
++    HEVCContext *s = &mvs;
++    int i;
++    int uv_commands_per_qpu = (1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS;
++    uint32_t *p;
++    printf("Allocate memory\n");
++    gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
++    s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm;
++
++    // Set up initial locations for uniform streams
++    p = s->unif_mvs;
++    for(i = 0; i < 8; i++) {
++        s->mvs_base[i] = p;
++        p += uv_commands_per_qpu;
++    }
++    // Now run a simple program that should just quit immediately after a single texture fetch
++    rpi_inter_clear(s);
++    for(i=0;i<4;i++) {
++      printf("Launch QPUs\n");
++      rpi_execute_inter_qpu(s);
++      printf("Done\n");
++    }
++    printf("Free memory\n");
++    gpu_free(&s->unif_mvs_ptr);
++    return;
++}
++#endif
++
++#if 0
+ 
+ int32_t hcoeffs[] = {-4, 10, -21, 70, 90, -24, 11, -4};
+ //int32_t hcoeffs[] = {1, 1, 1, 1, 1, 1, 1, 1};
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index 2b22d98..f9ad333 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -18,6 +18,7 @@ extern void gpu_cache_flush(GPU_MEM_PTR_T *p);
+ // QPU specific functions
+ extern void qpu_run_shader8(int code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
+ extern void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8, int unifs9, int unifs10, int unifs11, int unifs12);
++extern void rpi_test_qpu(void);
+ 
+ enum {
+   QPU_MC_SETUP,
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 41cc2e1..d7ed297 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -152,23 +152,23 @@ unsigned int rpi_shader[] = {
+ /* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+ /* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+ /* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000400] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00000408] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+-/* [0x00000410] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000400] */ 0x55015fc6, 0x100248a2, // mov r2, rb21         ; mul24 r2, r0, ra0
++/* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+ /* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000420] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000420] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ /* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000430] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000430] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ /* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000440] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000440] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+ /* [0x00000448] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000450] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000450] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+ /* [0x00000458] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000460] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000460] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+ /* [0x00000468] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000470] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000470] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+ /* [0x00000478] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000480] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x00000480] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+ /* [0x00000488] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+ /* [0x00000490] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+ /* [0x00000498] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+@@ -179,20 +179,20 @@ unsigned int rpi_shader[] = {
+ /* [0x000004c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+ /* [0x000004c8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+ /* [0x000004d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x000004d8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x000004d8] */ 0x8f54e1f6, 0xd0024821, // asr r0, r0, 14          ; mov r1, ra21
+ /* [0x000004e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x000004e8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x000004f0] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x000004f8] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000500] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000508] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000510] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000518] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000520] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000528] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x000004e8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x000004f0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x000004f8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000500] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000508] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000510] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000518] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000520] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000528] */ 0x8c9f223f, 0x100a0867, // add.ifnn r1, r1, r0     ; mov -, vw_wait
+ /* [0x00000530] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+ /* [0x00000538] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000540] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x00000540] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+ /* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+ /* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+ /* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 6851e83..02fdcb2 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -270,23 +270,23 @@ add t0s, ra_x2_base, r2
+ 
+ mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ 
+-mov r2, rb21         ; mul24 r3, r0, ra0
+-nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++mov r2, rb21         ; mul24 r2, r0, ra0
++nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++nop                  ; mul24      r3, ra1 << 1, r0 << 1
+ nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+ nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+ nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+ nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+ nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-sub r0, r2, r3
++add r0, r2, r3
+ 
+ mov r3, rb31
+ 
+@@ -302,23 +302,23 @@ sub.setf -, r3, 8 ; mov r1, ra22
+ # apply horizontal filter
+ brr.anyn -, r:uvloop
+ max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+-asr r0, r0, 15          ; mov r1, ra21
++asr r0, r0, 14          ; mov r1, ra21
+ min.setf ra15, r0, rb22
+ 
+ # apply vertical filter and write to VPM
+ 
+-nop                     ; mul24 r0, ra14, rb14
+-sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-sub.ifnn r1, r1, r0     ; mov -, vw_wait
++nop                     ; mul24 r1, ra14, rb14
++nop                     ; mul24 r0, ra13, rb13
++add r1, r1, r0          ; mul24 r0, ra12, rb12
++add r1, r1, r0          ; mul24 r0, ra11, rb11
++add r1, r1, r0          ; mul24 r0, ra10, rb10
++add r1, r1, r0          ; mul24 r0, ra9, rb9
++add r1, r1, r0          ; mul24 r0, ra8, rb8
++add r1, r1, r0          ; mul24 r0, ra15, rb15
++add.ifnn r1, r1, r0     ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+ brr.anyn -, r:uvloop
+-asr r1, r1, 15
++asr r1, r1, 14
+ min r1, r1, rb22
+ max vpm, r1, 0
+ 
+-- 
+2.7.4
+
+
+From 61628063461ee5d891af6dbedfd495efcf464012 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 13 May 2015 13:54:11 +0100
+Subject: [PATCH 18/68] Fixed chroma inter prediction
+
+---
+ libavcodec/hevc.c          |    8 +-
+ libavcodec/hevc.h          |    2 +-
+ libavcodec/rpi_shader.c    | 1170 ++++++++++++++++++++++----------------------
+ libavcodec/rpi_shader.h    |   22 +-
+ libavcodec/rpi_shader.qasm |   24 +-
+ 5 files changed, 617 insertions(+), 609 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index d5ea45e..d6d78ee 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -57,9 +57,11 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ #ifdef RPI_INTER_QPU
+ 
+ #define RPI_CHROMA_COMMAND_WORDS 12
++#define UV_COMMANDS_PER_QPU ((1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS)
+ // The QPU code for UV blocks only works up to a block width of 8
+ #define RPI_CHROMA_BLOCK_WIDTH 8
+ 
++
+ #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
+ 
+ // TODO Chroma only needs 4 taps
+@@ -2024,7 +2026,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+ 
+                 int x1_c = x0_c + (mv->x >> (2 + hshift));
+                 int y1_c = y0_c + (mv->y >> (2 + hshift));
+-                int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
++                //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
++                int chan = x0>>8;
+ 
+                 uint32_t *u = s->u_mvs[chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+@@ -2730,6 +2733,7 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP); // Also need a dummy for V
++        assert(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
+     }
+ 
+     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+@@ -3689,7 +3693,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     // Also add space for the startup command for each stream.
+ 
+     {
+-        int uv_commands_per_qpu = (1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS;
++        int uv_commands_per_qpu = UV_COMMANDS_PER_QPU;
+         uint32_t *p;
+         gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
+         s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 2497c47..d513579 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -45,7 +45,7 @@
+ 
+   #include "rpi_qpu.h"
+   // Use QPU for inter prediction
+-  // #define RPI_INTER_QPU
++  #define RPI_INTER_QPU
+ 
+ #endif
+ 
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index d7ed297..831633b 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -33,7 +33,7 @@ unsigned int rpi_shader[] = {
+ /* [0x00000040] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+ /* [0x00000048] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+ /* [0x00000050] */ 0x00000001, 0xe0020527, // mov ra20, 1
+-/* [0x00000058] */ 0x00000040, 0xe0020567, // mov ra21, 64
++/* [0x00000058] */ 0x00000020, 0xe0020567, // mov ra21, 32
+ /* [0x00000060] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+ /* [0x00000068] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+ /* [0x00000070] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+@@ -152,7 +152,7 @@ unsigned int rpi_shader[] = {
+ /* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+ /* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+ /* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000400] */ 0x55015fc6, 0x100248a2, // mov r2, rb21         ; mul24 r2, r0, ra0
++/* [0x00000400] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+ /* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+ /* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+ /* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+@@ -178,9 +178,9 @@ unsigned int rpi_shader[] = {
+ /* [0x000004b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+ /* [0x000004c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+ /* [0x000004c8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000004d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x000004d8] */ 0x8f54e1f6, 0xd0024821, // asr r0, r0, 14          ; mov r1, ra21
+-/* [0x000004e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x000004d0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x000004d8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x000004e0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+ /* [0x000004e8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+ /* [0x000004f0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+ /* [0x000004f8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+@@ -189,400 +189,400 @@ unsigned int rpi_shader[] = {
+ /* [0x00000510] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+ /* [0x00000518] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+ /* [0x00000520] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000528] */ 0x8c9f223f, 0x100a0867, // add.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x00000528] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+ /* [0x00000530] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000538] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000540] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000560] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000568] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000570] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000578] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000580] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000588] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000590] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000598] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000538] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000540] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x00000548] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000550] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x00000558] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000560] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000568] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000570] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000578] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000580] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000588] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000590] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000598] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000005a0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000005a8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter
+-/* [0x000005a0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000005a8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000005b0] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+-/* [0x000005b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000005c0] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+-/* [0x000005c8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000005d0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+-/* [0x000005d8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000005e0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+-/* [0x000005e8] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+-/* [0x000005f0] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+-/* [0x000005f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000600] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+-/* [0x00000608] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000610] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+-/* [0x00000618] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000620] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000628] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000630] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000638] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000640] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000648] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000650] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000658] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000660] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000668] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000670] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000678] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000680] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000688] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000690] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000698] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000006b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x000006d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000006f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000700] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000708] */ 0x000001d0, 0xf07809e7, // brr.anynn -, r:fast_path
+-/* [0x00000710] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000718] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000720] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000728] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000005b0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000005b8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000005c0] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
++/* [0x000005c8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000005d0] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
++/* [0x000005d8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000005e0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
++/* [0x000005e8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000005f0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
++/* [0x000005f8] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
++/* [0x00000600] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
++/* [0x00000608] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000610] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
++/* [0x00000618] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000620] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
++/* [0x00000628] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000630] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000638] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000640] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000648] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000650] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000658] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000660] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000668] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000670] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000678] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000680] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000688] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000690] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000698] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000006a0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006a8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006b0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006b8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000006c0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006c8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006d0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006d8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x000006e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000700] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000708] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000710] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000718] */ 0x000001d0, 0xf07809e7, // brr.anynn -, r:fast_path
++/* [0x00000720] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000728] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000730] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000738] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :loop
+-/* [0x00000730] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000738] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000740] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000748] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000750] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+-/* [0x00000758] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000760] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000768] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000770] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000778] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000780] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000788] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00000790] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000798] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000007a0] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000007a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000007b0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000007b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000007c0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x000007c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x000007d0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x000007d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x000007e0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x000007e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x000007f0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x000007f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000800] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+-/* [0x00000808] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000810] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000818] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000820] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000828] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000830] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000838] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000840] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000848] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:loop
+-/* [0x00000850] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x00000858] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+-/* [0x00000860] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x00000868] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x00000870] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x00000878] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000880] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000888] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000890] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000898] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x000008a0] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x000008a8] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-/* [0x000008b0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000008b8] */ 0xfffffe58, 0xf06809e7, // brr.anyn -, r:loop
+-/* [0x000008c0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+-/* [0x000008c8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000008d0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x000008d8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000008e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000008e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000008f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000740] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000748] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000750] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000758] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000760] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
++/* [0x00000768] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000770] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000778] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000780] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000788] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000790] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000798] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x000007a0] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000007a8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000007b0] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000007b8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000007c0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000007c8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000007d0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x000007d8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x000007e0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x000007e8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x000007f0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x000007f8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000800] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000808] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000810] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x00000818] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000820] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000828] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000830] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000838] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000840] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000848] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000850] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000858] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:loop
++/* [0x00000860] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x00000868] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x00000870] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x00000878] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x00000880] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x00000888] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000890] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000898] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x000008a0] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x000008a8] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x000008b0] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x000008b8] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x000008c0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000008c8] */ 0xfffffe58, 0xf06809e7, // brr.anyn -, r:loop
++/* [0x000008d0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x000008d8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000008e0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000008e8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000008f0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000008f8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000900] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // :fast_path
+-/* [0x000008f8] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000908] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :fast_loop
+-/* [0x00000900] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000908] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000910] */ 0x95727d9b, 0x1004475f, // mov.ifz ra_y, ra_y_next   ; mov rb31, r3
+-/* [0x00000918] */ 0x95690dbf, 0x10044623, // mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
+-/* [0x00000920] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000928] */ 0x929de5e4, 0x100248a1, // min r2, r2, rb_frame_height_minus_1 ; mov r1, r4
+-/* [0x00000930] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000938] */ 0xec414c87, 0x10024e20, // add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
+-/* [0x00000940] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000948] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00000950] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
+-/* [0x00000958] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
+-/* [0x00000960] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
+-/* [0x00000968] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
+-/* [0x00000970] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
+-/* [0x00000978] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
+-/* [0x00000980] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
+-/* [0x00000988] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
+-/* [0x00000990] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000998] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x000009a0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x000009a8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x000009b0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x000009b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000009c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8       ; mov r1, ra22
+-/* [0x000009c8] */ 0xffffff18, 0xf06809e7, // brr.anyn -, r:fast_loop
+-/* [0x000009d0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x000009d8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+-/* [0x000009e0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x000009e8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x000009f0] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x000009f8] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000a00] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000a08] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000a10] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000a18] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000a20] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000a28] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-/* [0x00000a30] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000a38] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:fast_loop
+-/* [0x00000a40] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+-/* [0x00000a48] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000a50] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000a60] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000910] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000918] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000920] */ 0x95727d9b, 0x1004475f, // mov.ifz ra_y, ra_y_next   ; mov rb31, r3
++/* [0x00000928] */ 0x95690dbf, 0x10044623, // mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
++/* [0x00000930] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000938] */ 0x929de5e4, 0x100248a1, // min r2, r2, rb_frame_height_minus_1 ; mov r1, r4
++/* [0x00000940] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000948] */ 0xec414c87, 0x10024e20, // add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
++/* [0x00000950] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000958] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00000960] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
++/* [0x00000968] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
++/* [0x00000970] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
++/* [0x00000978] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
++/* [0x00000980] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
++/* [0x00000988] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
++/* [0x00000990] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
++/* [0x00000998] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
++/* [0x000009a0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x000009a8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x000009b0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x000009b8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x000009c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x000009c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000009d0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8       ; mov r1, ra22
++/* [0x000009d8] */ 0xffffff18, 0xf06809e7, // brr.anyn -, r:fast_loop
++/* [0x000009e0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x000009e8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x000009f0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x000009f8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x00000a00] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x00000a08] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000a10] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000a18] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000a20] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000a28] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000a30] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000a38] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x00000a40] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000a48] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:fast_loop
++/* [0x00000a50] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x00000a58] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000a60] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000a68] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000a70] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000a78] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a80] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_b
+-/* [0x00000a78] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000a80] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000a88] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+-/* [0x00000a90] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000a98] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+-/* [0x00000aa0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000aa8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+-/* [0x00000ab0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000ab8] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+-/* [0x00000ac0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+-/* [0x00000ac8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+-/* [0x00000ad0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000ad8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+-/* [0x00000ae0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000ae8] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+-/* [0x00000af0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000af8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000b00] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000b08] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000b10] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000b18] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000b20] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000b28] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000b30] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000b38] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000b40] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000b48] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000b50] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000b58] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000b60] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000b68] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000b70] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+-/* [0x00000b78] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000b80] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000b88] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000b90] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000b98] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000ba0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ba8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000bb0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000bb8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000bc0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000bc8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000bd0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000bd8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000be0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000be8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000bf0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000bf8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000c00] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000c08] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000c10] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000a88] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000a90] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000a98] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
++/* [0x00000aa0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000aa8] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
++/* [0x00000ab0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000ab8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
++/* [0x00000ac0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000ac8] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
++/* [0x00000ad0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
++/* [0x00000ad8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
++/* [0x00000ae0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000ae8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
++/* [0x00000af0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000af8] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
++/* [0x00000b00] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000b08] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000b10] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000b18] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000b20] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000b28] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000b30] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000b38] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000b40] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000b48] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000b50] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000b58] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000b60] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000b68] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000b70] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000b78] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000b80] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
++/* [0x00000b88] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000b90] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000b98] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ba0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ba8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000bb0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000bb8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000bc0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000bc8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000bd0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000bd8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000be0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000be8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000bf0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000bf8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000c00] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000c08] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000c10] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000c18] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000c20] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :bloop
+-/* [0x00000c18] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000c20] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000c28] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000c30] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000c38] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+-/* [0x00000c40] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000c48] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000c50] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000c58] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000c60] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000c68] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000c70] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00000c78] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000c80] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000c88] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000c90] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000c98] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000ca0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000ca8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000cb0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000cb8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000cc0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000cc8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000cd0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000cd8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000ce0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000ce8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+-/* [0x00000cf0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000cf8] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000d00] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000d08] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000d10] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000d18] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000d20] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000d28] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000d30] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:bloop
+-/* [0x00000d38] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x00000d40] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+-/* [0x00000d48] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x00000d50] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x00000d58] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x00000d60] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000d68] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000d70] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000d78] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000d80] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000d88] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000d90] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-/* [0x00000d98] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000da0] */ 0x8fc8f3f6, 0xd0020867, // asr r1, r1, 15          ; mov -, vr_wait
+-/* [0x00000da8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000db0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+-/* [0x00000db8] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:bloop
+-/* [0x00000dc0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x00000dc8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+-/* [0x00000dd0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+-/* [0x00000dd8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000de0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000de8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000df0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000c28] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000c30] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000c38] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000c40] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000c48] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
++/* [0x00000c50] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000c58] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000c60] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000c68] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000c70] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000c78] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000c80] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00000c88] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000c90] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000c98] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000ca0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000ca8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000cb0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000cb8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000cc0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000cc8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000cd0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000cd8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000ce0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000ce8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000cf0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000cf8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x00000d00] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000d08] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000d10] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000d18] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000d20] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000d28] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000d30] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000d38] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000d40] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:bloop
++/* [0x00000d48] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x00000d50] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x00000d58] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x00000d60] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x00000d68] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x00000d70] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000d78] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000d80] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000d88] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000d90] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000d98] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000da0] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x00000da8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000db0] */ 0x8fc8f3f6, 0xd0020867, // asr r1, r1, 15          ; mov -, vr_wait
++/* [0x00000db8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000dc0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
++/* [0x00000dc8] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:bloop
++/* [0x00000dd0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x00000dd8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x00000de0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
++/* [0x00000de8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000df0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000df8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000e00] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_honly
+-/* [0x00000df8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000e00] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000e08] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+-/* [0x00000e10] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000e18] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+-/* [0x00000e20] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000e28] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+-/* [0x00000e30] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000e38] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+-/* [0x00000e40] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+-/* [0x00000e48] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+-/* [0x00000e50] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000e58] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+-/* [0x00000e60] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000e68] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+-/* [0x00000e70] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000e78] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000e80] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000e88] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000e90] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000e98] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000ea0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000ea8] */ 0x0c9de1c0, 0xd0021467, // add rb17, r0, -2
+-/* [0x00000eb0] */ 0x919c71c0, 0xd0024812, // shl r0, r0, 7 ; mov rb18,r0
+-/* [0x00000eb8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000ec0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000ec8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000ed0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000ed8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ee0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ee8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ef0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000ef8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f00] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f08] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f10] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000f18] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000f20] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000f28] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000f30] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000e08] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000e10] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000e18] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
++/* [0x00000e20] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000e28] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
++/* [0x00000e30] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000e38] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
++/* [0x00000e40] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000e48] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
++/* [0x00000e50] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
++/* [0x00000e58] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
++/* [0x00000e60] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000e68] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
++/* [0x00000e70] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000e78] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
++/* [0x00000e80] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000e88] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000e90] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000e98] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000ea0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000ea8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000eb0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000eb8] */ 0x0c9de1c0, 0xd0021467, // add rb17, r0, -2
++/* [0x00000ec0] */ 0x919c71c0, 0xd0024812, // shl r0, r0, 7 ; mov rb18,r0
++/* [0x00000ec8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000ed0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000ed8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000ee0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000ee8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ef0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ef8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f00] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000f08] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f10] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f18] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f20] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000f28] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000f30] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000f38] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000f40] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :loop_honly
+-/* [0x00000f38] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000f40] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000f48] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000f50] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000f58] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+-/* [0x00000f60] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000f68] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000f70] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000f78] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000f80] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000f88] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000f90] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00000f98] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000fa0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000fa8] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000fb0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000fb8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000fc0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000fc8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000fd0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000fd8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000fe0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000fe8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000ff0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000ff8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00001000] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00001008] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
+-/* [0x00001010] */ 0x8d5927f6, 0x100269e1, // sub.setf -, r3, rb18 ; mov r1, ra22
+-/* [0x00001018] */ 0x559f2fc1, 0x100049e0, // mov -, vw_wait   ; mul24 r0, r0, r1
+-/* [0x00001020] */ 0xfffffef8, 0xf06809e7, // brr.anyn -, r:loop_honly
+-/* [0x00001028] */ 0x0f9cf1c0, 0xd0020827, // asr r0, r0, 15
+-/* [0x00001030] */ 0x129d61c0, 0x10020827, // min r0, r0, rb22
+-/* [0x00001038] */ 0x139c01c0, 0xd0020c27, // max vpm, r0, 0
+-/* [0x00001040] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001048] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00001050] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00001058] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000f48] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000f50] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000f58] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000f60] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000f68] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
++/* [0x00000f70] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000f78] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000f80] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000f88] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000f90] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000f98] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000fa0] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00000fa8] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000fb0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000fb8] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000fc0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000fc8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000fd0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000fd8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000fe0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000fe8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000ff0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000ff8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00001000] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00001008] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00001010] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00001018] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
++/* [0x00001020] */ 0x8d5927f6, 0x100269e1, // sub.setf -, r3, rb18 ; mov r1, ra22
++/* [0x00001028] */ 0x559f2fc1, 0x100049e0, // mov -, vw_wait   ; mul24 r0, r0, r1
++/* [0x00001030] */ 0xfffffef8, 0xf06809e7, // brr.anyn -, r:loop_honly
++/* [0x00001038] */ 0x0f9cf1c0, 0xd0020827, // asr r0, r0, 15
++/* [0x00001040] */ 0x129d61c0, 0x10020827, // min r0, r0, rb22
++/* [0x00001048] */ 0x139c01c0, 0xd0020c27, // max vpm, r0, 0
++/* [0x00001050] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001058] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00001060] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001068] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00001060] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00001068] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00001070] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001078] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001070] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00001078] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+ /* [0x00001080] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00001088] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001090] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00001098] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x000010a0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00001090] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001098] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010a0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000010a8] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x000010b0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_exit1
+-/* [0x000010a8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x000010b0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000010b8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010b8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+ /* [0x000010c0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x000010c8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000010d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x000010d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x000010e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x000010d0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010d8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010e0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000010e8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x000010f0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit
+-/* [0x000010e8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x000010f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000010f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000010f8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+ /* [0x00001100] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00001108] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001110] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001118] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001110] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001118] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00001120] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001128] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001130] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+@@ -592,225 +592,227 @@ unsigned int rpi_shader[] = {
+ /* [0x00001150] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001158] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001160] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001168] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00001170] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00001178] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00001168] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001170] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001178] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00001180] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00001188] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit4
+-/* [0x00001180] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00001188] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001190] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001190] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+ /* [0x00001198] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x000011a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000011a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000011b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000011a8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000011b0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x000011b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000011c0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x000011c8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x000011d0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x000011c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000011c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000011d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000011d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x000011e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x000011d8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x000011e0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000011e8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000011e8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+ /* [0x000011f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x000011f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001200] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001208] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001200] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001208] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00001210] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001218] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001220] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001228] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001230] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001238] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00001240] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00001248] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00001238] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001240] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001248] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00001250] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00001258] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_setup_uv
+-/* [0x00001250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00001258] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
+-/* [0x00001260] */ 0x15827d80, 0x10020767, // mov ra_y, unif
+-/* [0x00001268] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
+-/* [0x00001270] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00001278] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
+-/* [0x00001280] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+-/* [0x00001288] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+-/* [0x00001290] */ 0x15827d80, 0x10021427, // mov rb16, unif
+-/* [0x00001298] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000012a0] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+-/* [0x000012a8] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+-/* [0x000012b0] */ 0x00000001, 0xe0020527, // mov ra20, 1
+-/* [0x000012b8] */ 0x00000040, 0xe0020567, // mov ra21, 64
+-/* [0x000012c0] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+-/* [0x000012c8] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+-/* [0x000012d0] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+-/* [0x000012d8] */ 0x00000040, 0xe0021567, // mov rb21, 64
+-/* [0x000012e0] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+-/* [0x000012e8] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+-/* [0x000012f0] */ 0x00000000, 0xe0020227, // mov ra8, 0
+-/* [0x000012f8] */ 0x00000000, 0xe0020267, // mov ra9, 0
+-/* [0x00001300] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+-/* [0x00001308] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+-/* [0x00001310] */ 0x00000000, 0xe0020327, // mov ra12, 0
+-/* [0x00001318] */ 0x00000000, 0xe0020367, // mov ra13, 0
+-/* [0x00001320] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+-/* [0x00001328] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x00001330] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00001338] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x00001340] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00001348] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00001350] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00001358] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00001360] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00001368] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00001370] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+-/* [0x00001378] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+-/* [0x00001380] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+-/* [0x00001388] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00001390] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x00001398] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x000013a0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x000013a8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x000013b0] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x000013b8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x000013c0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000013c8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x000013d0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x000013d8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+-/* [0x000013e0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+-/* [0x000013e8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+-/* [0x000013f0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+-/* [0x000013f8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x00001400] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00001408] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00001410] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+-/* [0x00001418] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00001420] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+-/* [0x00001428] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+-/* [0x00001430] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+-/* [0x00001438] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001440] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00001268] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
++/* [0x00001270] */ 0x15827d80, 0x10020767, // mov ra_y, unif
++/* [0x00001278] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
++/* [0x00001280] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00001288] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
++/* [0x00001290] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
++/* [0x00001298] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
++/* [0x000012a0] */ 0x15827d80, 0x10021427, // mov rb16, unif
++/* [0x000012a8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000012b0] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
++/* [0x000012b8] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
++/* [0x000012c0] */ 0x00000001, 0xe0020527, // mov ra20, 1
++/* [0x000012c8] */ 0x00000020, 0xe0020567, // mov ra21, 32
++/* [0x000012d0] */ 0x00000100, 0xe00205a7, // mov ra22, 256
++/* [0x000012d8] */ 0x00000008, 0xe00205e7, // mov ra23, 8
++/* [0x000012e0] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
++/* [0x000012e8] */ 0x00000040, 0xe0021567, // mov rb21, 64
++/* [0x000012f0] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x000012f8] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x00001300] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x00001308] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x00001310] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x00001318] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x00001320] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x00001328] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x00001330] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x00001338] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x00001340] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00001348] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00001350] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00001358] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00001360] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00001368] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00001370] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00001378] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00001380] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x00001388] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x00001390] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x00001398] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x000013a0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x000013a8] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x000013b0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x000013b8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x000013c0] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x000013c8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x000013d0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000013d8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x000013e0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x000013e8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
++/* [0x000013f0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
++/* [0x000013f8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
++/* [0x00001400] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
++/* [0x00001408] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x00001410] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00001418] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00001420] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
++/* [0x00001428] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00001430] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
++/* [0x00001438] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
++/* [0x00001440] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+ /* [0x00001448] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001450] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00001458] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00001460] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00001468] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001470] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00001478] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+-/* [0x00001480] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++/* [0x00001450] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001458] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001460] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00001468] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00001470] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00001478] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001480] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00001488] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
++/* [0x00001490] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+ // ::mc_filter_uv_b
+-/* [0x00001488] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00001490] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00001498] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000014a0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000014a8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000014b0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000014b8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000014c0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000014c8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000014d0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000014d8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000014e0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000014e8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000014f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000014f8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00001500] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00001508] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00001510] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00001518] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00001520] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00001528] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00001530] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00001538] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00001540] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00001548] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00001550] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00001558] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+-/* [0x00001560] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00001568] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001570] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001578] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001580] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001588] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00001590] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001598] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000015a0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000015a8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x000015b0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015b8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015c0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000015c8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000015d0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015d8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015e0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015e8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x000015f0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000015f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00001600] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00001498] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000014a0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000014a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000014b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000014b8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000014c0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000014c8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000014d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000014d8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000014e0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000014e8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000014f0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000014f8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00001500] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001508] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00001510] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00001518] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00001520] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00001528] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00001530] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00001538] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00001540] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00001548] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00001550] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00001558] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00001560] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00001568] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
++/* [0x00001570] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00001578] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001580] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001588] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001590] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001598] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000015a0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000015a8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000015b0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000015b8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x000015c0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015c8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015d0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000015d8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000015e0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015e8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015f0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000015f8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00001600] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00001608] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00001610] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x00001608] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00001610] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00001618] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00001620] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00001628] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00001630] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00001638] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00001640] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00001648] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00001650] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00001658] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00001660] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00001668] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+-/* [0x00001670] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00001678] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00001680] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00001688] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00001690] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00001698] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000016a0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x000016a8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x000016b0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x000016b8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x000016c0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x000016c8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x000016d0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x000016d8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x000016e0] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+-/* [0x000016e8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x000016f0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x000016f8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00001700] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00001708] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00001710] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00001718] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00001720] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00001728] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00001730] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x00001738] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+-/* [0x00001740] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x00001748] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x00001750] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x00001758] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00001760] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00001768] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00001770] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00001778] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00001780] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00001788] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-/* [0x00001790] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00001798] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+-/* [0x000017a0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000017a8] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+-/* [0x000017b0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000017b8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x000017c0] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+-/* [0x000017c8] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+-/* [0x000017d0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000017d8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000017e0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000017e8] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x000017f0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x000017f8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001800] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00001808] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00001810] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00001618] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00001620] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00001628] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00001630] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00001638] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00001640] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00001648] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00001650] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00001658] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00001660] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00001668] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00001670] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00001678] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
++/* [0x00001680] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00001688] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00001690] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00001698] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000016a0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000016a8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000016b0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x000016b8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x000016c0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x000016c8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x000016d0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x000016d8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x000016e0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x000016e8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x000016f0] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x000016f8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00001700] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00001708] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00001710] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00001718] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00001720] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00001728] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00001730] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00001738] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00001740] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x00001748] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x00001750] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x00001758] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x00001760] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x00001768] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00001770] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00001778] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00001780] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00001788] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00001790] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00001798] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x000017a0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000017a8] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x000017b0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000017b8] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
++/* [0x000017c0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000017c8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x000017d0] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x000017d8] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
++/* [0x000017e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000017e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000017f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000017f8] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00001800] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00001808] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001810] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00001818] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001820] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index db971f4..3464cdb 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -5,16 +5,16 @@ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup (rpi_shader + 0)
+ #define mc_filter_uv (rpi_shader + 146)
+-#define mc_filter (rpi_shader + 360)
+-#define mc_filter_b (rpi_shader + 670)
+-#define mc_filter_honly (rpi_shader + 894)
+-#define mc_exit (rpi_shader + 1048)
+-#define mc_exit1 (rpi_shader + 1066)
+-#define mc_interrupt_exit (rpi_shader + 1082)
+-#define mc_interrupt_exit4 (rpi_shader + 1120)
+-#define mc_interrupt_exit8 (rpi_shader + 1142)
+-#define mc_setup_uv (rpi_shader + 1172)
+-#define mc_filter_uv_b (rpi_shader + 1314)
+-#define mc_end (rpi_shader + 1542)
++#define mc_filter (rpi_shader + 364)
++#define mc_filter_b (rpi_shader + 674)
++#define mc_filter_honly (rpi_shader + 898)
++#define mc_exit (rpi_shader + 1052)
++#define mc_exit1 (rpi_shader + 1070)
++#define mc_interrupt_exit (rpi_shader + 1086)
++#define mc_interrupt_exit4 (rpi_shader + 1124)
++#define mc_interrupt_exit8 (rpi_shader + 1146)
++#define mc_setup_uv (rpi_shader + 1176)
++#define mc_filter_uv_b (rpi_shader + 1318)
++#define mc_end (rpi_shader + 1546)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 02fdcb2..4809e1d 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -21,7 +21,7 @@
+ # rb19                                          next ra16
+ #
+ # ra20                                          1
+-# ra21                                          64
++# ra21                                          32
+ # ra22                                          256
+ # ra23                                          8
+ #
+@@ -97,7 +97,7 @@ add rb24, r1, r0
+ # load constants
+ 
+ mov ra20, 1
+-mov ra21, 64
++mov ra21, 32
+ mov ra22, 256
+ mov ra23, 8
+ 
+@@ -270,7 +270,7 @@ add t0s, ra_x2_base, r2
+ 
+ mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ 
+-mov r2, rb21         ; mul24 r2, r0, ra0
++nop                  ; mul24 r2, r0, ra0
+ nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+ nop                  ; mul24      r3, ra1 << 1, r0 << 1
+ nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+@@ -301,9 +301,9 @@ sub.setf -, r3, 8 ; mov r1, ra22
+ 
+ # apply horizontal filter
+ brr.anyn -, r:uvloop
+-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+-asr r0, r0, 14          ; mov r1, ra21
+-min.setf ra15, r0, rb22
++mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
++asr ra15, r0, 8         ; nop
++nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
+ 
+ # apply vertical filter and write to VPM
+ 
+@@ -315,12 +315,14 @@ add r1, r1, r0          ; mul24 r0, ra10, rb10
+ add r1, r1, r0          ; mul24 r0, ra9, rb9
+ add r1, r1, r0          ; mul24 r0, ra8, rb8
+ add r1, r1, r0          ; mul24 r0, ra15, rb15
+-add.ifnn r1, r1, r0     ; mov -, vw_wait
++add r1, r1, r0          ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-brr.anyn -, r:uvloop
+ asr r1, r1, 14
+-min r1, r1, rb22
+-max vpm, r1, 0
++add r1, r1, ra21
++brr.anyn -, r:uvloop
++asr r1, r1, 6          # Delay 1
++min r1, r1, rb22       # Delay 2
++max vpm, r1, 0         # Delay 3
+ 
+ # DMA out for U
+ 
+@@ -1161,7 +1163,7 @@ add rb24, r1, r0
+ # load constants
+ 
+ mov ra20, 1
+-mov ra21, 64
++mov ra21, 32
+ mov ra22, 256
+ mov ra23, 8
+ 
+-- 
+2.7.4
+
+
+From b7321192751956ed7deceeb3dabe22ccedb8e08d Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 13 May 2015 14:37:32 +0100
+Subject: [PATCH 19/68] Removed unused luma functions
+
+---
+ libavcodec/hevc.c          |    4 +-
+ libavcodec/rpi_qpu.c       |   32 +-
+ libavcodec/rpi_shader.c    | 1097 +++++++++++++-------------------------------
+ libavcodec/rpi_shader.h    |   19 +-
+ libavcodec/rpi_shader.qasm |  970 +++------------------------------------
+ 5 files changed, 396 insertions(+), 1726 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index d6d78ee..31b8b2f 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2731,8 +2731,8 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+         return;
+     for(k=0;k<8;k++) {
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
+-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP); // Also need a dummy for V
++        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
++        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for V
+         assert(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
+     }
+ 
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 4d9eda8..4e90cc1 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -172,7 +172,7 @@ static int gpu_init(volatile struct GPU **gpu) {
+ 
+   // Now copy over the QPU code into GPU memory
+   {
+-    int num_bytes = qpu_get_fn(QPU_MC_END) - qpu_get_fn(QPU_MC_SETUP);
++    int num_bytes = qpu_get_fn(QPU_MC_END) - qpu_get_fn(QPU_MC_SETUP_UV);
+     assert(num_bytes<=QPU_CODE_SIZE*sizeof(unsigned int));
+     memcpy((void*)ptr->qpu_code, rpi_shader, num_bytes);
+   }
+@@ -612,24 +612,24 @@ unsigned int qpu_get_fn(int num) {
+       gpu_unlock();
+     }
+     switch(num) {
+-    case QPU_MC_SETUP:
+-      fn = mc_setup;
+-      break;
+-    case QPU_MC_FILTER:
+-      fn = mc_filter;
+-      break;
++    //case QPU_MC_SETUP:
++    //  fn = mc_setup;
++    //  break;
++    //case QPU_MC_FILTER:
++    //  fn = mc_filter;
++    //  break;
+     case QPU_MC_EXIT:
+       fn = mc_exit;
+       break;
+-    case QPU_MC_INTERRUPT_EXIT:
+-      fn = mc_interrupt_exit;
+-      break;
+-    case QPU_MC_FILTER_B:
+-      fn = mc_filter_b;
+-      break;
+-    case QPU_MC_FILTER_HONLY:
+-      fn = mc_filter_honly;
+-      break;
++    //case QPU_MC_INTERRUPT_EXIT:
++    //  fn = mc_interrupt_exit;
++    //  break;
++    //case QPU_MC_FILTER_B:
++    //  fn = mc_filter_b;
++    //  break;
++    //case QPU_MC_FILTER_HONLY:
++    //  fn = mc_filter_honly;
++    //  break;
+     case QPU_MC_SETUP_UV:
+       fn = mc_setup_uv;
+       break;
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 831633b..170e8ac 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -21,798 +21,331 @@ __declspec(align(8))
+ __attribute__((aligned(8)))
+ #endif
+ unsigned int rpi_shader[] = {
+-// ::mc_setup
++// ::mc_setup_uv
+ /* [0x00000000] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+ /* [0x00000008] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
+ /* [0x00000010] */ 0x15827d80, 0x10020767, // mov ra_y, unif
+ /* [0x00000018] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
+-/* [0x00000020] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+-/* [0x00000028] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+-/* [0x00000030] */ 0x15827d80, 0x10021427, // mov rb16, unif
+-/* [0x00000038] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000040] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+-/* [0x00000048] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+-/* [0x00000050] */ 0x00000001, 0xe0020527, // mov ra20, 1
+-/* [0x00000058] */ 0x00000020, 0xe0020567, // mov ra21, 32
+-/* [0x00000060] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+-/* [0x00000068] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+-/* [0x00000070] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+-/* [0x00000078] */ 0x00000040, 0xe0021567, // mov rb21, 64
+-/* [0x00000080] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+-/* [0x00000088] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+-/* [0x00000090] */ 0x00000000, 0xe0020227, // mov ra8, 0
+-/* [0x00000098] */ 0x00000000, 0xe0020267, // mov ra9, 0
+-/* [0x000000a0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+-/* [0x000000a8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+-/* [0x000000b0] */ 0x00000000, 0xe0020327, // mov ra12, 0
+-/* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
+-/* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+-/* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x000000d0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x000000d8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x000000e0] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x000000e8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x000000f0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x000000f8] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000100] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000108] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000110] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+-/* [0x00000118] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+-/* [0x00000120] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+-/* [0x00000128] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00000130] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x00000138] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000140] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000148] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000150] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000158] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000160] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000168] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x00000170] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x00000178] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+-/* [0x00000180] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+-/* [0x00000188] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+-/* [0x00000190] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+-/* [0x00000198] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000001a0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
++/* [0x00000020] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000028] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
++/* [0x00000030] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
++/* [0x00000038] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
++/* [0x00000040] */ 0x15827d80, 0x10021427, // mov rb16, unif
++/* [0x00000048] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000050] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
++/* [0x00000058] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
++/* [0x00000060] */ 0x00000001, 0xe0020527, // mov ra20, 1
++/* [0x00000068] */ 0x00000020, 0xe0020567, // mov ra21, 32
++/* [0x00000070] */ 0x00000100, 0xe00205a7, // mov ra22, 256
++/* [0x00000078] */ 0x00000008, 0xe00205e7, // mov ra23, 8
++/* [0x00000080] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
++/* [0x00000088] */ 0x00000040, 0xe0021567, // mov rb21, 64
++/* [0x00000090] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x00000098] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x000000a0] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x000000a8] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x000000b0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x000000b8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x000000c0] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x000000c8] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x000000d0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x000000d8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x000000e0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x000000e8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x000000f0] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x000000f8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000100] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000108] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000110] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000118] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000120] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x00000128] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x00000130] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x00000138] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000140] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00000148] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000150] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000158] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000160] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000168] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000170] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000178] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000180] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x00000188] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
++/* [0x00000190] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
++/* [0x00000198] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
++/* [0x000001a0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+ /* [0x000001a8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x000001b0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+-/* [0x000001b8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+-/* [0x000001c0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x000001b0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000001b8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x000001c0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+ /* [0x000001c8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x000001d0] */ 0x4c9d00cf, 0x10024821, // add r0, r0, r3; mul24 r1, r1, rb_pitch
+-/* [0x000001d8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+-/* [0x000001e0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x000001e8] */ 0x949dc5c0, 0xd0025890, // and r2, r2, ~3; mov ra_x_base, r0
+-/* [0x000001f0] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+-/* [0x000001f8] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+-/* [0x00000200] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000208] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000210] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000218] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000220] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000228] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000230] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000238] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+-/* [0x00000240] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++/* [0x000001d0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
++/* [0x000001d8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
++/* [0x000001e0] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
++/* [0x000001e8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000001f0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000001f8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000200] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000208] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000210] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000218] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000220] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000228] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
++/* [0x00000230] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+ // ::mc_filter_uv
+-/* [0x00000248] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000250] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000258] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000260] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000268] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000270] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000278] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000280] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000288] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000290] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000298] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000002a0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000002a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000002b0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000002b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000002c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000002c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000002d0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x000002d8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x000002e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000002e8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000002f0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000002f8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000300] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000330] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000338] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000340] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000348] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000350] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000358] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000360] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000368] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000370] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000378] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000380] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000388] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000390] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000398] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000003a0] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000238] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000240] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000248] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000250] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000258] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000260] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000268] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000270] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000278] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000280] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000288] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000290] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000298] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000002a0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000002a8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000002b0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000002b8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000002c0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x000002c8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x000002d0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000002d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000002e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000002e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000002f0] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x000002f8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000300] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000308] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000310] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000318] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000320] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000328] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000330] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000338] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000340] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000348] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000350] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000358] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000360] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000368] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000370] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000378] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000380] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000388] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000390] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x000003a8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000003b0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x000003b8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x000003c0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000003c8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000003d0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000003d8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003e0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000400] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000420] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000430] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000440] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000448] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000450] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000458] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000460] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000468] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000470] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000478] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000480] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000488] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000490] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000498] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x000004a0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x000004a8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x000004b0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x000004b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000004c0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x000004c8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000004d0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x000004d8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x000004e0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x000004e8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x000004f0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x000004f8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000500] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000508] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000510] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000518] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000520] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000528] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000530] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000538] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000540] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x00000548] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000550] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x00000558] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000560] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000568] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000570] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000578] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000580] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000588] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000590] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000598] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x000005a0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000005a8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-// ::mc_filter
+-/* [0x000005b0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000005b8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000005c0] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+-/* [0x000005c8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000005d0] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+-/* [0x000005d8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000005e0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+-/* [0x000005e8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000005f0] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+-/* [0x000005f8] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+-/* [0x00000600] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+-/* [0x00000608] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000610] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+-/* [0x00000618] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000620] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+-/* [0x00000628] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000630] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000638] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000640] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000648] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000650] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000658] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000660] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000668] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000670] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000678] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000680] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000688] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000690] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000698] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000006a0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006a8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006b0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006b8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000006c0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006c8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006d0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006d8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x000006e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000700] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000708] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000710] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000718] */ 0x000001d0, 0xf07809e7, // brr.anynn -, r:fast_path
+-/* [0x00000720] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000728] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000730] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000738] */ 0x00000000, 0xe00208e7, // mov r3, 0
+-// :loop
+-/* [0x00000740] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000748] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000750] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000758] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000760] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+-/* [0x00000768] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000770] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000778] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000780] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000788] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000790] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000798] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x000007a0] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000007a8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000007b0] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000007b8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000007c0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000007c8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000007d0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x000007d8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x000007e0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x000007e8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x000007f0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x000007f8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000800] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000808] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000810] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+-/* [0x00000818] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000820] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000828] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000830] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000838] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000840] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000848] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000850] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000858] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:loop
+-/* [0x00000860] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x00000868] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+-/* [0x00000870] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x00000878] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x00000880] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x00000888] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000890] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000898] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x000008a0] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x000008a8] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x000008b0] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x000008b8] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-/* [0x000008c0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000008c8] */ 0xfffffe58, 0xf06809e7, // brr.anyn -, r:loop
+-/* [0x000008d0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+-/* [0x000008d8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000008e0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x000008e8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000008f0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000008f8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000900] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-// :fast_path
+-/* [0x00000908] */ 0x00000000, 0xe00208e7, // mov r3, 0
+-// :fast_loop
+-/* [0x00000910] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000918] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000920] */ 0x95727d9b, 0x1004475f, // mov.ifz ra_y, ra_y_next   ; mov rb31, r3
+-/* [0x00000928] */ 0x95690dbf, 0x10044623, // mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
+-/* [0x00000930] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000938] */ 0x929de5e4, 0x100248a1, // min r2, r2, rb_frame_height_minus_1 ; mov r1, r4
+-/* [0x00000940] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000948] */ 0xec414c87, 0x10024e20, // add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
+-/* [0x00000950] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000958] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00000960] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
+-/* [0x00000968] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
+-/* [0x00000970] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
+-/* [0x00000978] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
+-/* [0x00000980] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
+-/* [0x00000988] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
+-/* [0x00000990] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
+-/* [0x00000998] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
+-/* [0x000009a0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x000009a8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x000009b0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x000009b8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x000009c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x000009c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000009d0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8       ; mov r1, ra22
+-/* [0x000009d8] */ 0xffffff18, 0xf06809e7, // brr.anyn -, r:fast_loop
+-/* [0x000009e0] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x000009e8] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+-/* [0x000009f0] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x000009f8] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x00000a00] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x00000a08] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000a10] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000a18] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000a20] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000a28] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000a30] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000a38] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-/* [0x00000a40] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000a48] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:fast_loop
+-/* [0x00000a50] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+-/* [0x00000a58] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000a60] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000a68] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000a70] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000a78] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a80] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-// ::mc_filter_b
+-/* [0x00000a88] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000a90] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000a98] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+-/* [0x00000aa0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000aa8] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+-/* [0x00000ab0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000ab8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+-/* [0x00000ac0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000ac8] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+-/* [0x00000ad0] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+-/* [0x00000ad8] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+-/* [0x00000ae0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000ae8] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+-/* [0x00000af0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000af8] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+-/* [0x00000b00] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000b08] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000b10] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000b18] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000b20] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000b28] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000b30] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000b38] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000b40] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000b48] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000b50] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000b58] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000b60] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000b68] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000b70] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000b78] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000b80] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+-/* [0x00000b88] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000b90] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000b98] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ba0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ba8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000bb0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000bb8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000bc0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000bc8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000bd0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000bd8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000be0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000be8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000bf0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000bf8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000c00] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000c08] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000c10] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000c18] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000c20] */ 0x00000000, 0xe00208e7, // mov r3, 0
+-// :bloop
+-/* [0x00000c28] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000c30] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000c38] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000c40] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000c48] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+-/* [0x00000c50] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000c58] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000c60] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000c68] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000c70] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000c78] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000c80] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00000c88] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000c90] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000c98] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000ca0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000ca8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000cb0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000cb8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000cc0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000cc8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000cd0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000cd8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000ce0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000ce8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000cf0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000cf8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+-/* [0x00000d00] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000d08] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000d10] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000d18] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000d20] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000d28] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000d30] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000d38] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000d40] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:bloop
+-/* [0x00000d48] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x00000d50] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+-/* [0x00000d58] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x00000d60] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x00000d68] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x00000d70] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000d78] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000d80] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000d88] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000d90] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000d98] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000da0] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-/* [0x00000da8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000db0] */ 0x8fc8f3f6, 0xd0020867, // asr r1, r1, 15          ; mov -, vr_wait
+-/* [0x00000db8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000dc0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+-/* [0x00000dc8] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:bloop
+-/* [0x00000dd0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x00000dd8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+-/* [0x00000de0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+-/* [0x00000de8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000df0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000df8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000e00] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-// ::mc_filter_honly
+-/* [0x00000e08] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000e10] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000e18] */ 0x156e7d80, 0x10020667, // mov ra_x2shift, ra_x2shift_next
+-/* [0x00000e20] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000e28] */ 0x0c9c81c0, 0xd00208a7, // add r2, r0, 8
+-/* [0x00000e30] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000e38] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3,unif
+-/* [0x00000e40] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000e48] */ 0x139c05c0, 0xd00208a7, // max r2, r2, 0
+-/* [0x00000e50] */ 0x129d95c0, 0x100208a7, // min r2, r2, rb_frame_width_minus_1
+-/* [0x00000e58] */ 0x119c35c0, 0xd00206e7, // shl ra_x2shift_next, r2, 3
+-/* [0x00000e60] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000e68] */ 0x0c9e74c0, 0x100208a7, // add r2, r2, r3
+-/* [0x00000e70] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000e78] */ 0x149dc5c0, 0xd00206a7, // and ra_x2_base_next, r2, ~3
+-/* [0x00000e80] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000e88] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000e90] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000e98] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000ea0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000ea8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000eb0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000eb8] */ 0x0c9de1c0, 0xd0021467, // add rb17, r0, -2
+-/* [0x00000ec0] */ 0x919c71c0, 0xd0024812, // shl r0, r0, 7 ; mov rb18,r0
+-/* [0x00000ec8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000ed0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000ed8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000ee0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000ee8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ef0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ef8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f00] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000f08] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f10] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f18] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f20] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000f28] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000f30] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000f38] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000f40] */ 0x00000000, 0xe00208e7, // mov r3, 0
+-// :loop_honly
+-/* [0x00000f48] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000f50] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000f58] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000f60] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000f68] */ 0xee654987, 0x10024860, // shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20
+-/* [0x00000f70] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000f78] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000f80] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000f88] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000f90] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000f98] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000fa0] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00000fa8] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000fb0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000fb8] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000fc0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000fc8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000fd0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000fd8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000fe0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000fe8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000ff0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000ff8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00001000] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00001008] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00001010] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00001018] */ 0x8d9df4ff, 0x10024823, // sub r0, r2, r3       ; mov r3, rb31
+-/* [0x00001020] */ 0x8d5927f6, 0x100269e1, // sub.setf -, r3, rb18 ; mov r1, ra22
+-/* [0x00001028] */ 0x559f2fc1, 0x100049e0, // mov -, vw_wait   ; mul24 r0, r0, r1
+-/* [0x00001030] */ 0xfffffef8, 0xf06809e7, // brr.anyn -, r:loop_honly
+-/* [0x00001038] */ 0x0f9cf1c0, 0xd0020827, // asr r0, r0, 15
+-/* [0x00001040] */ 0x129d61c0, 0x10020827, // min r0, r0, rb22
+-/* [0x00001048] */ 0x139c01c0, 0xd0020c27, // max vpm, r0, 0
+-/* [0x00001050] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001058] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00001060] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00001068] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-// ::mc_exit
+-/* [0x00001070] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00001078] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00001080] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001088] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001090] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001098] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000010a0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x000010a8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x000010b0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-// ::mc_exit1
+-/* [0x000010b8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x000010c0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000010c8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000010d0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000010d8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000010e0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x000010e8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x000010f0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-// ::mc_interrupt_exit
+-/* [0x000010f8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00001100] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001108] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001110] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001118] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001120] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001128] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001130] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001138] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001140] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001148] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001150] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001158] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001160] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001168] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001170] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001178] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00001180] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00001188] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-// ::mc_interrupt_exit4
+-/* [0x00001190] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00001198] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000011a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000011a8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000011b0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000011b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000011c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000011c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000011d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x000011d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x000011e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-// ::mc_interrupt_exit8
+-/* [0x000011e8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x000011f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000011f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001200] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001208] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001210] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001218] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001220] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001228] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001230] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001238] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001240] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001248] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00001250] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00001258] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-// ::mc_setup_uv
+-/* [0x00001260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00001268] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
+-/* [0x00001270] */ 0x15827d80, 0x10020767, // mov ra_y, unif
+-/* [0x00001278] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
+-/* [0x00001280] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00001288] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
+-/* [0x00001290] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+-/* [0x00001298] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+-/* [0x000012a0] */ 0x15827d80, 0x10021427, // mov rb16, unif
+-/* [0x000012a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000012b0] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+-/* [0x000012b8] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+-/* [0x000012c0] */ 0x00000001, 0xe0020527, // mov ra20, 1
+-/* [0x000012c8] */ 0x00000020, 0xe0020567, // mov ra21, 32
+-/* [0x000012d0] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+-/* [0x000012d8] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+-/* [0x000012e0] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+-/* [0x000012e8] */ 0x00000040, 0xe0021567, // mov rb21, 64
+-/* [0x000012f0] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+-/* [0x000012f8] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+-/* [0x00001300] */ 0x00000000, 0xe0020227, // mov ra8, 0
+-/* [0x00001308] */ 0x00000000, 0xe0020267, // mov ra9, 0
+-/* [0x00001310] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+-/* [0x00001318] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+-/* [0x00001320] */ 0x00000000, 0xe0020327, // mov ra12, 0
+-/* [0x00001328] */ 0x00000000, 0xe0020367, // mov ra13, 0
+-/* [0x00001330] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+-/* [0x00001338] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x00001340] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00001348] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x00001350] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00001358] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00001360] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00001368] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00001370] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00001378] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00001380] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+-/* [0x00001388] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+-/* [0x00001390] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+-/* [0x00001398] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x000013a0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x000013a8] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x000013b0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x000013b8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x000013c0] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x000013c8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x000013d0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000013d8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x000013e0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x000013e8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+-/* [0x000013f0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+-/* [0x000013f8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+-/* [0x00001400] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+-/* [0x00001408] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x00001410] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00001418] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00001420] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+-/* [0x00001428] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00001430] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+-/* [0x00001438] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+-/* [0x00001440] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+-/* [0x00001448] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001450] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001458] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001460] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00001468] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00001470] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00001478] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001480] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00001488] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+-/* [0x00001490] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++/* [0x00000398] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000003a0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x000003a8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x000003b0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000003b8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000003c0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000003c8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003d0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003d8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000003e0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x000003e8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000003f0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000003f8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000400] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000408] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000410] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000418] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000420] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000428] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000430] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000438] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000440] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000448] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000450] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000458] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000460] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000468] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000470] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000478] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000480] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000488] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000490] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000498] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x000004a0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x000004a8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000004b0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x000004b8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x000004c0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x000004c8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x000004d0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x000004d8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x000004e0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x000004e8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x000004f0] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x000004f8] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000500] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000508] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000510] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000518] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000520] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000528] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000530] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x00000538] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000540] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000560] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000568] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000570] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000578] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000580] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000588] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000590] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000598] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b
+-/* [0x00001498] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000014a0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000014a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000014b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000014b8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000014c0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000014c8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000014d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000014d8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000014e0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000014e8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000014f0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000014f8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00001500] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001508] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00001510] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00001518] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00001520] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00001528] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00001530] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00001538] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00001540] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00001548] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00001550] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00001558] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00001560] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00001568] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
+-/* [0x00001570] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00001578] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001580] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001588] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001590] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001598] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000015a0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000015a8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000015b0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000015b8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x000015c0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015c8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015d0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000015d8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000015e0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015e8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015f0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000015f8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00001600] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00001608] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00001610] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000005a0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000005a8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000005b0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000005b8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000005c0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000005c8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000005d0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000005d8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000005e0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000005e8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000005f0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000005f8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000600] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000608] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000610] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000618] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000620] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000628] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000630] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000638] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000640] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000648] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000650] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000658] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000660] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000668] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000670] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
++/* [0x00000678] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000680] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000688] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000690] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000698] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000006a8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006b0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006b8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006c0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x000006c8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006d0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006d8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006e0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000006e8] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006f0] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006f8] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000700] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000708] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000710] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000718] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x00001618] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00001620] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00001628] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00001630] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00001638] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00001640] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00001648] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00001650] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00001658] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00001660] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00001668] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00001670] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00001678] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+-/* [0x00001680] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00001688] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00001690] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00001698] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000016a0] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000016a8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000016b0] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x000016b8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x000016c0] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x000016c8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x000016d0] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x000016d8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x000016e0] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x000016e8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x000016f0] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
+-/* [0x000016f8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00001700] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00001708] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00001710] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00001718] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00001720] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00001728] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00001730] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00001738] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00001740] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x00001748] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+-/* [0x00001750] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x00001758] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x00001760] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x00001768] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00001770] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00001778] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00001780] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00001788] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00001790] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00001798] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-/* [0x000017a0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000017a8] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+-/* [0x000017b0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000017b8] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+-/* [0x000017c0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000017c8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x000017d0] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+-/* [0x000017d8] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+-/* [0x000017e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000017e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000017f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000017f8] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00001800] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00001808] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001810] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00001818] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00001820] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000720] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000728] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000730] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000738] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000740] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000748] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000750] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000758] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000760] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000768] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000770] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000778] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
++/* [0x00000780] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
++/* [0x00000788] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000790] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000798] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000007a0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000007a8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000007b0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000007b8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x000007c0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x000007c8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x000007d0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x000007d8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x000007e0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x000007e8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x000007f0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x000007f8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x00000800] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000808] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000810] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000818] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000820] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000828] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000830] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000838] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000848] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
++/* [0x00000850] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
++/* [0x00000858] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
++/* [0x00000860] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
++/* [0x00000868] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
++/* [0x00000870] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000878] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000880] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000888] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000890] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000898] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x000008a0] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x000008a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000008b0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x000008b8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000008c0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
++/* [0x000008c8] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000008d0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x000008d8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x000008e0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
++/* [0x000008e8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000008f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000008f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000900] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000908] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000910] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000918] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000920] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000928] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_exit
++/* [0x00000930] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000938] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000940] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000948] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000950] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000958] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000960] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000968] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000970] */ 0x009e7000, 0x100009e7, // nop        ; nop
++// ::mc_interrupt_exit8
++/* [0x00000978] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000980] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000988] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000990] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000998] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000009a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009d0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009d8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000009e0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x000009e8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 3464cdb..9de4535 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -3,18 +3,11 @@
+ 
+ extern unsigned int rpi_shader[];
+ 
+-#define mc_setup (rpi_shader + 0)
+-#define mc_filter_uv (rpi_shader + 146)
+-#define mc_filter (rpi_shader + 364)
+-#define mc_filter_b (rpi_shader + 674)
+-#define mc_filter_honly (rpi_shader + 898)
+-#define mc_exit (rpi_shader + 1052)
+-#define mc_exit1 (rpi_shader + 1070)
+-#define mc_interrupt_exit (rpi_shader + 1086)
+-#define mc_interrupt_exit4 (rpi_shader + 1124)
+-#define mc_interrupt_exit8 (rpi_shader + 1146)
+-#define mc_setup_uv (rpi_shader + 1176)
+-#define mc_filter_uv_b (rpi_shader + 1318)
+-#define mc_end (rpi_shader + 1546)
++#define mc_setup_uv (rpi_shader + 0)
++#define mc_filter_uv (rpi_shader + 142)
++#define mc_filter_uv_b (rpi_shader + 360)
++#define mc_exit (rpi_shader + 588)
++#define mc_interrupt_exit8 (rpi_shader + 606)
++#define mc_end (rpi_shader + 636)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 4809e1d..cd7346d 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -71,8 +71,10 @@
+ 
+ .set rb_const_64,                  rb21
+ 
+-# mc_setup(next_kernel, x, y, ref_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1)
+-::mc_setup
++
++################################################################################
++# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
++::mc_setup_uv
+ 
+ # Read starting kernel
+ mov ra31, unif
+@@ -80,7 +82,9 @@ mov ra31, unif
+ # Load first request location
+ add ra_x_base, unif, elem_num # Store x
+ mov ra_y, unif # Store y
+-mov ra_x2_base, unif # Store frame base
++mov ra_x2_base, unif # Store frame u base
++nop
++sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
+ 
+ # Read image dimensions
+ sub rb25,unif,1
+@@ -143,29 +147,24 @@ mov r1, vpm_setup(0, 4, h8p(0, 0))
+ add rb28, r0, r1
+ 
+ # Compute base address for first and second access
+-#add r0, unif, elem_num     # x
+ mov r0, ra_x_base           # Load x
+-add r2, r0, 8               # x+8
+ max r0, r0, 0; mov r1, ra_y # Load y
+ min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
+-shl ra_xshift_next, r0, 3
+-max r2, r2, 0
++shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+ add ra_y, r1, 1
+-min r2, r2, rb_frame_width_minus_1
+-shl ra_x2shift_next, r2, 3
+-max r1, r1, 0  # y
+-min r1, r1, rb_frame_height_minus_1
+-add r0, r0, r3; mul24 r1, r1, rb_pitch
+-add r2, r2, r3
++add r0, r0, r3
+ and r0, r0, ~3
+-and r2, r2, ~3; mov ra_x_base, r0
++max r1, r1, 0 ; mov ra_x_base, r0 # y
++min r1, r1, rb_frame_height_minus_1
+ # submit texture requests for first line
++add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+ add t0s, r0, r1 ; mov ra_x2_base, r2
+ add t0s, r2, r1
+ 
+ # Dump padding words
+ mov r0, unif
+ mov r0, unif
++mov r0, unif
+ 
+ # submit texture requests for second line
+ max r1, ra_y, 0
+@@ -176,6 +175,8 @@ nop ; mul24 r1, r1, rb_pitch
+ add t0s, r1, ra_x_base
+ add t0s, r1, ra_x2_base
+ 
++
++
+ ################################################################################
+ 
+ # mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
+@@ -341,453 +342,26 @@ add vw_setup, rb26, r0 # VDW setup 0
+ mov vw_setup, rb29 # Stride
+ mov vw_addr, unif # start the VDW
+ 
+-################################################################################
+-
+-
+-# mc_filter(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+-
+-# At this point we have already issued two pairs of texture requests for the current block
+-# ra_x_base, ra_x16_base point to the current coordinates for this block
+-::mc_filter
+-mov ra31, unif
+-
+-# per-channel shifts were calculated on the *previous* invocation
+-
+-mov ra_xshift, ra_xshift_next
+-mov ra_x2shift, ra_x2shift_next
+-
+-# get base addresses and per-channel shifts for *next* invocation
+-add r0, unif, elem_num    # x
+-add r2, r0, 8 # x+8
+-max r0, r0, 0; mov r1, unif # y
+-min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
+-shl ra_xshift_next, r0, 3
+-max r2, r2, 0
+-min r2, r2, rb_frame_width_minus_1
+-shl ra_x2shift_next, r2, 3
+-add r0, r0, r3
+-add r2, r2, r3
+-and rb_x_base_next, r0, ~3
+-and ra_x2_base_next, r2, ~3
+-mov ra_y_next, r1
+-
+-# set up VPM write
+-mov vw_setup, rb28
+-
+-# get width,height of block
+-mov r2, 16
+-mov r0, unif
+-shr r1, r0, r2 # Extract width
+-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+-and r0, r0, rb22 # Extract height
+-add rb17, r0, 5
+-add rb18, r0, 7
+-shl r0, r0, 7
+-add r0, r0, r1 # Combine width and height of destination area
+-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+-add rb26, r0, rb27
+-
+-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+-
+-# get filter coefficients
+-
+-mov r0, unif
+-asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-asr ra0, r0, rb23;      mov r0, unif
+-asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-asr ra4, r0, rb23;      mov r0, unif
+-asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-asr rb8, r0, rb23;      mov r0, unif
+-asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-brr.anynn -, r:fast_path
+-asr rb12, r0, rb23  # delay slot 1
+-
+-# r2 is elem_num
+-# r3 is loop counter
+-
+-mov r5rep, -8 # delay slot 2
+-
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
+-
+-# retrieve texture results and pick out bytes
+-# then submit two more texture requests
+-
+-## nop                                                                 ; ldtmu0     # loop counter increment
+-## shr r0, r4, ra17                                                    ; ldtmu0
+-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+-## add ra16, ra16, rb16 ; mov t0s, ra16
+-##
+-## # generate seven shifted versions
+-## # interleave with scroll of vertical context
+-##
+-## mov r2, rb21         ; mul24 r3, r0, ra0
+-## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-## sub r2, r2, r3                                                    ; ldtmu0
+-##
+-## mov r0, ra22
+-## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0
+-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+-## add ra16, ra16, rb16 ; mov t0s, ra16
+-##
+-## # apply horizontal filter
+-##
+-## asr r2, r2, 15    ; mul24 r3, r0, ra0
+-## min r2, r2, rb22
+-## max ra13, r2, 0
+-##
+-## # generate seven shifted versions
+-## # interleave with scroll of vertical context
+-##
+-## mov r2, rb21
+-## sub r2, r2, r3 ; mul24      r3, ra1 << 1, r0 << 1
+-## nop            ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
+-## nop            ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
+-## nop            ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
+-## nop            ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
+-## nop            ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
+-## nop            ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
+-## nop            ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-## sub r0, r2, r3
+-##
+-## # apply horizontal filter
+-##
+-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+-## asr r0, r0, 15
+-## min r0, r0, rb22
+-## max ra14, r0, 0
+-##
+-##
+-##
+-##
+-## nop                                                                 ; ldtmu0     # loop counter increment
+-## shr r0, r4, ra17                                                    ; ldtmu0
+-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+-## add ra16, ra16, rb16 ; mov t0s, ra16
+-##
+-## # generate seven shifted versions
+-## # interleave with scroll of vertical context
+-##
+-## mov r2, rb21         ; mul24 r3, r0, ra0
+-## sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-## nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-## sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-## nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-## sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-## nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-## sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-## nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-## sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-## nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-## sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-## nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-## sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-## nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-## sub r0, r2, r3
+-##
+-## # apply horizontal filter
+-##
+-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+-## asr r0, r0, 15
+-## min r0, r0, rb22
+-## max ra15, r0, 0
+-
+-
+-
+-
+-mov r3, 0
+-
+-:loop
+-# retrieve texture results and pick out bytes
+-# then submit two more texture requests
+-
+-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+-
+-max r2, ra_y, 0  # y
+-min r2, r2, rb_frame_height_minus_1
+-add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-add t0s, ra_x2_base, r2
+-
+-# generate seven shifted versions
+-# interleave with scroll of vertical context
+-
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-
+-mov r2, rb21         ; mul24 r3, r0, ra0
+-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-sub r0, r2, r3
+-
+-mov r3, rb31
+-
+-mov ra8, ra9
+-mov ra9, ra10
+-mov ra10, ra11
+-mov ra11, ra12
+-mov ra12, ra13
+-mov ra13, ra14
+-
+-sub.setf -, r3, 8 ; mov r1, ra22
+-
+-# apply horizontal filter
+-brr.anyn -, r:loop
+-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+-asr r0, r0, 15          ; mov r1, ra21
+-min.setf ra15, r0, rb22
+-
+-# apply vertical filter and write to VPM
+-
+-nop                     ; mul24 r0, ra14, rb14
+-sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-brr.anyn -, r:loop
+-asr r1, r1, 15
+-min r1, r1, rb22
+-max vpm, r1, 0
+-
+-# DMA out
+-
+-bra -, ra31
+-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+-mov vw_setup, rb29
+-mov vw_addr, unif # start the VDW
+-
+-####################################################
+-
+-:fast_path
+-## nop                                                                 ; ldtmu0     # loop counter increment
+-## shr r0, r4, ra17                                                    ; ldtmu0
+-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+-## add ra16, ra16, rb16 ; mov t0s, ra16
+-##
+-## # generate seven shifted versions
+-## # interleave with scroll of vertical context
+-##
+-## mov r2, rb21         ; mul24 r3, r0, ra0
+-## sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
+-## sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
+-## sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
+-## sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
+-## sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
+-## sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
+-## sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
+-## sub r2, r2, r3                                                    ; ldtmu0
+-##
+-## mov r0, ra22
+-## shr r0, r4, ra17     ; mul24 r2, r2, r0                           ; ldtmu0
+-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+-## add ra16, ra16, rb16 ; mov t0s, ra16
+-##
+-## # apply horizontal filter
+-##
+-## asr r2, r2, 15    ; mul24 r3, r0, ra0
+-## min r2, r2, rb22
+-## max ra13, r2, 0
+-##
+-## # generate seven shifted versions
+-## # interleave with scroll of vertical context
+-##
+-## mov r2, rb21
+-## sub r2, r2, r3 ; mul24    r3, ra1 << 1, r0 << 1
+-## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
+-## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
+-## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
+-## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
+-## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
+-## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
+-## sub r0, r2, r3
+-##
+-## # apply horizontal filter
+-##
+-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+-## asr r0, r0, 15
+-## min r0, r0, rb22
+-## max ra14, r0, 0
+-##
+-##
+-##
+-##
+-## nop                                                                 ; ldtmu0     # loop counter increment
+-## shr r0, r4, ra17                                                    ; ldtmu0
+-## shr r1, r4, ra17     ; v8subs r0, r0, rb20
+-## add t0s, ra16, r5    ; v8subs r1, r1, rb20
+-## add ra16, ra16, rb16 ; mov t0s, ra16
+-##
+-## # generate seven shifted versions
+-## # interleave with scroll of vertical context
+-##
+-## mov r2, rb21   ; mul24    r3, r0, ra0
+-## sub r2, r2, r3 ; mul24    r3, ra1 << 1, r0 << 1
+-## sub r2, r2, r3 ; mul24    r3, ra2 << 2, r0 << 2
+-## sub r2, r2, r3 ; mul24    r3, ra3 << 3, r0 << 3
+-## sub r2, r2, r3 ; mul24    r3, ra4 << 4, r0 << 4
+-## sub r2, r2, r3 ; mul24    r3, ra5 << 5, r0 << 5
+-## sub r2, r2, r3 ; mul24    r3, ra6 << 6, r0 << 6
+-## sub r2, r2, r3 ; mul24    r3, ra7 << 7, r0 << 7
+-## sub r0, r2, r3
+-##
+-## # apply horizontal filter
+-##
+-## nop          ; mul24 r0, r0, ra22         # last bit of context scroll, including clamp to zero
+-## asr r0, r0, 15
+-## min r0, r0, rb22
+-## max ra15, r0, 0
+-
+-
+-mov r3, 0  # This signifies the amount of unrolling
+-
+-:fast_loop
+-# retrieve texture results and pick out bytes
+-# then submit two more texture requests
+-
+-# Due to pipelining we can only skip second pipeline instructions related to the fetched pixels
+-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-mov.ifz ra_y, ra_y_next   ; mov rb31, r3
+-mov.ifz ra_x2_base, ra_x2_base_next   ; mov r3, rb_pitch
+-
+-max r2, ra_y, 0
+-min r2, r2, rb_frame_height_minus_1 ; mov r1, r4  # discard texture read
+-add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-add t0s, ra_x_base, r2    ; v8subs r0, r0, rb20
+-add t0s, ra_x2_base, r2
+-
+-# generate seven shifted versions
+-# interleave with scroll of vertical context
+-
+-mov r2, rb21         ; mul24 r3, r0, ra0
+-sub r2, r2, r3       ; mul24 r3, ra1 << 1, r0 << 1
+-sub r2, r2, r3       ; mul24 r3, ra2 << 2, r0 << 2
+-sub r2, r2, r3       ; mul24 r3, ra3 << 3, r0 << 3
+-sub r2, r2, r3       ; mul24 r3, ra4 << 4, r0 << 4
+-sub r2, r2, r3       ; mul24 r3, ra5 << 5, r0 << 5
+-sub r2, r2, r3       ; mul24 r3, ra6 << 6, r0 << 6
+-sub r2, r2, r3       ; mul24 r3, ra7 << 7, r0 << 7
+-sub r0, r2, r3       ; mov r3, rb31
+-
+-mov ra8, ra9
+-mov ra9, ra10
+-mov ra10, ra11
+-mov ra11, ra12
+-mov ra12, ra13
+-mov ra13, ra14
+-
+-sub.setf -, r3, 8       ; mov r1, ra22
+-
+-# apply horizontal filter
+-
+-brr.anyn -, r:fast_loop
+-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+-asr r0, r0, 15          ; mov r1, ra21
+-min.setf ra15, r0, rb22
+-
+-# apply vertical filter and write to VPM
+-
+-nop                     ; mul24 r0, ra14, rb14
+-sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-brr.anyn -, r:fast_loop
+-asr r1, r1, 15
+-min r1, r1, rb22
+-max vpm, r1, 0
+-
+-# DMA out
+-
+-bra -, ra31
+-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+-mov vw_setup, rb29
+-mov vw_addr, unif # start the VDW
+ 
+ ################################################################################
+ 
+-# mc_filter_b(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+-
+-# At this point we have already issued two pairs of texture requests for the current block
+-# ra_x_base, ra_x16_base point to the current coordinates for this block
+-::mc_filter_b
++::mc_filter_uv_b
+ mov ra31, unif
+ 
+ # per-channel shifts were calculated on the *previous* invocation
+ 
+ mov ra_xshift, ra_xshift_next
+-mov ra_x2shift, ra_x2shift_next
+ 
+ # get base addresses and per-channel shifts for *next* invocation
+ add r0, unif, elem_num    # x
+-add r2, r0, 8 # x+8
+ max r0, r0, 0; mov r1, unif # y
+-min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
++min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+ shl ra_xshift_next, r0, 3
+-max r2, r2, 0
+-min r2, r2, rb_frame_width_minus_1
+-shl ra_x2shift_next, r2, 3
++sub r2, unif, r3 # compute offset from frame base u to frame base v
+ add r0, r0, r3
+-add r2, r2, r3
+ and rb_x_base_next, r0, ~3
+-and ra_x2_base_next, r2, ~3
+ mov ra_y_next, r1
++add ra_x2_base_next, rb_x_base_next, r2
+ 
+ # set up VPM write
+ mov vw_setup, rb28
+@@ -801,17 +375,22 @@ and r0, r0, rb22 # Extract height
+ add rb17, r0, 5
+ add rb18, r0, 7
+ shl r0, r0, 7
++
+ # r0 is currently height<<7
+ # For vr_setup we want height<<20 (so 20-7=13 additional bits)
+ shl r3, r0, 13
+ shl r3, r3, 8 # Mask off top 8 bits
+ shr r3, r3, 8
++
+ add r0, r0, r1 # Combine width and height of destination area
+ shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+ add rb26, r0, rb27
++
+ # In a B frame, so also set up VPM read
+ add vr_setup, r3, rb28
+ 
++sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
++
+ # get filter coefficients
+ 
+ mov r0, unif
+@@ -837,9 +416,13 @@ asr rb12, r0, rb23
+ 
+ mov r5rep, -8
+ mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
+ mov r3, 0
+ 
+-:bloop
++:uvloop_b
+ # retrieve texture results and pick out bytes
+ # then submit two more texture requests
+ 
+@@ -847,7 +430,7 @@ sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+ shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+ mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+ mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
++shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+ 
+ max r2, ra_y, 0  # y
+ min r2, r2, rb_frame_height_minus_1
+@@ -861,6 +444,7 @@ add t0s, ra_x2_base, r2
+ mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ 
+ mov r2, rb21         ; mul24 r3, r0, ra0
++nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+ sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+ nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+ sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+@@ -889,7 +473,7 @@ mov ra13, ra14
+ sub.setf -, r3, 8 ; mov r1, ra22
+ 
+ # apply horizontal filter
+-brr.anyn -, r:bloop
++brr.anyn -, r:uvloop_b
+ max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+ asr r0, r0, 15          ; mov r1, ra21
+ min.setf ra15, r0, rb22
+@@ -906,213 +490,50 @@ sub r1, r1, r0          ; mul24 r0, ra8, rb8
+ sub r1, r1, r0          ; mul24 r0, ra15, rb15
+ sub.ifnn r1, r1, r0     ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-asr r1, r1, 15          ; mov -, vr_wait
++asr r1, r1, 15
+ min r1, r1, rb22
+ add r0, vpm, 1          # Blend in previous VPM contents at this location
+-brr.anyn -, r:bloop
++brr.anyn -, r:uvloop_b
+ max r1, r1, 0
+ add r1, r1, r0
+ shr vpm, r1, 1
+ 
+-# DMA out
++
++# DMA out for U
++
++mov vw_setup, rb26 # VDW setup 0
++mov vw_setup, rb29 # Stride
++mov vw_addr, unif # start the VDW
++
++# DMA out for V
++# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
++# Could potentially push this write into the start of the next pipeline stage.
++mov r0, 16
++mov -, vw_wait
+ 
+ bra -, ra31
+-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+-mov vw_setup, rb29
++add vw_setup, rb26, r0 # VDW setup 0
++mov vw_setup, rb29 # Stride
+ mov vw_addr, unif # start the VDW
+ 
+ ################################################################################
+ 
+-# mc_filter_honly(next_kernel, x, y, frame_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_dst)
+-# This filter only does horizontal filtering.
+-# It is assumed that the region to fetch does not include extra rows above.
++# mc_exit()
+ 
+-# At this point we have already issued two pairs of texture requests for the current block
+-# ra_x_base, ra_x16_base point to the current coordinates for this block
+-::mc_filter_honly
+-mov ra31, unif
++::mc_exit
++mov  -, vw_wait # wait on the VDW
+ 
+-# per-channel shifts were calculated on the *previous* invocation
++mov -,srel(0)
+ 
+-mov ra_xshift, ra_xshift_next
+-mov ra_x2shift, ra_x2shift_next
+-
+-# get base addresses and per-channel shifts for *next* invocation
+-add r0, unif, elem_num    # x
+-add r2, r0, 8 # x+8
+-max r0, r0, 0; mov r1, unif # y
+-min r0, r0, rb_frame_width_minus_1 ; mov r3,unif # frame_base
+-shl ra_xshift_next, r0, 3
+-max r2, r2, 0
+-min r2, r2, rb_frame_width_minus_1
+-shl ra_x2shift_next, r2, 3
+-add r0, r0, r3
+-add r2, r2, r3
+-and rb_x_base_next, r0, ~3
+-and ra_x2_base_next, r2, ~3
+-mov ra_y_next, r1
+-
+-# set up VPM write
+-mov vw_setup, rb28
+-
+-# get width,height of block
+-mov r2, 16
+-mov r0, unif
+-shr r1, r0, r2 # Extract width
+-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+-and r0, r0, rb22 # Extract height
+-add rb17, r0, -2 # Pipelining means we move data across 2 iterations early
+-shl r0, r0, 7 ; mov rb18,r0
+-add r0, r0, r1 # Combine width and height of destination area
+-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+-add rb26, r0, rb27
+-
+-# get filter coefficients
+-
+-mov r0, unif
+-asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-asr ra0, r0, rb23;      mov r0, unif
+-asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-asr ra4, r0, rb23;      mov r0, unif
+-mov r0, unif
+-
+-# r2 is elem_num
+-# r3 is loop counter
+-mov r5rep, -8
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]  # delay slot 3
+-mov r3, 0
+-
+-:loop_honly
+-# retrieve texture results and pick out bytes
+-# then submit two more texture requests
+-
+-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-shr r1, r4, ra_x2shift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+-
+-max r2, ra_y, 0  # y
+-min r2, r2, rb_frame_height_minus_1
+-add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-add t0s, ra_x2_base, r2
+-
+-# generate seven shifted versions
+-# interleave with scroll of vertical context
+-
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-
+-mov r2, rb21         ; mul24 r3, r0, ra0
+-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-sub r0, r2, r3       ; mov r3, rb31
+-
+-sub.setf -, r3, rb18 ; mov r1, ra22
+-
+-mov -, vw_wait   ; mul24 r0, r0, r1
+-brr.anyn -, r:loop_honly
+-asr r0, r0, 15          # delay 1
+-min r0, r0, rb22        # delay 2
+-max vpm, r0, 0          # delay 3
+-
+-# DMA out
+-bra -, ra31
+-mov vw_setup, rb26 # VDW: height rows, 16 8-bit units long
+-mov vw_setup, rb29
+-mov vw_addr, unif # start the VDW
+-
+-
+-################################################################################
+-
+-# mc_exit()
+-
+-::mc_exit
+-mov  -, vw_wait # wait on the VDW
+-
+-mov -,srel(0)
+-
+-ldtmu0
+-ldtmu0
+-ldtmu0
+-ldtmu0
++ldtmu0
++ldtmu0
++ldtmu0
++ldtmu0
+ 
+ nop        ; nop ; thrend
+ nop        ; nop # delay slot 1
+ nop        ; nop # delay slot 2
+ 
+-::mc_exit1
+-mov  -, vw_wait # wait on the VDW
+-
+-#mov -,srel(1)
+-
+-ldtmu0
+-ldtmu0
+-ldtmu0
+-ldtmu0
+-
+-nop        ; nop ; thrend
+-mov interrupt, 1; nop # delay slot 1
+-nop        ; nop # delay slot 2
+-
+-# mc_interrupt_exit()
+-::mc_interrupt_exit
+-mov  -, vw_wait # wait on the VDW
+-
+-ldtmu0
+-ldtmu0
+-ldtmu0
+-ldtmu0
+-
+-mov -,sacq(0) # 1
+-mov -,sacq(0) # 2
+-mov -,sacq(0) # 3
+-mov -,sacq(0) # 4
+-mov -,sacq(0) # 5
+-mov -,sacq(0) # 6
+-mov -,sacq(0) # 7
+-mov -,sacq(0) # 8
+-mov -,sacq(0) # 9
+-mov -,sacq(0) # 10
+-mov -,sacq(0) # 11
+-
+-nop        ; nop ; thrend
+-mov interrupt, 1; nop # delay slot 1
+-nop        ; nop # delay slot 2
+-
+-# mc_interrupt_exit4()
+-::mc_interrupt_exit4
+-mov  -, vw_wait # wait on the VDW
+-
+-ldtmu0
+-ldtmu0
+-ldtmu0
+-ldtmu0
+-
+-mov -,sacq(0) # 1
+-mov -,sacq(0) # 2
+-mov -,sacq(0) # 3
+-
+-nop        ; nop ; thrend
+-mov interrupt, 1; nop # delay slot 1
+-nop        ; nop # delay slot 2
+-
+ # mc_interrupt_exit8()
+ ::mc_interrupt_exit8
+ mov  -, vw_wait # wait on the VDW
+@@ -1134,282 +555,5 @@ nop        ; nop ; thrend
+ mov interrupt, 1; nop # delay slot 1
+ nop        ; nop # delay slot 2
+ 
+-################################################################################
+-# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
+-::mc_setup_uv
+-
+-# Read starting kernel
+-mov ra31, unif
+-
+-# Load first request location
+-add ra_x_base, unif, elem_num # Store x
+-mov ra_y, unif # Store y
+-mov ra_x2_base, unif # Store frame u base
+-nop
+-sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
+-
+-# Read image dimensions
+-sub rb25,unif,1
+-sub rb30,unif,1
+-
+-# get source pitch
+-mov rb16, unif
+-
+-# get destination pitch
+-mov r0, unif
+-mov r1, vdw_setup_1(0)
+-add rb24, r1, r0
+-
+-# load constants
+-
+-mov ra20, 1
+-mov ra21, 32
+-mov ra22, 256
+-mov ra23, 8
+-
+-mov rb20, 0xffffff00
+-mov rb21, 64
+-mov rb22, 255
+-mov rb23, 24
+-
+-# touch vertical context to keep simulator happy
+-
+-mov ra8, 0
+-mov ra9, 0
+-mov ra10, 0
+-mov ra11, 0
+-mov ra12, 0
+-mov ra13, 0
+-mov ra14, 0
+-mov ra15, 0
+-
+-# Compute part of VPM to use for DMA output
+-mov r2, qpu_num
+-and r2, r2, 15
+-mov r1, r2
+-asr r1, r1, 2
+-shl r1, r1, 6
+-mov r0, r2
+-and r0, r0, 3
+-add r0, r0, r1
+-mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+-shl r0, r0, 5
+-add rb27, r0, r1
+-
+-# Compute part of VPM to save data into
+-mov r2, qpu_num
+-and r2, r2, 15
+-mov r1, r2
+-asr r1, r1, 2
+-shl r1, r1, 6
+-mov r0, r2
+-and r0, r0, 3
+-add r0, r0, r1
+-mov r1, vpm_setup(0, 4, h8p(0, 0))
+-add rb28, r0, r1
+-
+-# Compute base address for first and second access
+-mov r0, ra_x_base           # Load x
+-max r0, r0, 0; mov r1, ra_y # Load y
+-min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
+-shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+-add ra_y, r1, 1
+-add r0, r0, r3
+-and r0, r0, ~3
+-max r1, r1, 0 ; mov ra_x_base, r0 # y
+-min r1, r1, rb_frame_height_minus_1
+-# submit texture requests for first line
+-add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+-add t0s, r0, r1 ; mov ra_x2_base, r2
+-add t0s, r2, r1
+-
+-# Dump padding words
+-mov r0, unif
+-mov r0, unif
+-mov r0, unif
+-
+-# submit texture requests for second line
+-max r1, ra_y, 0
+-min r1, r1, rb_frame_height_minus_1
+-add ra_y, ra_y, 1
+-bra -, ra31
+-nop ; mul24 r1, r1, rb_pitch
+-add t0s, r1, ra_x_base
+-add t0s, r1, ra_x2_base
+-
+-
+-
+-################################################################################
+-
+-::mc_filter_uv_b
+-mov ra31, unif
+-
+-# per-channel shifts were calculated on the *previous* invocation
+-
+-mov ra_xshift, ra_xshift_next
+-
+-# get base addresses and per-channel shifts for *next* invocation
+-add r0, unif, elem_num    # x
+-max r0, r0, 0; mov r1, unif # y
+-min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+-shl ra_xshift_next, r0, 3
+-sub r2, unif, r3 # compute offset from frame base u to frame base v
+-add r0, r0, r3
+-and rb_x_base_next, r0, ~3
+-mov ra_y_next, r1
+-add ra_x2_base_next, rb_x_base_next, r2
+-
+-# set up VPM write
+-mov vw_setup, rb28
+-
+-# get width,height of block
+-mov r2, 16
+-mov r0, unif
+-shr r1, r0, r2 # Extract width
+-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+-and r0, r0, rb22 # Extract height
+-add rb17, r0, 5
+-add rb18, r0, 7
+-shl r0, r0, 7
+-
+-# r0 is currently height<<7
+-# For vr_setup we want height<<20 (so 20-7=13 additional bits)
+-shl r3, r0, 13
+-shl r3, r3, 8 # Mask off top 8 bits
+-shr r3, r3, 8
+-
+-add r0, r0, r1 # Combine width and height of destination area
+-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+-add rb26, r0, rb27
+-
+-# In a B frame, so also set up VPM read
+-add vr_setup, r3, rb28
+-
+-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+-
+-# get filter coefficients
+-
+-mov r0, unif
+-asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-asr ra0, r0, rb23;      mov r0, unif
+-asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-asr ra4, r0, rb23;      mov r0, unif
+-asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-asr rb8, r0, rb23;      mov r0, unif
+-asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-asr rb12, r0, rb23
+-
+-# r2 is elem_num
+-# r3 is loop counter
+-
+-mov r5rep, -8
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-
+-# retrieve texture results and pick out bytes
+-# then submit two more texture requests
+-
+-mov r3, 0
+-
+-:uvloop_b
+-# retrieve texture results and pick out bytes
+-# then submit two more texture requests
+-
+-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+-
+-max r2, ra_y, 0  # y
+-min r2, r2, rb_frame_height_minus_1
+-add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-add t0s, ra_x2_base, r2
+-
+-# generate seven shifted versions
+-# interleave with scroll of vertical context
+-
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-
+-mov r2, rb21         ; mul24 r3, r0, ra0
+-nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
+-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-sub r0, r2, r3
+-
+-mov r3, rb31
+-
+-mov ra8, ra9
+-mov ra9, ra10
+-mov ra10, ra11
+-mov ra11, ra12
+-mov ra12, ra13
+-mov ra13, ra14
+-
+-sub.setf -, r3, 8 ; mov r1, ra22
+-
+-# apply horizontal filter
+-brr.anyn -, r:uvloop_b
+-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+-asr r0, r0, 15          ; mov r1, ra21
+-min.setf ra15, r0, rb22
+-
+-# apply vertical filter and write to VPM
+-
+-nop                     ; mul24 r0, ra14, rb14
+-sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-sub.ifnn r1, r1, r0     ; mov -, vw_wait
+-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-asr r1, r1, 15
+-min r1, r1, rb22
+-add r0, vpm, 1          # Blend in previous VPM contents at this location
+-brr.anyn -, r:uvloop_b
+-max r1, r1, 0
+-add r1, r1, r0
+-shr vpm, r1, 1
+-
+-
+-# DMA out for U
+-
+-mov vw_setup, rb26 # VDW setup 0
+-mov vw_setup, rb29 # Stride
+-mov vw_addr, unif # start the VDW
+-
+-# DMA out for V
+-# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
+-# Could potentially push this write into the start of the next pipeline stage.
+-mov r0, 16
+-mov -, vw_wait
+-
+-bra -, ra31
+-add vw_setup, rb26, r0 # VDW setup 0
+-mov vw_setup, rb29 # Stride
+-mov vw_addr, unif # start the VDW
+-
+ ::mc_end
++# Do not add code here because mc_end must appear after all other code.
+-- 
+2.7.4
+
+
+From d40d59de0f09fd1a6e7146532418b63d8e2711b7 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 13 May 2015 14:54:25 +0100
+Subject: [PATCH 20/68] Moved chroma P1 to QPUs
+
+---
+ libavcodec/hevc.c | 38 ++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 38 insertions(+)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 31b8b2f..391d139 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2070,6 +2070,44 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                     s->sh.luma_offset_l1[current_mv.ref_idx[1]]);
+ 
+         if (s->ps.sps->chroma_format_idc) {
++#ifdef RPI_INTER_QPU
++            if (s->enable_rpi) {
++                int reflist = 1;
++                int hshift           = s->ps.sps->hshift[1];
++                int vshift           = s->ps.sps->vshift[1];
++                const Mv *mv         = &current_mv.mv[reflist];
++                intptr_t mx          = av_mod_uintp2(mv->x, 2 + hshift);
++                intptr_t my          = av_mod_uintp2(mv->y, 2 + vshift);
++                intptr_t _mx         = mx << (1 - hshift);
++                intptr_t _my         = my << (1 - vshift); // Fractional part of motion vector
++
++                int x1_c = x0_c + (mv->x >> (2 + hshift));
++                int y1_c = y0_c + (mv->y >> (2 + hshift));
++                //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
++                int chan = x0>>8;
++
++                uint32_t *u = s->u_mvs[chan & 7];
++                for(int start_y=0;start_y < nPbH_c;start_y+=16) {
++                  for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
++                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
++                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
++                      *u++ = rpi_filter_coefs[_mx][0];
++                      *u++ = rpi_filter_coefs[_mx][1];
++                      *u++ = rpi_filter_coefs[_my][0];
++                      *u++ = rpi_filter_coefs[_my][1];
++                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
++                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
++                    }
++                }
++                s->u_mvs[chan & 7] = u;
++                return;
++            }
++#endif
+             RPI_REDIRECT(chroma_mc_uni)(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],
+                           1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
+                           s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);
+-- 
+2.7.4
+
+
+From 75777ba7927086e862104b14f6446e81bc789611 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 13 May 2015 15:13:47 +0100
+Subject: [PATCH 21/68] Added B prediction - not quite right
+
+---
+ libavcodec/hevc.c          |  58 ++++++++++++++++++++++++
+ libavcodec/rpi_shader.c    | 108 +++++++++++++++++++++++----------------------
+ libavcodec/rpi_shader.h    |   6 +--
+ libavcodec/rpi_shader.qasm |  48 ++++++++++----------
+ 4 files changed, 141 insertions(+), 79 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 391d139..47ddfff 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2127,6 +2127,64 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                    ref1->frame, &current_mv.mv[1], &current_mv);
+ 
+         if (s->ps.sps->chroma_format_idc) {
++#ifdef RPI_INTER_QPU
++            if (s->enable_rpi) {
++                int hshift           = s->ps.sps->hshift[1];
++                int vshift           = s->ps.sps->vshift[1];
++                const Mv *mv         = &current_mv.mv[0];
++                intptr_t mx          = av_mod_uintp2(mv->x, 2 + hshift);
++                intptr_t my          = av_mod_uintp2(mv->y, 2 + vshift);
++                intptr_t _mx         = mx << (1 - hshift);
++                intptr_t _my         = my << (1 - vshift); // Fractional part of motion vector
++                int x1_c = x0_c + (mv->x >> (2 + hshift));
++                int y1_c = y0_c + (mv->y >> (2 + hshift));
++
++                const Mv *mv2         = &current_mv.mv[1];
++                intptr_t mx2          = av_mod_uintp2(mv2->x, 2 + hshift);
++                intptr_t my2          = av_mod_uintp2(mv2->y, 2 + vshift);
++                intptr_t _mx2         = mx2 << (1 - hshift);
++                intptr_t _my2         = my2 << (1 - vshift); // Fractional part of motion vector
++
++                int x2_c = x0_c + (mv2->x >> (2 + hshift));
++                int y2_c = y0_c + (mv2->y >> (2 + hshift));
++
++                int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
++
++                uint32_t *u = s->u_mvs[chan & 7];
++                for(int start_y=0;start_y < nPbH_c;start_y+=16) {
++                  for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
++                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
++                      *u++ = rpi_filter_coefs[_mx][0];
++                      *u++ = rpi_filter_coefs[_mx][1];
++                      *u++ = rpi_filter_coefs[_my][0];
++                      *u++ = rpi_filter_coefs[_my][1];
++                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]); // TODO this will become unused once we have a dedicated pass0 filter
++                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
++
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = x2_c - 3 + start_x;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = y2_c - 3 + start_y;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
++                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
++                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
++                      *u++ = rpi_filter_coefs[_mx2][0];
++                      *u++ = rpi_filter_coefs[_mx2][1];
++                      *u++ = rpi_filter_coefs[_my2][0];
++                      *u++ = rpi_filter_coefs[_my2][1];
++                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
++                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
++                    }
++                }
++                s->u_mvs[chan & 7] = u;
++                return;
++            }
++#endif
+             RPI_REDIRECT(chroma_mc_bi)(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,
+                          x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);
+ 
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 170e8ac..5d00cb2 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -265,23 +265,23 @@ unsigned int rpi_shader[] = {
+ /* [0x00000760] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+ /* [0x00000768] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+ /* [0x00000770] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000778] */ 0x55015fc6, 0x100248a3, // mov r2, rb21         ; mul24 r3, r0, ra0
+-/* [0x00000780] */ 0x40038031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+-/* [0x00000788] */ 0x4d07f4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000778] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000780] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000788] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+ /* [0x00000790] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000798] */ 0x4d0be4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000798] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ /* [0x000007a0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000007a8] */ 0x4d0fd4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000007a8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ /* [0x000007b0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000007b8] */ 0x4d13c4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x000007b8] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+ /* [0x000007c0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x000007c8] */ 0x4d17b4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x000007c8] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+ /* [0x000007d0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x000007d8] */ 0x4d1ba4f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x000007d8] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+ /* [0x000007e0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x000007e8] */ 0x4d1f94f0, 0xd00248a3, // sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x000007e8] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+ /* [0x000007f0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x000007f8] */ 0x0d9e74c0, 0x10020827, // sub r0, r2, r3
++/* [0x000007f8] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+ /* [0x00000800] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+ /* [0x00000808] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+ /* [0x00000810] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+@@ -291,61 +291,63 @@ unsigned int rpi_shader[] = {
+ /* [0x00000830] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+ /* [0x00000838] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+ /* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000848] */ 0x533c0dc1, 0xd00243a0, // max ra14, ra15, 0       ; mul24 r0, r0, r1
+-/* [0x00000850] */ 0x8f54f1f6, 0xd0024821, // asr r0, r0, 15          ; mov r1, ra21
+-/* [0x00000858] */ 0x129d61c0, 0x100223e7, // min.setf ra15, r0, rb22
+-/* [0x00000860] */ 0x4038e037, 0x100049e0, // nop                     ; mul24 r0, ra14, rb14
+-/* [0x00000868] */ 0x4d34d237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-/* [0x00000870] */ 0x4d30c237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000878] */ 0x4d2cb237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000880] */ 0x4d28a237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000888] */ 0x4d249237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000890] */ 0x4d208237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000898] */ 0x4d3cf237, 0x10024860, // sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x000008a0] */ 0x8d9f223f, 0x100a0867, // sub.ifnn r1, r1, r0     ; mov -, vw_wait
++/* [0x00000848] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x00000850] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x00000858] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x00000860] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x00000868] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x00000870] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000878] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000880] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000888] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000890] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000898] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x000008a0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+ /* [0x000008a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000008b0] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
+-/* [0x000008b8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000008c0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+-/* [0x000008c8] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000008d0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x000008d8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+-/* [0x000008e0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+-/* [0x000008e8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000008f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000008f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000900] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000908] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000910] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000918] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000920] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000928] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000008b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000008b8] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x000008c0] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x000008c8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000008d0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
++/* [0x000008d8] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000008e0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x000008e8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x000008f0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
++/* [0x000008f8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000900] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000908] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000910] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000918] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000920] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000928] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000930] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000938] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000930] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000938] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00000940] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000948] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000940] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000948] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+ /* [0x00000950] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000958] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000960] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000968] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000970] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000960] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000968] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000970] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000978] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000980] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000978] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000980] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000988] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000988] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+ /* [0x00000990] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000998] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000009a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000009a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000009a8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x000009b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x000009b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x000009c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x000009c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x000009d0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000009d8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x000009e0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x000009e8] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x000009d8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009e0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000009e8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000009f0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x000009f8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 9de4535..e36c4ae 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -6,8 +6,8 @@ extern unsigned int rpi_shader[];
+ #define mc_setup_uv (rpi_shader + 0)
+ #define mc_filter_uv (rpi_shader + 142)
+ #define mc_filter_uv_b (rpi_shader + 360)
+-#define mc_exit (rpi_shader + 588)
+-#define mc_interrupt_exit8 (rpi_shader + 606)
+-#define mc_end (rpi_shader + 636)
++#define mc_exit (rpi_shader + 592)
++#define mc_interrupt_exit8 (rpi_shader + 610)
++#define mc_end (rpi_shader + 640)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index cd7346d..870437d2 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -443,23 +443,23 @@ add t0s, ra_x2_base, r2
+ 
+ mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ 
+-mov r2, rb21         ; mul24 r3, r0, ra0
+-nop                  ; mul24.ifnz r3, ra0 << 8, r1 << 8
+-sub r2, r2, r3       ; mul24      r3, ra1 << 1, r0 << 1
++nop                  ; mul24 r2, r0, ra0
++nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++nop                  ; mul24      r3, ra1 << 1, r0 << 1
+ nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-sub r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-sub r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-sub r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+ nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-sub r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+ nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-sub r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+ nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-sub r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+ nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-sub r0, r2, r3
++add r0, r2, r3
+ 
+ mov r3, rb31
+ 
+@@ -474,23 +474,25 @@ sub.setf -, r3, 8 ; mov r1, ra22
+ 
+ # apply horizontal filter
+ brr.anyn -, r:uvloop_b
+-max ra14, ra15, 0       ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+-asr r0, r0, 15          ; mov r1, ra21
+-min.setf ra15, r0, rb22
++mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
++asr ra15, r0, 8         ; nop
++nop                     ; nop
+ 
+ # apply vertical filter and write to VPM
+ 
+-nop                     ; mul24 r0, ra14, rb14
+-sub r1, r1, r0          ; mul24 r0, ra13, rb13
+-sub r1, r1, r0          ; mul24 r0, ra12, rb12
+-sub r1, r1, r0          ; mul24 r0, ra11, rb11
+-sub r1, r1, r0          ; mul24 r0, ra10, rb10
+-sub r1, r1, r0          ; mul24 r0, ra9, rb9
+-sub r1, r1, r0          ; mul24 r0, ra8, rb8
+-sub r1, r1, r0          ; mul24 r0, ra15, rb15
+-sub.ifnn r1, r1, r0     ; mov -, vw_wait
++nop                     ; mul24 r1, ra14, rb14
++nop                     ; mul24 r0, ra13, rb13
++add r1, r1, r0          ; mul24 r0, ra12, rb12
++add r1, r1, r0          ; mul24 r0, ra11, rb11
++add r1, r1, r0          ; mul24 r0, ra10, rb10
++add r1, r1, r0          ; mul24 r0, ra9, rb9
++add r1, r1, r0          ; mul24 r0, ra8, rb8
++add r1, r1, r0          ; mul24 r0, ra15, rb15
++add r1, r1, r0          ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-asr r1, r1, 15
++asr r1, r1, 14
++add r1, r1, ra21
++asr r1, r1, 6
+ min r1, r1, rb22
+ add r0, vpm, 1          # Blend in previous VPM contents at this location
+ brr.anyn -, r:uvloop_b
+-- 
+2.7.4
+
+
+From 3d4e94b8f0b08fe4c0b582fc7f1dbe9d1d9d60ed Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 08:15:55 +0100
+Subject: [PATCH 22/68] Added flush for SAO
+
+---
+ libavcodec/hevc.c        |  2 +-
+ libavcodec/hevc_filter.c | 39 ++++++++++++++++++++++++++-------------
+ 2 files changed, 27 insertions(+), 14 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 47ddfff..93e1eba 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2903,7 +2903,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+             rpi_execute_inter_qpu(s);
+ #endif
+             // Transform all blocks
+-            //printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
++            // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+             rpi_execute_transform(s);
+             // Perform inter prediction
+             rpi_execute_inter_cmds(s);
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 9b6e26d..92a8271 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -871,6 +871,21 @@ static void flush_buffer(AVBufferRef *bref) {
+     GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+     gpu_cache_flush(p);
+ }
++
++static void ff_hevc_flush_chroma(HEVCContext *s)
++{
++    if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
++            s->nal_unit_type == NAL_TSA_N   ||
++            s->nal_unit_type == NAL_STSA_N  ||
++            s->nal_unit_type == NAL_RADL_N  ||
++            s->nal_unit_type == NAL_RASL_N )) {
++        flush_buffer(s->frame->buf[1]);
++        flush_buffer(s->frame->buf[2]);
++        //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
++        //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
++        //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
++    }
++}
+ #endif
+ 
+ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+@@ -886,31 +901,29 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+             sao_filter_CTB(s, x - ctb_size, y);
+         if (y && x_end) {
+             sao_filter_CTB(s, x, y - ctb_size);
+-            if (s->threads_type & FF_THREAD_FRAME )
++            if (s->threads_type & FF_THREAD_FRAME ) {
++#ifdef RPI_INTER_QPU
++                ff_hevc_flush_chroma(s);
++#endif
+                 ff_thread_report_progress(&s->ref->tf, y, 0);
++            }
+         }
+         if (x_end && y_end) {
+             sao_filter_CTB(s, x , y);
+-            if (s->threads_type & FF_THREAD_FRAME )
++            if (s->threads_type & FF_THREAD_FRAME ) {
++#ifdef RPI_INTER_QPU
++                ff_hevc_flush_chroma(s);
++#endif
+                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
++            }
+         }
+     } else if (s->threads_type & FF_THREAD_FRAME && x_end) {
+         //int newh = y + ctb_size - 4;
+         //int currh = s->ref->tf.progress->data[0];
+         //if (((y + ctb_size)&63)==0)
+-        if (!(  s->nal_unit_type == NAL_TRAIL_N ||
+-            s->nal_unit_type == NAL_TSA_N   ||
+-            s->nal_unit_type == NAL_STSA_N  ||
+-            s->nal_unit_type == NAL_RADL_N  ||
+-            s->nal_unit_type == NAL_RASL_N )) {
+ #ifdef RPI_INTER_QPU
+-            flush_buffer(s->frame->buf[1]);
+-            flush_buffer(s->frame->buf[2]);
++        ff_hevc_flush_chroma(s);
+ #endif
+-            //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
+-            //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
+-            //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
+-        }
+         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
+     }
+ }
+-- 
+2.7.4
+
+
+From 3e337b9c4ef0c356a0259be2254ad1bc4d5bbe29 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 09:17:28 +0100
+Subject: [PATCH 23/68] Stopped using acceleration in unsupported cases
+
+---
+ libavcodec/hevc.c       | 14 +++++++-------
+ libavcodec/hevc_cabac.c |  4 ++--
+ 2 files changed, 9 insertions(+), 9 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 93e1eba..bfd5a55 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -1152,15 +1152,11 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+                         for (i = 0; i < (size * size); i++) {
+                             coeffs[i] = ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
+                         }
+-                        printf("Cross component not supported\n"); // TODO
+-                        exit(-1);
+                         s->hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
+                     }
+             }
+ 
+             if (lc->tu.cross_pf) {
+-                printf("Cross component not supported\n"); // TODO
+-                exit(-1);
+                 hls_cross_component_pred(s, 1);
+             }
+             for (i = 0; i < (s->ps.sps->chroma_format_idc == 2 ? 2 : 1); i++) {
+@@ -1189,8 +1185,6 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+                         for (i = 0; i < (size * size); i++) {
+                             coeffs[i] = ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);
+                         }
+-                        printf("Cross component not supported\n"); // TODO
+-                        exit(-1);
+                         s->hevcdsp.transform_add[log2_trafo_size_c-2](dst, coeffs, stride);
+                     }
+             }
+@@ -2857,7 +2851,13 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     int ctb_addr_ts = s->ps.pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
+ 
+ #ifdef RPI
+-    s->enable_rpi = 1; // TODO this should depend on cross component and frame width etc.
++    s->enable_rpi = s->ps.sps->bit_depth == 8
++                    && s->ps.sps->width <= RPI_MAX_WIDTH
++                    && !s->ps.pps->cross_component_prediction_enabled_flag
++                    && s->ps.pps->num_tile_rows <= 1 && s->ps.pps->num_tile_columns <= 1
++                    && !(s->ps.pps->weighted_pred_flag && s->sh.slice_type == P_SLICE)
++                    && !(s->ps.pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE);
++
+ #endif
+ 
+     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index 4f072be..38f53de 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -1513,9 +1513,9 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+ #ifdef RPI
+             if (!use_vpu) {
+               int max_xy = FFMAX(last_significant_coeff_x, last_significant_coeff_y);
+-              if (max_xy == 0)
++              if (max_xy == 0) {
+                   s->hevcdsp.idct_dc[log2_trafo_size-2](coeffs);
+-              else {
++              } else {
+                   int col_limit = last_significant_coeff_x + last_significant_coeff_y + 4;
+                   if (max_xy < 4)
+                       col_limit = FFMIN(4, col_limit);
+-- 
+2.7.4
+
+
+From 3941d3e4c2305fa037e8aba5a14cf698ac8673db Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 09:42:16 +0100
+Subject: [PATCH 24/68] Split B prediction into two passes
+
+---
+ libavcodec/hevc.c          |   1 +
+ libavcodec/hevc.h          |   1 +
+ libavcodec/rpi_qpu.c       |   3 +
+ libavcodec/rpi_qpu.h       |   1 +
+ libavcodec/rpi_shader.c    | 559 +++++++++++++++++++++++++++------------------
+ libavcodec/rpi_shader.h    |  11 +-
+ libavcodec/rpi_shader.qasm | 196 ++++++++++++++--
+ 7 files changed, 531 insertions(+), 241 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index bfd5a55..4b133d2 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -3801,6 +3801,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+             p += uv_commands_per_qpu;
+         }
+         s->mc_filter_uv = qpu_get_fn(QPU_MC_FILTER_UV);
++        s->mc_filter_uv_b0 = qpu_get_fn(QPU_MC_FILTER_UV_B0);
+         s->mc_filter_uv_b = qpu_get_fn(QPU_MC_FILTER_UV_B);
+ 
+     }
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index d513579..4a39e39 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -917,6 +917,7 @@ typedef struct HEVCContext {
+     uint32_t *u_mvs[8];
+     // Function pointers
+     uint32_t mc_filter_uv;
++    uint32_t mc_filter_uv_b0;
+     uint32_t mc_filter_uv_b;
+ #endif
+ 
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 4e90cc1..60bf079 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -636,6 +636,9 @@ unsigned int qpu_get_fn(int num) {
+     case QPU_MC_FILTER_UV:
+       fn = mc_filter_uv;
+       break;
++    case QPU_MC_FILTER_UV_B0:
++      fn = mc_filter_uv_b0;
++      break;
+     case QPU_MC_FILTER_UV_B:
+       fn = mc_filter_uv_b;
+       break;
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index f9ad333..543c84b 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -29,6 +29,7 @@ enum {
+   QPU_MC_FILTER_HONLY,
+   QPU_MC_SETUP_UV,
+   QPU_MC_FILTER_UV,
++  QPU_MC_FILTER_UV_B0,
+   QPU_MC_FILTER_UV_B,
+   QPU_MC_INTERRUPT_EXIT8,
+   QPU_MC_END
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 5d00cb2..88ad20b 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -39,18 +39,18 @@ unsigned int rpi_shader[] = {
+ /* [0x00000070] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+ /* [0x00000078] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+ /* [0x00000080] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+-/* [0x00000088] */ 0x00000040, 0xe0021567, // mov rb21, 64
+-/* [0x00000090] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+-/* [0x00000098] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+-/* [0x000000a0] */ 0x00000000, 0xe0020227, // mov ra8, 0
+-/* [0x000000a8] */ 0x00000000, 0xe0020267, // mov ra9, 0
+-/* [0x000000b0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+-/* [0x000000b8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+-/* [0x000000c0] */ 0x00000000, 0xe0020327, // mov ra12, 0
+-/* [0x000000c8] */ 0x00000000, 0xe0020367, // mov ra13, 0
+-/* [0x000000d0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+-/* [0x000000d8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x000000e0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000088] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x00000090] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x00000098] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x000000a0] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x000000a8] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x000000b0] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x000000b8] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x000000c0] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x000000c8] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x000000d0] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x000000d8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x000000e0] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+ /* [0x000000e8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+ /* [0x000000f0] */ 0x159e7480, 0x10020867, // mov r1, r2
+ /* [0x000000f8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+@@ -62,176 +62,176 @@ unsigned int rpi_shader[] = {
+ /* [0x00000128] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+ /* [0x00000130] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+ /* [0x00000138] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00000140] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x00000148] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000150] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000158] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000160] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000168] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000170] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000178] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x00000180] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x00000188] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+-/* [0x00000190] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+-/* [0x00000198] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+-/* [0x000001a0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+-/* [0x000001a8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x000001b0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000001b8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x000001c0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+-/* [0x000001c8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x000001d0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+-/* [0x000001d8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+-/* [0x000001e0] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+-/* [0x000001e8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000001f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000001f8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000200] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000208] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000210] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000218] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000220] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000228] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+-/* [0x00000230] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++/* [0x00000140] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
++/* [0x00000148] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00000150] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000158] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000160] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000168] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000170] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000178] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000180] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000188] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x00000190] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
++/* [0x00000198] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
++/* [0x000001a0] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
++/* [0x000001a8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
++/* [0x000001b0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
++/* [0x000001b8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
++/* [0x000001c0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
++/* [0x000001c8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x000001d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000001d8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x000001e0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
++/* [0x000001e8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x000001f0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
++/* [0x000001f8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
++/* [0x00000200] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
++/* [0x00000208] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000218] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000220] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000228] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000230] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000238] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000240] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000248] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
++/* [0x00000250] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+ // ::mc_filter_uv
+-/* [0x00000238] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000240] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000248] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000250] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000258] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000260] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000268] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000270] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000278] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000280] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000288] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000290] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000298] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000002a0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000002a8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000002b0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000002b8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000002c0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x000002c8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x000002d0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000002d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000002e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000002e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000002f0] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x000002f8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000300] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000308] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000310] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000318] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000320] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000328] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000330] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000338] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000340] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000348] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000350] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000358] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000360] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000368] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000370] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000378] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000380] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000388] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000390] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000258] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000260] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000268] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000270] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000278] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000280] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000288] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000290] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000298] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000002a0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000002a8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000002b0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000002b8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000002c0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000002c8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000002d0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000002d8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000002e0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x000002e8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x000002f0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000002f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000300] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000308] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000310] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000340] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000348] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000350] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000358] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000360] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000368] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000370] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000378] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000380] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000388] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000390] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000398] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x000003a0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000003a8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000003b0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x00000398] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000003a0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x000003a8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x000003b0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000003b8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000003c0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000003c8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003d0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000003d8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000003e0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x000003e8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000003f0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000003f8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000400] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000408] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000410] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000418] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000420] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000428] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000430] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000438] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000440] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000448] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000450] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000458] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000460] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000468] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000470] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000478] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000480] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000488] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000490] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000498] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x000004a0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x000004a8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000004b0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x000004b8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000004c0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x000004c8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x000004d0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x000004d8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x000004e0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x000004e8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x000004f0] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x000004f8] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000500] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000508] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000510] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000518] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000520] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000528] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000530] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x00000538] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000540] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x00000548] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000550] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000558] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000560] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000568] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000570] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000578] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000580] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000588] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000590] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000598] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-// ::mc_filter_uv_b
+-/* [0x000005a0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000005a8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000005b0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000005b8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000005c0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000005c8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000005d0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000005d8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000005e0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000005e8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000005f0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000005f8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000600] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000608] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000610] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000618] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000620] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000628] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000630] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000638] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000640] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000648] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000650] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000658] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000660] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000668] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000670] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
++/* [0x000003b8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000003c0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x000003c8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x000003d0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000003d8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000003e0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000003e8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003f0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003f8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000400] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000408] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000410] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000418] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000420] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000428] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000430] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000438] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000440] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000448] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000450] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000458] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000460] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000468] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000470] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000478] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000480] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000488] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000490] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000498] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x000004a0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x000004a8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x000004b0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x000004b8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x000004c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x000004c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000004d0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x000004d8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x000004e0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x000004e8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x000004f0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x000004f8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x00000500] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x00000508] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000510] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000518] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000520] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000528] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000530] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000538] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000540] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000548] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000550] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x00000558] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000560] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x00000568] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000570] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000578] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000580] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000588] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000590] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000598] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000005a0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000005a8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000005b0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000005b8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_filter_uv_b0
++/* [0x000005c0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000005c8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000005d0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000005d8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000005e0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000005e8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000005f0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000005f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000600] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000608] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000610] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000618] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000620] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000628] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000630] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000638] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000640] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000648] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000650] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000658] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000660] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000668] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000670] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+ /* [0x00000678] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+ /* [0x00000680] */ 0x15827d80, 0x10020827, // mov r0, unif
+ /* [0x00000688] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+@@ -253,7 +253,7 @@ unsigned int rpi_shader[] = {
+ /* [0x00000708] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+ /* [0x00000710] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ /* [0x00000718] */ 0x00000000, 0xe00208e7, // mov r3, 0
+-// :uvloop_b
++// :uvloop_b0
+ /* [0x00000720] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+ /* [0x00000728] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+ /* [0x00000730] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+@@ -290,7 +290,7 @@ unsigned int rpi_shader[] = {
+ /* [0x00000828] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+ /* [0x00000830] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+ /* [0x00000838] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+ /* [0x00000848] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+ /* [0x00000850] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+ /* [0x00000858] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+@@ -306,48 +306,163 @@ unsigned int rpi_shader[] = {
+ /* [0x000008a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+ /* [0x000008b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+ /* [0x000008b8] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x000008c0] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x000008c8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000008d0] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+-/* [0x000008d8] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000008e0] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x000008e8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+-/* [0x000008f0] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+-/* [0x000008f8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000900] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000908] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000910] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000918] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000920] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000928] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000930] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000938] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000008c0] */ 0xfffffad8, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x000008c8] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x000008d0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000008d8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000008e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000008e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000008f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000008f8] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000900] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000908] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000910] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000918] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000920] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_filter_uv_b
++/* [0x00000928] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000930] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000938] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000940] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000948] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000950] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000958] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000960] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000968] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000970] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000978] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000980] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000988] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000990] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000998] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000009a0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000009a8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000009b0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x000009b8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x000009c0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000009c8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x000009d0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x000009d8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x000009e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000009e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000009f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000009f8] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
++/* [0x00000a00] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000a08] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000a10] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a18] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a20] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a28] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000a30] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a38] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a40] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a48] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000a50] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a58] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a60] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a68] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000a70] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a78] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a80] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a88] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000a90] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000a98] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000aa0] */ 0x00000000, 0xe00208e7, // mov r3, 0
++// :uvloop_b
++/* [0x00000aa8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000ab0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000ab8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000ac0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000ac8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000ad0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000ad8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000ae0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000ae8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000af0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000af8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000b00] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000b08] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000b10] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000b18] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000b20] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000b28] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000b30] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000b38] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000b40] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000b48] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000b50] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000b58] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000b60] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000b68] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000b70] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000b78] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000b80] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000b88] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000b90] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000b98] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000ba0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000ba8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000bb0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000bb8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000bc0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000bc8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000bd0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x00000bd8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x00000be0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x00000be8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x00000bf0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x00000bf8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000c00] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000c08] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000c10] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000c18] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000c20] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000c28] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000c30] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000c38] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000c40] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x00000c48] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x00000c50] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000c58] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
++/* [0x00000c60] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000c68] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x00000c70] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x00000c78] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
++/* [0x00000c80] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000c88] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000c90] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000c98] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000ca0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000ca8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000cb0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000cb8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000cc0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000940] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000948] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00000950] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000958] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000960] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000968] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000970] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000978] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000980] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000cc8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000cd0] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000cd8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ce0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ce8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000cf0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000cf8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000d00] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000d08] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000988] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000990] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000998] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000009a0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000009a8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000009b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000009b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000009c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000009c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000009d0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000009d8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000009e0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000009e8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x000009f0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x000009f8] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000d10] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000d18] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000d20] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000d28] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000d30] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000d38] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000d40] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000d48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000d50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000d58] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000d60] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000d68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000d70] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000d78] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000d80] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index e36c4ae..809e582 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -4,10 +4,11 @@
+ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+-#define mc_filter_uv (rpi_shader + 142)
+-#define mc_filter_uv_b (rpi_shader + 360)
+-#define mc_exit (rpi_shader + 592)
+-#define mc_interrupt_exit8 (rpi_shader + 610)
+-#define mc_end (rpi_shader + 640)
++#define mc_filter_uv (rpi_shader + 150)
++#define mc_filter_uv_b0 (rpi_shader + 368)
++#define mc_filter_uv_b (rpi_shader + 586)
++#define mc_exit (rpi_shader + 818)
++#define mc_interrupt_exit8 (rpi_shader + 836)
++#define mc_end (rpi_shader + 866)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 870437d2..635b894 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -26,7 +26,7 @@
+ # ra23                                          8
+ #
+ # rb20                                          0xffffff00
+-# rb21                                          64
++# rb21                                          vpm_setup for writing 16bit results into VPM
+ # rb22                                          255
+ # rb23                                          24
+ #
+@@ -34,7 +34,7 @@
+ # rb25                                          frame width-1
+ # rb26                                          height<<23 + width<<16 + vdw_setup_0
+ # rb27                                          vdw_setup_0 (depends on QPU number)
+-# rb28                                          vpm_setup (depends on QPU number)
++# rb28                                          vpm_setup (depends on QPU number) for writing 8bit results into VPM
+ # rb29                                          vdw_setup_1(dst_pitch-width)
+ # rb30                                          frame height-1
+ # rb31                                          used as temp to count loop iterations
+@@ -69,8 +69,6 @@
+ .set ra_y_next,                    ra28
+ .set ra_y,                         ra29
+ 
+-.set rb_const_64,                  rb21
+-
+ 
+ ################################################################################
+ # mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
+@@ -106,7 +104,6 @@ mov ra22, 256
+ mov ra23, 8
+ 
+ mov rb20, 0xffffff00
+-mov rb21, 64
+ mov rb22, 255
+ mov rb23, 24
+ 
+@@ -123,6 +120,7 @@ mov ra15, 0
+ 
+ # Compute part of VPM to use for DMA output
+ mov r2, qpu_num
++shl r2, r2, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
+ and r2, r2, 15
+ mov r1, r2
+ asr r1, r1, 2
+@@ -135,16 +133,21 @@ shl r0, r0, 5
+ add rb27, r0, r1
+ 
+ # Compute part of VPM to save data into
+-mov r2, qpu_num
+-and r2, r2, 15
+-mov r1, r2
+-asr r1, r1, 2
+-shl r1, r1, 6
+-mov r0, r2
+-and r0, r0, 3
+-add r0, r0, r1
+-mov r1, vpm_setup(0, 4, h8p(0, 0))
++mov r2, qpu_num   # qpu_num = abcd
++shl r2, r2, 1
++and r2, r2, 15    # r2 = bcd0
++mov r1, r2        # r1 = bcd0
++asr r1, r1, 2     # r1 = bc
++shl r1, r1, 6     # r1 = bc000000
++mov r0, r2        # r0 = bcd0
++and r0, r0, 3     # r0 = d0
++add r0, r0, r1    # r0 = bc0000d0
++mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
+ add rb28, r0, r1
++asr r0, r0, 1     # r0 = bc0000d
++# Prepare VPM command for 16bit intermediates
++mov r1, vpm_setup(0, 2, h16p(0, 0))  # 2 is stride - stride acts on ADDR which is Y[5:0],H[0] for 16 bit
++add rb21, r0, r1
+ 
+ # Compute base address for first and second access
+ mov r0, ra_x_base           # Load x
+@@ -345,6 +348,171 @@ mov vw_addr, unif # start the VDW
+ 
+ ################################################################################
+ 
++# mc_filter_uv_b0(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
++
++# At this point we have already issued two pairs of texture requests for the current block
++# ra_x_base, ra_x16_base point to the current coordinates for this block
++::mc_filter_uv_b0
++mov ra31, unif
++
++# per-channel shifts were calculated on the *previous* invocation
++
++mov ra_xshift, ra_xshift_next
++
++# get base addresses and per-channel shifts for *next* invocation
++add r0, unif, elem_num    # x
++max r0, r0, 0; mov r1, unif # y
++min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
++shl ra_xshift_next, r0, 3
++sub r2, unif, r3 # compute offset from frame base u to frame base v
++add r0, r0, r3
++and rb_x_base_next, r0, ~3
++mov ra_y_next, r1
++add ra_x2_base_next, rb_x_base_next, r2
++
++# set up VPM write
++mov vw_setup, rb28
++
++# get width,height of block
++mov r2, 16
++mov r0, unif
++shr r1, r0, r2 # Extract width
++sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
++and r0, r0, rb22 # Extract height
++add rb17, r0, 5
++add rb18, r0, 7
++shl r0, r0, 7
++add r0, r0, r1 # Combine width and height of destination area
++shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
++add rb26, r0, rb27
++
++sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
++
++# get filter coefficients
++
++mov r0, unif
++asr ra3, r0, rb23;      mul24 r0, r0, ra22
++asr ra2, r0, rb23;      mul24 r0, r0, ra22
++asr ra1, r0, rb23;      mul24 r0, r0, ra22
++asr ra0, r0, rb23;      mov r0, unif
++asr ra7, r0, rb23;      mul24 r0, r0, ra22
++asr ra6, r0, rb23;      mul24 r0, r0, ra22
++asr ra5, r0, rb23;      mul24 r0, r0, ra22
++asr ra4, r0, rb23;      mov r0, unif
++asr rb11, r0, rb23;     mul24 r0, r0, ra22
++asr rb10, r0, rb23;     mul24 r0, r0, ra22
++asr rb9, r0, rb23;      mul24 r0, r0, ra22
++asr rb8, r0, rb23;      mov r0, unif
++asr rb15, r0, rb23;     mul24 r0, r0, ra22
++asr rb14, r0, rb23;     mul24 r0, r0, ra22
++asr rb13, r0, rb23;     mul24 r0, r0, ra22
++asr rb12, r0, rb23
++
++# r2 is elem_num
++# r3 is loop counter
++
++mov r5rep, -8
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++mov r3, 0
++
++:uvloop_b0
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
++shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
++
++max r2, ra_y, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++add t0s, ra_x2_base, r2
++
++# generate seven shifted versions
++# interleave with scroll of vertical context
++
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++nop                  ; mul24 r2, r0, ra0
++nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++nop                  ; mul24      r3, ra1 << 1, r0 << 1
++nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++add r0, r2, r3
++
++mov r3, rb31
++
++mov ra8, ra9
++mov ra9, ra10
++mov ra10, ra11
++mov ra11, ra12
++mov ra12, ra13
++mov ra13, ra14
++
++sub.setf -, r3, 8 ; mov r1, ra22
++
++# apply horizontal filter
++brr.anyn -, r:uvloop_b0
++mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
++asr ra15, r0, 8         ; nop
++nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
++
++# apply vertical filter and write to VPM
++
++nop                     ; mul24 r1, ra14, rb14
++nop                     ; mul24 r0, ra13, rb13
++add r1, r1, r0          ; mul24 r0, ra12, rb12
++add r1, r1, r0          ; mul24 r0, ra11, rb11
++add r1, r1, r0          ; mul24 r0, ra10, rb10
++add r1, r1, r0          ; mul24 r0, ra9, rb9
++add r1, r1, r0          ; mul24 r0, ra8, rb8
++add r1, r1, r0          ; mul24 r0, ra15, rb15
++add r1, r1, r0          ; mov -, vw_wait
++sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++asr r1, r1, 14
++add r1, r1, ra21
++brr.anyn -, r:uvloop
++asr r1, r1, 6          # Delay 1
++min r1, r1, rb22       # Delay 2
++max vpm, r1, 0         # Delay 3
++
++# DMA out for U
++
++mov vw_setup, rb26 # VDW setup 0
++mov vw_setup, rb29 # Stride
++mov vw_addr, unif # start the VDW
++
++# DMA out for V
++# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
++# Could potentially push this write into the start of the next pipeline stage.
++mov r0, 16
++mov -, vw_wait
++
++bra -, ra31
++add vw_setup, rb26, r0 # VDW setup 0
++mov vw_setup, rb29 # Stride
++mov vw_addr, unif # start the VDW
++
++################################################################################
++
+ ::mc_filter_uv_b
+ mov ra31, unif
+ 
+-- 
+2.7.4
+
+
+From 85d0ffa2bcf6a2b94c1a0c8f84241cda9ac92ce2 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 10:04:55 +0100
+Subject: [PATCH 25/68] Switch to using 16bit temp buffers
+
+---
+ libavcodec/hevc.c          |  2 +-
+ libavcodec/rpi_shader.c    |  4 ++--
+ libavcodec/rpi_shader.qasm | 10 +++++-----
+ 3 files changed, 8 insertions(+), 8 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 4b133d2..28a6660 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2147,7 +2147,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 uint32_t *u = s->u_mvs[chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b0;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 88ad20b..ffd3a07 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -220,7 +220,7 @@ unsigned int rpi_shader[] = {
+ /* [0x00000600] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+ /* [0x00000608] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+ /* [0x00000610] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000618] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000618] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+ /* [0x00000620] */ 0x00000010, 0xe00208a7, // mov r2, 16
+ /* [0x00000628] */ 0x15827d80, 0x10020827, // mov r0, unif
+ /* [0x00000630] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+@@ -346,7 +346,7 @@ unsigned int rpi_shader[] = {
+ /* [0x000009e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+ /* [0x000009e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+ /* [0x000009f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000009f8] */ 0x0c9dc7c0, 0x10020c67, // add vr_setup, r3, rb28
++/* [0x000009f8] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+ /* [0x00000a00] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+ /* [0x00000a08] */ 0x15827d80, 0x10020827, // mov r0, unif
+ /* [0x00000a10] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 635b894..9577121 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -26,7 +26,7 @@
+ # ra23                                          8
+ #
+ # rb20                                          0xffffff00
+-# rb21                                          vpm_setup for writing 16bit results into VPM
++# rb21                                          vpm_setup for reading/writing 16bit results into VPM
+ # rb22                                          255
+ # rb23                                          24
+ #
+@@ -370,8 +370,8 @@ and rb_x_base_next, r0, ~3
+ mov ra_y_next, r1
+ add ra_x2_base_next, rb_x_base_next, r2
+ 
+-# set up VPM write
+-mov vw_setup, rb28
++# set up VPM write, we need to save 16bit precision
++mov vw_setup, rb21
+ 
+ # get width,height of block
+ mov r2, 16
+@@ -554,8 +554,8 @@ add r0, r0, r1 # Combine width and height of destination area
+ shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+ add rb26, r0, rb27
+ 
+-# In a B frame, so also set up VPM read
+-add vr_setup, r3, rb28
++# In a B frame, so also set up VPM read (reading back 16bit precision)
++add vr_setup, r3, rb21
+ 
+ sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+ 
+-- 
+2.7.4
+
+
+From abc51bf61df597082fbd7cf1bba5031e4d44318b Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 10:30:44 +0100
+Subject: [PATCH 26/68] Corrected B prediction: matching md5 sum for hobbit50
+
+---
+ libavcodec/rpi_shader.c    | 815 ++++++++++++++++++++++-----------------------
+ libavcodec/rpi_shader.h    |  12 +-
+ libavcodec/rpi_shader.qasm |  36 +-
+ 3 files changed, 429 insertions(+), 434 deletions(-)
+
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index ffd3a07..77cca46 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -38,431 +38,428 @@ unsigned int rpi_shader[] = {
+ /* [0x00000068] */ 0x00000020, 0xe0020567, // mov ra21, 32
+ /* [0x00000070] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+ /* [0x00000078] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+-/* [0x00000080] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+-/* [0x00000088] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+-/* [0x00000090] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+-/* [0x00000098] */ 0x00000000, 0xe0020227, // mov ra8, 0
+-/* [0x000000a0] */ 0x00000000, 0xe0020267, // mov ra9, 0
+-/* [0x000000a8] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+-/* [0x000000b0] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+-/* [0x000000b8] */ 0x00000000, 0xe0020327, // mov ra12, 0
+-/* [0x000000c0] */ 0x00000000, 0xe0020367, // mov ra13, 0
+-/* [0x000000c8] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+-/* [0x000000d0] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x000000d8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x000000e0] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+-/* [0x000000e8] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x000000f0] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x000000f8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000100] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000108] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000110] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000118] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000120] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+-/* [0x00000128] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+-/* [0x00000130] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+-/* [0x00000138] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00000140] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+-/* [0x00000148] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x00000150] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000158] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000160] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000168] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000170] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000178] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000180] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x00000188] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x00000190] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
+-/* [0x00000198] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
+-/* [0x000001a0] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
+-/* [0x000001a8] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+-/* [0x000001b0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+-/* [0x000001b8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+-/* [0x000001c0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+-/* [0x000001c8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x000001d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000001d8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x000001e0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+-/* [0x000001e8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x000001f0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+-/* [0x000001f8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+-/* [0x00000200] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+-/* [0x00000208] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000080] */ 0x00000040, 0xe00207a7, // mov ra30, 64
++/* [0x00000088] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
++/* [0x00000090] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x00000098] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x000000a0] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x000000a8] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x000000b0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x000000b8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x000000c0] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x000000c8] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x000000d0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x000000d8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x000000e0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x000000e8] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
++/* [0x000000f0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x000000f8] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000100] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000108] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000110] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000118] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000120] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000128] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x00000130] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x00000138] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x00000140] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000148] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
++/* [0x00000150] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00000158] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000160] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000168] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000170] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000178] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000180] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000188] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000190] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x00000198] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
++/* [0x000001a0] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
++/* [0x000001a8] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
++/* [0x000001b0] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
++/* [0x000001b8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
++/* [0x000001c0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
++/* [0x000001c8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
++/* [0x000001d0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x000001d8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000001e0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x000001e8] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
++/* [0x000001f0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x000001f8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
++/* [0x00000200] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
++/* [0x00000208] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+ /* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
+ /* [0x00000218] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000220] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000228] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000230] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000238] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000240] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000248] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+-/* [0x00000250] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++/* [0x00000220] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000228] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000230] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000238] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000240] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000248] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000250] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
++/* [0x00000258] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+ // ::mc_filter_uv
+-/* [0x00000258] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000260] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000268] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000270] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000278] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000280] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000288] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000290] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000298] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000002a0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000002a8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000002b0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000002b8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000002c0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000002c8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000002d0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000002d8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000002e0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x000002e8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x000002f0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000002f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000300] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000308] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000310] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000340] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000348] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000350] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000358] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000360] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000368] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000370] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000378] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000380] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000388] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000390] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000398] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x000003a0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000003a8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000003b0] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000268] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000270] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000278] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000280] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000288] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000290] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000298] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000002a0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000002a8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000002b0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000002b8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000002c0] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000002c8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000002e8] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x000002f0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000318] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000320] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000328] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000330] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000338] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000340] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000348] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000350] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000358] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000360] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000368] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000370] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000378] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000380] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000388] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000390] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000398] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000003a0] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x000003a8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000003b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000003b8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x000003b8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000003c0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x000003c8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x000003d0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000003d8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000003e0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000003e8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003f0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000003f8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000400] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000408] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000410] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000418] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000420] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000428] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000430] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000438] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000440] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000448] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000450] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000458] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000460] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000468] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000470] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000478] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000480] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000488] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000490] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000498] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x000004a0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x000004a8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x000004b0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x000004b8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x000004c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x000004c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000004d0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x000004d8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000004e0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x000004e8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x000004f0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x000004f8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x00000500] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x00000508] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000510] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000518] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000520] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000528] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000530] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000538] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000540] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000548] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000550] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x00000558] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000560] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x00000568] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000570] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000578] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000580] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000588] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000590] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000598] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x000005a0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000005a8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x000005b0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000005b8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000003c0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000003c8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x000003d0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x000003d8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000003e0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000003e8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000003f0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003f8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000400] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000408] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000410] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000418] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000420] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000428] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000430] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000438] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000440] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000448] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000450] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000458] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000460] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000468] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000470] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000478] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000480] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000488] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000490] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000498] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x000004a0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x000004a8] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x000004b0] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x000004b8] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x000004c0] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x000004c8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x000004d0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000004d8] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x000004e0] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x000004e8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x000004f0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x000004f8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x00000500] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x00000508] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x00000510] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000518] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000520] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000528] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000530] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000538] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000540] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000548] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000550] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000558] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x00000560] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000568] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x00000570] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000578] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000580] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000588] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000590] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000598] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000005a0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000005a8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000005b0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000005b8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000005c0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b0
+-/* [0x000005c0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000005c8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000005d0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000005d8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000005e0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000005e8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000005f0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000005f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000600] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000608] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000610] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000618] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+-/* [0x00000620] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000628] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000630] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000638] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000640] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000648] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000650] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000658] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000660] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000668] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000670] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000678] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000680] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000688] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000690] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000698] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000006a8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006b0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006b8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006c0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x000006c8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006d0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006d8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006e0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000006e8] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006f0] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006f8] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000700] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000708] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000710] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000718] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000005c8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000005d0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000005d8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000005e0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000005e8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000005f0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000005f8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000600] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000608] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000610] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000618] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000620] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
++/* [0x00000628] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000630] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000638] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000640] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000648] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000650] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000658] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000660] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000668] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000670] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000678] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000680] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000688] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000690] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000698] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000006b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x000006d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000006e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000006f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000006f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000700] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000708] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000710] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000718] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000720] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x00000720] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000728] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000730] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000738] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000740] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000748] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000750] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000758] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000760] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000768] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000770] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000778] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000780] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000788] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000790] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000798] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000007a0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000007a8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000007b0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000007b8] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x000007c0] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x000007c8] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x000007d0] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x000007d8] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x000007e0] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x000007e8] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x000007f0] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x000007f8] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000800] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000808] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000810] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000818] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000820] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000828] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000830] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000838] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000840] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000848] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x00000850] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x00000858] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x00000860] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x00000868] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x00000870] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000878] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000880] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000888] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000890] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000898] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x000008a0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000008a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000008b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000008b8] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x000008c0] */ 0xfffffad8, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000008c8] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x000008d0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000008d8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x000008e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000008e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000008f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000008f8] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000900] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000908] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000910] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000918] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000920] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000728] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000730] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000738] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000740] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000748] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000750] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000758] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000760] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000768] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000770] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000778] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000780] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000788] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000790] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000798] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000007a0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000007a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000007b0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000007b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000007c0] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x000007c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x000007d0] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x000007d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x000007e0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x000007e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x000007f0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x000007f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000800] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000808] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000810] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000818] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000820] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000828] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000830] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000838] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000840] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000848] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000850] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x00000858] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x00000860] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x00000868] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x00000870] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x00000878] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000880] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000888] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000890] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000898] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x000008a0] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x000008a8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000008b0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000008b8] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x000008c0] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
++/* [0x000008c8] */ 0x009e7000, 0x100009e7, // nop
++/* [0x000008d0] */ 0x009e7000, 0x100009e7, // nop
++/* [0x000008d8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000008e0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000008e8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000008f0] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000008f8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000900] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000908] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000910] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000918] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b
+-/* [0x00000928] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000930] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000938] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000940] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000948] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000950] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000958] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000960] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000968] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000970] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000978] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000980] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000988] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000990] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000998] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000009a0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000009a8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000009b0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x000009b8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x000009c0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000009c8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x000009d0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x000009d8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x000009e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000009e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000009f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000009f8] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000a00] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000a08] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000a10] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a18] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a20] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a28] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000a30] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a38] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a40] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a48] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000a50] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a58] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a60] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a68] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000a70] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a78] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a80] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a88] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000a90] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000a98] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000aa0] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000920] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000928] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000930] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000938] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000940] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000948] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000950] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000958] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000960] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000968] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000970] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000978] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000980] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000988] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000990] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000998] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000009a0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000009a8] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x000009b0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x000009b8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000009c0] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x000009c8] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x000009d0] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x000009d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000009e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000009e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000009f0] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x000009f8] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000a00] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000a08] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a10] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a18] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a20] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000a28] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a30] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a38] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a40] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000a48] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a50] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a58] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000a60] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000a68] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a70] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a78] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000a80] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000a88] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000a90] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000a98] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x00000aa8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000ab0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000ab8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000ac0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000ac8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000ad0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000ad8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000ae0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000ae8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000af0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000af8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000b00] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000b08] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000b10] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000b18] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000b20] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000b28] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000b30] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000b38] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000b40] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000b48] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000b50] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000b58] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000b60] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000b68] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000b70] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000b78] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000b80] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000b88] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000b90] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000b98] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000ba0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000ba8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000bb0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000bb8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000bc0] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000bc8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000bd0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x00000bd8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x00000be0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x00000be8] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x00000bf0] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x00000bf8] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000c00] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000c08] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000c10] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000c18] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000c20] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000c28] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000c30] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000c38] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000c40] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x00000c48] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x00000c50] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000c58] */ 0x0cc01dc0, 0xd0020827, // add r0, vpm, 1
+-/* [0x00000c60] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000c68] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x00000c70] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+-/* [0x00000c78] */ 0x0e9c13c0, 0xd0020c27, // shr vpm, r1, 1
+-/* [0x00000c80] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000c88] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000c90] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000c98] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000ca0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000ca8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000cb0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000cb8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000cc0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000aa0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000aa8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000ab0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000ab8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000ac0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000ac8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000ad0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000ad8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000ae0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000ae8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000af0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000af8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000b00] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000b08] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000b10] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000b18] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000b20] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000b28] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000b30] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000b38] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000b40] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000b48] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000b50] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000b58] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000b60] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000b68] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000b70] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000b78] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000b80] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000b88] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000b90] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000b98] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000ba0] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000ba8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000bb0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000bb8] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000bc0] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000bc8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x00000bd0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x00000bd8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x00000be0] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x00000be8] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x00000bf0] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000bf8] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000c00] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000c08] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000c10] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000c18] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000c20] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000c28] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000c30] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000c38] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x00000c40] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x00000c48] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000c50] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00000c58] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000c60] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000c68] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000c70] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000c78] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000c80] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000c88] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000c90] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000c98] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000ca0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000ca8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000cc8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000cd0] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000cb0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000cb8] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000cc0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000cc8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000cd0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000cd8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ce0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ce8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000cf0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000cf8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000d00] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000d08] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000ce0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000ce8] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000cf0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000d10] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000cf8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000d00] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000d08] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000d10] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000d18] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000d20] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000d28] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000d30] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000d20] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000d28] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000d30] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000d38] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000d40] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000d48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000d50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d58] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d60] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d70] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000d78] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000d80] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000d58] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000d60] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000d68] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 809e582..6562fa9 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -4,11 +4,11 @@
+ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+-#define mc_filter_uv (rpi_shader + 150)
+-#define mc_filter_uv_b0 (rpi_shader + 368)
+-#define mc_filter_uv_b (rpi_shader + 586)
+-#define mc_exit (rpi_shader + 818)
+-#define mc_interrupt_exit8 (rpi_shader + 836)
+-#define mc_end (rpi_shader + 866)
++#define mc_filter_uv (rpi_shader + 152)
++#define mc_filter_uv_b0 (rpi_shader + 370)
++#define mc_filter_uv_b (rpi_shader + 584)
++#define mc_exit (rpi_shader + 812)
++#define mc_interrupt_exit8 (rpi_shader + 830)
++#define mc_end (rpi_shader + 860)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 9577121..562dc35 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -39,13 +39,13 @@
+ # rb30                                          frame height-1
+ # rb31                                          used as temp to count loop iterations
+ #
+-# ra24...ra30                                   15, 14, 13, 12, 11, 10, 9
+ # ra24                                          clipped(row start address+8+elem_num)&~3
+ # ra25                                          per-channel shifts 2
+ # ra26                                          next ra24
+ # ra27                                          next ra25
+ # ra28                                          next y
+ # ra29                                          y for next texture access
++# ra30                                          64
+ #
+ # ra31                                          next kernel address
+ 
+@@ -102,6 +102,7 @@ mov ra20, 1
+ mov ra21, 32
+ mov ra22, 256
+ mov ra23, 8
++mov ra30, 64
+ 
+ mov rb20, 0xffffff00
+ mov rb22, 255
+@@ -472,7 +473,7 @@ sub.setf -, r3, 8 ; mov r1, ra22
+ # apply horizontal filter
+ brr.anyn -, r:uvloop_b0
+ mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
+-asr ra15, r0, 8         ; nop
++asr ra15, r0, 8         ; nop  # TODO isn't ra15 already in 24bit precision, may not need the sign extension here?
+ nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
+ 
+ # apply vertical filter and write to VPM
+@@ -487,18 +488,18 @@ add r1, r1, r0          ; mul24 r0, ra8, rb8
+ add r1, r1, r0          ; mul24 r0, ra15, rb15
+ add r1, r1, r0          ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-asr r1, r1, 14
+-add r1, r1, ra21
+-brr.anyn -, r:uvloop
+-asr r1, r1, 6          # Delay 1
+-min r1, r1, rb22       # Delay 2
+-max vpm, r1, 0         # Delay 3
++#asr r1, r1, 14
++#add r1, r1, ra21
++brr.anyn -, r:uvloop_b0
++asr vpm, r1, 14        # Delay 1 shifts down by shift2=6, but results are still in 16bit precision TODO may be able to avoid the mul24 and use more delay slots
++nop                    # Delay 2
++nop                    # Delay 3
+ 
+ # DMA out for U
+ 
+ mov vw_setup, rb26 # VDW setup 0
+ mov vw_setup, rb29 # Stride
+-mov vw_addr, unif # start the VDW
++mov vw_addr, unif # start the VDW    # TODO in pass0 we don't need to save any results
+ 
+ # DMA out for V
+ # We need to wait for the U to complete first, but have nothing useful to compute while we wait.
+@@ -639,12 +640,11 @@ mov ra12, ra13
+ mov ra13, ra14
+ 
+ sub.setf -, r3, 8 ; mov r1, ra22
+-
+ # apply horizontal filter
+ brr.anyn -, r:uvloop_b
+ mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+ asr ra15, r0, 8         ; nop
+-nop                     ; nop
++nop                     ; nop    # TODO improve use of delay slots
+ 
+ # apply vertical filter and write to VPM
+ 
+@@ -658,15 +658,13 @@ add r1, r1, r0          ; mul24 r0, ra8, rb8
+ add r1, r1, r0          ; mul24 r0, ra15, rb15
+ add r1, r1, r0          ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-asr r1, r1, 14
+-add r1, r1, ra21
+-asr r1, r1, 6
+-min r1, r1, rb22
+-add r0, vpm, 1          # Blend in previous VPM contents at this location
++asr r1, r1, 14          # shift2=6
++add r1, r1, vpm         # Blend in previous VPM contents at this location
++add r1, r1, ra30
+ brr.anyn -, r:uvloop_b
+-max r1, r1, 0
+-add r1, r1, r0
+-shr vpm, r1, 1
++asr r1, r1, 7           # Delay 1
++min r1, r1, rb22        # Delay 2
++max vpm, r1, 0          # Delay 3
+ 
+ 
+ # DMA out for U
+-- 
+2.7.4
+
+
+From ea60373134f98099c4ebaf0d23cca666008b4bba Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 10:55:07 +0100
+Subject: [PATCH 27/68] P prediction uses 4 tap filters
+
+---
+ libavcodec/hevc.c          |  50 ++--
+ libavcodec/rpi_shader.c    | 631 ++++++++++++++++++++++-----------------------
+ libavcodec/rpi_shader.h    |  10 +-
+ libavcodec/rpi_shader.qasm |  43 +--
+ 4 files changed, 344 insertions(+), 390 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 28a6660..a47ebc5 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -65,15 +65,15 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
+ 
+ // TODO Chroma only needs 4 taps
+-static uint32_t rpi_filter_coefs[8][2] = {
+-        { ENCODE_COEFFS(  0,  0,  0,  64), ENCODE_COEFFS(   0,   0,  0,  0 ) },
+-        { ENCODE_COEFFS(  0,  0, -2,  58), ENCODE_COEFFS(  10,  -2,  0,  0 ) },
+-        { ENCODE_COEFFS(  0,  0, -4,  54), ENCODE_COEFFS(  16,  -2,  0,  0 ) },
+-        { ENCODE_COEFFS(  0,  0, -6,  46), ENCODE_COEFFS(  28,  -4,  0,  0 ) },
+-        { ENCODE_COEFFS(  0,  0, -4,  36), ENCODE_COEFFS(  36,  -4,  0,  0 ) },
+-        { ENCODE_COEFFS(  0,  0, -4,  28), ENCODE_COEFFS(  46,  -6,  0,  0 ) },
+-        { ENCODE_COEFFS(  0,  0, -2,  16), ENCODE_COEFFS(  54,  -4,  0,  0 ) },
+-        { ENCODE_COEFFS(  0,  0, -2,  10), ENCODE_COEFFS(  58,  -2,  0,  0 ) }
++static uint32_t rpi_filter_coefs[8][1] = {
++        { ENCODE_COEFFS(   0,  64,   0,   0) },
++        { ENCODE_COEFFS(  -2,  58,  10,  -2) },
++        { ENCODE_COEFFS(  -4,  54,  16,  -2) },
++        { ENCODE_COEFFS(  -6,  46,  28,  -4) },
++        { ENCODE_COEFFS(  -4,  36,  36,  -4) },
++        { ENCODE_COEFFS(  -4,  28,  46,  -6) },
++        { ENCODE_COEFFS(  -2,  16,  54,  -4) },
++        { ENCODE_COEFFS(  -2,  10,  58,  -2) }
+ };
+ 
+ static uint32_t get_vc_address(AVBufferRef *bref) {
+@@ -2027,16 +2027,16 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                       *u++ = rpi_filter_coefs[_mx][0];
+-                      *u++ = rpi_filter_coefs[_mx][1];
++                      u++;
+                       *u++ = rpi_filter_coefs[_my][0];
+-                      *u++ = rpi_filter_coefs[_my][1];
++                      u++;
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+@@ -2084,16 +2084,16 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                       *u++ = rpi_filter_coefs[_mx][0];
+-                      *u++ = rpi_filter_coefs[_mx][1];
++                      u++;
+                       *u++ = rpi_filter_coefs[_my][0];
+-                      *u++ = rpi_filter_coefs[_my][1];
++                      u++;
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+@@ -2148,29 +2148,29 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b0;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 3 + start_x;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 3 + start_y;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                       *u++ = rpi_filter_coefs[_mx][0];
+-                      *u++ = rpi_filter_coefs[_mx][1];
++                      u++;
+                       *u++ = rpi_filter_coefs[_my][0];
+-                      *u++ = rpi_filter_coefs[_my][1];
++                      u++;
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]); // TODO this will become unused once we have a dedicated pass0 filter
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+ 
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = x2_c - 3 + start_x;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = y2_c - 3 + start_y;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = x2_c - 1 + start_x;
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = y2_c - 1 + start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                       *u++ = rpi_filter_coefs[_mx2][0];
+-                      *u++ = rpi_filter_coefs[_mx2][1];
++                      u++;
+                       *u++ = rpi_filter_coefs[_my2][0];
+-                      *u++ = rpi_filter_coefs[_my2][1];
++                      u++;
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 77cca46..c8d0728 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -116,8 +116,8 @@ unsigned int rpi_shader[] = {
+ /* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+ /* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+ /* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000002e8] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x000002f0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x000002e8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000002f0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+ /* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+ /* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+ /* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+@@ -128,338 +128,315 @@ unsigned int rpi_shader[] = {
+ /* [0x00000330] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+ /* [0x00000338] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+ /* [0x00000340] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000348] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000350] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000358] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000360] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000368] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000370] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000378] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000380] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000388] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000390] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000398] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000003a0] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x000003a8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000003b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000003b8] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000348] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000350] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000358] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000360] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000368] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000370] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000378] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000380] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x000003c0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000003c8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x000003d0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x000003d8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000003e0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000003e8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000003f0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003f8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000400] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000408] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000410] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000418] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000420] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000428] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000430] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000438] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000440] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000448] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000450] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000458] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000460] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000468] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000470] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000478] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000480] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000488] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000490] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000498] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x000004a0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x000004a8] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x000004b0] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x000004b8] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x000004c0] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x000004c8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x000004d0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000004d8] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x000004e0] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000004e8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x000004f0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x000004f8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x00000500] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x00000508] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x00000510] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000518] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000520] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000528] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000530] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000538] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000540] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000548] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000550] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000558] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x00000560] */ 0xfffffe40, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000568] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x00000570] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000578] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000580] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000588] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000590] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000598] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x000005a0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x000005a8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000005b0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x000005b8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000005c0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000388] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000390] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000398] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x000003a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000003a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000003b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000003b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000003d0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x000003d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000003e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000003e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000003f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000003f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000400] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000408] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000410] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000418] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000420] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000428] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000430] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000438] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000440] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
++/* [0x00000448] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000450] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x00000458] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x00000460] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x00000468] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000470] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000478] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000480] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000488] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000490] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000498] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000004a0] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x000004a8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x000004b0] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x000004b8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000004c0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000004c8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000004d0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000004d8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000004e0] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000004e8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000004f0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000004f8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000500] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000508] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b0
+-/* [0x000005c8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000005d0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000005d8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000005e0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000005e8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000005f0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000005f8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000600] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000608] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000610] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000618] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000620] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+-/* [0x00000628] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000630] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000638] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000640] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000648] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000650] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000658] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000660] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000668] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000670] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000678] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000680] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000688] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000690] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000698] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000006b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x000006d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000006e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000006f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000006f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000700] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000708] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000710] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000718] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000720] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000510] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000518] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000520] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000528] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000530] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000538] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000540] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000548] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000550] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000558] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000560] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000568] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
++/* [0x00000570] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000578] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000580] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000588] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000590] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000598] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x000005a0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x000005a8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000005b0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000005b8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000005c0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000005c8] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x000005d0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005d8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005e0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005e8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005f0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000005f8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000600] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000608] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000610] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000618] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000620] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000628] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000630] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000638] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000640] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000648] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000650] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000658] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000668] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x00000728] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000730] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000738] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000740] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000748] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000750] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000758] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000760] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000768] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000770] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000778] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000780] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000788] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000790] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000798] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000007a0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000007a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000007b0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000007b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000007c0] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x000007c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x000007d0] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x000007d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x000007e0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x000007e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x000007f0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x000007f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000800] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000808] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000810] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000818] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000820] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000828] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000830] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000838] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000840] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000848] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000850] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x00000858] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x00000860] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x00000868] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x00000870] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x00000878] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000880] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000888] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000890] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000898] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x000008a0] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x000008a8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000008b0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000008b8] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x000008c0] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
+-/* [0x000008c8] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x000008d0] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x000008d8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000008e0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000008e8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000008f0] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x000008f8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000900] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000908] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000910] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000918] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000670] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000678] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000680] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000688] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000690] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000698] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000006a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000006a8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000006b0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000006b8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x000006c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000006c8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000006d0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000006d8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000006e0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000006e8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000006f0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000006f8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000700] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000708] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000710] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000718] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000720] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000728] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000730] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000738] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000740] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000748] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000750] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000758] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000760] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000768] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000770] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000778] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000780] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000788] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000790] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000798] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x000007a0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x000007a8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x000007b0] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x000007b8] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x000007c0] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x000007c8] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x000007d0] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x000007d8] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x000007e0] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x000007e8] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x000007f0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000007f8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000800] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000808] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
++/* [0x00000810] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000818] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000820] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000828] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000830] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000838] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000840] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000848] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000850] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000858] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000860] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b
+-/* [0x00000920] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000928] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000930] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000938] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000940] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000948] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000950] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000958] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000960] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000968] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000970] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000978] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000980] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000988] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000990] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000998] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000009a0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000009a8] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x000009b0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x000009b8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000009c0] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x000009c8] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x000009d0] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x000009d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000009e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000009e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000009f0] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x000009f8] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000a00] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000a08] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a10] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a18] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a20] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000a28] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a30] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a38] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a40] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000a48] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a50] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a58] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000a60] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000a68] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a70] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a78] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000a80] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000a88] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000a90] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000a98] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000868] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000870] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000878] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000880] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000888] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000890] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000898] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000008a0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000008a8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000008b0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000008b8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000008c0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000008c8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000008d0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000008d8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000008e0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000008e8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000008f0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x000008f8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000900] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000908] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000910] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000918] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000920] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000928] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000930] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000938] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000940] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000948] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000950] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000958] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000960] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000968] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000970] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000978] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000980] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000988] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000990] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000998] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000009a0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000009a8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000009b0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000009b8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000009c0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000009c8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x000009d0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000009d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000009e0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x00000aa0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000aa8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000ab0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000ab8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000ac0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000ac8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000ad0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000ad8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000ae0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000ae8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000af0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000af8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000b00] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000b08] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000b10] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000b18] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000b20] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000b28] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000b30] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000b38] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000b40] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000b48] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000b50] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000b58] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000b60] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000b68] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000b70] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000b78] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000b80] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000b88] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000b90] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000b98] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000ba0] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000ba8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000bb0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000bb8] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000bc0] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000bc8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x00000bd0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x00000bd8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x00000be0] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x00000be8] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x00000bf0] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000bf8] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000c00] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000c08] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000c10] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000c18] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000c20] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000c28] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000c30] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000c38] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x00000c40] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x00000c48] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000c50] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00000c58] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000c60] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000c68] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000c70] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000c78] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000c80] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000c88] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000c90] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000c98] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000ca0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000ca8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000009e8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000009f0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x000009f8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000a00] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000a08] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000a10] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000a18] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000a20] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000a28] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000a30] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000a38] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000a40] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000a48] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000a50] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000a58] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000a60] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000a68] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000a70] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000a78] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000a80] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00000a88] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00000a90] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00000a98] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00000aa0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00000aa8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00000ab0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00000ab8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000ac0] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000ac8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000ad0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000ad8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000ae0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000ae8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000af0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000af8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000b00] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000b08] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000b10] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x00000b18] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x00000b20] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x00000b28] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x00000b30] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x00000b38] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000b40] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000b48] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000b50] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000b58] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000b60] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000b68] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000b70] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000b78] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000b80] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x00000b88] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x00000b90] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000b98] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00000ba0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000ba8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000bb0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000bb8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000bc0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000bc8] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000bd0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000bd8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000be0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000be8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000bf0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000cb0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000cb8] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00000cc0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000cc8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000cd0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000cd8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ce0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000ce8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000cf0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000bf8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000c00] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000c08] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000c10] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000c18] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000c20] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000c28] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000c30] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000c38] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000cf8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000d00] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000d08] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000d10] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000d18] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000d20] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d28] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d30] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d38] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d40] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000d58] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000d60] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000d68] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000c40] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000c48] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000c50] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000c58] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000c60] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000c68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000c70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000c78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000c80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000c88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000c90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000c98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ca0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000ca8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000cb0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 6562fa9..1bf7a68 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -5,10 +5,10 @@ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+ #define mc_filter_uv (rpi_shader + 152)
+-#define mc_filter_uv_b0 (rpi_shader + 370)
+-#define mc_filter_uv_b (rpi_shader + 584)
+-#define mc_exit (rpi_shader + 812)
+-#define mc_interrupt_exit8 (rpi_shader + 830)
+-#define mc_end (rpi_shader + 860)
++#define mc_filter_uv_b0 (rpi_shader + 324)
++#define mc_filter_uv_b (rpi_shader + 538)
++#define mc_exit (rpi_shader + 766)
++#define mc_interrupt_exit8 (rpi_shader + 784)
++#define mc_end (rpi_shader + 814)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 562dc35..8e4f18f 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -16,8 +16,8 @@
+ # ra19                                          next ra17
+ #
+ # rb16                                          pitch
+-# rb17                                          height + 5
+-# rb18                                          height + 7
++# rb17                                          height + 1
++# rb18                                          height + 3
+ # rb19                                          next ra16
+ #
+ # ra20                                          1
+@@ -214,8 +214,8 @@ mov r0, unif
+ shr r1, r0, r2 # Extract width
+ sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+ and r0, r0, rb22 # Extract height
+-add rb17, r0, 5
+-add rb18, r0, 7
++add rb17, r0, 1
++add rb18, r0, 3
+ shl r0, r0, 7
+ add r0, r0, r1 # Combine width and height of destination area
+ shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+@@ -230,18 +230,11 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
+ asr ra2, r0, rb23;      mul24 r0, r0, ra22
+ asr ra1, r0, rb23;      mul24 r0, r0, ra22
+ asr ra0, r0, rb23;      mov r0, unif
+-asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-asr ra4, r0, rb23;      mov r0, unif
++                        mov r0, unif
+ asr rb11, r0, rb23;     mul24 r0, r0, ra22
+ asr rb10, r0, rb23;     mul24 r0, r0, ra22
+ asr rb9, r0, rb23;      mul24 r0, r0, ra22
+ asr rb8, r0, rb23;      mov r0, unif
+-asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-asr rb12, r0, rb23
+ 
+ # r2 is elem_num
+ # r3 is loop counter
+@@ -283,26 +276,14 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+ add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+ add r0, r2, r3
+ 
+ mov r3, rb31
+ 
+-mov ra8, ra9
+-mov ra9, ra10
+-mov ra10, ra11
+-mov ra11, ra12
+ mov ra12, ra13
+ mov ra13, ra14
+ 
+-sub.setf -, r3, 8 ; mov r1, ra22
++sub.setf -, r3, 4 ; mov r1, ra22
+ 
+ # apply horizontal filter
+ brr.anyn -, r:uvloop
+@@ -312,14 +293,10 @@ nop                     ; nop  # Delay slot 3 (TODO move more of the context scr
+ 
+ # apply vertical filter and write to VPM
+ 
+-nop                     ; mul24 r1, ra14, rb14
+-nop                     ; mul24 r0, ra13, rb13
+-add r1, r1, r0          ; mul24 r0, ra12, rb12
+-add r1, r1, r0          ; mul24 r0, ra11, rb11
+-add r1, r1, r0          ; mul24 r0, ra10, rb10
+-add r1, r1, r0          ; mul24 r0, ra9, rb9
+-add r1, r1, r0          ; mul24 r0, ra8, rb8
+-add r1, r1, r0          ; mul24 r0, ra15, rb15
++nop                     ; mul24 r1, ra14, rb10
++nop                     ; mul24 r0, ra13, rb9
++add r1, r1, r0          ; mul24 r0, ra12, rb8
++add r1, r1, r0          ; mul24 r0, ra15, rb11
+ add r1, r1, r0          ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+ asr r1, r1, 14
+-- 
+2.7.4
+
+
+From e4bdd110d4640519b751ab428e7976a1e9a15802 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 11:03:51 +0100
+Subject: [PATCH 28/68] Optimised B0 pass
+
+---
+ libavcodec/rpi_shader.c    | 424 +++++++++++++++++++++------------------------
+ libavcodec/rpi_shader.h    |   8 +-
+ libavcodec/rpi_shader.qasm |  43 +----
+ 3 files changed, 212 insertions(+), 263 deletions(-)
+
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index c8d0728..1f63ee0 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -204,239 +204,215 @@ unsigned int rpi_shader[] = {
+ /* [0x00000580] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+ /* [0x00000588] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+ /* [0x00000590] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000598] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x000005a0] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000598] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000005a0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+ /* [0x000005a8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+ /* [0x000005b0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+ /* [0x000005b8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+ /* [0x000005c0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000005c8] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x000005d0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005d8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005e0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005e8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005f0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000005f8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000600] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000608] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000610] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000618] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000620] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000628] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000630] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000638] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000640] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000648] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000650] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000658] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000668] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000005c8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005d0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005d8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005e0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005e8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000005f0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005f8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000600] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000608] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000610] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000618] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000620] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000628] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x00000670] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000678] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000680] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000688] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000690] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000698] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000006a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000006a8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000006b0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000006b8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x000006c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000006c8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000006d0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000006d8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000006e0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000006e8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000006f0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000006f8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000700] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000708] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000710] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000718] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000720] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000728] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000730] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000738] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000740] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000748] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000750] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000758] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000760] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000768] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000770] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000778] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000780] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000788] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000790] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000798] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x000007a0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x000007a8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x000007b0] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x000007b8] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x000007c0] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x000007c8] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x000007d0] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x000007d8] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x000007e0] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x000007e8] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x000007f0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000007f8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000800] */ 0xfffffe50, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000808] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
+-/* [0x00000810] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000818] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000820] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000828] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000830] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000838] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000840] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000848] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000850] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000858] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000860] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000630] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000638] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000640] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000648] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000650] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000658] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000660] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000668] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000670] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000678] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000680] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000688] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000690] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000698] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000006a0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000006a8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000006b0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000006b8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000006c0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000006c8] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x000006d0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x000006d8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x000006e0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000006e8] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
++/* [0x000006f0] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x000006f8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x00000700] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x00000708] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x00000710] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000718] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000720] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000728] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000730] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000738] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000740] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000748] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
++/* [0x00000750] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000758] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000760] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000768] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000770] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000778] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000780] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000788] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000790] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000798] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000007a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b
+-/* [0x00000868] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000870] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000878] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000880] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000888] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000890] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000898] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000008a0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000008a8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000008b0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000008b8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000008c0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000008c8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000008d0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000008d8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000008e0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000008e8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000008f0] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x000008f8] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000900] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000908] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000910] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000918] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000920] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000928] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000930] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000938] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000940] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000948] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000950] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000958] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000960] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000968] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000970] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000978] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000980] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000988] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000990] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000998] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000009a0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000009a8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000009b0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000009b8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000009c0] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000009c8] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x000009d0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000009d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000009e0] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000007a8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000007b0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000007b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000007c0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000007c8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000007d0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000007d8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000007e0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000007e8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000007f0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000007f8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000800] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000808] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000810] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000830] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000838] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000858] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000860] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000880] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
++/* [0x00000888] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000890] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000898] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000008b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x000008d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000008f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000900] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000908] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
++/* [0x00000910] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000918] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000920] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x000009e8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000009f0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x000009f8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000a00] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000a08] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000a10] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000a18] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000a20] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000a28] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000a30] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000a38] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000a40] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000a48] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000a50] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000a58] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000a60] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000a68] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000a70] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000a78] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000a80] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00000a88] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00000a90] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00000a98] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00000aa0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00000aa8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00000ab0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00000ab8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000ac0] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000ac8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000ad0] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000ad8] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000ae0] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000ae8] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000af0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000af8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000b00] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000b08] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000b10] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x00000b18] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x00000b20] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x00000b28] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x00000b30] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x00000b38] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000b40] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000b48] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000b50] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000b58] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000b60] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000b68] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000b70] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000b78] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000b80] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x00000b88] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x00000b90] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000b98] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00000ba0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000ba8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000bb0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000bb8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000bc0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000bc8] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000bd0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000bd8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000be0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000be8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000bf0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000928] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000930] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000938] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000940] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000948] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000950] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000958] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000960] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000968] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000970] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000978] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000980] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000988] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000990] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000998] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000009a0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000009a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000009b0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000009b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000009c0] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x000009c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x000009d0] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x000009d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x000009e0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x000009e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x000009f0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x000009f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00000a00] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000a08] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000a10] */ 0x15267d80, 0x10020227, // mov ra8, ra9
++/* [0x00000a18] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00000a20] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00000a28] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00000a30] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000a38] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000a40] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
++/* [0x00000a48] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000a50] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x00000a58] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x00000a60] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x00000a68] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
++/* [0x00000a70] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
++/* [0x00000a78] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
++/* [0x00000a80] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
++/* [0x00000a88] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
++/* [0x00000a90] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
++/* [0x00000a98] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
++/* [0x00000aa0] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
++/* [0x00000aa8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000ab0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000ab8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000ac0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x00000ac8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x00000ad0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000ad8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00000ae0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000ae8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000af0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000af8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000b00] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000b08] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000b10] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000b18] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000b20] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000b28] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000b30] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000bf8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000c00] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00000c08] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000c10] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000c18] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000c20] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000c28] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000c30] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000c38] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000b38] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000b40] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000b48] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000b50] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000b58] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000b60] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000b68] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000b70] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000b78] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000c40] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000c48] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000c50] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000c58] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000c60] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000c68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000c70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000c78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000c80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000c88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000c90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000c98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ca0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000ca8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000cb0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000b80] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000b88] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000b90] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000b98] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ba0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ba8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000bb0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000bb8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000bc0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000bc8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000bd0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000bd8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000be0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000be8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000bf0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 1bf7a68..cb74887 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -6,9 +6,9 @@ extern unsigned int rpi_shader[];
+ #define mc_setup_uv (rpi_shader + 0)
+ #define mc_filter_uv (rpi_shader + 152)
+ #define mc_filter_uv_b0 (rpi_shader + 324)
+-#define mc_filter_uv_b (rpi_shader + 538)
+-#define mc_exit (rpi_shader + 766)
+-#define mc_interrupt_exit8 (rpi_shader + 784)
+-#define mc_end (rpi_shader + 814)
++#define mc_filter_uv_b (rpi_shader + 490)
++#define mc_exit (rpi_shader + 718)
++#define mc_interrupt_exit8 (rpi_shader + 736)
++#define mc_end (rpi_shader + 766)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 8e4f18f..faa5755 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -357,15 +357,13 @@ mov r0, unif
+ shr r1, r0, r2 # Extract width
+ sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+ and r0, r0, rb22 # Extract height
+-add rb17, r0, 5
+-add rb18, r0, 7
++add rb17, r0, 1
++add rb18, r0, 3
+ shl r0, r0, 7
+ add r0, r0, r1 # Combine width and height of destination area
+ shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+ add rb26, r0, rb27
+ 
+-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+-
+ # get filter coefficients
+ 
+ mov r0, unif
+@@ -373,18 +371,11 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
+ asr ra2, r0, rb23;      mul24 r0, r0, ra22
+ asr ra1, r0, rb23;      mul24 r0, r0, ra22
+ asr ra0, r0, rb23;      mov r0, unif
+-asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-asr ra4, r0, rb23;      mov r0, unif
++                        mov r0, unif
+ asr rb11, r0, rb23;     mul24 r0, r0, ra22
+ asr rb10, r0, rb23;     mul24 r0, r0, ra22
+ asr rb9, r0, rb23;      mul24 r0, r0, ra22
+ asr rb8, r0, rb23;      mov r0, unif
+-asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-asr rb12, r0, rb23
+ 
+ # r2 is elem_num
+ # r3 is loop counter
+@@ -426,26 +417,14 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+ add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+ add r0, r2, r3
+ 
+ mov r3, rb31
+ 
+-mov ra8, ra9
+-mov ra9, ra10
+-mov ra10, ra11
+-mov ra11, ra12
+ mov ra12, ra13
+ mov ra13, ra14
+ 
+-sub.setf -, r3, 8 ; mov r1, ra22
++sub.setf -, r3, 4 ; mov r1, ra22
+ 
+ # apply horizontal filter
+ brr.anyn -, r:uvloop_b0
+@@ -455,18 +434,12 @@ nop                     ; nop  # Delay slot 3 (TODO move more of the context scr
+ 
+ # apply vertical filter and write to VPM
+ 
+-nop                     ; mul24 r1, ra14, rb14
+-nop                     ; mul24 r0, ra13, rb13
+-add r1, r1, r0          ; mul24 r0, ra12, rb12
+-add r1, r1, r0          ; mul24 r0, ra11, rb11
+-add r1, r1, r0          ; mul24 r0, ra10, rb10
+-add r1, r1, r0          ; mul24 r0, ra9, rb9
+-add r1, r1, r0          ; mul24 r0, ra8, rb8
+-add r1, r1, r0          ; mul24 r0, ra15, rb15
++nop                     ; mul24 r1, ra14, rb10
++nop                     ; mul24 r0, ra13, rb9
++add r1, r1, r0          ; mul24 r0, ra12, rb8
++add r1, r1, r0          ; mul24 r0, ra15, rb11
+ add r1, r1, r0          ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-#asr r1, r1, 14
+-#add r1, r1, ra21
+ brr.anyn -, r:uvloop_b0
+ asr vpm, r1, 14        # Delay 1 shifts down by shift2=6, but results are still in 16bit precision TODO may be able to avoid the mul24 and use more delay slots
+ nop                    # Delay 2
+-- 
+2.7.4
+
+
+From 93805e78a13d36e28ed84a0e8456da2eac45be89 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 11:12:43 +0100
+Subject: [PATCH 29/68] Optimised B pass
+
+---
+ libavcodec/rpi_shader.c    | 202 ++++++++++++++++++++-------------------------
+ libavcodec/rpi_shader.h    |   6 +-
+ libavcodec/rpi_shader.qasm |  41 ++-------
+ 3 files changed, 100 insertions(+), 149 deletions(-)
+
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 1f63ee0..4e6c5ea 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -289,8 +289,8 @@ unsigned int rpi_shader[] = {
+ /* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+ /* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+ /* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000830] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000838] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000830] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000838] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+ /* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+ /* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+ /* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+@@ -299,120 +299,96 @@ unsigned int rpi_shader[] = {
+ /* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+ /* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+ /* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000880] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000888] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000890] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000898] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008a0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008a8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000008b0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008b8] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008c8] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x000008d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000008f0] */ 0x4f5971c6, 0x100253e0, // asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008f8] */ 0x4f5971c6, 0x100253a0, // asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000900] */ 0x4f5971c6, 0x10025360, // asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000908] */ 0x0f9d71c0, 0x10021327, // asr rb12, r0, rb23
+-/* [0x00000910] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000918] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000920] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000880] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000888] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000890] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000898] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000008a8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000008b0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008b8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008c0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008c8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000008d0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000008e0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x00000928] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000930] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000938] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000940] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000948] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000950] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000958] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000960] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000968] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000970] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000978] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000980] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000988] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000990] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000998] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000009a0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000009a8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000009b0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000009b8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000009c0] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x000009c8] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x000009d0] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x000009d8] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x000009e0] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x000009e8] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x000009f0] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x000009f8] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00000a00] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000a08] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000a10] */ 0x15267d80, 0x10020227, // mov ra8, ra9
+-/* [0x00000a18] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00000a20] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00000a28] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00000a30] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000a38] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000a40] */ 0x8d5887f6, 0xd00269e1, // sub.setf -, r3, 8 ; mov r1, ra22
+-/* [0x00000a48] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000a50] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x00000a58] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x00000a60] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x00000a68] */ 0x4038e037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb14
+-/* [0x00000a70] */ 0x4034d037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb13
+-/* [0x00000a78] */ 0x4c30c237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb12
+-/* [0x00000a80] */ 0x4c2cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb11
+-/* [0x00000a88] */ 0x4c28a237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb10
+-/* [0x00000a90] */ 0x4c249237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb9
+-/* [0x00000a98] */ 0x4c208237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb8
+-/* [0x00000aa0] */ 0x4c3cf237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb15
+-/* [0x00000aa8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000ab0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000ab8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000ac0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x00000ac8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x00000ad0] */ 0xfffffe38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000ad8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00000ae0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000ae8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000af0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000af8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000b00] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000b08] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000b10] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000b18] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000b20] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000b28] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000b30] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000008e8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000008f0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x000008f8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000900] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000908] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000910] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000918] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000920] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000928] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000930] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000938] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000940] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000948] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000950] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000958] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000960] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000968] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000970] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000978] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000980] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000988] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000990] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000998] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000009a0] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
++/* [0x000009a8] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000009b0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x000009b8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x000009c0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x000009c8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000009d0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000009d8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000009e0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000009e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000009f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000009f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000a00] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x00000a08] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x00000a10] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000a18] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00000a20] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000a28] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000a30] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000a38] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a40] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000a48] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000a50] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000a60] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000b38] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000b40] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00000b48] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000b50] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000b58] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000b60] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000b68] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000b70] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000b78] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a78] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a80] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a98] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000aa0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000ab0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000b80] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000b88] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000b90] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000b98] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ba0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ba8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000bb0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000bb8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000bc0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000bc8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000bd0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000bd8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000be0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000be8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000bf0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000ac0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ad8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ae0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b10] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b18] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b20] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000b28] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000b30] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index cb74887..53da629 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -7,8 +7,8 @@ extern unsigned int rpi_shader[];
+ #define mc_filter_uv (rpi_shader + 152)
+ #define mc_filter_uv_b0 (rpi_shader + 324)
+ #define mc_filter_uv_b (rpi_shader + 490)
+-#define mc_exit (rpi_shader + 718)
+-#define mc_interrupt_exit8 (rpi_shader + 736)
+-#define mc_end (rpi_shader + 766)
++#define mc_exit (rpi_shader + 670)
++#define mc_interrupt_exit8 (rpi_shader + 688)
++#define mc_end (rpi_shader + 718)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index faa5755..f38c926 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -491,8 +491,8 @@ mov r0, unif
+ shr r1, r0, r2 # Extract width
+ sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+ and r0, r0, rb22 # Extract height
+-add rb17, r0, 5
+-add rb18, r0, 7
++add rb17, r0, 1
++add rb18, r0, 3
+ shl r0, r0, 7
+ 
+ # r0 is currently height<<7
+@@ -508,8 +508,6 @@ add rb26, r0, rb27
+ # In a B frame, so also set up VPM read (reading back 16bit precision)
+ add vr_setup, r3, rb21
+ 
+-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+-
+ # get filter coefficients
+ 
+ mov r0, unif
+@@ -517,18 +515,11 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
+ asr ra2, r0, rb23;      mul24 r0, r0, ra22
+ asr ra1, r0, rb23;      mul24 r0, r0, ra22
+ asr ra0, r0, rb23;      mov r0, unif
+-asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-asr ra4, r0, rb23;      mov r0, unif
++                        mov r0, unif
+ asr rb11, r0, rb23;     mul24 r0, r0, ra22
+ asr rb10, r0, rb23;     mul24 r0, r0, ra22
+ asr rb9, r0, rb23;      mul24 r0, r0, ra22
+ asr rb8, r0, rb23;      mov r0, unif
+-asr rb15, r0, rb23;     mul24 r0, r0, ra22
+-asr rb14, r0, rb23;     mul24 r0, r0, ra22
+-asr rb13, r0, rb23;     mul24 r0, r0, ra22
+-asr rb12, r0, rb23
+ 
+ # r2 is elem_num
+ # r3 is loop counter
+@@ -570,26 +561,14 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+ add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+ add r0, r2, r3
+ 
+ mov r3, rb31
+ 
+-mov ra8, ra9
+-mov ra9, ra10
+-mov ra10, ra11
+-mov ra11, ra12
+ mov ra12, ra13
+ mov ra13, ra14
+ 
+-sub.setf -, r3, 8 ; mov r1, ra22
++sub.setf -, r3, 4 ; mov r1, ra22
+ # apply horizontal filter
+ brr.anyn -, r:uvloop_b
+ mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+@@ -598,14 +577,10 @@ nop                     ; nop    # TODO improve use of delay slots
+ 
+ # apply vertical filter and write to VPM
+ 
+-nop                     ; mul24 r1, ra14, rb14
+-nop                     ; mul24 r0, ra13, rb13
+-add r1, r1, r0          ; mul24 r0, ra12, rb12
+-add r1, r1, r0          ; mul24 r0, ra11, rb11
+-add r1, r1, r0          ; mul24 r0, ra10, rb10
+-add r1, r1, r0          ; mul24 r0, ra9, rb9
+-add r1, r1, r0          ; mul24 r0, ra8, rb8
+-add r1, r1, r0          ; mul24 r0, ra15, rb15
++nop                     ; mul24 r1, ra14, rb10
++nop                     ; mul24 r0, ra13, rb9
++add r1, r1, r0          ; mul24 r0, ra12, rb8
++add r1, r1, r0          ; mul24 r0, ra15, rb11
+ add r1, r1, r0          ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+ asr r1, r1, 14          # shift2=6
+-- 
+2.7.4
+
+
+From e48df43c16de74dddbc7c702d64dd01eaf8e6b39 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 11:17:09 +0100
+Subject: [PATCH 30/68] Used P delay slots more efficiently
+
+---
+ libavcodec/rpi_shader.c    | 437 ++++++++++++++++++++++-----------------------
+ libavcodec/rpi_shader.h    |  10 +-
+ libavcodec/rpi_shader.qasm |  19 +-
+ 3 files changed, 228 insertions(+), 238 deletions(-)
+
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 4e6c5ea..a1af4e3 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -156,239 +156,236 @@ unsigned int rpi_shader[] = {
+ /* [0x00000408] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+ /* [0x00000410] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ /* [0x00000418] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000420] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000428] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000430] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000420] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000428] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000430] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+ /* [0x00000438] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000440] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+-/* [0x00000448] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000450] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x00000458] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x00000460] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x00000468] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000470] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000478] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000480] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000488] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000490] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000498] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000004a0] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x000004a8] */ 0xfffffec0, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000004b0] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x000004b8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000004c0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x000004c8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000004d0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000004d8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000004e0] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x000004e8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x000004f0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000004f8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000500] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000508] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000440] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000448] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000450] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000458] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000460] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000468] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000470] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000478] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000480] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000488] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x00000490] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000498] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x000004a0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000004a8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000004b0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000004b8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000004c0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000004c8] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000004d0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000004d8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000004e0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000004e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000004f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b0
+-/* [0x00000510] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000518] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000520] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000528] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000530] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000538] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000540] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000548] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000550] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000558] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000560] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000568] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+-/* [0x00000570] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000578] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000580] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000588] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000590] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000598] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000005a0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000005a8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000005b0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000005b8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000005c0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000005c8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005d0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005d8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005e0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005e8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000005f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005f8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000600] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000608] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000610] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000618] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000620] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000628] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000004f8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000500] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000508] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000510] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000518] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000520] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000528] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000530] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000538] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000540] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000548] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000550] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
++/* [0x00000558] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000560] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000568] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000570] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000578] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000580] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000588] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x00000590] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000598] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000005a0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000005a8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000005b0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005b8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005c0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005c8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005d0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000005d8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000005e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000005f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000600] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000608] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000610] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x00000630] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000638] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000640] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000648] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000650] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000658] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000660] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000668] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000670] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000678] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000680] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000688] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000690] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000698] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000006a0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000006a8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000006b0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000006b8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000006c0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000006c8] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x000006d0] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x000006d8] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x000006e0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000006e8] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+-/* [0x000006f0] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x000006f8] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x00000700] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x00000708] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x00000710] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000718] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000720] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000728] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000730] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000738] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000740] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000748] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
+-/* [0x00000750] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000758] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000760] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000768] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000770] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000778] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000780] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000788] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000790] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000798] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000007a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000618] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000620] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000628] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000630] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000638] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000640] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000648] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000650] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000658] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000660] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000668] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000670] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000678] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000680] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000688] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000690] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000698] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000006a0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000006a8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000006b0] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x000006b8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x000006c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x000006c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000006d0] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
++/* [0x000006d8] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x000006e0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x000006e8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x000006f0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x000006f8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000700] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000708] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000710] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000718] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000720] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000728] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000730] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
++/* [0x00000738] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000740] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000748] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000750] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000758] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000760] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000768] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000770] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000778] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000780] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000788] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b
+-/* [0x000007a8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000007b0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000007b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000007c0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000007c8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000007d0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000007d8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000007e0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000007e8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000007f0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000007f8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000800] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000808] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000810] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000830] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x00000838] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000858] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000860] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000880] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000888] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000890] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000898] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000008a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000008b0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008b8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008c0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008c8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000008d0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000008e0] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000790] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000798] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000007a0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000007a8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000007b0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000007b8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000007c0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000007c8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000007d0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000007d8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000007e0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000007e8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000007f0] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000007f8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000800] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000808] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000810] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000818] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000820] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x00000828] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000830] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000838] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000840] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000848] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000850] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000858] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000860] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000868] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000870] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000878] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000880] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000888] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000890] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000898] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008a0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008a8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008b0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000008b8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000008c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000008c8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x000008e8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000008f0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x000008f8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000900] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000908] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000910] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000918] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000920] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000928] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000930] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000938] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000940] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000948] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000950] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000958] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000960] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000968] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000970] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000978] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000980] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000988] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000990] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000998] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000009a0] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+-/* [0x000009a8] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000009b0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x000009b8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x000009c0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x000009c8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000009d0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000009d8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000009e0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000009e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000009f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000009f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000a00] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x00000a08] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x00000a10] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000a18] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00000a20] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000a28] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000a30] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000a38] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a40] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000a48] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000a50] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000a60] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000008d0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000008d8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x000008e0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x000008e8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000008f0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000008f8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000900] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000908] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000910] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000918] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000920] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000928] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000930] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000938] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000940] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000948] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000950] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000958] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000960] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000968] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
++/* [0x00000970] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
++/* [0x00000978] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00000980] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000988] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
++/* [0x00000990] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000998] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
++/* [0x000009a0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
++/* [0x000009a8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
++/* [0x000009b0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000009b8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000009c0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000009c8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000009d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000009d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000009e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000009e8] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x000009f0] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x000009f8] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000a00] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00000a08] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000a10] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000a18] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000a20] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a28] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000a30] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000a38] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000a40] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000a48] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000a50] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a58] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000a78] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a80] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a60] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a68] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a70] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a98] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000aa0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000ab0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a90] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000a98] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000aa0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000ac0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000aa8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000ab0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ad8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ae0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ad0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b10] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b18] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b20] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000b28] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000b30] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000b08] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000b10] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000b18] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 53da629..1fb3e37 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -5,10 +5,10 @@ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+ #define mc_filter_uv (rpi_shader + 152)
+-#define mc_filter_uv_b0 (rpi_shader + 324)
+-#define mc_filter_uv_b (rpi_shader + 490)
+-#define mc_exit (rpi_shader + 670)
+-#define mc_interrupt_exit8 (rpi_shader + 688)
+-#define mc_end (rpi_shader + 718)
++#define mc_filter_uv_b0 (rpi_shader + 318)
++#define mc_filter_uv_b (rpi_shader + 484)
++#define mc_exit (rpi_shader + 664)
++#define mc_interrupt_exit8 (rpi_shader + 682)
++#define mc_end (rpi_shader + 712)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index f38c926..02e95dd 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -268,6 +268,7 @@ add t0s, ra_x2_base, r2
+ 
+ mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ 
++# apply horizontal filter
+ nop                  ; mul24 r2, r0, ra0
+ nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+ nop                  ; mul24      r3, ra1 << 1, r0 << 1
+@@ -276,20 +277,12 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+ add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-add r0, r2, r3
+-
+-mov r3, rb31
+-
+-mov ra12, ra13
+-mov ra13, ra14
+-
+-sub.setf -, r3, 4 ; mov r1, ra22
+-
+-# apply horizontal filter
++add r0, r2, r3       ; mov r3, rb31
++sub.setf -, r3, 4    ; mov ra12, ra13
+ brr.anyn -, r:uvloop
+-mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
+-asr ra15, r0, 8         ; nop
+-nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
++mov ra13, ra14       # Delay slot 1
++mov ra14, ra15       # Delay slot 2
++mov ra15, r0         # Delay slot 3
+ 
+ # apply vertical filter and write to VPM
+ 
+-- 
+2.7.4
+
+
+From b33dfc243ff5509299685add3c532ab7f207fd73 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 11:22:25 +0100
+Subject: [PATCH 31/68] Improved use of delay slots
+
+---
+ libavcodec/rpi_shader.c    | 503 ++++++++++++++++++++++-----------------------
+ libavcodec/rpi_shader.h    |  10 +-
+ libavcodec/rpi_shader.qasm |  41 ++--
+ 3 files changed, 265 insertions(+), 289 deletions(-)
+
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index a1af4e3..c498f28 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -122,270 +122,263 @@ unsigned int rpi_shader[] = {
+ /* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+ /* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+ /* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000318] */ 0x0d9c8e40, 0xd00229e7, // sub.setf -,8,r1
+-/* [0x00000320] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000328] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000330] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000338] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000340] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000348] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000350] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000358] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000360] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000368] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000370] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000378] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000380] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000340] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000348] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000350] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000358] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000360] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000368] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000370] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000378] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x00000388] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000390] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000398] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x000003a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000003a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000003b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000003b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000003c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000003d0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x000003d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000003e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000003e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000003f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000003f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000400] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000408] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000410] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000418] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000420] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000428] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000430] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000438] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000440] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000448] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000450] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000458] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000460] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000468] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000470] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000478] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000480] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000488] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x00000490] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000498] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x000004a0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000004a8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x000004b0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000004b8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000004c0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000004c8] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x000004d0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x000004d8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000004e0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x000004e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000004f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000380] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000388] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000390] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000398] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000003a0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000003a8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000003b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003b8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003c0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000003c8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x000003d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000003d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000003e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000003e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000003f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000003f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000400] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000408] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000410] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000418] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000420] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000428] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000430] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000438] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000440] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000448] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000450] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000458] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000460] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000468] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000470] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000478] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000480] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x00000488] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000490] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x00000498] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000004a0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000004a8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000004b0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000004b8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000004c0] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000004c8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000004d0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000004d8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000004e0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000004e8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b0
+-/* [0x000004f8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000500] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000508] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000510] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000518] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000520] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000528] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000530] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000538] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000540] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000548] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000550] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+-/* [0x00000558] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000560] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000568] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000570] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000578] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000580] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x00000588] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x00000590] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000598] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000005a0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000005a8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000005b0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005b8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005c0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005c8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005d0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000005d8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000005e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000005f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000600] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000608] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000610] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000004f0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000004f8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000500] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000508] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000510] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000518] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000520] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000528] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000530] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000538] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000540] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000548] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
++/* [0x00000550] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000558] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000560] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000568] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000570] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000578] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000580] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x00000588] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000590] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000598] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000005a0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000005a8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005b0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005b8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005c0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005c8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000005d0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005d8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000005e0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000005e8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005f0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000005f8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000600] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000608] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x00000618] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000620] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000628] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000630] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000638] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000640] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000648] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000650] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000658] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000660] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000668] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000670] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000678] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000680] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000688] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000690] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000698] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000006a0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000006a8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000006b0] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x000006b8] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x000006c0] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x000006c8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000006d0] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+-/* [0x000006d8] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x000006e0] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x000006e8] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x000006f0] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x000006f8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000700] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000708] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000710] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000718] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000720] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000728] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000730] */ 0x0f9ce3c0, 0xd0020c27, // asr vpm, r1, 14
+-/* [0x00000738] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000740] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000748] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000750] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000758] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000760] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000768] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000770] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000778] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000780] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000788] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000610] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000618] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000620] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000628] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000630] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000638] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000640] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000648] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000650] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000658] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000668] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000670] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000678] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000680] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000688] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000690] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000698] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000006a0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000006a8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x000006b0] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x000006b8] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x000006c0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000006c8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x000006d0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000006d8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000006e0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000006e8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000006f0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000006f8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000700] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
++/* [0x00000708] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000710] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
++/* [0x00000718] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000720] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000728] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000730] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000738] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000740] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000748] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000750] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000758] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000760] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000768] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b
+-/* [0x00000790] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000798] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000007a0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000007a8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000007b0] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000007b8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000007c0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000007c8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000007d0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000007d8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000007e0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000007e8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000007f0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000007f8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000800] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000808] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000810] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000818] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x00000820] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x00000828] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000830] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000838] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000840] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000848] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000850] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000858] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000860] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000868] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000870] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000878] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000880] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000888] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000890] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000898] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008a0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008a8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008b0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000008b8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000008c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000008c8] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000770] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000778] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000780] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000788] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000790] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000798] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000007a0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000007a8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000007b0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000007b8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000007c0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000007c8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000007d0] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000007d8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000007e0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000007e8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000007f0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000007f8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000800] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x00000808] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000810] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000818] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000820] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000828] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000830] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000838] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000840] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000848] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000850] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000858] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000860] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000868] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000870] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000878] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000880] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000888] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000890] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000898] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000008a0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000008a8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x000008d0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000008d8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x000008e0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x000008e8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000008f0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000008f8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000900] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000908] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000910] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000918] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000920] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000928] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000930] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000938] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000940] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000948] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000950] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000958] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000960] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000968] */ 0x0c9e74c0, 0x10020827, // add r0, r2, r3
+-/* [0x00000970] */ 0x159dffc0, 0x100208e7, // mov r3, rb31
+-/* [0x00000978] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00000980] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000988] */ 0x8d5847f6, 0xd00269e1, // sub.setf -, r3, 4 ; mov r1, ra22
+-/* [0x00000990] */ 0xffffff20, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000998] */ 0x553e7d81, 0x100243a0, // mov ra14, ra15          ; mul24 r0, r0, r1
+-/* [0x000009a0] */ 0x0f9c81c0, 0xd00203e7, // asr ra15, r0, 8         ; nop
+-/* [0x000009a8] */ 0x009e7000, 0x100009e7, // nop                     ; nop
+-/* [0x000009b0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000009b8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000009c0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000009c8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000009d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000009d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000009e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000009e8] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x000009f0] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x000009f8] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000a00] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00000a08] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000a10] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000a18] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000a20] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a28] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000a30] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000a38] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000a40] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000a48] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000a50] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a58] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000008b0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000008b8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x000008c0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x000008c8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000008d0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000008d8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000008e0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000008e8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000008f0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000008f8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000900] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000908] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000910] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000918] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000920] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000928] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000930] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000938] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000940] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000948] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000950] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000958] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000960] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000968] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000970] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000978] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000980] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000988] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000990] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000998] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000009a0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000009a8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000009b0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x000009b8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x000009c0] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000009c8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x000009d0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000009d8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000009e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000009e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000009f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000009f8] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000a08] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000a10] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000a18] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a20] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000a60] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a68] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00000a70] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a28] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a30] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a38] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a40] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a48] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a58] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000a60] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a68] */ 0x009e7000, 0x100009e7, // nop        ; nop
++// ::mc_interrupt_exit8
++/* [0x00000a70] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+ /* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a90] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000a98] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000aa0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-// ::mc_interrupt_exit8
+-/* [0x00000aa8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000ab0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ad0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b08] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000b10] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000b18] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000aa0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000aa8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ab0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ab8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ac0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ac8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ad0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000ad8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000ae0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 1fb3e37..3fac45f 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -5,10 +5,10 @@ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+ #define mc_filter_uv (rpi_shader + 152)
+-#define mc_filter_uv_b0 (rpi_shader + 318)
+-#define mc_filter_uv_b (rpi_shader + 484)
+-#define mc_exit (rpi_shader + 664)
+-#define mc_interrupt_exit8 (rpi_shader + 682)
+-#define mc_end (rpi_shader + 712)
++#define mc_filter_uv_b0 (rpi_shader + 316)
++#define mc_filter_uv_b (rpi_shader + 476)
++#define mc_exit (rpi_shader + 650)
++#define mc_interrupt_exit8 (rpi_shader + 668)
++#define mc_end (rpi_shader + 698)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 02e95dd..10f5113 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -221,8 +221,6 @@ add r0, r0, r1 # Combine width and height of destination area
+ shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+ add rb26, r0, rb27
+ 
+-sub.setf -,8,r1 # 8-r1, so if <0 (negative) we need to use the full code
+-
+ # get filter coefficients
+ 
+ mov r0, unif
+@@ -410,20 +408,12 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+ add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-add r0, r2, r3
+-
+-mov r3, rb31
+-
+-mov ra12, ra13
+-mov ra13, ra14
+-
+-sub.setf -, r3, 4 ; mov r1, ra22
+-
+-# apply horizontal filter
++add r0, r2, r3       ; mov r3, rb31
++sub.setf -, r3, 4    ; mov ra12, ra13
+ brr.anyn -, r:uvloop_b0
+-mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll
+-asr ra15, r0, 8         ; nop  # TODO isn't ra15 already in 24bit precision, may not need the sign extension here?
+-nop                     ; nop  # Delay slot 3 (TODO move more of the context scroll into here)
++mov ra13, ra14       # Delay slot 1
++mov ra14, ra15       # Delay slot 2
++mov ra15, r0         # Delay slot 3
+ 
+ # apply vertical filter and write to VPM
+ 
+@@ -432,9 +422,9 @@ nop                     ; mul24 r0, ra13, rb9
+ add r1, r1, r0          ; mul24 r0, ra12, rb8
+ add r1, r1, r0          ; mul24 r0, ra15, rb11
+ add r1, r1, r0          ; mov -, vw_wait
+-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++sub.setf -, r3, rb18
+ brr.anyn -, r:uvloop_b0
+-asr vpm, r1, 14        # Delay 1 shifts down by shift2=6, but results are still in 16bit precision TODO may be able to avoid the mul24 and use more delay slots
++asr vpm, r1, 6         # Delay 1 shifts down by shift2=6, but results are still in 16bit precision
+ nop                    # Delay 2
+ nop                    # Delay 3
+ 
+@@ -554,19 +544,12 @@ add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+ nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+ add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+ nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-add r0, r2, r3
+-
+-mov r3, rb31
+-
+-mov ra12, ra13
+-mov ra13, ra14
+-
+-sub.setf -, r3, 4 ; mov r1, ra22
+-# apply horizontal filter
++add r0, r2, r3       ; mov r3, rb31
++sub.setf -, r3, 4    ; mov ra12, ra13
+ brr.anyn -, r:uvloop_b
+-mov ra14, ra15          ; mul24 r0, r0, r1         # last bit of context scroll, including clamp to zero
+-asr ra15, r0, 8         ; nop
+-nop                     ; nop    # TODO improve use of delay slots
++mov ra13, ra14       # Delay slot 1
++mov ra14, ra15       # Delay slot 2
++mov ra15, r0         # Delay slot 3
+ 
+ # apply vertical filter and write to VPM
+ 
+-- 
+2.7.4
+
+
+From af59f8e00eb977e97debc5e72ba47e0077db1787 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 11:31:23 +0100
+Subject: [PATCH 32/68] Avoid writeback of first B results
+
+---
+ libavcodec/rpi_shader.c    | 229 ++++++++++++++++++++++-----------------------
+ libavcodec/rpi_shader.h    |   8 +-
+ libavcodec/rpi_shader.qasm |  18 +---
+ 3 files changed, 121 insertions(+), 134 deletions(-)
+
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index c498f28..ba453a2 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -255,130 +255,125 @@ unsigned int rpi_shader[] = {
+ /* [0x00000710] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+ /* [0x00000718] */ 0x009e7000, 0x100009e7, // nop
+ /* [0x00000720] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000728] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000730] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000738] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000740] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000748] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000750] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000758] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000760] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000768] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000728] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000730] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000738] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000740] */ 0x009e7000, 0x100009e7, // nop
+ // ::mc_filter_uv_b
+-/* [0x00000770] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000778] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000780] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000788] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000790] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000798] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000007a0] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000007a8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000007b0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000007b8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000007c0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000007c8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000007d0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000007d8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000007e0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000007e8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000007f0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000007f8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x00000800] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x00000808] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000810] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000818] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000820] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000828] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000830] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000838] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000840] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000748] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000750] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000758] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000760] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000768] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000770] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000778] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000780] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000788] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000790] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000798] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000007a0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000007a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000007b0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000007b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000007c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000007c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000007d0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000007d8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000007e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000007e8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x000007f0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x000007f8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000800] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000808] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000810] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000818] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000820] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000828] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000830] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000838] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000840] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+ /* [0x00000848] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000850] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000858] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000860] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000868] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000870] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000878] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000880] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000888] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000890] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000898] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000008a0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000008a8] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000850] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000858] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000860] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000868] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000870] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000878] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000880] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x000008b0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000008b8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x000008c0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x000008c8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000008d0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000008d8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000008e0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000008e8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000008f0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000008f8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000900] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000908] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000910] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000918] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000920] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000928] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000930] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000938] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000940] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000948] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000950] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000958] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000960] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000968] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000970] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000978] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000980] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000988] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000990] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000998] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000009a0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000009a8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000009b0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x000009b8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x000009c0] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000009c8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x000009d0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000009d8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x000009e0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000009e8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000009f0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000009f8] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000a08] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000a10] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000a18] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a20] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000888] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000890] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000898] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x000008a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000008a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000008b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000008b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000008c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000008c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000008d0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000008e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000008e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000008f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000008f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000900] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000908] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000910] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000918] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000920] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000928] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000930] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000938] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000940] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000948] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000950] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000958] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000960] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000968] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000970] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000978] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000980] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000988] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x00000990] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x00000998] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000009a0] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x000009a8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000009b0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000009b8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000009c0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000009c8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000009d0] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000009e0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000009e8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000009f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000009f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000a28] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a30] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00000a38] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a40] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a48] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a58] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000a60] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000a68] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a08] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a10] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a18] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a20] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a28] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a30] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000a38] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a40] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000a70] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a48] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a58] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a60] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a68] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000a98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000aa0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000aa8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ab0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ab8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ac0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ac8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ad0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000ad8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000ae0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000ab0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 3fac45f..45dbe0e 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -6,9 +6,9 @@ extern unsigned int rpi_shader[];
+ #define mc_setup_uv (rpi_shader + 0)
+ #define mc_filter_uv (rpi_shader + 152)
+ #define mc_filter_uv_b0 (rpi_shader + 316)
+-#define mc_filter_uv_b (rpi_shader + 476)
+-#define mc_exit (rpi_shader + 650)
+-#define mc_interrupt_exit8 (rpi_shader + 668)
+-#define mc_end (rpi_shader + 698)
++#define mc_filter_uv_b (rpi_shader + 466)
++#define mc_exit (rpi_shader + 640)
++#define mc_interrupt_exit8 (rpi_shader + 658)
++#define mc_end (rpi_shader + 688)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 10f5113..e138c95 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -428,22 +428,14 @@ asr vpm, r1, 6         # Delay 1 shifts down by shift2=6, but results are still
+ nop                    # Delay 2
+ nop                    # Delay 3
+ 
++# in pass0 we don't really need to save any results, but need to discard the uniforms
+ # DMA out for U
+ 
+-mov vw_setup, rb26 # VDW setup 0
+-mov vw_setup, rb29 # Stride
+-mov vw_addr, unif # start the VDW    # TODO in pass0 we don't need to save any results
+-
+-# DMA out for V
+-# We need to wait for the U to complete first, but have nothing useful to compute while we wait.
+-# Could potentially push this write into the start of the next pipeline stage.
+-mov r0, 16
+-mov -, vw_wait
+-
+ bra -, ra31
+-add vw_setup, rb26, r0 # VDW setup 0
+-mov vw_setup, rb29 # Stride
+-mov vw_addr, unif # start the VDW
++mov r0, unif           # Delay 1
++mov r0, unif           # Delay 2
++nop                    # Delay 3
++
+ 
+ ################################################################################
+ 
+-- 
+2.7.4
+
+
+From 12e57278cb19a769d2e1488e8e94003027493d09 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 14 May 2015 11:36:24 +0100
+Subject: [PATCH 33/68] Cutdown size of chroma prediction commands
+
+---
+ libavcodec/hevc.c          |  17 +-
+ libavcodec/rpi_shader.c    | 543 ++++++++++++++++++++++-----------------------
+ libavcodec/rpi_shader.h    |  12 +-
+ libavcodec/rpi_shader.qasm |  11 +-
+ 4 files changed, 281 insertions(+), 302 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index a47ebc5..32b89d5 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -56,7 +56,7 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ 
+ #ifdef RPI_INTER_QPU
+ 
+-#define RPI_CHROMA_COMMAND_WORDS 12
++#define RPI_CHROMA_COMMAND_WORDS 10
+ #define UV_COMMANDS_PER_QPU ((1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS)
+ // The QPU code for UV blocks only works up to a block width of 8
+ #define RPI_CHROMA_BLOCK_WIDTH 8
+@@ -2032,11 +2032,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+-                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                       *u++ = rpi_filter_coefs[_mx][0];
+-                      u++;
+                       *u++ = rpi_filter_coefs[_my][0];
+-                      u++;
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+@@ -2091,9 +2088,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                       *u++ = rpi_filter_coefs[_mx][0];
+-                      u++;
+                       *u++ = rpi_filter_coefs[_my][0];
+-                      u++;
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+@@ -2154,11 +2149,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                       *u++ = rpi_filter_coefs[_mx][0];
+-                      u++;
+                       *u++ = rpi_filter_coefs[_my][0];
+-                      u++;
+-                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]); // TODO this will become unused once we have a dedicated pass0 filter
+-                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
++                      u+=2; // Intermediate results are not written back in first pass of B filtering
+ 
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = x2_c - 1 + start_x;
+@@ -2166,11 +2158,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+-                      // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                       *u++ = rpi_filter_coefs[_mx2][0];
+-                      u++;
+                       *u++ = rpi_filter_coefs[_my2][0];
+-                      u++;
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+@@ -2808,7 +2797,7 @@ static void rpi_inter_clear(HEVCContext *s)
+         *s->u_mvs[i]++ = pic_height;
+         *s->u_mvs[i]++ = s->frame->linesize[1];
+         *s->u_mvs[i]++ = s->frame->linesize[2];
+-        s->u_mvs[i] += 3;  // Padding words
++        s->u_mvs[i] += 1;  // Padding words
+     }
+ }
+ 
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index ba453a2..b0b93b5 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -89,291 +89,286 @@ unsigned int rpi_shader[] = {
+ /* [0x00000200] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+ /* [0x00000208] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+ /* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000218] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000220] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000228] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000230] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000238] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000240] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000248] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000250] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+-/* [0x00000258] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++/* [0x00000218] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000220] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000228] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000230] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000238] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000240] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
++/* [0x00000248] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+ // ::mc_filter_uv
+-/* [0x00000260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000268] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000270] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000278] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000280] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000288] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000290] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000298] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000002a0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000002a8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000002b0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000002b8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000002c0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000002c8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000002e8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000002f0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000340] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000348] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000350] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000358] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000360] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000368] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000370] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000378] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000258] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000260] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000268] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000270] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000278] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000280] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000288] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000290] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000298] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000002a0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000002a8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000002b0] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000002b8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000002c0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000002c8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000002d0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000002d8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000002e0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000002e8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000002f0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000002f8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000300] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000330] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000338] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000340] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000348] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000350] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000358] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000360] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x00000380] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000388] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000390] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000398] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000003a0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000003a8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000003b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003b8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000003c0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000003c8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x000003d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000003d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000003e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000003e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000003f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000003f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000400] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000408] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000410] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000418] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000420] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000428] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000430] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000438] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000440] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000448] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000450] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000458] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000460] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000468] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000470] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000478] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000480] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x00000488] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000490] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x00000498] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000004a0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x000004a8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000004b0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000004b8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000004c0] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x000004c8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x000004d0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000004d8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x000004e0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000004e8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000368] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000370] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000378] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000380] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000388] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000390] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000398] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003a0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003a8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000003b0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x000003b8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000003c0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000003c8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000003d0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000003d8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000003e0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000003e8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000003f0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000003f8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000400] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000408] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000410] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000418] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000420] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000428] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000430] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000438] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000440] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000448] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000450] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000458] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000460] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000468] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
++/* [0x00000470] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000478] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x00000480] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000488] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000490] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000498] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000004a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000004a8] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000004b0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000004b8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000004c0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000004c8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000004d0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b0
+-/* [0x000004f0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000004f8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000500] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000508] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000510] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000518] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000520] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000528] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000530] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000538] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000540] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000548] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+-/* [0x00000550] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000558] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000560] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000568] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000570] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000578] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x00000580] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x00000588] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000590] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000598] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000005a0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000005a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005b0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005b8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005c0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005c8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000005d0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005d8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000005e0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000005e8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005f0] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000005f8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000600] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000608] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000004d8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000004e0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000004e8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000004f0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000004f8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000500] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000508] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000510] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000518] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000520] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000528] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000530] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
++/* [0x00000538] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000540] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000548] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000550] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000558] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000560] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000568] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x00000570] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000578] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000580] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000588] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000590] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000598] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005a0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005a8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005b0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000005b8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000005c0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000005c8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005d0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x000005d8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000005e0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000005e8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x00000610] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000618] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000620] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000628] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000630] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000638] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000640] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000648] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000650] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000658] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000668] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000670] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000678] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000680] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000688] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000690] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000698] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000006a0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000006a8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x000006b0] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x000006b8] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x000006c0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000006c8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x000006d0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x000006d8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000006e0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000006e8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000006f0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000006f8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000700] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+-/* [0x00000708] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000710] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+-/* [0x00000718] */ 0x009e7000, 0x100009e7, // nop
++/* [0x000005f0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000005f8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000600] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000608] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000610] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000618] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000620] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000628] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000630] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000638] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000640] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000648] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000650] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000658] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000660] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000668] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000670] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000678] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000680] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000688] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000690] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000698] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x000006a0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000006a8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x000006b0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000006b8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000006c0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000006c8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000006d0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000006d8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000006e0] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
++/* [0x000006e8] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x000006f0] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
++/* [0x000006f8] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000700] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000708] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000710] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000718] */ 0x15827d80, 0x10020827, // mov r0, unif
+ /* [0x00000720] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000728] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000730] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000738] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000740] */ 0x009e7000, 0x100009e7, // nop
+ // ::mc_filter_uv_b
+-/* [0x00000748] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000750] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000758] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000760] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000768] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000770] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000778] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000780] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000788] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000790] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000798] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000007a0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000007a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000007b0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000007b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000007c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000007c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000007d0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000007d8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000007e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000007e8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x000007f0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x000007f8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000800] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000808] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000810] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000818] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000820] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000828] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000830] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000838] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000840] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000848] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000850] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000858] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000860] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000868] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000870] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000878] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000880] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000728] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000730] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000738] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000740] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000748] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000750] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000758] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000760] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000768] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000770] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000778] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000780] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000788] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000790] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000798] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000007a0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000007a8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000007b0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000007b8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000007c0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000007c8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x000007d0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x000007d8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x000007e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000007e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000007f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000007f8] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000800] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000808] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000810] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000818] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000820] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000828] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000830] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000838] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000840] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000848] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000850] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000858] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x00000888] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000890] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000898] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x000008a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000008a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000008b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000008b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000008c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000008c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000008d0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000008e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000008e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000008f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000008f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000900] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000908] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000910] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000918] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000920] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000928] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000930] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000938] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000940] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000948] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000950] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000958] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000960] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000968] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000970] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000978] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000980] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000988] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x00000990] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x00000998] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000009a0] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x000009a8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000009b0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x000009b8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000009c0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000009c8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000009d0] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x000009e0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000009e8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x000009f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000009f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000860] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000868] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000870] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000878] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000880] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000888] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000890] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000898] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000008a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000008a8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x000008b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000008b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000008c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000008c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000008d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000008d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000008e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000008e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000008f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000008f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000900] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000908] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000910] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000918] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000920] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000928] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000930] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000938] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000940] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000948] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000950] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000958] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000960] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x00000968] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x00000970] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000978] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00000980] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000988] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000990] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000998] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000009a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000009a8] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000009b0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000009b8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000009c0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000009c8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000009d0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a08] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00000a10] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a18] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a20] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a28] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a30] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000a38] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000a40] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x000009e0] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x000009e8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000009f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x000009f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a00] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a08] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000a10] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a18] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000a48] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a58] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a60] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a68] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a20] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a28] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a30] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a38] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a40] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a58] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a60] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000a70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000a78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000aa0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000ab0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a80] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000a88] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000a90] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 45dbe0e..99927c4 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -4,11 +4,11 @@
+ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+-#define mc_filter_uv (rpi_shader + 152)
+-#define mc_filter_uv_b0 (rpi_shader + 316)
+-#define mc_filter_uv_b (rpi_shader + 466)
+-#define mc_exit (rpi_shader + 640)
+-#define mc_interrupt_exit8 (rpi_shader + 658)
+-#define mc_end (rpi_shader + 688)
++#define mc_filter_uv (rpi_shader + 148)
++#define mc_filter_uv_b0 (rpi_shader + 310)
++#define mc_filter_uv_b (rpi_shader + 458)
++#define mc_exit (rpi_shader + 630)
++#define mc_interrupt_exit8 (rpi_shader + 648)
++#define mc_end (rpi_shader + 678)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index e138c95..d9ffcda 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -167,8 +167,6 @@ add t0s, r2, r1
+ 
+ # Dump padding words
+ mov r0, unif
+-mov r0, unif
+-mov r0, unif
+ 
+ # submit texture requests for second line
+ max r1, ra_y, 0
+@@ -228,11 +226,10 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
+ asr ra2, r0, rb23;      mul24 r0, r0, ra22
+ asr ra1, r0, rb23;      mul24 r0, r0, ra22
+ asr ra0, r0, rb23;      mov r0, unif
+-                        mov r0, unif
+ asr rb11, r0, rb23;     mul24 r0, r0, ra22
+ asr rb10, r0, rb23;     mul24 r0, r0, ra22
+ asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-asr rb8, r0, rb23;      mov r0, unif
++asr rb8, r0, rb23
+ 
+ # r2 is elem_num
+ # r3 is loop counter
+@@ -362,11 +359,10 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
+ asr ra2, r0, rb23;      mul24 r0, r0, ra22
+ asr ra1, r0, rb23;      mul24 r0, r0, ra22
+ asr ra0, r0, rb23;      mov r0, unif
+-                        mov r0, unif
+ asr rb11, r0, rb23;     mul24 r0, r0, ra22
+ asr rb10, r0, rb23;     mul24 r0, r0, ra22
+ asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-asr rb8, r0, rb23;      mov r0, unif
++asr rb8, r0, rb23
+ 
+ # r2 is elem_num
+ # r3 is loop counter
+@@ -490,11 +486,10 @@ asr ra3, r0, rb23;      mul24 r0, r0, ra22
+ asr ra2, r0, rb23;      mul24 r0, r0, ra22
+ asr ra1, r0, rb23;      mul24 r0, r0, ra22
+ asr ra0, r0, rb23;      mov r0, unif
+-                        mov r0, unif
+ asr rb11, r0, rb23;     mul24 r0, r0, ra22
+ asr rb10, r0, rb23;     mul24 r0, r0, ra22
+ asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-asr rb8, r0, rb23;      mov r0, unif
++asr rb8, r0, rb23
+ 
+ # r2 is elem_num
+ # r3 is loop counter
+-- 
+2.7.4
+
+
+From 3e8f02cf9d3e4bfcd07a5fcf321ace07c4f2e6f3 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Thu, 14 May 2015 15:21:49 +0100
+Subject: [PATCH 34/68] hevc: don't redirect when not rpi_enabled
+
+---
+ libavcodec/hevc.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 32b89d5..2459e34 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -1468,7 +1468,7 @@ static int hls_pcm_sample(HEVCContext *s, int x0, int y0, int log2_cb_size)
+  */
+ 
+ #ifdef RPI_INTER
+-#define RPI_REDIRECT(fn) rpi_ ## fn
++#define RPI_REDIRECT(fn) (s->enable_rpi ? rpi_ ## fn : fn)
+ static void rpi_luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                         AVFrame *ref, const Mv *mv, int x_off, int y_off,
+                         int block_w, int block_h, int luma_weight, int luma_offset)
+-- 
+2.7.4
+
+
+From 6da455b382b28c3c1f4e98c1703a695cdb946ad3 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Thu, 14 May 2015 15:22:02 +0100
+Subject: [PATCH 35/68] Use /dev/vcio for mailbox access
+
+---
+ libavcodec/rpi_mailbox.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/libavcodec/rpi_mailbox.c b/libavcodec/rpi_mailbox.c
+index 536896f..77a56dd 100644
+--- a/libavcodec/rpi_mailbox.c
++++ b/libavcodec/rpi_mailbox.c
+@@ -39,7 +39,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ 
+ #define MAJOR_NUM 100
+ #define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
+-#define DEVICE_FILE_NAME "/dev/char_dev"
++#define DEVICE_FILE_NAME "/dev/vcio"
+ 
+ #include "rpi_mailbox.h"
+ 
+-- 
+2.7.4
+
+
+From f96ef6131f16a4c03b8e2882bdf7319c3b646a6c Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Thu, 14 May 2015 15:25:25 +0100
+Subject: [PATCH 36/68] Use vcsm for all memory allocations
+
+---
+ libavcodec/rpi_qpu.c | 174 +++++++++++++++++++--------------------------------
+ 1 file changed, 64 insertions(+), 110 deletions(-)
+
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 60bf079..f62051f 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -1,7 +1,5 @@
+ #ifdef RPI
+-// define RPI_USE_VCSM to use the vcsm device for shared memory
+ // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
+-#define RPI_USE_VCSM
+ // define RPI_TIME_TOTAL_QPU to print out how much time is spent in the QPU code
+ #define RPI_TIME_TOTAL_QPU
+ // define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
+@@ -25,9 +23,7 @@
+ #include "rpi_shader.h"
+ #include "rpi_hevc_transform.h"
+ 
+-#ifdef RPI_USE_VCSM
+ #include "rpi_user_vcsm.h"
+-#endif
+ 
+ // On Pi2 there is no way to access the VPU L2 cache
+ // GPU_MEM_FLG should be 4 for uncached memory.  (Or C for alias to allocate in the VPU L2 cache)
+@@ -96,7 +92,6 @@ struct GPU
+   unsigned int vpu_code[VPU_CODE_SIZE];
+   short transMatrix2even[16*16*2];
+   int open_count; // Number of allocated video buffers
+-  unsigned int vc_handle; // Handle of this memory
+   int      mb; // Mailbox handle
+   int      vc; // Address in GPU memory
+   int mail[12]; // These are used to pass pairs of code/unifs to the QPUs
+@@ -105,6 +100,7 @@ struct GPU
+ // Stop more than one thread trying to allocate memory or use the processing resources at once
+ static pthread_mutex_t gpu_mutex = PTHREAD_MUTEX_INITIALIZER;
+ static volatile struct GPU* gpu = NULL;
++static GPU_MEM_PTR_T gpu_mem_ptr;
+ 
+ #if defined(RPI_TIME_TOTAL_QPU) || defined(RPI_TIME_TOTAL_VPU)
+ static unsigned int Microseconds(void) {
+@@ -132,39 +128,27 @@ static volatile int vpu_async_tail=0; // Contains the number of posted jobs
+ static volatile int vpu_async_head=0;
+ #endif
+ 
++static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb);
++static void gpu_free_internal(GPU_MEM_PTR_T *p);
++
+ // Connect to QPU, returns 0 on success.
+ static int gpu_init(volatile struct GPU **gpu) {
+   int mb = mbox_open();
+   int vc;
+-  int handle;
+   volatile struct GPU* ptr;
+ 	if (mb < 0)
+ 		return -1;
+ 
+ 	if (qpu_enable(mb, 1)) return -2;
+ 
+-#ifdef RPI_USE_VCSM
+   vcsm_init();
+-#endif
++  gpu_malloc_uncached_internal(sizeof(struct GPU), &gpu_mem_ptr, mb);
++  ptr = (volatile struct GPU*)gpu_mem_ptr.arm;
++  memset(ptr, 0, sizeof *ptr);
++  vc = gpu_mem_ptr.vc;
+ 
+-  handle = mem_alloc(mb, sizeof(struct GPU), 4096, GPU_MEM_FLG);
+-  if (!handle)
+-  {
+-    qpu_enable(mb, 0);
+-    return -3;
+-  }
+-	vc = mem_lock(mb, handle);
+-	ptr = mapmem_shared((vc+GPU_MEM_MAP)&~0xc0000000, sizeof(struct GPU));
+-	if (ptr == NULL)
+-	{	mem_free(mb, handle);
+-		mem_unlock(mb, handle);
+-		qpu_enable(mb, 0);
+-		return -4;
+-	}
+-
+-	ptr->mb = mb;
+-	ptr->vc_handle = handle;
+-	ptr->vc = vc;
++  ptr->mb = mb;
++  ptr->vc = vc;
+ 
+   printf("GPU allocated at 0x%x\n",vc);
+ 
+@@ -226,94 +210,74 @@ static void gpu_unlock(void) {
+   pthread_mutex_unlock(&gpu_mutex);
+ }
+ 
++static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb) {
++  p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
++  assert(p->vcsm_handle);
++  p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
++  assert(p->vc_handle);
++  p->arm = vcsm_lock(p->vcsm_handle);
++  assert(p->arm);
++  p->vc = mem_lock(mb, p->vc_handle);
++  assert(p->vc);
++  return 0;
++}
++
+ // Allocate memory on GPU
+ // Fills in structure <p> containing ARM pointer, videocore handle, videocore memory address, numbytes
+ // Returns 0 on success.
+ // This allocates memory that will not be cached in ARM's data cache.
+ // Therefore safe to use without data cache flushing.
+-int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p) {
++int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p)
++{
++  int r;
+   gpu_lock();
+-  p->vc_handle = mem_alloc(gpu->mb, numbytes, 4096, GPU_MEM_FLG);
+-  p->vcsm_handle = 0;
+-  if (!p->vc_handle)
+-  {
+-    qpu_enable(gpu->mb, 0);
+-    return -3;
+-  }
+-  p->vc = mem_lock(gpu->mb, p->vc_handle);
+-  p->arm = mapmem_shared((p->vc+GPU_MEM_MAP)&~0xc0000000,numbytes);
+-  p->numbytes = numbytes;
+-  if (p->arm == NULL)
+-  {
+-    mem_free(gpu->mb, p->vc_handle);
+-    mem_unlock(gpu->mb, p->vc_handle);
+-    gpu_unlock();
+-    qpu_enable(gpu->mb, 0);
+-    return -4;
+-  }
++  r = gpu_malloc_uncached_internal(numbytes, p, gpu->mb);
+   gpu->open_count++;
+   gpu_unlock();
+-  return 0;
++  return r;
+ }
+ 
+ void gpu_cache_flush(GPU_MEM_PTR_T *p)
+ {
+-  // This only works when using RPI_USE_VCSM
+   void *tmp = vcsm_lock(p->vcsm_handle);
+   vcsm_unlock_ptr(tmp);
+ }
+ 
++static int gpu_malloc_cached_internal(int numbytes, GPU_MEM_PTR_T *p) {
++  p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" );
++  //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" );
++  //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
++  //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST_AND_VC, (char *)"Video Frame" );
++  assert(p->vcsm_handle);
++  p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
++  assert(p->vc_handle);
++  p->arm = vcsm_lock(p->vcsm_handle);
++  assert(p->arm);
++  p->vc = mem_lock(gpu->mb, p->vc_handle);
++  assert(p->vc);
++  return 0;
++}
++
+ // This allocates data that will be
+ //    Cached in ARM L2
+ //    Uncached in VPU L2
+-int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p) {
++int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p)
++{
++  int r;
+   gpu_lock();
+-#ifdef RPI_USE_VCSM
+-  {
+-      p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" ); // f....... locks up for VP9 - retest this?
+-      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" ); // 3b...... works
+-      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" ); //fb...... locks up
+-      //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST_AND_VC, (char *)"Video Frame" ); // 3b works (but corrupted due to caching)
+-      p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
+-      p->arm = vcsm_lock(p->vcsm_handle);
+-      p->vc = mem_lock(gpu->mb, p->vc_handle);
+-  }
+-#else
+-  p->vc_handle = mem_alloc(gpu->mb, numbytes, 4096, GPU_MEM_FLG);
+-  p->vcsm_handle = 0;
+-  if (!p->handle)
+-  {
+-    qpu_enable(gpu->mb, 0);
+-    return -3;
+-  }
+-  p->vc = mem_lock(gpu->mb, p->vc_handle);
+-  printf("This mapmem_private does not seem to work\n");
+-  exit(-1);
+-  p->arm = mapmem_private((p->vc+GPU_MEM_MAP)&~0xc0000000,numbytes);
+-  p->numbytes = numbytes;
+-  if (p->arm == NULL)
+-  {
+-    mem_free(gpu->mb, p->handle);
+-    mem_unlock(gpu->mb, p->handle);
+-    gpu_unlock();
+-    qpu_enable(gpu->mb, 0);
+-    return -4;
+-  }
+-#endif
++  r = gpu_malloc_cached_internal(numbytes, p);
+   gpu->open_count++;
+   gpu_unlock();
+-  return 0;
++  return r;
+ }
+ 
+ static void gpu_term(void)
+ {
+-	int mb;
+-	unsigned handle;
++  int mb;
+ 
+   if (gpu==NULL)
+     return;
+   mb = gpu->mb;
+-  handle = gpu->vc_handle;
+ 
+ #ifdef RPI_ASYNC
+   {
+@@ -323,37 +287,26 @@ static void gpu_term(void)
+   }
+ #endif
+ 
++  qpu_enable(mb, 0);
++  gpu_free_internal(&gpu_mem_ptr);
+ 
+-	unmapmem((void*)gpu, sizeof(struct GPU));
+-	mem_unlock(mb, handle);
+-	mem_free(mb, handle);
+-	qpu_enable(mb, 0);
+-#ifdef RPI_USE_VCSM
+   vcsm_exit();
+-#endif
+-	mbox_close(mb);
++
++  mbox_close(mb);
+   gpu = NULL;
+ }
+ 
+-void gpu_free(GPU_MEM_PTR_T *p) {
++void gpu_free_internal(GPU_MEM_PTR_T *p) {
+   int mb = gpu->mb;
+-	unsigned handle = p->vc_handle;
++  mem_unlock(mb,p->vc_handle);
++  vcsm_unlock_ptr(p->arm);
++  vcsm_free(p->vcsm_handle);
++}
++
++void gpu_free(GPU_MEM_PTR_T *p) {
+   gpu_lock();
+-#ifdef RPI_USE_VCSM
+-  if (p->vcsm_handle) {
+-      mem_unlock(mb,p->vc_handle);
+-      vcsm_unlock_ptr(p->arm);
+-      vcsm_free(p->vcsm_handle);
+-  } else {
+-	unmapmem((void*)p->arm, sizeof(struct GPU));
+-      mem_unlock(mb, handle);
+-      mem_free(mb, handle);
+-  }
+-#else
+-	unmapmem((void*)p->arm, sizeof(struct GPU));
+-	mem_unlock(mb, handle);
+-	mem_free(mb, handle);
+-#endif
++
++  gpu_free_internal(p);
+ 
+   gpu->open_count--;
+   if (gpu->open_count==0) {
+@@ -386,20 +339,21 @@ unsigned int vpu_get_constants(void) {
+ 
+ static void *vpu_start(void *arg) {
+   while(1) {
++    int *p;
+     pthread_mutex_lock(&post_mutex);
+     while( vpu_async_tail - vpu_async_head <= 0)
+     {
+       //printf("Checking number %d %d\n",vpu_async_head,vpu_async_tail);
+       pthread_cond_wait(&post_cond_tail, &post_mutex);
+     }
+-    int *p = vpu_cmds[vpu_async_head%MAXCMDS];
++    p = vpu_cmds[vpu_async_head%MAXCMDS];
+     pthread_mutex_unlock(&post_mutex);
+ 
+     if (p[6] == -1) {
+       break; // Last job
+     }
+     if (p[7]) {
+-        GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
++        //GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
+         //gpu_cache_flush(buf);
+     }
+     vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
+-- 
+2.7.4
+
+
+From 7c94b833b48a455d27d82eb2ca1b53a162705caf Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Thu, 14 May 2015 15:43:17 +0100
+Subject: [PATCH 37/68] Enable EARLY_MALLOC and fix sps access bug
+
+---
+ libavcodec/hevc.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 2459e34..4e82a15 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -44,7 +44,7 @@
+ #ifdef RPI
+   #include "rpi_qpu.h"
+   // For some unknown reason, the code seems to crash if I do a late malloc
+-  #define EARLY_MALLOC
++  //#define EARLY_MALLOC
+   // Move Inter prediction into separate pass
+   #define RPI_INTER
+ #endif
+@@ -149,7 +149,8 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
+ #ifdef RPI
+ #ifdef EARLY_MALLOC
+ #else
+-    int coeffs_in_ctb = (1 << s->ps.sps->log2_ctb_size) * (1 << s->ps.sps->log2_ctb_size);
++    assert(sps);
++    int coeffs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
+     int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
+     printf("pic_arrays_init\n");
+     printf("Allocated %d\n",coefs_per_row);
+-- 
+2.7.4
+
+
+From 0a0a92817a7959d213dca9c75a242b6ad88d6b80 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Thu, 14 May 2015 16:40:51 +0100
+Subject: [PATCH 38/68] Add copy of av_mod_uintp2 for use with stable ffmpeg
+
+---
+ libavcodec/hevc.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 4e82a15..80db603 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -51,6 +51,14 @@
+ 
+ // #define DISABLE_MC
+ 
++#ifndef av_mod_uintp2
++static av_always_inline av_const unsigned av_mod_uintp2_c(unsigned a, unsigned p)
++{
++    return a & ((1 << p) - 1);
++}
++#   define av_mod_uintp2   av_mod_uintp2_c
++#endif
++
+ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12] = 4, [16] = 5, [24] = 6, [32] = 7, [48] = 8, [64] = 9 };
+ 
+ 
+-- 
+2.7.4
+
+
+From c48d08e968b24c2e260b0cc76c7901a1b4d75bbf Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Mon, 18 May 2015 11:11:02 +0100
+Subject: [PATCH 39/68] Added support for weighted prediction in P frames
+
+---
+ libavcodec/hevc.c          |  52 ++++-
+ libavcodec/rpi_shader.c    | 566 +++++++++++++++++++++++----------------------
+ libavcodec/rpi_shader.h    |  12 +-
+ libavcodec/rpi_shader.qasm |  39 +++-
+ 4 files changed, 384 insertions(+), 285 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 80db603..9668ef8 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -64,7 +64,7 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ 
+ #ifdef RPI_INTER_QPU
+ 
+-#define RPI_CHROMA_COMMAND_WORDS 10
++#define RPI_CHROMA_COMMAND_WORDS 12
+ #define UV_COMMANDS_PER_QPU ((1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS)
+ // The QPU code for UV blocks only works up to a block width of 8
+ #define RPI_CHROMA_BLOCK_WIDTH 8
+@@ -2031,6 +2031,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 int y1_c = y0_c + (mv->y >> (2 + hshift));
+                 //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+                 int chan = x0>>8;
++                int weight_flag      = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
++                                       (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+ 
+                 uint32_t *u = s->u_mvs[chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+@@ -2043,6 +2045,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                       *u++ = rpi_filter_coefs[_mx][0];
+                       *u++ = rpi_filter_coefs[_my][0];
++                      if (weight_flag) {
++                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0] & 0xffff);
++                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1] & 0xffff);
++                      } else {
++                          *u++ = 1; // Weight of 1 and offset of 0
++                          *u++ = 1;
++                      }
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+@@ -2085,6 +2094,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 int y1_c = y0_c + (mv->y >> (2 + hshift));
+                 //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+                 int chan = x0>>8;
++                int weight_flag      = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
++                                       (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+ 
+                 uint32_t *u = s->u_mvs[chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+@@ -2098,6 +2109,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                       *u++ = rpi_filter_coefs[_mx][0];
+                       *u++ = rpi_filter_coefs[_my][0];
++                      if (weight_flag) {
++                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[1]][0] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[1]][0] & 0xffff);
++                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[1]][1] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[1]][1] & 0xffff);
++                      } else {
++                          *u++ = 1; // Weight of 1 and offset of 0
++                          *u++ = 1;
++                      }
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+@@ -2159,6 +2177,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                       *u++ = rpi_filter_coefs[_mx][0];
+                       *u++ = rpi_filter_coefs[_my][0];
++                      u+=2; // Weights not supported in B slices
+                       u+=2; // Intermediate results are not written back in first pass of B filtering
+ 
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b;
+@@ -2169,6 +2188,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
+                       *u++ = rpi_filter_coefs[_mx2][0];
+                       *u++ = rpi_filter_coefs[_my2][0];
++                      u+=2; // Weights not supported in B slices
+                       *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+@@ -2795,6 +2815,9 @@ static void rpi_inter_clear(HEVCContext *s)
+     int i;
+     int pic_width        = s->ps.sps->width >> s->ps.sps->hshift[1];
+     int pic_height       = s->ps.sps->height >> s->ps.sps->vshift[1];
++    int weight_flag      = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
++                           (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
++
+     for(i=0;i<8;i++) {
+         s->u_mvs[i] = s->mvs_base[i];
+         *s->u_mvs[i]++ = 0;
+@@ -2806,6 +2829,13 @@ static void rpi_inter_clear(HEVCContext *s)
+         *s->u_mvs[i]++ = pic_height;
+         *s->u_mvs[i]++ = s->frame->linesize[1];
+         *s->u_mvs[i]++ = s->frame->linesize[2];
++        if (weight_flag) {
++            *s->u_mvs[i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
++            *s->u_mvs[i]++ = s->sh.chroma_log2_weight_denom + 6;
++        } else {
++            *s->u_mvs[i]++ = 1 << 5;
++            *s->u_mvs[i]++ = 6;
++        }
+         s->u_mvs[i] += 1;  // Padding words
+     }
+ }
+@@ -2849,12 +2879,29 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     int ctb_addr_ts = s->ps.pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];
+ 
+ #ifdef RPI
++#ifdef RPI_INTER_QPU
+     s->enable_rpi = s->ps.sps->bit_depth == 8
+                     && s->ps.sps->width <= RPI_MAX_WIDTH
+                     && !s->ps.pps->cross_component_prediction_enabled_flag
+                     && s->ps.pps->num_tile_rows <= 1 && s->ps.pps->num_tile_columns <= 1
+-                    && !(s->ps.pps->weighted_pred_flag && s->sh.slice_type == P_SLICE)
+                     && !(s->ps.pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE);
++#else
++    s->enable_rpi = s->ps.sps->bit_depth == 8
++                    && s->ps.sps->width <= RPI_MAX_WIDTH
++                    && !s->ps.pps->cross_component_prediction_enabled_flag
++                    && s->ps.pps->num_tile_rows <= 1 && s->ps.pps->num_tile_columns <= 1;
++#endif
++
++    /*if (!s->enable_rpi) {
++      if (s->ps.pps->cross_component_prediction_enabled_flag)
++        printf("Cross component\n");
++      if (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)
++        printf("Tiles\n");
++      if (s->ps.pps->weighted_pred_flag && s->sh.slice_type == P_SLICE)
++        printf("Weighted P slice\n");
++      if (s->ps.pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE)
++        printf("Weighted B slice\n");
++    }*/
+ 
+ #endif
+ 
+@@ -2987,6 +3034,7 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
+ 
+ #ifdef RPI
+     s->enable_rpi = 0;
++    //printf("Wavefront\n");
+ #endif
+ 
+     if(ctb_row) {
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index b0b93b5..3f04d80 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -88,287 +88,307 @@ unsigned int rpi_shader[] = {
+ /* [0x000001f8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+ /* [0x00000200] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+ /* [0x00000208] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+-/* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000218] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000220] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000228] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000230] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000238] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000240] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+-/* [0x00000248] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++/* [0x00000210] */ 0x15827d80, 0x10021327, // mov rb12,unif
++/* [0x00000218] */ 0x15827d80, 0x10021367, // mov rb13,unif
++/* [0x00000220] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000228] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000230] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000238] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000240] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000248] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000250] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
++/* [0x00000258] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
+ // ::mc_filter_uv
+-/* [0x00000250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000258] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000260] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000268] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000270] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000278] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000280] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000288] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000290] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000298] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000002a0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000002a8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000002b0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000002b8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000002c0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000002c8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000002d0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000002d8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000002e0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000002e8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000002f0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000002f8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000300] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000330] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000338] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000340] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000348] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x00000350] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000358] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000360] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000268] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000270] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000278] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000280] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000288] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000290] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000298] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000002a0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000002a8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000002b0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000002b8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000002c0] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000002c8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000002e8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000002f0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000340] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000348] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000350] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000358] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000360] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000368] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000370] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
++/* [0x00000378] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000380] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
++/* [0x00000388] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000390] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
++/* [0x00000398] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000003a0] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
++/* [0x000003a8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000003b0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x00000368] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000370] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000378] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000380] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000388] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000390] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000398] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003a0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000003a8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000003b0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x000003b8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000003c0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000003c8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000003d0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000003d8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000003e0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000003e8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000003f0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000003f8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000400] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000408] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000410] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000418] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000420] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000428] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000430] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000438] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000440] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000448] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000450] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000458] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000460] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000468] */ 0x0c567380, 0x10020867, // add r1, r1, ra21
+-/* [0x00000470] */ 0xfffffed8, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000478] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
+-/* [0x00000480] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000488] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000490] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000498] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000004a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000004a8] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x000004b0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x000004b8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000004c0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x000004c8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000004d0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000003b8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000003c0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x000003c8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x000003d0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000003d8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000003e0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000003e8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003f0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003f8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000400] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000408] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000410] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000418] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000420] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000428] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000430] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000438] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000440] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000448] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000450] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000458] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000460] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000468] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000470] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000478] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000480] */ 0x00000020, 0xe0021327, // mov rb12,32
++/* [0x00000488] */ 0x00000006, 0xe0021367, // mov rb13,6
++/* [0x00000490] */ 0x00000001, 0xe00213a7, // mov rb14,1
++/* [0x00000498] */ 0x00000000, 0xe00213e7, // mov rb15,0
++/* [0x000004a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000004a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000004b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000004b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000004c0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000004c8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000004d0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000004d8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
++/* [0x000004e0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
++/* [0x000004e8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
++/* [0x000004f0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x000004f8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
++/* [0x00000500] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000508] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000510] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000518] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000520] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000528] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000530] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000538] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000540] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000548] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000550] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b0
+-/* [0x000004d8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000004e0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000004e8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000004f0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000004f8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000500] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000508] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000510] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000518] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000520] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000528] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000530] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+-/* [0x00000538] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000540] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000548] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000550] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000558] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000560] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x00000568] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x00000570] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000578] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000580] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000588] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000590] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000598] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005a0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005a8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005b0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000005b8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000005c0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000005c8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000005d0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x000005d8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000005e0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000005e8] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000558] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000560] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000568] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000570] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000578] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000580] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000588] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000590] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000598] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x000005a0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000005a8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x000005b0] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
++/* [0x000005b8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000005c0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005c8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000005d0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000005d8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000005e0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000005e8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000005f0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000005f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000600] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000608] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000610] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000618] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000620] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000628] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000630] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000638] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000640] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000648] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000650] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000658] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000660] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000668] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000670] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000678] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x000005f0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000005f8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000600] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000608] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000610] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000618] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000620] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000628] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000630] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000638] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000640] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000648] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000650] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000658] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000660] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000668] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000670] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000678] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000680] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000688] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000690] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000698] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x000006a0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000006a8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x000006b0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x000006b8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000006c0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000006c8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000006d0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000006d8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000006e0] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+-/* [0x000006e8] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x000006f0] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+-/* [0x000006f8] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000700] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000708] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000710] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000718] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000720] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000680] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000688] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000690] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000698] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000006a0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000006a8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000006b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000006b8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000006c0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x000006c8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x000006d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000006d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000006e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000006e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000006f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000006f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000700] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000708] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000710] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000718] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000720] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000728] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000730] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000738] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000740] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000748] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000750] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000758] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000760] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000768] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000770] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
++/* [0x00000778] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000780] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
++/* [0x00000788] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000790] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000798] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000007a0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000007a8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000007b0] */ 0x009e7000, 0x100009e7, // nop
+ // ::mc_filter_uv_b
+-/* [0x00000728] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000730] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000738] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000740] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000748] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000750] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000758] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000760] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000768] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000770] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000778] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000780] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000788] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000790] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000798] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000007a0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000007a8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000007b0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000007b8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000007c0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000007c8] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x000007d0] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x000007d8] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x000007e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000007e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000007f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000007f8] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000800] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000808] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000810] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000818] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000820] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000828] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000830] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000838] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000840] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x00000848] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000850] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000858] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000007b8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000007c0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000007c8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000007d0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000007d8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000007e0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000007e8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000007f0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000007f8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
++/* [0x00000800] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000808] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
++/* [0x00000810] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000818] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000820] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000828] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000830] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000838] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000840] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000848] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x00000850] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000858] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000860] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000868] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000870] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000878] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000880] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000888] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000890] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000898] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008a0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008a8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008b0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000008b8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008c0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008c8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008d0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x000008d8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000008e0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000008e8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000008f0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000008f8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x00000860] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000868] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000870] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000878] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000880] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000888] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000890] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000898] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000008a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000008a8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x000008b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000008b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000008c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000008c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000008d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000008d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000008e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000008e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000008f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000008f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000900] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000908] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000910] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000918] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000920] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000928] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000930] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000938] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000940] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000948] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000950] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x00000958] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000960] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x00000968] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x00000970] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000978] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00000980] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000988] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000990] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000998] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000009a0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x000009a8] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x000009b0] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x000009b8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000009c0] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x000009c8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x000009d0] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000900] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000908] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
++/* [0x00000910] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++/* [0x00000918] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000920] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000928] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000930] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000938] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000940] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
++/* [0x00000948] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
++/* [0x00000950] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000958] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000960] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000968] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000970] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000978] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000980] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000988] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000990] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000998] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x000009a0] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x000009a8] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000009b0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000009b8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x000009c0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000009c8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000009d0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000009d8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000009e0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000009e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000009f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000009f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000a00] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x00000a08] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x00000a10] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000a18] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00000a20] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000a28] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000a30] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000a38] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a40] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000a48] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000a50] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000a60] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x000009e0] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x000009e8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000009f0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x000009f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a00] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a08] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000a10] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000a18] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a78] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a80] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a98] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000aa0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000ab0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000a20] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a28] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a30] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a38] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a40] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a48] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a50] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a58] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a60] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a68] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000a80] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000a88] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000a90] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000ac0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ad8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ae0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b10] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b18] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000b20] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000b28] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000b30] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 99927c4..cec9901 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -4,11 +4,11 @@
+ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+-#define mc_filter_uv (rpi_shader + 148)
+-#define mc_filter_uv_b0 (rpi_shader + 310)
+-#define mc_filter_uv_b (rpi_shader + 458)
+-#define mc_exit (rpi_shader + 630)
+-#define mc_interrupt_exit8 (rpi_shader + 648)
+-#define mc_end (rpi_shader + 678)
++#define mc_filter_uv (rpi_shader + 152)
++#define mc_filter_uv_b0 (rpi_shader + 342)
++#define mc_filter_uv_b (rpi_shader + 494)
++#define mc_exit (rpi_shader + 670)
++#define mc_interrupt_exit8 (rpi_shader + 688)
++#define mc_end (rpi_shader + 718)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index d9ffcda..97c4c02 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -9,7 +9,12 @@
+ #                                               (ra15 isn't clamped to zero - this happens during the
+ #                                                copy to ra14, and during its use in the vertical filter)
+ #
+-# rb8...rb15                                    eight vertical filter coefficients
++# rb8...rb11                                    eight vertical filter coefficients
++
++# rb12 offset to add before shift
++# rb13 shift
++# rb14 weight (U on left, V on right)
++# rb15 offset (U on left, V on right)
+ #
+ # ra16                                          clipped(row start address+elem_num)&~3
+ # ra17                                          per-channel shifts
+@@ -165,6 +170,9 @@ add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+ add t0s, r0, r1 ; mov ra_x2_base, r2
+ add t0s, r2, r1
+ 
++mov rb12,unif # offset before shift
++mov rb13,unif # offset after shift
++
+ # Dump padding words
+ mov r0, unif
+ 
+@@ -231,11 +239,21 @@ asr rb10, r0, rb23;     mul24 r0, r0, ra22
+ asr rb9, r0, rb23;      mul24 r0, r0, ra22
+ asr rb8, r0, rb23
+ 
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++mov r0, unif # U offset/weight
++asr rb15, r0, r2  # Compute offset from MSBs
++shl r0, r0, r2
++asr rb14, r0, r2  # Compute weight from LSBs
++mov r0, unif # V offset/weight
++asr.ifnz rb15, r0, r2
++shl r0, r0, r2
++asr.ifnz rb14, r0, r2
++
+ # r2 is elem_num
+ # r3 is loop counter
+ 
+ mov r5rep, -8
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ 
+ # retrieve texture results and pick out bytes
+ # then submit two more texture requests
+@@ -279,6 +297,11 @@ mov ra13, ra14       # Delay slot 1
+ mov ra14, ra15       # Delay slot 2
+ mov ra15, r0         # Delay slot 3
+ 
++mov rb12,32
++mov rb13,6
++mov rb14,1
++mov rb15,0
++
+ # apply vertical filter and write to VPM
+ 
+ nop                     ; mul24 r1, ra14, rb10
+@@ -288,9 +311,11 @@ add r1, r1, r0          ; mul24 r0, ra15, rb11
+ add r1, r1, r0          ; mov -, vw_wait
+ sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+ asr r1, r1, 14
+-add r1, r1, ra21
++nop                     ; mul24 r1, r1, rb14
++add r1, r1, rb12
++asr r1, r1, rb13
+ brr.anyn -, r:uvloop
+-asr r1, r1, 6          # Delay 1
++add r1, r1, rb15       # Delay 1
+ min r1, r1, rb22       # Delay 2
+ max vpm, r1, 0         # Delay 3
+ 
+@@ -364,6 +389,9 @@ asr rb10, r0, rb23;     mul24 r0, r0, ra22
+ asr rb9, r0, rb23;      mul24 r0, r0, ra22
+ asr rb8, r0, rb23
+ 
++mov r0, unif # U offset/weight
++mov r0, unif # V offset/weight
++
+ # r2 is elem_num
+ # r3 is loop counter
+ 
+@@ -491,6 +519,9 @@ asr rb10, r0, rb23;     mul24 r0, r0, ra22
+ asr rb9, r0, rb23;      mul24 r0, r0, ra22
+ asr rb8, r0, rb23
+ 
++mov r0, unif # U offset/weight
++mov r0, unif # V offset/weight
++
+ # r2 is elem_num
+ # r3 is loop counter
+ 
+-- 
+2.7.4
+
+
+From 310d994ea39e29b41a6a013abc4d94e6b90487b2 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Tue, 19 May 2015 08:43:30 +0100
+Subject: [PATCH 40/68] Improved ordering of tasks
+
+---
+ libavcodec/hevc.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 9668ef8..951e2d3 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2943,15 +2943,15 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+           s->dblk_cmds[s->num_dblk_cmds][0] = x_ctb;
+           s->dblk_cmds[s->num_dblk_cmds++][1] = y_ctb;
+           if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->ps.sps->width) {
+-#ifdef RPI_INTER_QPU
+-            // Kick off inter prediction on QPUs
+-            rpi_execute_inter_qpu(s);
+-#endif
+             // Transform all blocks
+             // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+             rpi_execute_transform(s);
+             // Perform inter prediction
+             rpi_execute_inter_cmds(s);
++#ifdef RPI_INTER_QPU
++            // Kick off inter prediction on QPUs
++            rpi_execute_inter_qpu(s);
++#endif
+             // Wait for transform completion
+             vpu_wait(s->vpu_id);
+ 
+-- 
+2.7.4
+
+
+From d6e1ce7898196e49e52a6223c12979b3d0014588 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 20 May 2015 19:58:19 +0100
+Subject: [PATCH 41/68] Drafted Luma inter prediction
+
+---
+ libavcodec/rpi_shader.qasm | 594 ++++++++++++++++++++++++++++++++++++++++++---
+ 1 file changed, 554 insertions(+), 40 deletions(-)
+
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 97c4c02..9cfc0d9 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -2,7 +2,10 @@
+ #
+ # ra0...ra7                                     eight horizontal filter coefficients
+ #
+-# rb1...rb7                                     seven shifted copies of the current unfiltered row
++# rb0 rx_shift2
++# rb1 ra_y2_next
++#
++# rb4...rb7
+ #
+ # ra8...ra15                                    eight filtered rows of context (rb15 == most recent)
+ #
+@@ -26,9 +29,9 @@
+ # rb19                                          next ra16
+ #
+ # ra20                                          1
+-# ra21                                          32
++# ra21                                          ra_21
+ # ra22                                          256
+-# ra23                                          8
++# ra23                                          rx_shift2_next
+ #
+ # rb20                                          0xffffff00
+ # rb21                                          vpm_setup for reading/writing 16bit results into VPM
+@@ -57,16 +60,23 @@
+ .set rb_frame_width_minus_1,       rb25
+ .set rb_frame_height_minus_1,      rb30
+ .set rb_pitch,                     rb16
+-.set ra_x_base,                    ra16
+-.set rb_x_base_next,               rb19
+-.set ra_x2_base,                   ra24
+-.set ra_x2_base_next,              ra26
++.set ra_x,                         ra16
++.set ra_y2,                        ra21
++.set ra_y2_next,                   rb1
++
++.set rb_x_next,                    rb19
++.set rx_frame_base2_next,          rb19
++
++.set ra_frame_base,                ra24
++.set ra_frame_base_next,           ra26
+ .set ra_xshift,                    ra17
+ 
+-.set ra_x2shift,                   ra25
+ .set ra_u2v_ref_offset,            ra25
++.set ra_frame_base2,               ra25
+ 
+ .set ra_xshift_next,               ra19
++.set rx_xshift2,                   rb0
++.set rx_xshift2_next,              ra23
+ 
+ .set ra_x2shift_next,              ra27
+ .set ra_u2v_dst_offset,            ra27
+@@ -83,11 +93,11 @@
+ mov ra31, unif
+ 
+ # Load first request location
+-add ra_x_base, unif, elem_num # Store x
++add ra_x, unif, elem_num # Store x
+ mov ra_y, unif # Store y
+-mov ra_x2_base, unif # Store frame u base
++mov ra_frame_base, unif # Store frame u base
+ nop
+-sub ra_u2v_ref_offset, unif, ra_x2_base # Store offset to add to move from u to v in reference frame
++sub ra_u2v_ref_offset, unif, ra_frame_base # Store offset to add to move from u to v in reference frame
+ 
+ # Read image dimensions
+ sub rb25,unif,1
+@@ -104,9 +114,7 @@ add rb24, r1, r0
+ # load constants
+ 
+ mov ra20, 1
+-mov ra21, 32
+ mov ra22, 256
+-mov ra23, 8
+ mov ra30, 64
+ 
+ mov rb20, 0xffffff00
+@@ -156,18 +164,18 @@ mov r1, vpm_setup(0, 2, h16p(0, 0))  # 2 is stride - stride acts on ADDR which i
+ add rb21, r0, r1
+ 
+ # Compute base address for first and second access
+-mov r0, ra_x_base           # Load x
++mov r0, ra_x           # Load x
+ max r0, r0, 0; mov r1, ra_y # Load y
+-min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base  # Load the frame base
++min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base  # Load the frame base
+ shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+ add ra_y, r1, 1
+ add r0, r0, r3
+ and r0, r0, ~3
+-max r1, r1, 0 ; mov ra_x_base, r0 # y
++max r1, r1, 0 ; mov ra_x, r0 # y
+ min r1, r1, rb_frame_height_minus_1
+ # submit texture requests for first line
+ add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+-add t0s, r0, r1 ; mov ra_x2_base, r2
++add t0s, r0, r1 ; mov ra_frame_base, r2
+ add t0s, r2, r1
+ 
+ mov rb12,unif # offset before shift
+@@ -182,8 +190,8 @@ min r1, r1, rb_frame_height_minus_1
+ add ra_y, ra_y, 1
+ bra -, ra31
+ nop ; mul24 r1, r1, rb_pitch
+-add t0s, r1, ra_x_base
+-add t0s, r1, ra_x2_base
++add t0s, r1, ra_x
++add t0s, r1, ra_frame_base
+ 
+ 
+ 
+@@ -192,7 +200,7 @@ add t0s, r1, ra_x2_base
+ # mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
+ 
+ # At this point we have already issued two pairs of texture requests for the current block
+-# ra_x_base, ra_x16_base point to the current coordinates for this block
++# ra_x, ra_x16_base point to the current coordinates for this block
+ ::mc_filter_uv
+ mov ra31, unif
+ 
+@@ -207,9 +215,9 @@ min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+ shl ra_xshift_next, r0, 3
+ sub r2, unif, r3 # compute offset from frame base u to frame base v
+ add r0, r0, r3
+-and rb_x_base_next, r0, ~3
++and rb_x_next, r0, ~3
+ mov ra_y_next, r1
+-add ra_x2_base_next, rb_x_base_next, r2
++add ra_frame_base_next, rb_x_next, r2
+ 
+ # set up VPM write
+ mov vw_setup, rb28
+@@ -265,16 +273,16 @@ mov r3, 0
+ # then submit two more texture requests
+ 
+ sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+ mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+ shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+ 
+ max r2, ra_y, 0  # y
+ min r2, r2, rb_frame_height_minus_1
+ add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-add t0s, ra_x2_base, r2
++add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++add t0s, ra_frame_base, r2
+ 
+ # generate seven shifted versions
+ # interleave with scroll of vertical context
+@@ -297,7 +305,7 @@ mov ra13, ra14       # Delay slot 1
+ mov ra14, ra15       # Delay slot 2
+ mov ra15, r0         # Delay slot 3
+ 
+-mov rb12,32
++mov rb12,32 # TODO remove these to make P weighted prediction work properly
+ mov rb13,6
+ mov rb14,1
+ mov rb15,0
+@@ -342,7 +350,7 @@ mov vw_addr, unif # start the VDW
+ # mc_filter_uv_b0(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
+ 
+ # At this point we have already issued two pairs of texture requests for the current block
+-# ra_x_base, ra_x16_base point to the current coordinates for this block
++# ra_x, ra_x16_base point to the current coordinates for this block
+ ::mc_filter_uv_b0
+ mov ra31, unif
+ 
+@@ -357,9 +365,9 @@ min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+ shl ra_xshift_next, r0, 3
+ sub r2, unif, r3 # compute offset from frame base u to frame base v
+ add r0, r0, r3
+-and rb_x_base_next, r0, ~3
++and rb_x_next, r0, ~3
+ mov ra_y_next, r1
+-add ra_x2_base_next, rb_x_base_next, r2
++add ra_frame_base_next, rb_x_next, r2
+ 
+ # set up VPM write, we need to save 16bit precision
+ mov vw_setup, rb21
+@@ -408,16 +416,16 @@ mov r3, 0
+ # then submit two more texture requests
+ 
+ sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+ mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+ shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+ 
+ max r2, ra_y, 0  # y
+ min r2, r2, rb_frame_height_minus_1
+ add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-add t0s, ra_x2_base, r2
++add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++add t0s, ra_frame_base, r2
+ 
+ # generate seven shifted versions
+ # interleave with scroll of vertical context
+@@ -477,9 +485,9 @@ min r0, r0, rb_frame_width_minus_1 ; mov r3, unif # frame_base
+ shl ra_xshift_next, r0, 3
+ sub r2, unif, r3 # compute offset from frame base u to frame base v
+ add r0, r0, r3
+-and rb_x_base_next, r0, ~3
++and rb_x_next, r0, ~3
+ mov ra_y_next, r1
+-add ra_x2_base_next, rb_x_base_next, r2
++add ra_frame_base_next, rb_x_next, r2
+ 
+ # set up VPM write
+ mov vw_setup, rb28
+@@ -538,16 +546,16 @@ mov r3, 0
+ # then submit two more texture requests
+ 
+ sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
++shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+ mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+ shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+ 
+ max r2, ra_y, 0  # y
+ min r2, r2, rb_frame_height_minus_1
+ add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-add t0s, ra_x2_base, r2
++add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++add t0s, ra_frame_base, r2
+ 
+ # generate seven shifted versions
+ # interleave with scroll of vertical context
+@@ -642,5 +650,511 @@ nop        ; nop ; thrend
+ mov interrupt, 1; nop # delay slot 1
+ nop        ; nop # delay slot 2
+ 
++
++
++
++
++# LUMA CODE
++
++# The idea is to form B predictions by doing 8 pixels from ref0 in parallel with 8 pixels from ref1.
++# For P frames we make the second x,y coordinates offset by +8
++
++################################################################################
++# mc_setup(next_kernel, x, y, ref_y_base, x2, y2, ref_y2_base, frame_width, frame_height, pitch, dst_pitch, offset, shift, pad2)
++::mc_setup
++
++# Read starting kernel
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++mov ra31, unif
++
++# Compute base address for first and second access
++add r0, unif, elem_num # Load x
++max r0, r0, 0; mov r1, unif # Load y
++min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
++shl ra_xshift_next, r0, 3 # Compute shifts
++add ra_y, r1, 1
++and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++add r2, r2, r0  # r2 is address for frame0 (not including y offset)
++max r1, r1, 0
++min r1, r1, rb_frame_height_minus_1
++nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
++add t0s, r2, r1 ; mov ra_frame_base, r2
++
++add r0, unif, elem_num # Load x
++max r0, r0, 0; mov r1, unif # Load y
++min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
++shl rx_xshift2_next, r0, 3 # Compute shifts
++add ra_y2, r1, 1
++and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++add r2, r2, r0  # r2 is address for frame1 (not including y offset)
++max r1, r1, 0
++min r1, r1, rb_frame_height_minus_1
++nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
++add t0s, r2, r1 ; mov ra_frame_base2, r2
++
++
++# Read image dimensions
++sub rb25,unif,1
++sub rb30,unif,1
++
++# get source pitch
++mov rb16, unif
++
++# get destination pitch
++mov r0, unif
++mov r1, vdw_setup_1(0)
++add rb24, r1, r0
++
++# load constants
++
++mov ra20, 1
++mov ra22, 256
++mov ra30, 64
++
++mov rb20, 0xffffff00
++mov rb22, 255
++mov rb23, 24
++
++# touch vertical context to keep simulator happy
++
++mov ra8, 0
++mov ra9, 0
++mov ra10, 0
++mov ra11, 0
++mov ra12, 0
++mov ra13, 0
++mov ra14, 0
++mov ra15, 0
++
++# Compute part of VPM to use for DMA output
++mov r2, qpu_num
++mov r1, r2
++asr r1, r1, 2
++shl r1, r1, 6
++mov r0, r2
++and r0, r0, 3
++add r0, r0, r1
++mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
++shl r0, r0, 5
++add rb27, r0, r1
++
++# Compute part of VPM to save data into
++mov r2, qpu_num   # qpu_num = abcd
++mov r1, r2
++asr r1, r1, 2
++shl r1, r1, 6
++mov r0, r2
++and r0, r0, 3
++add r0, r0, r1
++mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
++add rb28, r0, r1
++
++mov rb12,unif # offset before shift
++mov rb13,unif # shift
++
++# Dump padding words
++mov r0, unif
++
++# submit texture requests for second line
++max r1, ra_y, 0
++min r1, r1, rb_frame_height_minus_1
++add ra_y, ra_y, 1
++nop ; mul24 r1, r1, rb_pitch
++add t0s, r1, ra_frame_base
++
++max r1, ra_y2, 0
++min r1, r1, rb_frame_height_minus_1
++bra -, ra31
++add ra_y2, ra_y2, 1           # Delay 1
++nop ; mul24 r1, r1, rb_pitch  # Delay 2
++add t0s, r1, ra_frame_base2   # Delay 3
++
++
++################################################################################
++
++# mc_filter(next_kernel, x, y, frame_base, x2, y2, frame_base2, height, hcoeffs[0], hcoeffs2[0], hcoeffs[1], hcoeffs2[1], vcoeffs[0], vcoeffs2[0], vcoeffs[1], vcoeffs2[1], offsetweight0, offsetweight1, this_dst)
++# In a P block, only the first half of coefficients contain used information.
++# At this point we have already issued two pairs of texture requests for the current block
++# ra_x, ra_x16_base point to the current coordinates for this block
++::mc_filter
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++mov ra31, unif
++
++# per-channel shifts were calculated on the *previous* invocation
++
++mov ra_xshift, ra_xshift_next
++mov rx_xshift2, rx_xshift2_next
++
++# get base addresses and per-channel shifts for *next* invocation
++add r0, unif, elem_num # Load x
++max r0, r0, 0; mov r1, unif # Load y
++min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
++shl ra_xshift_next, r0, 3 # Compute shifts
++mov ra_y_next, r1
++and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++add ra_frame_base_next, r2, r0  # r2 is address for frame0 (not including y offset)
++
++add r0, unif, elem_num # Load x
++max r0, r0, 0   ; mov r1, unif # Load y
++min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
++shl rx_xshift2_next, r0, 3 # Compute shifts
++add ra_y2_next, r1, 1
++and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
++
++
++# set up VPM write
++mov vw_setup, rb28
++
++# get width,height of block
++mov r2, 16
++mov r0, unif
++shr r1, r0, r2 # Extract width
++sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
++and r0, r0, rb22 # Extract height
++add rb17, r0, 5
++add rb18, r0, 7
++shl r0, r0, 7
++add r0, r0, r1 # Combine width and height of destination area
++shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
++add rb26, r0, rb27
++
++# get filter coefficients and discard unused B frame values
++mov r0, unif
++mov.ifnz -, unif # Alternate coefficients are unused for P frames
++asr ra3, r0, rb23;      mul24 r0, r0, ra22 # These may need some pre-rotation to be used in B frames correctly
++asr ra2, r0, rb23;      mul24 r0, r0, ra22
++asr ra1, r0, rb23;      mul24 r0, r0, ra22
++asr ra0, r0, rb23;      mov r0, unif
++mov.ifnz -, unif
++asr ra7, r0, rb23;      mul24 r0, r0, ra22
++asr ra6, r0, rb23;      mul24 r0, r0, ra22
++asr ra5, r0, rb23;      mul24 r0, r0, ra22
++asr ra4, r0, rb23;      mov r0, unif
++mov.ifnz -, unif
++asr rb11, r0, rb23;     mul24 r0, r0, ra22
++asr rb10, r0, rb23;     mul24 r0, r0, ra22
++asr rb9, r0, rb23;      mul24 r0, r0, ra22
++asr rb8, r0, rb23;      mov r0, unif
++mov.ifnz -, unif
++asr rb7, r0, rb23;      mul24 r0, r0, ra22
++asr rb6, r0, rb23;      mul24 r0, r0, ra22
++asr rb5, r0, rb23;      mul24 r0, r0, ra22
++asr rb4, r0, rb23
++
++mov r0, unif # Frame0 offset/weight
++mov.ifnz -, unif # Frame1 offset/weight unused
++asr rb15, r0, r2  # Compute offset from MSBs
++shl r0, r0, r2
++asr rb14, r0, r2  # Compute weight from LSBs
++
++# r3 is loop counter
++
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++mov r3, 0
++
++:yloop
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++# If we knew there was no clipping then this code would get simpler.
++# Perhaps we could add on the pitch and clip using larger values?
++
++sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
++mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++shr r1, r4, rx_xshift2
++mov.ifz ra_y2, ra_y2_next
++
++max r2, ra_y, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
++
++max r2, ra_y2, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
++
++
++# generate seven shifted versions
++# interleave with scroll of vertical context
++
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++# apply horizontal filter
++nop                  ; mul24 r2, r0, ra0
++nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++nop                  ; mul24      r3, ra1 << 1, r0 << 1
++nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++add r0, r2, r3       ; mov r3, rb31
++sub.setf -, r3, 8    ; mov ra12, ra13
++mov ra9, ra10
++mov ra10, ra11
++mov ra11, ra12
++mov ra12, ra13
++brr.anyn -, r:yloop
++mov ra13, ra14       # Delay slot 1
++mov ra14, ra15       # Delay slot 2
++mov ra15, r0         # Delay slot 3
++
++# apply vertical filter and write to VPM
++
++nop                     ; mul24 r1, ra14, rb10
++nop                     ; mul24 r0, ra13, rb9
++add r1, r1, r0          ; mul24 r0, ra12, rb8
++add r1, r1, r0          ; mul24 r0, ra15, rb11
++add r1, r1, r0          ; mul24 r0, ra8, rb4
++add r1, r1, r0          ; mul24 r0, ra9, rb5
++add r1, r1, r0          ; mul24 r0, ra10, rb6
++add r1, r1, r0          ; mul24 r0, ra11, rb7
++
++add r1, r1, r0          ; mov -, vw_wait
++sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++asr r1, r1, 14
++nop                     ; mul24 r1, r1, rb14
++add r1, r1, rb12
++asr r1, r1, rb13
++brr.anyn -, r:yloop
++add r1, r1, rb15       # Delay 1
++min r1, r1, rb22       # Delay 2
++max vpm, r1, 0         # Delay 3
++
++# DMA out
++
++bra -, ra31
++mov vw_setup, rb26 # VDW setup 0    Delay 1
++mov vw_setup, rb29 # Stride         Delay 2
++mov vw_addr, unif # start the VDW   Delay 3
++
++
++
++################################################################################
++
++# mc_filter_b(next_kernel, x, y, frame_base, x2, y2, frame_base2, width_height, hcoeffs[0], hcoeffs2[0], hcoeffs[1], hcoeffs2[1], vcoeffs[0], vcoeffs2[0], vcoeffs[1], vcoeffs2[1], offsetweight0, offsetweight1, this_dst)
++# In a P block, only the first half of coefficients contain used information.
++# At this point we have already issued two pairs of texture requests for the current block
++# May be better to just send 16.16 motion vector and figure out the coefficients inside this block (only 4 cases so can compute hcoeffs in around 24 cycles?)
++# Can fill in the coefficients so only
++# Can also assume default weighted prediction for B frames.
++# Perhaps can unpack coefficients in a more efficient manner by doing H/V for a and b at the same time?
++# Or possibly by taking advantage of symmetry?
++# From 19->7 32bits per command.
++::mc_filter_b
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++mov ra31, unif
++
++# per-channel shifts were calculated on the *previous* invocation
++
++mov ra_xshift, ra_xshift_next
++mov rx_xshift2, rx_xshift2_next
++
++# get base addresses and per-channel shifts for *next* invocation
++add r0, unif, elem_num # Load x
++max r0, r0, 0; mov r1, unif # Load y
++min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
++shl ra_xshift_next, r0, 3 # Compute shifts
++mov ra_y_next, r1
++and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++add ra_frame_base_next, r2, r0  # r2 is address for frame0 (not including y offset)
++
++add r0, unif, elem_num # Load x
++max r0, r0, 0   ; mov r1, unif # Load y
++min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
++shl rx_xshift2_next, r0, 3 # Compute shifts
++add ra_y2_next, r1, 1
++and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
++
++
++# set up VPM write
++mov vw_setup, rb28
++
++# get width,height of block
++mov r2, 16
++mov r0, unif
++shr r1, r0, r2 # Extract width
++sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
++and r0, r0, rb22 # Extract height
++add rb17, r0, 5
++add rb18, r0, 7
++shl r0, r0, 7
++add r0, r0, r1 # Combine width and height of destination area
++shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
++add rb26, r0, rb27
++
++# get filter coefficients and discard unused B frame values
++mov r0, unif
++mov r1, 1
++mov.ifnz r0, unif # Alternate coefficients are unused for P frames
++nop              ;      mul24 r0, r0 << 13, r1 << 13
++asr ra3, r0, rb23;      mul24 r0, r0, ra22
++nop              ;      mul24 r0, r0 << 14, r1 << 14
++asr ra2, r0, rb23;      mul24 r0, r0, ra22
++nop              ;      mul24 r0, r0 << 15, r1 << 15 # Adjust such that a rotate of 1 will produce the values with first 8 on left, second 8 on right
++asr ra1, r0, rb23;      mul24 r0, r0, ra22
++asr ra0, r0, rb23;      mov r0, unif
++mov.ifnz r0, unif
++nop              ;      mul24 r0, r0 << 9, r1 << 9
++asr ra7, r0, rb23;      mul24 r0, r0, ra22
++nop              ;      mul24 r0, r0 << 10, r1 << 10
++asr ra6, r0, rb23;      mul24 r0, r0, ra22
++nop              ;      mul24 r0, r0 << 11, r1 << 11
++asr ra5, r0, rb23;      mul24 r0, r0, ra22
++nop              ;      mul24 r0, r0 << 12, r1 << 12
++asr ra4, r0, rb23;      mov r0, unif
++mov.ifnz r0, unif
++asr rb11, r0, rb23;     mul24 r0, r0, ra22
++asr rb10, r0, rb23;     mul24 r0, r0, ra22
++asr rb9, r0, rb23;      mul24 r0, r0, ra22
++asr rb8, r0, rb23;      mov r0, unif
++mov.ifnz r0, unif
++asr rb7, r0, rb23;      mul24 r0, r0, ra22
++asr rb6, r0, rb23;      mul24 r0, r0, ra22
++asr rb5, r0, rb23;      mul24 r0, r0, ra22
++asr rb4, r0, rb23
++
++mov r0, unif # Frame0 offset/weight
++mov.ifnz r0, unif # Frame1 offset/weight unused
++asr rb15, r0, r2  # Compute offset from MSBs
++shl r0, r0, r2
++asr rb14, r0, r2  # Compute weight from LSBs
++
++# r3 is loop counter
++
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++mov r3, 0
++
++:yloopb
++# retrieve texture results and pick out bytes
++# then submit two more texture requests
++
++# If we knew there was no clipping then this code would get simpler.
++# Perhaps we could add on the pitch and clip using larger values?
++
++sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
++mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++shr r1, r4, rx_xshift2
++mov.ifz ra_y2, ra_y2_next
++
++max r2, ra_y, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
++
++max r2, ra_y2, 0  # y
++min r2, r2, rb_frame_height_minus_1
++add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
++
++
++# generate seven shifted versions
++# interleave with scroll of vertical context
++
++mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++
++# apply horizontal filter
++nop                  ; mul24 r2, r0, ra0
++nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++nop                  ; mul24      r3, ra1 << 1, r0 << 1
++nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++add r0, r2, r3       ; mov r3, rb31
++sub.setf -, r3, 8    ; mov ra12, ra13
++mov ra9, ra10
++mov ra10, ra11
++mov ra11, ra12
++mov ra12, ra13
++brr.anyn -, r:yloopb
++mov ra13, ra14       # Delay slot 1
++mov ra14, ra15       # Delay slot 2
++mov ra15, r0         # Delay slot 3
++
++# apply vertical filter and write to VPM
++
++nop                     ; mul24 r1, ra14, rb10
++nop                     ; mul24 r0, ra13, rb9
++add r1, r1, r0          ; mul24 r0, ra12, rb8
++add r1, r1, r0          ; mul24 r0, ra15, rb11
++add r1, r1, r0          ; mul24 r0, ra8, rb4
++add r1, r1, r0          ; mul24 r0, ra9, rb5
++add r1, r1, r0          ; mul24 r0, ra10, rb6
++add r1, r1, r0          ; mul24 r0, ra11, rb7
++
++add r1, r1, r0          ; mov -, vw_wait
++sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++asr r1, r1, 14
++nop                     ; mul24 r1, r1 << 8, ra20 << 8 # Rotate to align left and right halves
++add r1, r1, ra30        ; mul24 r0, r1, rb14
++add r1, r1, r0
++brr.anyn -, r:yloopb
++asr r1, r1, 7          # Delay 1
++min r1, r1, rb22       # Delay 2
++max vpm, r1, 0         # Delay 3
++
++# DMA out
++bra -, ra31
++mov vw_setup, rb26 # VDW setup 0    Delay 1
++mov vw_setup, rb29 # Stride         Delay 2
++mov vw_addr, unif # start the VDW   Delay 3
++
++################################################################################
++
++# mc_interrupt_exit12()
++::mc_interrupt_exit12
++mov  -, vw_wait # wait on the VDW
++
++ldtmu0
++ldtmu0
++ldtmu0
++ldtmu0
++
++mov -,sacq(0) # 1
++mov -,sacq(0) # 2
++mov -,sacq(0) # 3
++mov -,sacq(0) # 4
++mov -,sacq(0) # 5
++mov -,sacq(0) # 6
++mov -,sacq(0) # 7
++mov -,sacq(0) # 8
++mov -,sacq(0) # 9
++mov -,sacq(0) # 10
++mov -,sacq(0) # 11
++
++nop        ; nop ; thrend
++mov interrupt, 1; nop # delay slot 1
++nop        ; nop # delay slot 2
++
++
+ ::mc_end
+ # Do not add code here because mc_end must appear after all other code.
+-- 
+2.7.4
+
+
+From f2ffe4186fa49cb27579953c276b51728a08a8b5 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 20 May 2015 19:58:30 +0100
+Subject: [PATCH 42/68] Added support for fast cache flush in deblocker
+
+---
+ libavcodec/hevc_filter.c   |   44 +-
+ libavcodec/rpi_qpu.c       |    6 +
+ libavcodec/rpi_qpu.h       |    2 +
+ libavcodec/rpi_shader.c    | 1028 +++++++++++++++++++++++++++++---------------
+ libavcodec/rpi_shader.h    |   16 +-
+ libavcodec/rpi_user_vcsm.h |   22 +
+ 6 files changed, 768 insertions(+), 350 deletions(-)
+
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 92a8271..186317a 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -37,6 +37,11 @@
+ 
+ #include "bit_depth_template.c"
+ 
++#ifdef RPI
++#include "rpi_user_vcsm.h"
++#include "rpi_qpu.h"
++#endif
++
+ #define LUMA 0
+ #define CB 1
+ #define CR 2
+@@ -872,15 +877,46 @@ static void flush_buffer(AVBufferRef *bref) {
+     gpu_cache_flush(p);
+ }
+ 
+-static void ff_hevc_flush_chroma(HEVCContext *s)
++// Return Physical address for this image
++static int ff_hevc_buf_base(AVBufferRef *bref) {
++  GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
++  return p->vc & 0x3fffffff;
++}
++
++static void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
+ {
+     if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
+             s->nal_unit_type == NAL_TSA_N   ||
+             s->nal_unit_type == NAL_STSA_N  ||
+             s->nal_unit_type == NAL_RADL_N  ||
+             s->nal_unit_type == NAL_RASL_N )) {
++#define RPI_FAST_CACHEFLUSH
++#ifdef RPI_FAST_CACHEFLUSH
++        struct vcsm_user_clean_invalid_s iocache = {};
++        int curr_y = f->progress->data[0];
++        int sz,base;
++        if (curr_y < 0) curr_y = 0;
++        if (n<=curr_y) return; // Should not happen
++        sz = s->frame->linesize[1] * (n-curr_y);
++        base = s->frame->linesize[1] * curr_y;
++        iocache.s[0].cmd = 3; // Flush L1 cache
++        iocache.s[0].addr = 0;
++        iocache.s[0].size  = 0;
++
++        iocache.s[1].cmd = 2;
++        iocache.s[1].addr = ff_hevc_buf_base(s->frame->buf[1]) + base;
++        iocache.s[1].size  = sz;
++
++        iocache.s[2].cmd = 2;
++        iocache.s[2].addr = ff_hevc_buf_base(s->frame->buf[2]) + base;
++        iocache.s[2].size  = sz;
++
++        vcsm_clean_invalid( gpu_get_mailbox(), &iocache );
++
++#else
+         flush_buffer(s->frame->buf[1]);
+         flush_buffer(s->frame->buf[2]);
++#endif
+         //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
+         //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
+         //memcpy(s->dummy.arm,s->frame->data[2],1024*32);
+@@ -903,7 +939,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+             sao_filter_CTB(s, x, y - ctb_size);
+             if (s->threads_type & FF_THREAD_FRAME ) {
+ #ifdef RPI_INTER_QPU
+-                ff_hevc_flush_chroma(s);
++                ff_hevc_flush_chroma(s,&s->ref->tf, y);
+ #endif
+                 ff_thread_report_progress(&s->ref->tf, y, 0);
+             }
+@@ -912,7 +948,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+             sao_filter_CTB(s, x , y);
+             if (s->threads_type & FF_THREAD_FRAME ) {
+ #ifdef RPI_INTER_QPU
+-                ff_hevc_flush_chroma(s);
++                ff_hevc_flush_chroma(s, &s->ref->tf, y + ctb_size);
+ #endif
+                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
+             }
+@@ -922,7 +958,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+         //int currh = s->ref->tf.progress->data[0];
+         //if (((y + ctb_size)&63)==0)
+ #ifdef RPI_INTER_QPU
+-        ff_hevc_flush_chroma(s);
++        ff_hevc_flush_chroma(s, &s->ref->tf, y + ctb_size - 4);
+ #endif
+         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
+     }
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index f62051f..fd8a276 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -237,6 +237,12 @@ int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p)
+   return r;
+ }
+ 
++int gpu_get_mailbox(void)
++{
++  assert(gpu);
++  return gpu->mb;
++}
++
+ void gpu_cache_flush(GPU_MEM_PTR_T *p)
+ {
+   void *tmp = vcsm_lock(p->vcsm_handle);
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index 543c84b..88965e5 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -49,4 +49,6 @@ extern int rpi_test_shader(void);
+ extern void rpi_do_block(const unsigned char *in_buffer_vc, int src_pitch, unsigned char *dst_vc, int dst_pitch, unsigned char *dst);
+ extern void rpi_do_block_arm(const unsigned char *in_buffer, int src_pitch, unsigned char *dst, int dst_pitch);
+ 
++extern int gpu_get_mailbox(void);
++
+ #endif
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 3f04d80..9c30e32 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -23,11 +23,11 @@ __attribute__((aligned(8)))
+ unsigned int rpi_shader[] = {
+ // ::mc_setup_uv
+ /* [0x00000000] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000008] */ 0x0c9a0f80, 0x10020427, // add ra_x_base, unif, elem_num
++/* [0x00000008] */ 0x0c9a0f80, 0x10020427, // add ra_x, unif, elem_num
+ /* [0x00000010] */ 0x15827d80, 0x10020767, // mov ra_y, unif
+-/* [0x00000018] */ 0x15827d80, 0x10020627, // mov ra_x2_base, unif
++/* [0x00000018] */ 0x15827d80, 0x10020627, // mov ra_frame_base, unif
+ /* [0x00000020] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000028] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_x2_base
++/* [0x00000028] */ 0x0d620f80, 0x10020667, // sub ra_u2v_ref_offset, unif, ra_frame_base
+ /* [0x00000030] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+ /* [0x00000038] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+ /* [0x00000040] */ 0x15827d80, 0x10021427, // mov rb16, unif
+@@ -35,360 +35,708 @@ unsigned int rpi_shader[] = {
+ /* [0x00000050] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+ /* [0x00000058] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+ /* [0x00000060] */ 0x00000001, 0xe0020527, // mov ra20, 1
+-/* [0x00000068] */ 0x00000020, 0xe0020567, // mov ra21, 32
+-/* [0x00000070] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+-/* [0x00000078] */ 0x00000008, 0xe00205e7, // mov ra23, 8
+-/* [0x00000080] */ 0x00000040, 0xe00207a7, // mov ra30, 64
+-/* [0x00000088] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+-/* [0x00000090] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+-/* [0x00000098] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+-/* [0x000000a0] */ 0x00000000, 0xe0020227, // mov ra8, 0
+-/* [0x000000a8] */ 0x00000000, 0xe0020267, // mov ra9, 0
+-/* [0x000000b0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+-/* [0x000000b8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+-/* [0x000000c0] */ 0x00000000, 0xe0020327, // mov ra12, 0
+-/* [0x000000c8] */ 0x00000000, 0xe0020367, // mov ra13, 0
+-/* [0x000000d0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+-/* [0x000000d8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x000000e0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x000000e8] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+-/* [0x000000f0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x000000f8] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000100] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000108] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000110] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000118] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000120] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000128] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+-/* [0x00000130] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+-/* [0x00000138] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+-/* [0x00000140] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00000148] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+-/* [0x00000150] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x00000158] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000160] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000168] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000170] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000178] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000180] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000188] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x00000190] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x00000198] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
+-/* [0x000001a0] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
+-/* [0x000001a8] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
+-/* [0x000001b0] */ 0x15427d80, 0x10020827, // mov r0, ra_x_base
+-/* [0x000001b8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+-/* [0x000001c0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_x2_base
+-/* [0x000001c8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+-/* [0x000001d0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x000001d8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000001e0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x000001e8] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x_base, r0
+-/* [0x000001f0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x000001f8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+-/* [0x00000200] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_x2_base, r2
+-/* [0x00000208] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+-/* [0x00000210] */ 0x15827d80, 0x10021327, // mov rb12,unif
+-/* [0x00000218] */ 0x15827d80, 0x10021367, // mov rb13,unif
+-/* [0x00000220] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000228] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000230] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000238] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000240] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000248] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000250] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x_base
+-/* [0x00000258] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_x2_base
++/* [0x00000068] */ 0x00000100, 0xe00205a7, // mov ra22, 256
++/* [0x00000070] */ 0x00000040, 0xe00207a7, // mov ra30, 64
++/* [0x00000078] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
++/* [0x00000080] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x00000088] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x00000090] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x00000098] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x000000a0] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x000000a8] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x000000b0] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x000000d0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x000000d8] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
++/* [0x000000e0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x000000e8] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x000000f0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x000000f8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000100] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000108] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000110] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000118] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x00000120] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x00000128] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x00000130] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000138] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
++/* [0x00000140] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00000148] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000150] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000158] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000160] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000168] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000170] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000178] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000180] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x00000188] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
++/* [0x00000190] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
++/* [0x00000198] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
++/* [0x000001a0] */ 0x15427d80, 0x10020827, // mov r0, ra_x
++/* [0x000001a8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
++/* [0x000001b0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
++/* [0x000001b8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
++/* [0x000001c0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x000001c8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000001d0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x000001d8] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
++/* [0x000001e0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x000001e8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
++/* [0x000001f0] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
++/* [0x000001f8] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
++/* [0x00000200] */ 0x15827d80, 0x10021327, // mov rb12,unif
++/* [0x00000208] */ 0x15827d80, 0x10021367, // mov rb13,unif
++/* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000218] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000220] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000228] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000230] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000238] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000240] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
++/* [0x00000248] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
+ // ::mc_filter_uv
+-/* [0x00000260] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000268] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000270] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000278] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000280] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000288] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000290] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000298] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000002a0] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000002a8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000002b0] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000002b8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000002c0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000002c8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000002d0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000002d8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000002e0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000002e8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000002f0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000002f8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000300] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000308] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000310] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000318] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000320] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000328] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000330] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000338] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000340] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000348] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000350] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000358] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x00000360] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000368] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000370] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+-/* [0x00000378] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000380] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+-/* [0x00000388] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000390] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
+-/* [0x00000398] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000003a0] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
+-/* [0x000003a8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000003b0] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000258] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000260] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000268] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000270] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000278] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000280] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000288] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000290] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
++/* [0x00000298] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000002a0] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
++/* [0x000002a8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000002b0] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000002b8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000002c0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000002c8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000002d0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000002d8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000002e0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000002e8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000002f0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000002f8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000300] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000330] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000338] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000340] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000348] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000350] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000358] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000360] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
++/* [0x00000368] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000370] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
++/* [0x00000378] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000380] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
++/* [0x00000388] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000390] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
++/* [0x00000398] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000003a0] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x000003b8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000003c0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x000003c8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x000003d0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000003d8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000003e0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000003e8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003f0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000003f8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000400] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000408] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000410] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000418] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000420] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000428] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000430] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000438] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000440] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000448] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000450] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000458] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000460] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000468] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000470] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000478] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000480] */ 0x00000020, 0xe0021327, // mov rb12,32
+-/* [0x00000488] */ 0x00000006, 0xe0021367, // mov rb13,6
+-/* [0x00000490] */ 0x00000001, 0xe00213a7, // mov rb14,1
+-/* [0x00000498] */ 0x00000000, 0xe00213e7, // mov rb15,0
+-/* [0x000004a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000004a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000004b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000004b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000004c0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000004c8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000004d0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000004d8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+-/* [0x000004e0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+-/* [0x000004e8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+-/* [0x000004f0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000004f8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+-/* [0x00000500] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000508] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000510] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000518] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000520] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000528] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000530] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000538] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000540] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000548] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000550] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000003a8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000003b0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++/* [0x000003b8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x000003c0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000003c8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000003d0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000003d8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003e0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++/* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
++/* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000400] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000420] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000430] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000440] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000448] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000450] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000458] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000460] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000468] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000470] */ 0x00000020, 0xe0021327, // mov rb12,32
++/* [0x00000478] */ 0x00000006, 0xe0021367, // mov rb13,6
++/* [0x00000480] */ 0x00000001, 0xe00213a7, // mov rb14,1
++/* [0x00000488] */ 0x00000000, 0xe00213e7, // mov rb15,0
++/* [0x00000490] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000498] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000004a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000004a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000004b0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000004b8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000004c0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000004c8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
++/* [0x000004d0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
++/* [0x000004d8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
++/* [0x000004e0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x000004e8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
++/* [0x000004f0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000004f8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000500] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000508] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000510] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000518] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000520] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000528] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000530] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000538] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000540] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b0
+-/* [0x00000558] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000560] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000568] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000570] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000578] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000580] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000588] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000590] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000598] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x000005a0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000005a8] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x000005b0] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+-/* [0x000005b8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000005c0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005c8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000005d0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000005d8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000005e0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000005e8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000005f0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000005f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000600] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000608] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000610] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000618] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000620] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000628] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000630] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000638] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000640] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000648] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000650] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x00000658] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000660] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000668] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000670] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000678] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000548] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000550] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000558] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000560] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000568] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000570] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000578] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000580] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000588] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
++/* [0x00000590] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000598] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
++/* [0x000005a0] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
++/* [0x000005a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000005b0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000005c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000005c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000005d0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000005d8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000005e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000005e8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000005f0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000005f8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000600] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000608] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000610] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000618] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000620] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000628] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000630] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000638] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000640] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000648] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000650] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000658] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000668] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x00000680] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000688] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000690] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000698] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000006a0] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000006a8] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000006b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000006b8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000006c0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x000006c8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x000006d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000006d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000006e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000006e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000006f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000006f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000700] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000708] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000710] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000718] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000720] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000728] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000730] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000738] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000740] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000748] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000750] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000758] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000760] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000768] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000770] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+-/* [0x00000778] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000780] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+-/* [0x00000788] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000790] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000798] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x000007a0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000007a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000007b0] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000670] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000678] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++/* [0x00000680] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00000688] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000690] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000698] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000006a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000006a8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000006b0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++/* [0x000006b8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
++/* [0x000006c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000006c8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000006d0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000006d8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000006e0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000006e8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000006f0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000006f8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000700] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000708] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000710] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000718] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000720] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000728] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000730] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000738] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000740] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000748] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000750] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000758] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000760] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
++/* [0x00000768] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000770] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
++/* [0x00000778] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000780] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000788] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000790] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000798] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000007a0] */ 0x009e7000, 0x100009e7, // nop
+ // ::mc_filter_uv_b
+-/* [0x000007b8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000007c0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000007c8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000007d0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000007d8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000007e0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000007e8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000007f0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000007f8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_base_next, r0, ~3
+-/* [0x00000800] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000808] */ 0x0c9d3e80, 0x100206a7, // add ra_x2_base_next, rb_x_base_next, r2
+-/* [0x00000810] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000818] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000820] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000828] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000830] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000838] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000840] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x00000848] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x00000850] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000858] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000860] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000868] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000870] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000878] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000880] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000888] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000890] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000898] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008a0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008a8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008b0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000008b8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008c0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008c8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008d0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x000008d8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000008e0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000008e8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000008f0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000008f8] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000007a8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000007b0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000007b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000007c0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000007c8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000007d0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000007d8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000007e0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000007e8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
++/* [0x000007f0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000007f8] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
++/* [0x00000800] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000808] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000810] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000830] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000838] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000858] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000860] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000880] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000888] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000890] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000898] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000008a8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008b0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008b8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008c0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x000008c8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000008d0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000008d8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000008e0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000008e8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x00000900] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000908] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x_base, rb_x_base_next       ; ldtmu0
+-/* [0x00000910] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_x2_base, ra_x2_base_next ; mov rb31, r3
+-/* [0x00000918] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000920] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000928] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000930] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000938] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000940] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x_base, r2    ; v8subs r1, r1, rb20
+-/* [0x00000948] */ 0x0c627c80, 0x10020e27, // add t0s, ra_x2_base, r2
+-/* [0x00000950] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000958] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000960] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000968] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000970] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000978] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000980] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000988] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000990] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000998] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x000009a0] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x000009a8] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000009b0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000009b8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x000009c0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x000009c8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000009d0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000009d8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000009e0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000009e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000009f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000009f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x00000a00] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x00000a08] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x00000a10] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000a18] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00000a20] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000a28] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000a30] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000a38] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a40] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000a48] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000a50] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000a58] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000a60] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000a68] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a70] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000008f0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000008f8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++/* [0x00000900] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00000908] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000910] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000918] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000920] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000928] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000930] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++/* [0x00000938] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
++/* [0x00000940] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000948] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000950] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000958] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000960] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000968] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000970] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000978] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000980] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000988] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000990] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000998] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000009a0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000009a8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x000009b0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000009b8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000009c0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000009c8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000009d0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000009d8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000009e0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000009e8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000009f0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x000009f8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x00000a00] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000a08] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00000a10] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000a18] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000a20] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000a28] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a30] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000a38] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000a40] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000a48] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000a50] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000a58] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a60] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000a78] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a80] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a68] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a70] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a98] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000aa0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000ab0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a98] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000aa0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000aa8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000ac0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000ab0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ad8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ae0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b10] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b18] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b20] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000b28] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000b30] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000b10] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000b18] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000b20] */ 0x009e7000, 0x100009e7, // nop        ; nop
++// ::mc_setup
++/* [0x00000b28] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000b30] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000b38] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000b40] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000b48] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000b50] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000b58] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x00000b60] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000b68] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
++/* [0x00000b70] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x00000b78] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000b80] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
++/* [0x00000b88] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
++/* [0x00000b90] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000b98] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000ba0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000ba8] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
++/* [0x00000bb0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
++/* [0x00000bb8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000bc0] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
++/* [0x00000bc8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x00000bd0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000bd8] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
++/* [0x00000be0] */ 0x8c9e7452, 0x10025e19, // add t0s, r2, r1 ; mov ra_frame_base2, r2
++/* [0x00000be8] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
++/* [0x00000bf0] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
++/* [0x00000bf8] */ 0x15827d80, 0x10021427, // mov rb16, unif
++/* [0x00000c00] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000c08] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
++/* [0x00000c10] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
++/* [0x00000c18] */ 0x00000001, 0xe0020527, // mov ra20, 1
++/* [0x00000c20] */ 0x00000100, 0xe00205a7, // mov ra22, 256
++/* [0x00000c28] */ 0x00000040, 0xe00207a7, // mov ra30, 64
++/* [0x00000c30] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
++/* [0x00000c38] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x00000c40] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x00000c48] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x00000c50] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x00000c58] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x00000c60] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x00000c68] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x00000c70] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x00000c78] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x00000c80] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x00000c88] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000c90] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000c98] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000ca0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000ca8] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000cb0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000cb8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000cc0] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x00000cc8] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x00000cd0] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x00000cd8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000ce0] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000ce8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000cf0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000cf8] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000d00] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000d08] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000d10] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000d18] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x00000d20] */ 0x15827d80, 0x10021327, // mov rb12,unif
++/* [0x00000d28] */ 0x15827d80, 0x10021367, // mov rb13,unif
++/* [0x00000d30] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000d38] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000d40] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000d48] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000d50] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000d58] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
++/* [0x00000d60] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
++/* [0x00000d68] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000d70] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000d78] */ 0x0c541dc0, 0xd0020567, // add ra_y2, ra_y2, 1
++/* [0x00000d80] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000d88] */ 0x0c667380, 0x10020e27, // add t0s, r1, ra_frame_base2
++// ::mc_filter
++/* [0x00000d90] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000d98] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000da0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000da8] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
++/* [0x00000db0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000db8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000dc0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000dc8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000dd0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000dd8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000de0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
++/* [0x00000de8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000df0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
++/* [0x00000df8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000e00] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
++/* [0x00000e08] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
++/* [0x00000e10] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000e18] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
++/* [0x00000e20] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000e28] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000e30] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000e38] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000e40] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000e48] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000e50] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000e58] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000e60] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000e68] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000e70] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000e78] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000e80] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000e88] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000e90] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000e98] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ea0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ea8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000eb0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000eb8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ec0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ec8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ed0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000ed8] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000ee0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000ee8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000ef0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ef8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000f00] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000f08] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f10] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f18] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f20] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
++/* [0x00000f28] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000f30] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000f38] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
++/* [0x00000f40] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000f48] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
++/* [0x00000f50] */ 0x00000000, 0xe00208e7, // mov r3, 0
++// :yloop
++/* [0x00000f58] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++/* [0x00000f60] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
++/* [0x00000f68] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00000f70] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000f78] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
++/* [0x00000f80] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
++/* [0x00000f88] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000f90] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000f98] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++/* [0x00000fa0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
++/* [0x00000fa8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
++/* [0x00000fb0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000fb8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++/* [0x00000fc0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
++/* [0x00000fc8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000fd0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000fd8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000fe0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000fe8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000ff0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000ff8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00001000] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00001008] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00001010] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00001018] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00001020] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00001028] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00001030] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00001038] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00001040] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00001048] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00001050] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00001058] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
++/* [0x00001060] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00001068] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00001070] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00001078] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00001080] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
++/* [0x00001088] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00001090] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00001098] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000010a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000010a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000010b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000010b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000010c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
++/* [0x000010c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
++/* [0x000010d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
++/* [0x000010d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
++/* [0x000010e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000010e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000010f0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000010f8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
++/* [0x00001100] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
++/* [0x00001108] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
++/* [0x00001110] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
++/* [0x00001118] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
++/* [0x00001120] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00001128] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00001130] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001138] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00001140] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001148] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_filter_b
++/* [0x00001150] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00001158] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00001160] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00001168] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
++/* [0x00001170] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00001178] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00001180] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00001188] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00001190] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00001198] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x000011a0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
++/* [0x000011a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000011b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
++/* [0x000011b8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x000011c0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
++/* [0x000011c8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
++/* [0x000011d0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x000011d8] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
++/* [0x000011e0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000011e8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000011f0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000011f8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00001200] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00001208] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00001210] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00001218] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00001220] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00001228] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00001230] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00001238] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00001240] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001248] */ 0x00000001, 0xe0020867, // mov r1, 1
++/* [0x00001250] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x00001258] */ 0x409f3001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 13, r1 << 13
++/* [0x00001260] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001268] */ 0x409f2001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 14, r1 << 14
++/* [0x00001270] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001278] */ 0x409f1001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 15, r1 << 15
++/* [0x00001280] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001288] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00001290] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x00001298] */ 0x409f7001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 9, r1 << 9
++/* [0x000012a0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000012a8] */ 0x409f6001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 10, r1 << 10
++/* [0x000012b0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000012b8] */ 0x409f5001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 11, r1 << 11
++/* [0x000012c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000012c8] */ 0x409f4001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 12, r1 << 12
++/* [0x000012d0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x000012d8] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x000012e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000012e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000012f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000012f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00001300] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x00001308] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001310] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001318] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001320] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
++/* [0x00001328] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001330] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x00001338] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
++/* [0x00001340] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00001348] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
++/* [0x00001350] */ 0x00000000, 0xe00208e7, // mov r3, 0
++// :yloopb
++/* [0x00001358] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++/* [0x00001360] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
++/* [0x00001368] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00001370] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00001378] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
++/* [0x00001380] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
++/* [0x00001388] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00001390] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00001398] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++/* [0x000013a0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
++/* [0x000013a8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
++/* [0x000013b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000013b8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++/* [0x000013c0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
++/* [0x000013c8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000013d0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000013d8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000013e0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000013e8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000013f0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000013f8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00001400] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00001408] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00001410] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00001418] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00001420] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00001428] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00001430] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00001438] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00001440] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00001448] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00001450] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00001458] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
++/* [0x00001460] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00001468] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00001470] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00001478] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00001480] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
++/* [0x00001488] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00001490] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00001498] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000014a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000014a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000014b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000014b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000014c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
++/* [0x000014c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
++/* [0x000014d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
++/* [0x000014d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
++/* [0x000014e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000014e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000014f0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000014f8] */ 0x4053800e, 0xd00049e1, // nop                     ; mul24 r1, r1 << 8, ra20 << 8
++/* [0x00001500] */ 0x4c78e38f, 0x10024860, // add r1, r1, ra30        ; mul24 r0, r1, rb14
++/* [0x00001508] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x00001510] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloopb
++/* [0x00001518] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00001520] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00001528] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00001530] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001538] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00001540] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001548] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++// ::mc_interrupt_exit12
++/* [0x00001550] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00001558] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001560] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001568] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001570] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001578] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001580] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001588] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001590] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001598] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000015a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000015a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000015b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000015b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000015c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000015c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000015d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000015d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x000015e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index cec9901..3fa8531 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -4,11 +4,15 @@
+ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+-#define mc_filter_uv (rpi_shader + 152)
+-#define mc_filter_uv_b0 (rpi_shader + 342)
+-#define mc_filter_uv_b (rpi_shader + 494)
+-#define mc_exit (rpi_shader + 670)
+-#define mc_interrupt_exit8 (rpi_shader + 688)
+-#define mc_end (rpi_shader + 718)
++#define mc_filter_uv (rpi_shader + 148)
++#define mc_filter_uv_b0 (rpi_shader + 338)
++#define mc_filter_uv_b (rpi_shader + 490)
++#define mc_exit (rpi_shader + 666)
++#define mc_interrupt_exit8 (rpi_shader + 684)
++#define mc_setup (rpi_shader + 714)
++#define mc_filter (rpi_shader + 868)
++#define mc_filter_b (rpi_shader + 1108)
++#define mc_interrupt_exit12 (rpi_shader + 1364)
++#define mc_end (rpi_shader + 1402)
+ 
+ #endif
+diff --git a/libavcodec/rpi_user_vcsm.h b/libavcodec/rpi_user_vcsm.h
+index fbebbbe..95e6de1 100644
+--- a/libavcodec/rpi_user_vcsm.h
++++ b/libavcodec/rpi_user_vcsm.h
+@@ -418,6 +418,28 @@ int vcsm_unlock_hdl( unsigned int handle );
+ */
+ int vcsm_unlock_hdl_sp( unsigned int handle, int cache_no_flush );
+ 
++/* Clean and/or invalidate the memory associated with this user opaque handle
++**
++** Returns:        non-zero on error
++**
++** structure contains a list of flush/invalidate commands. Commands are:
++** 0: nop
++** 1: invalidate given physical range in L2
++** 2: clean      given physical range in L2
++** 3: clean+invalidate all of L1
++** 4: flush      all of L2 and all of L1
++*/
++struct vcsm_user_clean_invalid_s {
++    struct {
++       unsigned int cmd;
++       unsigned int addr;
++       unsigned int size;
++    } s[8];
++};
++
++int vcsm_clean_invalid( unsigned int handle, struct vcsm_user_clean_invalid_s *s );
++
++
+ #ifdef __cplusplus
+ }
+ #endif
+-- 
+2.7.4
+
+
+From 09685ab55aecb9400e354522894e0fbbb6381ca9 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 20 May 2015 21:12:55 +0100
+Subject: [PATCH 43/68] Added multi mailbox - not working
+
+---
+ libavcodec/hevc.c        | 40 ++++++++++++++++++++++++++++---
+ libavcodec/rpi_mailbox.c | 47 +++++++++++++++++++++++++++++++++++++
+ libavcodec/rpi_mailbox.h |  5 ++++
+ libavcodec/rpi_qpu.c     | 61 ++++++++++++++++++++++++++++++++++++++++++++----
+ libavcodec/rpi_qpu.h     |  2 ++
+ 5 files changed, 147 insertions(+), 8 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 951e2d3..ab63efd 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -47,6 +47,11 @@
+   //#define EARLY_MALLOC
+   // Move Inter prediction into separate pass
+   #define RPI_INTER
++
++  #ifdef RPI_INTER_QPU
++    // Define RPI_MULTI_MAILBOX to use the updated mailbox that can launch both QPU and VPU
++    #define RPI_MULTI_MAILBOX
++  #endif
+ #endif
+ 
+ // #define DISABLE_MC
+@@ -2843,10 +2848,14 @@ static void rpi_inter_clear(HEVCContext *s)
+ static void rpi_execute_inter_qpu(HEVCContext *s)
+ {
+     int k;
++    int i;
+     uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;
+-
+-    if (s->sh.slice_type == I_SLICE)
+-        return;
++    if (s->sh.slice_type == I_SLICE) {
++#ifdef RPI_MULTI_MAILBOX
++      rpi_execute_transform(s);
++      return;
++#endif
++    }
+     for(k=0;k<8;k++) {
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
+@@ -2856,6 +2865,22 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+ 
+     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+ 
++#ifdef RPI_MULTI_MAILBOX
++    gpu_cache_flush(&s->coeffs_buf_accelerated);
++    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0,
++                                   qpu_get_fn(QPU_MC_SETUP_UV),
++                                   (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
++                                 );
++    for(i=0;i<4;i++)
++        s->num_coeffs[i] = 0;
++#else
+     qpu_run_shader8(qpu_get_fn(QPU_MC_SETUP_UV),
+       (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+       (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+@@ -2866,6 +2891,7 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+       (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+       (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
+       );
++#endif
+ }
+ #endif
+ 
+@@ -2945,6 +2971,12 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+           if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->ps.sps->width) {
+             // Transform all blocks
+             // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
++#ifdef RPI_MULTI_MAILBOX
++            // Kick off inter prediction on QPUs
++            rpi_execute_inter_qpu(s);
++            // Perform luma inter prediction
++            rpi_execute_inter_cmds(s);
++#else
+             rpi_execute_transform(s);
+             // Perform inter prediction
+             rpi_execute_inter_cmds(s);
+@@ -2952,6 +2984,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+             // Kick off inter prediction on QPUs
+             rpi_execute_inter_qpu(s);
+ #endif
++#endif
++
+             // Wait for transform completion
+             vpu_wait(s->vpu_id);
+ 
+diff --git a/libavcodec/rpi_mailbox.c b/libavcodec/rpi_mailbox.c
+index 77a56dd..3904efc 100644
+--- a/libavcodec/rpi_mailbox.c
++++ b/libavcodec/rpi_mailbox.c
+@@ -276,6 +276,53 @@ unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigne
+    return p[5];
+ }
+ 
++void execute_multi(int file_desc,
++   unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout,
++   unsigned num_qpus_2, unsigned control_2, unsigned noflush_2, unsigned timeout_2,
++   unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5,
++   unsigned code_2, unsigned r0_2, unsigned r1_2, unsigned r2_2, unsigned r3_2, unsigned r4_2, unsigned r5_2) {
++   int i=0;
++   unsigned p[32];
++
++   p[i++] = 0; // size
++   p[i++] = 0x00000000; // process request
++   p[i++] = 0x30018; // (the tag id)
++   p[i++] = 88; // (size of the buffer)
++   p[i++] = 88; // (size of the data)
++
++   p[i++] = num_qpus;
++   p[i++] = control;
++   p[i++] = noflush;
++   p[i++] = timeout; // ms
++
++   p[i++] = num_qpus_2;
++   p[i++] = control_2;
++   p[i++] = noflush_2;
++   p[i++] = timeout_2; // ms
++
++   p[i++] = code;
++   p[i++] = r0;
++   p[i++] = r1;
++   p[i++] = r2;
++   p[i++] = r3;
++   p[i++] = r4;
++   p[i++] = r5;
++
++   p[i++] = code_2;
++   p[i++] = r0_2;
++   p[i++] = r1_2;
++   p[i++] = r2_2;
++   p[i++] = r3_2;
++   p[i++] = r4_2;
++   p[i++] = r5_2;
++
++   p[i++] = 0x00000000; // end tag
++   p[0] = i*sizeof *p; // actual size
++
++   mbox_property(file_desc, p);
++   return;
++}
++
+ int mbox_open() {
+    int file_desc;
+ 
+diff --git a/libavcodec/rpi_mailbox.h b/libavcodec/rpi_mailbox.h
+index c264d2e..5898102 100644
+--- a/libavcodec/rpi_mailbox.h
++++ b/libavcodec/rpi_mailbox.h
+@@ -15,6 +15,11 @@ extern void unmapmem(void *addr, unsigned size);
+ 
+ extern unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+ extern unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout);
++extern void execute_multi(int file_desc,
++   unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout,
++   unsigned num_qpus_2, unsigned control_2, unsigned noflush_2, unsigned timeout_2,
++   unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5,
++   unsigned code_2, unsigned r0_2, unsigned r1_2, unsigned r2_2, unsigned r3_2, unsigned r4_2, unsigned r5_2);
+ extern unsigned qpu_enable(int file_desc, unsigned enable);
+ 
+ #endif
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index fd8a276..feb3284 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -123,7 +123,7 @@ static pthread_cond_t post_cond_head = PTHREAD_COND_INITIALIZER;
+ static pthread_cond_t post_cond_tail = PTHREAD_COND_INITIALIZER;
+ static pthread_mutex_t post_mutex = PTHREAD_MUTEX_INITIALIZER;
+ 
+-static int vpu_cmds[MAXCMDS][8];
++static int vpu_cmds[MAXCMDS][16];
+ static volatile int vpu_async_tail=0; // Contains the number of posted jobs
+ static volatile int vpu_async_head=0;
+ #endif
+@@ -346,6 +346,7 @@ unsigned int vpu_get_constants(void) {
+ static void *vpu_start(void *arg) {
+   while(1) {
+     int *p;
++    int qpu_code;
+     pthread_mutex_lock(&post_mutex);
+     while( vpu_async_tail - vpu_async_head <= 0)
+     {
+@@ -358,12 +359,25 @@ static void *vpu_start(void *arg) {
+     if (p[6] == -1) {
+       break; // Last job
+     }
+-    if (p[7]) {
++    qpu_code = p[7];
++    //if (p[7]) {
+         //GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
+         //gpu_cache_flush(buf);
+-    }
+-    vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
++    //}
++    if (!qpu_code) {
++      vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
++    } else {
++      int i;
++      for(i=0;i<8;i++) {
++        gpu->mail[i*2] = p[8+i];
++        gpu->mail[i*2 + 1] = qpu_code;
++      }
+ 
++      execute_multi(gpu->mb,8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
++                              0, 0, 0, 0,
++                              p[0], p[1], p[2], p[3], p[4], p[5], p[6], // VPU0
++                              0,    0   , 0   , 0   , 0   , 0   , 0); // VPU1
++    }
+     pthread_mutex_lock(&post_mutex);
+     vpu_async_head++;
+     pthread_cond_broadcast(&post_cond_head);
+@@ -400,7 +414,43 @@ int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned
+     p[4] = r3;
+     p[5] = r4;
+     p[6] = r5;
+-    p[7] = (int) buf;
++    p[7] = 0;
++    if (num<=1)
++      pthread_cond_broadcast(&post_cond_tail); // Otherwise the vpu thread must already be awake
++    pthread_mutex_unlock(&post_mutex);
++    return id;
++  }
++}
++
++int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5,
++                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8)
++{
++
++  pthread_mutex_lock(&post_mutex);
++  {
++    int id = vpu_async_tail++;
++    int *p = vpu_cmds[id%MAXCMDS];
++    int num = vpu_async_tail - vpu_async_head;
++    if (num>MAXCMDS) {
++      printf("Too many commands submitted\n");
++      exit(-1);
++    }
++    p[0] = vpu_code;
++    p[1] = r0;
++    p[2] = r1;
++    p[3] = r2;
++    p[4] = r3;
++    p[5] = r4;
++    p[6] = r5;
++    p[7] = qpu_code;
++    p[8 ] = unifs1;
++    p[9 ] = unifs2;
++    p[10] = unifs3;
++    p[11] = unifs4;
++    p[12] = unifs5;
++    p[13] = unifs6;
++    p[14] = unifs7;
++    p[15] = unifs8;
+     if (num<=1)
+       pthread_cond_broadcast(&post_cond_tail); // Otherwise the vpu thread must already be awake
+     pthread_mutex_unlock(&post_mutex);
+@@ -966,6 +1016,7 @@ void rpi_do_block(const uint8_t *in_buffer_vc, int src_pitch, uint8_t *dst_vc, i
+ }
+ 
+ 
++
+ #endif
+ 
+ #endif // RPI
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index 88965e5..2f08f03 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -41,6 +41,8 @@ extern unsigned int vpu_get_fn(void);
+ extern unsigned int vpu_get_constants(void);
+ extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+ extern int vpu_post_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf);
++int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5,
++                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
+ extern void vpu_wait( int id);
+ 
+ // Simple test of shader code
+-- 
+2.7.4
+
+
+From 311f2da06d13a98d9bdda2df8684d7cf55b9a08e Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Thu, 21 May 2015 16:50:02 +0100
+Subject: [PATCH 44/68] Pass qpu number in as uniform
+
+---
+ libavcodec/hevc.c          |    2 +-
+ libavcodec/rpi_shader.c    | 1288 ++++++++++++++++++++++----------------------
+ libavcodec/rpi_shader.h    |   20 +-
+ libavcodec/rpi_shader.qasm |   10 +-
+ 4 files changed, 657 insertions(+), 663 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index ab63efd..caadfaa 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -2834,6 +2834,7 @@ static void rpi_inter_clear(HEVCContext *s)
+         *s->u_mvs[i]++ = pic_height;
+         *s->u_mvs[i]++ = s->frame->linesize[1];
+         *s->u_mvs[i]++ = s->frame->linesize[2];
++        *s->u_mvs[i]++ = i;
+         if (weight_flag) {
+             *s->u_mvs[i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
+             *s->u_mvs[i]++ = s->sh.chroma_log2_weight_denom + 6;
+@@ -2841,7 +2842,6 @@ static void rpi_inter_clear(HEVCContext *s)
+             *s->u_mvs[i]++ = 1 << 5;
+             *s->u_mvs[i]++ = 6;
+         }
+-        s->u_mvs[i] += 1;  // Padding words
+     }
+ }
+ 
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index 9c30e32..a0f0282 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -48,8 +48,8 @@ unsigned int rpi_shader[] = {
+ /* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
+ /* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+ /* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x000000d0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x000000d8] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
++/* [0x000000d0] */ 0x15827d80, 0x100208e7, // mov r3, unif
++/* [0x000000d8] */ 0x119c17c0, 0xd00208a7, // shl r2, r3, 1
+ /* [0x000000e0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+ /* [0x000000e8] */ 0x159e7480, 0x10020867, // mov r1, r2
+ /* [0x000000f0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+@@ -60,669 +60,669 @@ unsigned int rpi_shader[] = {
+ /* [0x00000118] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+ /* [0x00000120] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+ /* [0x00000128] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+-/* [0x00000130] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00000138] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+-/* [0x00000140] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x00000148] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000150] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000158] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000160] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000168] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000170] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000178] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x00000180] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x00000188] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
+-/* [0x00000190] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
+-/* [0x00000198] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
+-/* [0x000001a0] */ 0x15427d80, 0x10020827, // mov r0, ra_x
+-/* [0x000001a8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+-/* [0x000001b0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
+-/* [0x000001b8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+-/* [0x000001c0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x000001c8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000001d0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x000001d8] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
+-/* [0x000001e0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x000001e8] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+-/* [0x000001f0] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
+-/* [0x000001f8] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+-/* [0x00000200] */ 0x15827d80, 0x10021327, // mov rb12,unif
+-/* [0x00000208] */ 0x15827d80, 0x10021367, // mov rb13,unif
+-/* [0x00000210] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000218] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000220] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000228] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000230] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000238] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000240] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
+-/* [0x00000248] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
++/* [0x00000130] */ 0x119c17c0, 0xd00208a7, // shl r2, r3, 1
++/* [0x00000138] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00000140] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000148] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000150] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000158] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000160] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000168] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000170] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000178] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x00000180] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
++/* [0x00000188] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
++/* [0x00000190] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
++/* [0x00000198] */ 0x15427d80, 0x10020827, // mov r0, ra_x
++/* [0x000001a0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
++/* [0x000001a8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
++/* [0x000001b0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
++/* [0x000001b8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x000001c0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000001c8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x000001d0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
++/* [0x000001d8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x000001e0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
++/* [0x000001e8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
++/* [0x000001f0] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
++/* [0x000001f8] */ 0x15827d80, 0x10021327, // mov rb12,unif
++/* [0x00000200] */ 0x15827d80, 0x10021367, // mov rb13,unif
++/* [0x00000208] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000210] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000218] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000220] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000228] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000230] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
++/* [0x00000238] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
+ // ::mc_filter_uv
+-/* [0x00000250] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000258] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000260] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000268] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000270] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000278] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000280] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000288] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000290] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+-/* [0x00000298] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000002a0] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+-/* [0x000002a8] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000002b0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000002b8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000002c0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000002c8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000002d0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000002d8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000002e0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000002e8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000002f0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000002f8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000300] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000308] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000310] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000318] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000320] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000328] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000330] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000338] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000340] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000348] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x00000350] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000358] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000360] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+-/* [0x00000368] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000370] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+-/* [0x00000378] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000380] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
+-/* [0x00000388] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000390] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
+-/* [0x00000398] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000003a0] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000240] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000248] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000250] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000258] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000260] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000268] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000270] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000278] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000280] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
++/* [0x00000288] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000290] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
++/* [0x00000298] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000002a0] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000002a8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000002b0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000002b8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000002c0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000002c8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000002d0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000002d8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000002e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000002e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000002f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000002f8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000300] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000308] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000310] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000318] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000320] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000328] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000330] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000338] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000340] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000348] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000350] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
++/* [0x00000358] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000360] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
++/* [0x00000368] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000370] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
++/* [0x00000378] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000380] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
++/* [0x00000388] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000390] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x000003a8] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000003b0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+-/* [0x000003b8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x000003c0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000003c8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000003d0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000003d8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003e0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000003e8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+-/* [0x000003f0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+-/* [0x000003f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000400] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000408] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000410] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000418] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000420] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000428] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000430] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000438] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000440] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000448] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000450] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000458] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000460] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000468] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000470] */ 0x00000020, 0xe0021327, // mov rb12,32
+-/* [0x00000478] */ 0x00000006, 0xe0021367, // mov rb13,6
+-/* [0x00000480] */ 0x00000001, 0xe00213a7, // mov rb14,1
+-/* [0x00000488] */ 0x00000000, 0xe00213e7, // mov rb15,0
+-/* [0x00000490] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000498] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000004a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000004a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000004b0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000004b8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000004c0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000004c8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+-/* [0x000004d0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+-/* [0x000004d8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+-/* [0x000004e0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000004e8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+-/* [0x000004f0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000004f8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000500] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000508] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000510] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000518] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000520] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000528] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000530] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000538] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000540] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000398] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000003a0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++/* [0x000003a8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x000003b0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000003b8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000003c0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000003c8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000003d0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003d8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++/* [0x000003e0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
++/* [0x000003e8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000003f0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000003f8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000400] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000408] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000410] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000418] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000420] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000428] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000430] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000438] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000440] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000448] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000450] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000458] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000460] */ 0x00000020, 0xe0021327, // mov rb12,32
++/* [0x00000468] */ 0x00000006, 0xe0021367, // mov rb13,6
++/* [0x00000470] */ 0x00000001, 0xe00213a7, // mov rb14,1
++/* [0x00000478] */ 0x00000000, 0xe00213e7, // mov rb15,0
++/* [0x00000480] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000488] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000490] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000498] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000004a0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000004a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000004b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000004b8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
++/* [0x000004c0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
++/* [0x000004c8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
++/* [0x000004d0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x000004d8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
++/* [0x000004e0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000004e8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000004f0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000004f8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000500] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000508] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000510] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000518] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000520] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000528] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000530] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b0
+-/* [0x00000548] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000550] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000558] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000560] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000568] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000570] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000578] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000580] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000588] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+-/* [0x00000590] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000598] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+-/* [0x000005a0] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+-/* [0x000005a8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000005b0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005b8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000005c0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000005c8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000005d0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000005d8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000005e0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000005e8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000005f0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000005f8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000600] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000608] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000610] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000618] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000620] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000628] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000630] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000638] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000640] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x00000648] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000650] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000658] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000660] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000668] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000538] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000540] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000548] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000550] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000558] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000560] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000568] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000570] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000578] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
++/* [0x00000580] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000588] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
++/* [0x00000590] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
++/* [0x00000598] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000005a0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005a8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000005b0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000005b8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000005c0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000005c8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000005d0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000005d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000005e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000005e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000005f0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005f8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000600] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000608] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000610] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000618] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000620] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000628] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000630] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000638] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000640] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000648] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000650] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000658] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x00000670] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000678] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+-/* [0x00000680] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x00000688] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000690] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000698] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000006a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000006a8] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000006b0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+-/* [0x000006b8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+-/* [0x000006c0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000006c8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000006d0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000006d8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000006e0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000006e8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000006f0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000006f8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000700] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000708] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000710] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000718] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000720] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000728] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000730] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000738] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000740] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000748] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000750] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000758] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000760] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+-/* [0x00000768] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000770] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+-/* [0x00000778] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000780] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000788] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000790] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000798] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000007a0] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000660] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000668] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++/* [0x00000670] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00000678] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000680] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000688] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000690] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000698] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000006a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++/* [0x000006a8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
++/* [0x000006b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000006b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000006c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000006c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000006d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000006d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000006e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000006e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000006f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000006f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000700] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000708] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000710] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000718] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000720] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000728] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000730] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000738] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000740] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000748] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000750] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
++/* [0x00000758] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000760] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
++/* [0x00000768] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000770] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000778] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000780] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000788] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000790] */ 0x009e7000, 0x100009e7, // nop
+ // ::mc_filter_uv_b
+-/* [0x000007a8] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000007b0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000007b8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000007c0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000007c8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000007d0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000007d8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000007e0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000007e8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+-/* [0x000007f0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000007f8] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+-/* [0x00000800] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000808] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000810] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000818] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000820] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000828] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000830] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x00000838] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x00000840] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000848] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000850] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000858] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000860] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000868] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000870] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000878] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000880] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000888] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000890] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000898] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008a0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x000008a8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008b0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008b8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008c0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x000008c8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000008d0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000008d8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000008e0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000008e8] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000798] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000007a0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000007a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000007b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x000007b8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x000007c0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x000007c8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x000007d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x000007d8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
++/* [0x000007e0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x000007e8] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
++/* [0x000007f0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000007f8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000800] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000808] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000810] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000818] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000820] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000828] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x00000830] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000838] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x00000840] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x00000848] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x00000850] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000858] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000860] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000868] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000870] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000878] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000880] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000888] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000890] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000898] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008a0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000008a8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000008b0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x000008b8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000008c0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000008c8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000008d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000008d8] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x000008f0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000008f8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+-/* [0x00000900] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x00000908] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000910] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000918] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000920] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000928] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000930] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+-/* [0x00000938] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+-/* [0x00000940] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000948] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000950] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000958] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000960] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000968] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000970] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000978] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000980] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000988] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000990] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000998] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000009a0] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x000009a8] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x000009b0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x000009b8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000009c0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000009c8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000009d0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000009d8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000009e0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000009e8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000009f0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x000009f8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x00000a00] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000a08] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00000a10] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000a18] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000a20] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000a28] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a30] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000a38] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000a40] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000a48] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000a50] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000a58] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a60] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000008e0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x000008e8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++/* [0x000008f0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x000008f8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000900] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000908] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000910] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000918] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000920] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++/* [0x00000928] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
++/* [0x00000930] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000938] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000940] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000948] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000950] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000958] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000960] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000968] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000970] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000978] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000980] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000988] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000990] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000998] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x000009a0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000009a8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000009b0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000009b8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000009c0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000009c8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000009d0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000009d8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000009e0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x000009e8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x000009f0] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000009f8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00000a00] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000a08] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000a10] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00000a18] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a20] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000a28] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x00000a30] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x00000a38] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000a40] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x00000a48] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00000a50] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000a68] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a70] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a58] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a60] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a68] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a70] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a88] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a90] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a98] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000aa0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000aa8] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a88] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000a90] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a98] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000ab0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000aa0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000aa8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ab0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ac8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ad0] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000ac8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000ad0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b00] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b08] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b10] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000b18] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000b20] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000b00] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000b08] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000b10] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_setup
+-/* [0x00000b28] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000b30] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000b38] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000b40] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000b48] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00000b50] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000b58] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x00000b60] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00000b68] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+-/* [0x00000b70] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x00000b78] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000b80] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+-/* [0x00000b88] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
+-/* [0x00000b90] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000b98] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000ba0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00000ba8] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+-/* [0x00000bb0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
+-/* [0x00000bb8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00000bc0] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+-/* [0x00000bc8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x00000bd0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000bd8] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+-/* [0x00000be0] */ 0x8c9e7452, 0x10025e19, // add t0s, r2, r1 ; mov ra_frame_base2, r2
+-/* [0x00000be8] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+-/* [0x00000bf0] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+-/* [0x00000bf8] */ 0x15827d80, 0x10021427, // mov rb16, unif
+-/* [0x00000c00] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000c08] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+-/* [0x00000c10] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+-/* [0x00000c18] */ 0x00000001, 0xe0020527, // mov ra20, 1
+-/* [0x00000c20] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+-/* [0x00000c28] */ 0x00000040, 0xe00207a7, // mov ra30, 64
+-/* [0x00000c30] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+-/* [0x00000c38] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+-/* [0x00000c40] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+-/* [0x00000c48] */ 0x00000000, 0xe0020227, // mov ra8, 0
+-/* [0x00000c50] */ 0x00000000, 0xe0020267, // mov ra9, 0
+-/* [0x00000c58] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+-/* [0x00000c60] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+-/* [0x00000c68] */ 0x00000000, 0xe0020327, // mov ra12, 0
+-/* [0x00000c70] */ 0x00000000, 0xe0020367, // mov ra13, 0
+-/* [0x00000c78] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+-/* [0x00000c80] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x00000c88] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00000c90] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000c98] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000ca0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000ca8] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000cb0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000cb8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000cc0] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+-/* [0x00000cc8] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+-/* [0x00000cd0] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+-/* [0x00000cd8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00000ce0] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000ce8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000cf0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000cf8] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000d00] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000d08] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000d10] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x00000d18] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x00000d20] */ 0x15827d80, 0x10021327, // mov rb12,unif
+-/* [0x00000d28] */ 0x15827d80, 0x10021367, // mov rb13,unif
+-/* [0x00000d30] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000d38] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000d40] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000d48] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000d50] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000d58] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
+-/* [0x00000d60] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
+-/* [0x00000d68] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000d70] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000d78] */ 0x0c541dc0, 0xd0020567, // add ra_y2, ra_y2, 1
+-/* [0x00000d80] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000d88] */ 0x0c667380, 0x10020e27, // add t0s, r1, ra_frame_base2
++/* [0x00000b18] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000b20] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000b28] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000b30] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000b38] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000b40] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000b48] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x00000b50] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000b58] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
++/* [0x00000b60] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x00000b68] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000b70] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
++/* [0x00000b78] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
++/* [0x00000b80] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000b88] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000b90] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000b98] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
++/* [0x00000ba0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
++/* [0x00000ba8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000bb0] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
++/* [0x00000bb8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x00000bc0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000bc8] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
++/* [0x00000bd0] */ 0x8c9e7452, 0x10025e19, // add t0s, r2, r1 ; mov ra_frame_base2, r2
++/* [0x00000bd8] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
++/* [0x00000be0] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
++/* [0x00000be8] */ 0x15827d80, 0x10021427, // mov rb16, unif
++/* [0x00000bf0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000bf8] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
++/* [0x00000c00] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
++/* [0x00000c08] */ 0x00000001, 0xe0020527, // mov ra20, 1
++/* [0x00000c10] */ 0x00000100, 0xe00205a7, // mov ra22, 256
++/* [0x00000c18] */ 0x00000040, 0xe00207a7, // mov ra30, 64
++/* [0x00000c20] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
++/* [0x00000c28] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x00000c30] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x00000c38] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x00000c40] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x00000c48] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x00000c50] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x00000c58] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x00000c60] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x00000c68] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x00000c70] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x00000c78] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000c80] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000c88] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000c90] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000c98] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000ca0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000ca8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000cb0] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x00000cb8] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x00000cc0] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x00000cc8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000cd0] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000cd8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000ce0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000ce8] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000cf0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000cf8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000d00] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000d08] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x00000d10] */ 0x15827d80, 0x10021327, // mov rb12,unif
++/* [0x00000d18] */ 0x15827d80, 0x10021367, // mov rb13,unif
++/* [0x00000d20] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000d28] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000d30] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000d38] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000d40] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000d48] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
++/* [0x00000d50] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
++/* [0x00000d58] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000d60] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000d68] */ 0x0c541dc0, 0xd0020567, // add ra_y2, ra_y2, 1
++/* [0x00000d70] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000d78] */ 0x0c667380, 0x10020e27, // add t0s, r1, ra_frame_base2
+ // ::mc_filter
+-/* [0x00000d90] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000d98] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000da0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000da8] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
+-/* [0x00000db0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000db8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000dc0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00000dc8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000dd0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000dd8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00000de0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
+-/* [0x00000de8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000df0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
+-/* [0x00000df8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00000e00] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+-/* [0x00000e08] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
+-/* [0x00000e10] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00000e18] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
+-/* [0x00000e20] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000e28] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000e30] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000e38] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000e40] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000e48] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000e50] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000e58] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000e60] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000e68] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000e70] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000e78] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000e80] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000e88] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000e90] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000e98] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ea0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ea8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000eb0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000eb8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ec0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ec8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ed0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000ed8] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000ee0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000ee8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000ef0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ef8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000f00] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000f08] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f10] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f18] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f20] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
+-/* [0x00000f28] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000f30] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000f38] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+-/* [0x00000f40] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000f48] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+-/* [0x00000f50] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000d80] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000d88] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000d90] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000d98] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
++/* [0x00000da0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000da8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000db0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000db8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000dc0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000dc8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000dd0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
++/* [0x00000dd8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000de0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
++/* [0x00000de8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000df0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
++/* [0x00000df8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
++/* [0x00000e00] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000e08] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
++/* [0x00000e10] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000e18] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000e20] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000e28] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000e30] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000e38] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000e40] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000e48] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000e50] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000e58] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000e60] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000e68] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000e70] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000e78] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000e80] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000e88] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000e90] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000e98] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000ea0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000ea8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000eb0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000eb8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ec0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x00000ec8] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000ed0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000ed8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000ee0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ee8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x00000ef0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000ef8] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f00] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f08] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000f10] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
++/* [0x00000f18] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000f20] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
++/* [0x00000f28] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
++/* [0x00000f30] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000f38] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
++/* [0x00000f40] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :yloop
+-/* [0x00000f58] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+-/* [0x00000f60] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+-/* [0x00000f68] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x00000f70] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000f78] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+-/* [0x00000f80] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+-/* [0x00000f88] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000f90] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000f98] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+-/* [0x00000fa0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+-/* [0x00000fa8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+-/* [0x00000fb0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000fb8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+-/* [0x00000fc0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+-/* [0x00000fc8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000fd0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000fd8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000fe0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000fe8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000ff0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000ff8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00001000] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00001008] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00001010] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00001018] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00001020] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00001028] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00001030] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00001038] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00001040] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00001048] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00001050] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00001058] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
+-/* [0x00001060] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00001068] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00001070] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00001078] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00001080] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
+-/* [0x00001088] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00001090] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00001098] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x000010a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000010a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000010b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000010b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000010c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+-/* [0x000010c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+-/* [0x000010d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+-/* [0x000010d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+-/* [0x000010e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000010e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000010f0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000010f8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+-/* [0x00001100] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+-/* [0x00001108] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+-/* [0x00001110] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
+-/* [0x00001118] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+-/* [0x00001120] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00001128] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00001130] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001138] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00001140] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00001148] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000f48] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++/* [0x00000f50] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
++/* [0x00000f58] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00000f60] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000f68] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
++/* [0x00000f70] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
++/* [0x00000f78] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000f80] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000f88] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++/* [0x00000f90] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
++/* [0x00000f98] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
++/* [0x00000fa0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000fa8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++/* [0x00000fb0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
++/* [0x00000fb8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000fc0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000fc8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000fd0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000fd8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000fe0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000fe8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000ff0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000ff8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00001000] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00001008] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00001010] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00001018] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00001020] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00001028] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00001030] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00001038] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00001040] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00001048] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
++/* [0x00001050] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00001058] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00001060] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00001068] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00001070] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
++/* [0x00001078] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00001080] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00001088] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00001090] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00001098] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000010a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000010a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000010b0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
++/* [0x000010b8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
++/* [0x000010c0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
++/* [0x000010c8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
++/* [0x000010d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000010d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000010e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000010e8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
++/* [0x000010f0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
++/* [0x000010f8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
++/* [0x00001100] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
++/* [0x00001108] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
++/* [0x00001110] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00001118] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00001120] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001128] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00001130] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001138] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_b
+-/* [0x00001150] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00001158] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00001160] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00001168] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
+-/* [0x00001170] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00001178] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00001180] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00001188] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00001190] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00001198] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x000011a0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
+-/* [0x000011a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000011b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
+-/* [0x000011b8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x000011c0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+-/* [0x000011c8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
+-/* [0x000011d0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x000011d8] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
+-/* [0x000011e0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000011e8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000011f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000011f8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00001200] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00001208] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00001210] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00001218] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00001220] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00001228] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00001230] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00001238] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00001240] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001248] */ 0x00000001, 0xe0020867, // mov r1, 1
+-/* [0x00001250] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x00001258] */ 0x409f3001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 13, r1 << 13
+-/* [0x00001260] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001268] */ 0x409f2001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 14, r1 << 14
+-/* [0x00001270] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001278] */ 0x409f1001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 15, r1 << 15
+-/* [0x00001280] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001288] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00001290] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x00001298] */ 0x409f7001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 9, r1 << 9
+-/* [0x000012a0] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000012a8] */ 0x409f6001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 10, r1 << 10
+-/* [0x000012b0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000012b8] */ 0x409f5001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 11, r1 << 11
+-/* [0x000012c0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000012c8] */ 0x409f4001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 12, r1 << 12
+-/* [0x000012d0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x000012d8] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x000012e0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000012e8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000012f0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000012f8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00001300] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x00001308] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001310] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001318] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001320] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
+-/* [0x00001328] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001330] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x00001338] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+-/* [0x00001340] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00001348] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+-/* [0x00001350] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00001140] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00001148] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00001150] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00001158] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
++/* [0x00001160] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00001168] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00001170] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00001178] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00001180] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00001188] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00001190] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
++/* [0x00001198] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000011a0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
++/* [0x000011a8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x000011b0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
++/* [0x000011b8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
++/* [0x000011c0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x000011c8] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
++/* [0x000011d0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000011d8] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000011e0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000011e8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000011f0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000011f8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00001200] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00001208] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00001210] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00001218] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00001220] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00001228] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00001230] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001238] */ 0x00000001, 0xe0020867, // mov r1, 1
++/* [0x00001240] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x00001248] */ 0x409f3001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 13, r1 << 13
++/* [0x00001250] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001258] */ 0x409f2001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 14, r1 << 14
++/* [0x00001260] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001268] */ 0x409f1001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 15, r1 << 15
++/* [0x00001270] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001278] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00001280] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x00001288] */ 0x409f7001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 9, r1 << 9
++/* [0x00001290] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001298] */ 0x409f6001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 10, r1 << 10
++/* [0x000012a0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000012a8] */ 0x409f5001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 11, r1 << 11
++/* [0x000012b0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000012b8] */ 0x409f4001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 12, r1 << 12
++/* [0x000012c0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
++/* [0x000012c8] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x000012d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000012d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000012e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000012e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
++/* [0x000012f0] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x000012f8] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001300] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001308] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00001310] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
++/* [0x00001318] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001320] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
++/* [0x00001328] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
++/* [0x00001330] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00001338] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
++/* [0x00001340] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :yloopb
+-/* [0x00001358] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+-/* [0x00001360] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+-/* [0x00001368] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x00001370] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00001378] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+-/* [0x00001380] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+-/* [0x00001388] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00001390] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00001398] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+-/* [0x000013a0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+-/* [0x000013a8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+-/* [0x000013b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000013b8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+-/* [0x000013c0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+-/* [0x000013c8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000013d0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000013d8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000013e0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000013e8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000013f0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000013f8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00001400] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00001408] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00001410] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00001418] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00001420] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00001428] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00001430] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00001438] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00001440] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00001448] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00001450] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00001458] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
+-/* [0x00001460] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00001468] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00001470] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00001478] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00001480] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
+-/* [0x00001488] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00001490] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00001498] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x000014a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000014a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000014b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000014b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000014c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+-/* [0x000014c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+-/* [0x000014d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+-/* [0x000014d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+-/* [0x000014e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000014e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000014f0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000014f8] */ 0x4053800e, 0xd00049e1, // nop                     ; mul24 r1, r1 << 8, ra20 << 8
+-/* [0x00001500] */ 0x4c78e38f, 0x10024860, // add r1, r1, ra30        ; mul24 r0, r1, rb14
+-/* [0x00001508] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+-/* [0x00001510] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloopb
+-/* [0x00001518] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00001520] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00001528] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00001530] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001538] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00001540] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00001548] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00001348] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++/* [0x00001350] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
++/* [0x00001358] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00001360] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00001368] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
++/* [0x00001370] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
++/* [0x00001378] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00001380] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00001388] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++/* [0x00001390] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
++/* [0x00001398] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
++/* [0x000013a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000013a8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++/* [0x000013b0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
++/* [0x000013b8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000013c0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000013c8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000013d0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000013d8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000013e0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000013e8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000013f0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000013f8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00001400] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00001408] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00001410] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00001418] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00001420] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00001428] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00001430] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00001438] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00001440] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00001448] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
++/* [0x00001450] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00001458] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00001460] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00001468] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00001470] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
++/* [0x00001478] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00001480] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00001488] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00001490] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00001498] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000014a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000014a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000014b0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
++/* [0x000014b8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
++/* [0x000014c0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
++/* [0x000014c8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
++/* [0x000014d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000014d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000014e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x000014e8] */ 0x4053800e, 0xd00049e1, // nop                     ; mul24 r1, r1 << 8, ra20 << 8
++/* [0x000014f0] */ 0x4c78e38f, 0x10024860, // add r1, r1, ra30        ; mul24 r0, r1, rb14
++/* [0x000014f8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x00001500] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloopb
++/* [0x00001508] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x00001510] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00001518] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00001520] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001528] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00001530] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001538] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_interrupt_exit12
+-/* [0x00001550] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00001540] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00001548] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001550] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00001558] */ 0x009e7000, 0xa00009e7, // ldtmu0
+ /* [0x00001560] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001568] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001570] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001568] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001570] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001578] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001580] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x00001588] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+@@ -732,11 +732,9 @@ unsigned int rpi_shader[] = {
+ /* [0x000015a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x000015b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+ /* [0x000015b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000015c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000015c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000015d0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x000015d8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x000015e0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x000015c0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000015c8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x000015d0] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 3fa8531..6e552d9 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -4,15 +4,15 @@
+ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+-#define mc_filter_uv (rpi_shader + 148)
+-#define mc_filter_uv_b0 (rpi_shader + 338)
+-#define mc_filter_uv_b (rpi_shader + 490)
+-#define mc_exit (rpi_shader + 666)
+-#define mc_interrupt_exit8 (rpi_shader + 684)
+-#define mc_setup (rpi_shader + 714)
+-#define mc_filter (rpi_shader + 868)
+-#define mc_filter_b (rpi_shader + 1108)
+-#define mc_interrupt_exit12 (rpi_shader + 1364)
+-#define mc_end (rpi_shader + 1402)
++#define mc_filter_uv (rpi_shader + 144)
++#define mc_filter_uv_b0 (rpi_shader + 334)
++#define mc_filter_uv_b (rpi_shader + 486)
++#define mc_exit (rpi_shader + 662)
++#define mc_interrupt_exit8 (rpi_shader + 680)
++#define mc_setup (rpi_shader + 710)
++#define mc_filter (rpi_shader + 864)
++#define mc_filter_b (rpi_shader + 1104)
++#define mc_interrupt_exit12 (rpi_shader + 1360)
++#define mc_end (rpi_shader + 1398)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 9cfc0d9..a0b8e5a 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -133,8 +133,8 @@ mov ra14, 0
+ mov ra15, 0
+ 
+ # Compute part of VPM to use for DMA output
+-mov r2, qpu_num
+-shl r2, r2, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
++mov r3, unif
++shl r2, r3, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
+ and r2, r2, 15
+ mov r1, r2
+ asr r1, r1, 2
+@@ -147,8 +147,7 @@ shl r0, r0, 5
+ add rb27, r0, r1
+ 
+ # Compute part of VPM to save data into
+-mov r2, qpu_num   # qpu_num = abcd
+-shl r2, r2, 1
++shl r2, r3, 1
+ and r2, r2, 15    # r2 = bcd0
+ mov r1, r2        # r1 = bcd0
+ asr r1, r1, 2     # r1 = bc
+@@ -181,9 +180,6 @@ add t0s, r2, r1
+ mov rb12,unif # offset before shift
+ mov rb13,unif # offset after shift
+ 
+-# Dump padding words
+-mov r0, unif
+-
+ # submit texture requests for second line
+ max r1, ra_y, 0
+ min r1, r1, rb_frame_height_minus_1
+-- 
+2.7.4
+
+
+From db6fe49d50e42c444b5833acc6206c0bbfaacef4 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Sat, 23 May 2015 13:20:21 +0100
+Subject: [PATCH 45/68] Add new cache flushing routine
+
+---
+ libavcodec/hevc.c          |  8 +++--
+ libavcodec/hevc_filter.c   | 39 ++++++++++-----------
+ libavcodec/rpi_qpu.c       | 17 +++++++--
+ libavcodec/rpi_qpu.h       |  2 ++
+ libavcodec/rpi_user_vcsm.h | 86 ++++++++++++++++++++++++++--------------------
+ 5 files changed, 91 insertions(+), 61 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index caadfaa..9d12583 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -3575,9 +3575,13 @@ static int decode_nal_units(HEVCContext *s, const uint8_t *buf, int length)
+     }
+ 
+ fail:
+-    if (s->ref && s->threads_type == FF_THREAD_FRAME)
++    if (s->ref && s->threads_type == FF_THREAD_FRAME) {
++#ifdef RPI_INTER_QPU
++        void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n);
++        ff_hevc_flush_chroma(s, &s->ref->tf, s->ps.sps->height);
++#endif
+         ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);
+-
++    }
+     return ret;
+ }
+ 
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 186317a..ec84e8a 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -883,36 +883,35 @@ static int ff_hevc_buf_base(AVBufferRef *bref) {
+   return p->vc & 0x3fffffff;
+ }
+ 
+-static void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
++void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n);
++void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
+ {
+     if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
+             s->nal_unit_type == NAL_TSA_N   ||
+             s->nal_unit_type == NAL_STSA_N  ||
+             s->nal_unit_type == NAL_RADL_N  ||
+             s->nal_unit_type == NAL_RASL_N )) {
+-#define RPI_FAST_CACHEFLUSH
+ #ifdef RPI_FAST_CACHEFLUSH
+         struct vcsm_user_clean_invalid_s iocache = {};
+-        int curr_y = f->progress->data[0];
++        int curr_y = ((int *)f->progress->data)[0];
++        int curr_uv = curr_y >> s->ps.sps->vshift[1];
++        int n_uv = n >> s->ps.sps->vshift[1];
+         int sz,base;
+-        if (curr_y < 0) curr_y = 0;
+-        if (n<=curr_y) return; // Should not happen
+-        sz = s->frame->linesize[1] * (n-curr_y);
+-        base = s->frame->linesize[1] * curr_y;
+-        iocache.s[0].cmd = 3; // Flush L1 cache
+-        iocache.s[0].addr = 0;
+-        iocache.s[0].size  = 0;
+-
+-        iocache.s[1].cmd = 2;
+-        iocache.s[1].addr = ff_hevc_buf_base(s->frame->buf[1]) + base;
++        if (curr_uv < 0) curr_uv = 0;
++        if (n_uv<=curr_uv) { assert(0); return; } // Should not happen
++        sz = s->frame->linesize[1] * (n_uv-curr_uv);
++        base = s->frame->linesize[1] * curr_uv;
++        GPU_MEM_PTR_T *p = av_buffer_pool_opaque(s->frame->buf[1]);
++        iocache.s[0].handle = p->vcsm_handle;
++        iocache.s[0].cmd = 3; // clean+invalidate
++        iocache.s[0].addr = p->arm + base;
++        iocache.s[0].size  = sz;
++        p = av_buffer_pool_opaque(s->frame->buf[2]);
++        iocache.s[1].handle = p->vcsm_handle;
++        iocache.s[1].cmd = 3; // clean+invalidate
++        iocache.s[1].addr = p->arm + base;
+         iocache.s[1].size  = sz;
+-
+-        iocache.s[2].cmd = 2;
+-        iocache.s[2].addr = ff_hevc_buf_base(s->frame->buf[2]) + base;
+-        iocache.s[2].size  = sz;
+-
+-        vcsm_clean_invalid( gpu_get_mailbox(), &iocache );
+-
++        vcsm_clean_invalid( &iocache );
+ #else
+         flush_buffer(s->frame->buf[1]);
+         flush_buffer(s->frame->buf[2]);
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index feb3284..aa65a77 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -211,6 +211,7 @@ static void gpu_unlock(void) {
+ }
+ 
+ static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb) {
++  p->numbytes = numbytes;
+   p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
+   assert(p->vcsm_handle);
+   p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
+@@ -243,13 +244,25 @@ int gpu_get_mailbox(void)
+   return gpu->mb;
+ }
+ 
++// Call this to clean and invalidate a region of memory
+ void gpu_cache_flush(GPU_MEM_PTR_T *p)
+ {
+-  void *tmp = vcsm_lock(p->vcsm_handle);
+-  vcsm_unlock_ptr(tmp);
++#define RPI_FAST_CACHEFLUSH
++#ifdef RPI_FAST_CACHEFLUSH
++    struct vcsm_user_clean_invalid_s iocache = {};
++    iocache.s[0].handle = p->vcsm_handle;
++    iocache.s[0].cmd = 3; // clean+invalidate
++    iocache.s[0].addr = p->arm;
++    iocache.s[0].size  = p->numbytes;
++    vcsm_clean_invalid( &iocache );
++#else
++    void *tmp = vcsm_lock(p->vcsm_handle);
++    vcsm_unlock_ptr(tmp);
++#endif
+ }
+ 
+ static int gpu_malloc_cached_internal(int numbytes, GPU_MEM_PTR_T *p) {
++  p->numbytes = numbytes;
+   p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" );
+   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" );
+   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index 2f08f03..0565a60 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -1,6 +1,8 @@
+ #ifndef RPI_QPU_H
+ #define RPI_QPU_H
+ 
++#define RPI_FAST_CACHEFLUSH
++
+ typedef struct gpu_mem_ptr_s {
+   unsigned char *arm; // Pointer to memory mapped on ARM side
+   int vc_handle;   // Videocore handle of relocatable memory
+diff --git a/libavcodec/rpi_user_vcsm.h b/libavcodec/rpi_user_vcsm.h
+index 95e6de1..db41a4d 100644
+--- a/libavcodec/rpi_user_vcsm.h
++++ b/libavcodec/rpi_user_vcsm.h
+@@ -1,29 +1,41 @@
+-/*
+-Copyright (c) 2012, Broadcom Europe Ltd
+-All rights reserved.
+-
+-Redistribution and use in source and binary forms, with or without
+-modification, are permitted provided that the following conditions are met:
+-    * Redistributions of source code must retain the above copyright
+-      notice, this list of conditions and the following disclaimer.
+-    * Redistributions in binary form must reproduce the above copyright
+-      notice, this list of conditions and the following disclaimer in the
+-      documentation and/or other materials provided with the distribution.
+-    * Neither the name of the copyright holder nor the
+-      names of its contributors may be used to endorse or promote products
+-      derived from this software without specific prior written permission.
+-
+-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-*/
++/*****************************************************************************
++* Copyright 2001 - 2011 Broadcom Corporation.  All rights reserved.
++*
++* This program is the proprietary software of Broadcom Corporation and/or
++* its licensors, and may only be used, duplicated, modified or distributed
++* pursuant to the terms and conditions of a separate, written license
++* agreement executed between you and Broadcom (an "Authorized License").
++* Except as set forth in an Authorized License, Broadcom grants no license
++* (express or implied), right to use, or waiver of any kind with respect to
++* the Software, and Broadcom expressly reserves all rights in and to the
++* Software and all intellectual property rights therein.  IF YOU HAVE NO
++* AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY
++* WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF
++* THE SOFTWARE.
++*
++* Except as expressly set forth in the Authorized License,
++* 1. This program, including its structure, sequence and organization,
++*    constitutes the valuable trade secrets of Broadcom, and you shall use
++*    all reasonable efforts to protect the confidentiality thereof, and to
++*    use this information only in connection with your use of Broadcom
++*    integrated circuit products.
++* 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
++*    AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
++*    WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
++*    RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL
++*    IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS
++*    FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS,
++*    QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU
++*    ASSUME THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
++* 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
++*    LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT,
++*    OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
++*    YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN
++*    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS
++*    OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER
++*    IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
++*    ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
++*****************************************************************************/
+ 
+ #ifndef __USER_VCSM__H__INCLUDED__
+ #define __USER_VCSM__H__INCLUDED__
+@@ -424,21 +436,21 @@ int vcsm_unlock_hdl_sp( unsigned int handle, int cache_no_flush );
+ **
+ ** structure contains a list of flush/invalidate commands. Commands are:
+ ** 0: nop
+-** 1: invalidate given physical range in L2
+-** 2: clean      given physical range in L2
+-** 3: clean+invalidate all of L1
+-** 4: flush      all of L2 and all of L1
++** 1: invalidate       given virtual range in L1/L2
++** 2: clean            given virtual range in L1/L2
++** 3: clean+invalidate given virtual range in L1/L2
++** 4: flush all L1/L2
+ */
+ struct vcsm_user_clean_invalid_s {
+-    struct {
+-       unsigned int cmd;
+-       unsigned int addr;
+-       unsigned int size;
+-    } s[8];
++   struct {
++      unsigned int cmd;
++      unsigned int handle;
++      unsigned int addr;
++      unsigned int size;
++   } s[8];
+ };
+ 
+-int vcsm_clean_invalid( unsigned int handle, struct vcsm_user_clean_invalid_s *s );
+-
++int vcsm_clean_invalid( struct vcsm_user_clean_invalid_s *s );
+ 
+ #ifdef __cplusplus
+ }
+-- 
+2.7.4
+
+
+From 87a6cb3a4f7189e711c85de6d20077b6453b2ebe Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Sat, 23 May 2015 21:10:10 +0100
+Subject: [PATCH 46/68] Fix multi mailbox extra transform call
+
+---
+ libavcodec/hevc.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 9d12583..30f5834 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -3024,7 +3024,9 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ #ifdef RPI_INTER_QPU
+         rpi_execute_inter_qpu(s);
+ #endif
++#ifndef RPI_MULTI_MAILBOX
+         rpi_execute_transform(s);
++#endif
+         rpi_execute_inter_cmds(s);
+         vpu_wait(s->vpu_id);
+         rpi_execute_pred_cmds(s);
+-- 
+2.7.4
+
+
+From 2a3672a1bda0296453953bebe8b17d69445260b4 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 27 May 2015 16:44:29 +0100
+Subject: [PATCH 47/68] Added support for running luma prediction on QPUs
+
+---
+ libavcodec/hevc.c          |  237 +++++++-
+ libavcodec/hevc.h          |   26 +-
+ libavcodec/hevc_filter.c   |   23 +-
+ libavcodec/rpi_qpu.c       |  156 ++++--
+ libavcodec/rpi_qpu.h       |    8 +-
+ libavcodec/rpi_shader.c    | 1313 ++++++++++++++++++++++----------------------
+ libavcodec/rpi_shader.h    |   21 +-
+ libavcodec/rpi_shader.qasm |  883 ++++++++++++++---------------
+ 8 files changed, 1464 insertions(+), 1203 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 30f5834..2da88ec 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -52,6 +52,11 @@
+     // Define RPI_MULTI_MAILBOX to use the updated mailbox that can launch both QPU and VPU
+     #define RPI_MULTI_MAILBOX
+   #endif
++
++  // Define RPI_CACHE_UNIF_MVS to write motion vector uniform stream to cached memory
++  // RPI_CACHE_UNIF_MVS doesn't seem to make much difference, so left undefined.
++
++
+ #endif
+ 
+ // #define DISABLE_MC
+@@ -74,6 +79,13 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ // The QPU code for UV blocks only works up to a block width of 8
+ #define RPI_CHROMA_BLOCK_WIDTH 8
+ 
++// Split image of 2048 into parts 64 wide
++// So some QPUs will have 3 blocks of 64 to do, and others 2 blocks for an image 2048 wide with 32 blocks across
++// Each block of 64*64
++// Smallest CTU size is 16x16, so smallest block is 8x8
++// Corresponds to a total of 83kbytes over all 12 QPUs
++#define RPI_LUMA_COMMAND_WORDS 9
++#define Y_COMMANDS_PER_QPU ((1+3*(64*64)/(8*8)) * RPI_LUMA_COMMAND_WORDS)
+ 
+ #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
+ 
+@@ -2015,10 +2027,46 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+         int nPbW_c = nPbW >> s->ps.sps->hshift[1];
+         int nPbH_c = nPbH >> s->ps.sps->vshift[1];
+ 
+-        RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref0->frame,
++#ifdef RPI_LUMA_QPU
++        if (s->enable_rpi) {
++            int reflist = 0;
++            const Mv *mv         = &current_mv.mv[reflist];
++            int mx          = mv->x & 3;
++            int my          = mv->y & 3;
++            int my_mx = (my<<8) + mx;
++            int my2_mx2_my_mx = (my_mx << 16) + my_mx;
++            int x1 = x0 + (mv->x >> 2);
++            int y1 = y0 + (mv->y >> 2);
++            int chan = x0>>6; // 64 wide blocks per QPU
++            int weight_flag = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
++                              (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
++            uint32_t *y = s->y_mvs[chan % 12];
++            for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
++              for(int start_x=0;start_x < nPbW;start_x+=16) {
++                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
++                  *y++ = ( (nPbW<16 ? nPbW : 16) << 16 ) + (nPbH<16 ? nPbH : 16);
++                  *y++ = my2_mx2_my_mx;
++                  if (weight_flag) {
++                      *y++ = (s->sh.luma_offset_l0[current_mv.ref_idx[reflist]] << 16) + (s->sh.luma_weight_l0[current_mv.ref_idx[reflist]] & 0xffff);
++                  } else {
++                      *y++ = 1; // Weight of 1 and offset of 0
++                  }
++                  *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
++                }
++            }
++            s->y_mvs[chan % 12] = y;
++        } else
++#endif
++        {
++            RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref0->frame,
+                     &current_mv.mv[0], x0, y0, nPbW, nPbH,
+                     s->sh.luma_weight_l0[current_mv.ref_idx[0]],
+                     s->sh.luma_offset_l0[current_mv.ref_idx[0]]);
++        }
+ 
+         if (s->ps.sps->chroma_format_idc) {
+ #ifdef RPI_INTER_QPU
+@@ -2078,10 +2126,47 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+         int nPbW_c = nPbW >> s->ps.sps->hshift[1];
+         int nPbH_c = nPbH >> s->ps.sps->vshift[1];
+ 
+-        RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref1->frame,
++#ifdef RPI_LUMA_QPU
++        if (s->enable_rpi) {
++            int reflist = 1;
++            const Mv *mv    = &current_mv.mv[reflist];
++            int mx          = mv->x & 3;
++            int my          = mv->y & 3;
++            int my_mx = (my<<8) + mx;
++            int my2_mx2_my_mx = (my_mx << 16) + my_mx;
++            int x1 = x0 + (mv->x >> 2);
++            int y1 = y0 + (mv->y >> 2);
++            int chan = x0>>6; // 64 wide blocks per QPU
++            int weight_flag = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
++                              (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
++            uint32_t *y = s->y_mvs[chan % 12];
++            for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
++              for(int start_x=0;start_x < nPbW;start_x+=16) {
++                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
++                  *y++ = ( (nPbW<16 ? nPbW : 16) << 16 ) + (nPbH<16 ? nPbH : 16);
++                  *y++ = my2_mx2_my_mx;
++                  if (weight_flag) {
++                      *y++ = (s->sh.luma_offset_l0[current_mv.ref_idx[reflist]] << 16) + (s->sh.luma_weight_l0[current_mv.ref_idx[reflist]] & 0xffff);
++                  } else {
++                      *y++ = 1; // Weight of 1 and offset of 0
++                  }
++                  *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
++                }
++            }
++            s->y_mvs[chan % 12] = y;
++        } else
++#endif
++
++        {
++            RPI_REDIRECT(luma_mc_uni)(s, dst0, s->frame->linesize[0], ref1->frame,
+                     &current_mv.mv[1], x0, y0, nPbW, nPbH,
+                     s->sh.luma_weight_l1[current_mv.ref_idx[1]],
+                     s->sh.luma_offset_l1[current_mv.ref_idx[1]]);
++        }
+ 
+         if (s->ps.sps->chroma_format_idc) {
+ #ifdef RPI_INTER_QPU
+@@ -2115,8 +2200,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = rpi_filter_coefs[_mx][0];
+                       *u++ = rpi_filter_coefs[_my][0];
+                       if (weight_flag) {
+-                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[1]][0] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[1]][0] & 0xffff);
+-                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[1]][1] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[1]][1] & 0xffff);
++                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[reflist]][0] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[reflist]][0] & 0xffff);
++                          *u++ = (s->sh.chroma_offset_l0[current_mv.ref_idx[reflist]][1] << 16) + (s->sh.chroma_weight_l0[current_mv.ref_idx[reflist]][1] & 0xffff);
+                       } else {
+                           *u++ = 1; // Weight of 1 and offset of 0
+                           *u++ = 1;
+@@ -2143,9 +2228,44 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+         int nPbW_c = nPbW >> s->ps.sps->hshift[1];
+         int nPbH_c = nPbH >> s->ps.sps->vshift[1];
+ 
+-        RPI_REDIRECT(luma_mc_bi)(s, dst0, s->frame->linesize[0], ref0->frame,
++#ifdef RPI_LUMA_QPU
++        if (s->enable_rpi) {
++            const Mv *mv    = &current_mv.mv[0];
++            int mx          = mv->x & 3;
++            int my          = mv->y & 3;
++            int my_mx = (my<<8) + mx;
++            const Mv *mv2    = &current_mv.mv[1];
++            int mx2          = mv2->x & 3;
++            int my2          = mv2->y & 3;
++            int my2_mx2 = (my2<<8) + mx2;
++            int my2_mx2_my_mx = (my2_mx2 << 16) + my_mx;
++            int x1 = x0 + (mv->x >> 2);
++            int y1 = y0 + (mv->y >> 2);
++            int x2 = x0 + (mv2->x >> 2);
++            int y2 = y0 + (mv2->y >> 2);
++            int chan = x0>>6; // 64 wide blocks per QPU
++            uint32_t *y = s->y_mvs[chan % 12];
++            for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
++              for(int start_x=0;start_x < nPbW;start_x+=8) { // B blocks work 8 at a time
++                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = ((y2 - 3 + start_y) << 16) + ( (x2 - 3 + start_x) & 0xffff); // Second fetch is for ref1
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
++                  *y++ = ( (nPbW<8 ? nPbW : 8) << 16 ) + (nPbH<16 ? nPbH : 16);
++                  *y++ = my2_mx2_my_mx;
++                  *y++ = 1; // B frame weighted prediction not supported
++                  *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter_b;
++                }
++            }
++            s->y_mvs[chan % 12] = y;
++        } else
++#endif
++        {
++            RPI_REDIRECT(luma_mc_bi)(s, dst0, s->frame->linesize[0], ref0->frame,
+                    &current_mv.mv[0], x0, y0, nPbW, nPbH,
+                    ref1->frame, &current_mv.mv[1], &current_mv);
++        }
+ 
+         if (s->ps.sps->chroma_format_idc) {
+ #ifdef RPI_INTER_QPU
+@@ -2834,7 +2954,6 @@ static void rpi_inter_clear(HEVCContext *s)
+         *s->u_mvs[i]++ = pic_height;
+         *s->u_mvs[i]++ = s->frame->linesize[1];
+         *s->u_mvs[i]++ = s->frame->linesize[2];
+-        *s->u_mvs[i]++ = i;
+         if (weight_flag) {
+             *s->u_mvs[i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
+             *s->u_mvs[i]++ = s->sh.chroma_log2_weight_denom + 6;
+@@ -2842,7 +2961,31 @@ static void rpi_inter_clear(HEVCContext *s)
+             *s->u_mvs[i]++ = 1 << 5;
+             *s->u_mvs[i]++ = 6;
+         }
++        *s->u_mvs[i]++ = i;  // Select section of VPM (avoid collisions with 3d unit)
++    }
++
++#ifdef RPI_LUMA_QPU
++    for(i=0;i<12;i++) {
++        s->y_mvs[i] = s->y_mvs_base[i];
++        *s->y_mvs[i]++ = 0; // y_x
++        *s->y_mvs[i]++ = 0; // ref_y_base
++        *s->y_mvs[i]++ = 0; // y2_x2
++        *s->y_mvs[i]++ = 0; // ref_y2_base
++        *s->y_mvs[i]++ = (s->ps.sps->width << 16) + s->ps.sps->height;
++        *s->y_mvs[i]++ = s->frame->linesize[0]; // pitch
++        *s->y_mvs[i]++ = s->frame->linesize[0]; // dst_pitch
++        if (weight_flag) {
++            int offset = 1 << (s->sh.luma_log2_weight_denom + 6 - 1);
++            int shift = s->sh.luma_log2_weight_denom + 6;
++            *s->y_mvs[i]++ = (offset << 16) + shift;
++        } else {
++            int offset = 1 << 5;
++            int shift = 6;
++            *s->y_mvs[i]++ = (offset << 16) + shift;
++        }
++        *s->y_mvs[i]++ = 0; // Next kernel
+     }
++#endif
+ }
+ 
+ static void rpi_execute_inter_qpu(HEVCContext *s)
+@@ -2850,6 +2993,9 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+     int k;
+     int i;
+     uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;
++#ifdef RPI_LUMA_QPU
++    uint32_t *y_unif_vc = (uint32_t *)s->y_unif_mvs_ptr.vc;
++#endif
+     if (s->sh.slice_type == I_SLICE) {
+ #ifdef RPI_MULTI_MAILBOX
+       rpi_execute_transform(s);
+@@ -2865,8 +3011,23 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+ 
+     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+ 
++#ifdef RPI_LUMA_QPU
++    for(k=0;k<12;k++) {
++        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+1] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
++        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for second request
++        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
++        assert(s->y_mvs[k] - s->y_mvs_base[k] < Y_COMMANDS_PER_QPU);
++    }
++    s->y_mvs[12-1][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT12); // This QPU will signal interrupt when all others are done and have acquired a semaphore
++#endif
++
++
+ #ifdef RPI_MULTI_MAILBOX
++#ifdef RPI_CACHE_UNIF_MVS
++    gpu_cache_flush3(&s->coeffs_buf_accelerated,&s->y_unif_mvs_ptr, &s->unif_mvs_ptr);
++#else
+     gpu_cache_flush(&s->coeffs_buf_accelerated);
++#endif
+     s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0,
+                                    qpu_get_fn(QPU_MC_SETUP_UV),
+                                    (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+@@ -2876,7 +3037,27 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+                                    (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                    (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+                                    (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-                                   (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
++                                   (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++#ifdef RPI_LUMA_QPU
++                                   qpu_get_fn(QPU_MC_SETUP),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[0 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[1 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[2 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[3 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[4 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[5 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[6 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[7 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[8 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[9 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[10 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[11 ] - (uint32_t*)s->y_unif_mvs_ptr.arm))
++#else
++                                   0,
++                                   0,0,0,0,
++                                   0,0,0,0,
++                                   0,0,0,0
++#endif
+                                  );
+     for(i=0;i<4;i++)
+         s->num_coeffs[i] = 0;
+@@ -2892,6 +3073,8 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+       (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
+       );
+ #endif
++
++
+ }
+ #endif
+ 
+@@ -3579,8 +3762,7 @@ static int decode_nal_units(HEVCContext *s, const uint8_t *buf, int length)
+ fail:
+     if (s->ref && s->threads_type == FF_THREAD_FRAME) {
+ #ifdef RPI_INTER_QPU
+-        void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n);
+-        ff_hevc_flush_chroma(s, &s->ref->tf, s->ps.sps->height);
++        ff_hevc_flush_buffer(s, &s->ref->tf, s->ps.sps->height);
+ #endif
+         ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);
+     }
+@@ -3767,7 +3949,6 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+ 
+ #ifdef RPI
+     av_freep(&s->unif_mv_cmds);
+-    av_freep(&s->unif_xfm_cmds);
+     av_freep(&s->univ_pred_cmds);
+ 
+ #ifdef RPI_INTER_QPU
+@@ -3776,7 +3957,12 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+         s->unif_mvs = 0;
+     }
+ #endif
+-    //gpu_free(&s->dummy);
++#ifdef RPI_LUMA_QPU
++    if (s->y_unif_mvs) {
++        gpu_free( &s->y_unif_mvs_ptr );
++        s->y_unif_mvs = 0;
++    }
++#endif
+ 
+ #ifdef EARLY_MALLOC
+     printf("hevc_decode_free\n");
+@@ -3861,9 +4047,6 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     s->unif_mv_cmds = av_mallocz(sizeof(HEVCMvCmd)*RPI_MAX_MV_CMDS);
+     if (!s->unif_mv_cmds)
+         goto fail;
+-    s->unif_xfm_cmds = av_mallocz(sizeof(HEVCXfmCmd)*RPI_MAX_XFM_CMDS);
+-    if (!s->unif_xfm_cmds)
+-        goto fail;
+     s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
+     if (!s->univ_pred_cmds)
+         goto fail;
+@@ -3877,7 +4060,11 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     {
+         int uv_commands_per_qpu = UV_COMMANDS_PER_QPU;
+         uint32_t *p;
++#ifdef RPI_CACHE_UNIF_MVS
++        gpu_malloc_cached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
++#else
+         gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
++#endif
+         s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
+ 
+         // Set up initial locations for uniform streams
+@@ -3892,6 +4079,28 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+ 
+     }
+ #endif
++#ifdef RPI_LUMA_QPU
++    {
++        int y_commands_per_qpu = Y_COMMANDS_PER_QPU;
++        uint32_t *p;
++#ifdef RPI_CACHE_UNIF_MVS
++        gpu_malloc_cached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr );
++#else
++        gpu_malloc_uncached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr );
++#endif
++        s->y_unif_mvs = (uint32_t *) s->y_unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
++
++        // Set up initial locations for uniform streams
++        p = s->y_unif_mvs;
++        for(i = 0; i < 12; i++) {
++            s->y_mvs_base[i] = p;
++            p += y_commands_per_qpu;
++        }
++        s->mc_filter = qpu_get_fn(QPU_MC_FILTER);
++        s->mc_filter_b = qpu_get_fn(QPU_MC_FILTER_B);
++
++    }
++#endif
+     //gpu_malloc_uncached(2048*64,&s->dummy);
+ 
+ #ifdef EARLY_MALLOC
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 4a39e39..5df9dcd 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -44,9 +44,13 @@
+ #ifdef RPI
+ 
+   #include "rpi_qpu.h"
+-  // Use QPU for inter prediction
++  // Define RPI_INTER_QPU to use QPU for chroma inter prediction
+   #define RPI_INTER_QPU
+ 
++  #ifdef RPI_INTER_QPU
++    // Define RPI_LUMA_QPU to also use QPU for luma inter prediction
++    #define RPI_LUMA_QPU
++  #endif
+ #endif
+ 
+ #define MAX_DPB_SIZE 16 // A.4.1
+@@ -809,7 +813,6 @@ typedef struct HEVCLocalContext {
+ 
+ // Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane, * 2 for bi
+ #define RPI_MAX_MV_CMDS   (2*16*3*(RPI_MAX_WIDTH/4))
+-#define RPI_MAX_XFM_CMDS  (16*3*(RPI_MAX_WIDTH/4))
+ // Each block can have an intra prediction and a transform_add command
+ #define RPI_MAX_PRED_CMDS (2*16*3*(RPI_MAX_WIDTH/4))
+ // Worst case is 16x16 CTUs
+@@ -844,9 +847,6 @@ typedef struct HEVCMvCmd {
+     int8_t ref_idx[2];
+ } HEVCMvCmd;
+ 
+-// Command for transform to process a block of coefficients
+-typedef struct HEVCXfmCmd {
+-} HEVCXfmCmd;
+ 
+ // Command for intra prediction and transform_add of predictions to coefficients
+ #define RPI_PRED_TRANSFORM_ADD 0
+@@ -892,8 +892,7 @@ typedef struct HEVCContext {
+ 
+ #ifdef RPI
+     int enable_rpi;
+-    HEVCMvCmd *unif_mv_cmds;  // TODO rename
+-    HEVCXfmCmd *unif_xfm_cmds;
++    HEVCMvCmd *unif_mv_cmds;
+     HEVCPredCmd *univ_pred_cmds;
+     int buf_width;
+     GPU_MEM_PTR_T coeffs_buf_default;
+@@ -920,6 +919,15 @@ typedef struct HEVCContext {
+     uint32_t mc_filter_uv_b0;
+     uint32_t mc_filter_uv_b;
+ #endif
++#ifdef RPI_LUMA_QPU
++    GPU_MEM_PTR_T y_unif_mvs_ptr;
++    uint32_t *y_unif_mvs; // Base of memory for motion vector commands
++    uint32_t *y_mvs_base[12];
++    uint32_t *y_mvs[12];
++    // Function pointers
++    uint32_t mc_filter;
++    uint32_t mc_filter_b;
++#endif
+ 
+ #endif
+ 
+@@ -1166,6 +1174,10 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+                                  int log2_trafo_size, enum ScanType scan_idx,
+                                  int c_idx);
+ 
++#ifdef RPI_INTER_QPU
++extern void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n);
++#endif
++
+ void ff_hevc_hls_mvd_coding(HEVCContext *s, int x0, int y0, int log2_cb_size);
+ 
+ 
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index ec84e8a..11629e4 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -883,8 +883,7 @@ static int ff_hevc_buf_base(AVBufferRef *bref) {
+   return p->vc & 0x3fffffff;
+ }
+ 
+-void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n);
+-void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
++void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+ {
+     if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
+             s->nal_unit_type == NAL_TSA_N   ||
+@@ -911,10 +910,24 @@ void ff_hevc_flush_chroma(HEVCContext *s, ThreadFrame *f, int n)
+         iocache.s[1].cmd = 3; // clean+invalidate
+         iocache.s[1].addr = p->arm + base;
+         iocache.s[1].size  = sz;
++
++#ifdef RPI_LUMA_QPU
++        p = av_buffer_pool_opaque(s->frame->buf[0]);
++        sz = s->frame->linesize[0] * (n-curr_y);
++        base = s->frame->linesize[0] * curr_y;
++        iocache.s[2].handle = p->vcsm_handle;
++        iocache.s[2].cmd = 3; // clean+invalidate
++        iocache.s[2].addr = p->arm + base;
++        iocache.s[2].size  = sz;
++#endif
+         vcsm_clean_invalid( &iocache );
+ #else
+         flush_buffer(s->frame->buf[1]);
+         flush_buffer(s->frame->buf[2]);
++#ifdef RPI_LUMA_QPU
++        flush_buffer(s->frame->buf[1]);
++#endif
++
+ #endif
+         //memcpy(s->dummy.arm,s->frame->data[0],2048*64);
+         //memcpy(s->dummy.arm,s->frame->data[1],1024*32);
+@@ -938,7 +951,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+             sao_filter_CTB(s, x, y - ctb_size);
+             if (s->threads_type & FF_THREAD_FRAME ) {
+ #ifdef RPI_INTER_QPU
+-                ff_hevc_flush_chroma(s,&s->ref->tf, y);
++                ff_hevc_flush_buffer(s,&s->ref->tf, y);
+ #endif
+                 ff_thread_report_progress(&s->ref->tf, y, 0);
+             }
+@@ -947,7 +960,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+             sao_filter_CTB(s, x , y);
+             if (s->threads_type & FF_THREAD_FRAME ) {
+ #ifdef RPI_INTER_QPU
+-                ff_hevc_flush_chroma(s, &s->ref->tf, y + ctb_size);
++                ff_hevc_flush_buffer(s, &s->ref->tf, y + ctb_size);
+ #endif
+                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
+             }
+@@ -957,7 +970,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+         //int currh = s->ref->tf.progress->data[0];
+         //if (((y + ctb_size)&63)==0)
+ #ifdef RPI_INTER_QPU
+-        ff_hevc_flush_chroma(s, &s->ref->tf, y + ctb_size - 4);
++        ff_hevc_flush_buffer(s, &s->ref->tf, y + ctb_size - 4);
+ #endif
+         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
+     }
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index aa65a77..e12304b 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -1,9 +1,11 @@
+ #ifdef RPI
+ // This works better than the mmap in that the memory can be cached, but requires a kernel modification to enable the device.
+ // define RPI_TIME_TOTAL_QPU to print out how much time is spent in the QPU code
+-#define RPI_TIME_TOTAL_QPU
++//#define RPI_TIME_TOTAL_QPU
+ // define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
+ //#define RPI_TIME_TOTAL_VPU
++// define RPI_TIME_TOTAL_POSTED to print out how much time is spent in the multi execute QPU/VPU combined
++//#define RPI_TIME_TOTAL_POSTED
+ // define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
+ #define RPI_ASYNC
+ 
+@@ -94,7 +96,8 @@ struct GPU
+   int open_count; // Number of allocated video buffers
+   int      mb; // Mailbox handle
+   int      vc; // Address in GPU memory
+-  int mail[12]; // These are used to pass pairs of code/unifs to the QPUs
++  int mail[12*2]; // These are used to pass pairs of code/unifs to the QPUs for the first QPU task
++  int mail2[12*2]; // These are used to pass pairs of code/unifs to the QPUs for the second QPU task
+ };
+ 
+ // Stop more than one thread trying to allocate memory or use the processing resources at once
+@@ -102,7 +105,7 @@ static pthread_mutex_t gpu_mutex = PTHREAD_MUTEX_INITIALIZER;
+ static volatile struct GPU* gpu = NULL;
+ static GPU_MEM_PTR_T gpu_mem_ptr;
+ 
+-#if defined(RPI_TIME_TOTAL_QPU) || defined(RPI_TIME_TOTAL_VPU)
++#if defined(RPI_TIME_TOTAL_QPU) || defined(RPI_TIME_TOTAL_VPU) || defined(RPI_TIME_TOTAL_POSTED)
+ static unsigned int Microseconds(void) {
+     struct timespec ts;
+     unsigned int x;
+@@ -123,7 +126,7 @@ static pthread_cond_t post_cond_head = PTHREAD_COND_INITIALIZER;
+ static pthread_cond_t post_cond_tail = PTHREAD_COND_INITIALIZER;
+ static pthread_mutex_t post_mutex = PTHREAD_MUTEX_INITIALIZER;
+ 
+-static int vpu_cmds[MAXCMDS][16];
++static int vpu_cmds[MAXCMDS][32];
+ static volatile int vpu_async_tail=0; // Contains the number of posted jobs
+ static volatile int vpu_async_head=0;
+ #endif
+@@ -247,7 +250,6 @@ int gpu_get_mailbox(void)
+ // Call this to clean and invalidate a region of memory
+ void gpu_cache_flush(GPU_MEM_PTR_T *p)
+ {
+-#define RPI_FAST_CACHEFLUSH
+ #ifdef RPI_FAST_CACHEFLUSH
+     struct vcsm_user_clean_invalid_s iocache = {};
+     iocache.s[0].handle = p->vcsm_handle;
+@@ -261,6 +263,34 @@ void gpu_cache_flush(GPU_MEM_PTR_T *p)
+ #endif
+ }
+ 
++void gpu_cache_flush3(GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2)
++{
++#ifdef RPI_FAST_CACHEFLUSH
++    struct vcsm_user_clean_invalid_s iocache = {};
++    iocache.s[0].handle = p0->vcsm_handle;
++    iocache.s[0].cmd = 3; // clean+invalidate
++    iocache.s[0].addr = (int) p0->arm;
++    iocache.s[0].size  = p0->numbytes;
++    iocache.s[1].handle = p1->vcsm_handle;
++    iocache.s[1].cmd = 3; // clean+invalidate
++    iocache.s[1].addr = (int) p1->arm;
++    iocache.s[1].size  = p1->numbytes;
++    iocache.s[2].handle = p2->vcsm_handle;
++    iocache.s[2].cmd = 3; // clean+invalidate
++    iocache.s[2].addr = (int) p2->arm;
++    iocache.s[2].size  = p2->numbytes;
++    vcsm_clean_invalid( &iocache );
++#else
++    void *tmp;
++    tmp = vcsm_lock(p0->vcsm_handle);
++    vcsm_unlock_ptr(tmp);
++    tmp = vcsm_lock(p1->vcsm_handle);
++    vcsm_unlock_ptr(tmp);
++    tmp = vcsm_lock(p2->vcsm_handle);
++    vcsm_unlock_ptr(tmp);
++#endif
++}
++
+ static int gpu_malloc_cached_internal(int numbytes, GPU_MEM_PTR_T *p) {
+   p->numbytes = numbytes;
+   p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST, (char *)"Video Frame" );
+@@ -357,9 +387,19 @@ unsigned int vpu_get_constants(void) {
+ #ifdef RPI_ASYNC
+ 
+ static void *vpu_start(void *arg) {
++#ifdef RPI_TIME_TOTAL_POSTED
++  int last_time=0;
++  long long on_time=0;
++  long long off_time=0;
++  int start_time;
++  int end_time;
++  int count=0;
++#endif
+   while(1) {
++    int i;
+     int *p;
+     int qpu_code;
++    int qpu_codeb;
+     pthread_mutex_lock(&post_mutex);
+     while( vpu_async_tail - vpu_async_head <= 0)
+     {
+@@ -373,24 +413,49 @@ static void *vpu_start(void *arg) {
+       break; // Last job
+     }
+     qpu_code = p[7];
++    qpu_codeb = p[16];
+     //if (p[7]) {
+         //GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
+         //gpu_cache_flush(buf);
+     //}
++
++#ifdef RPI_TIME_TOTAL_POSTED
++    start_time = Microseconds();
++    if (last_time==0)
++      last_time = start_time;
++    off_time += start_time-last_time;
++#endif
++
+     if (!qpu_code) {
+       vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
+     } else {
+-      int i;
+       for(i=0;i<8;i++) {
+         gpu->mail[i*2] = p[8+i];
+         gpu->mail[i*2 + 1] = qpu_code;
+       }
+-
+-      execute_multi(gpu->mb,8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
+-                              0, 0, 0, 0,
++      for(i=0;i<12;i++) {
++        gpu->mail2[i*2] = p[17+i];
++        gpu->mail2[i*2 + 1] = qpu_codeb;
++      }
++#if (0)
++      vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
++      execute_qpu(gpu->mb,8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */);
++#else
++      execute_multi(gpu->mb,
++                              12,gpu->vc + offsetof(struct GPU, mail2), 1, 5000,
++                              8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
+                               p[0], p[1], p[2], p[3], p[4], p[5], p[6], // VPU0
+                               0,    0   , 0   , 0   , 0   , 0   , 0); // VPU1
++#endif
+     }
++#ifdef RPI_TIME_TOTAL_POSTED
++    end_time = Microseconds();
++    last_time = end_time;
++    on_time += end_time - start_time;
++    count++;
++    if ((count&0x7f)==0)
++      printf("Posted %d On=%dms, Off=%dms\n",count,(int)(on_time/1000),(int)(off_time/1000));
++#endif
+     pthread_mutex_lock(&post_mutex);
+     vpu_async_head++;
+     pthread_cond_broadcast(&post_cond_head);
+@@ -436,7 +501,9 @@ int vpu_post_code(unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned
+ }
+ 
+ int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5,
+-                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8)
++                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8,
++                      int qpu_codeb, int unifs1b, int unifs2b, int unifs3b, int unifs4b, int unifs5b, int unifs6b, int unifs7b, int unifs8b, int unifs9b, int unifs10b, int unifs11b, int unifs12b
++                      )
+ {
+ 
+   pthread_mutex_lock(&post_mutex);
+@@ -464,6 +531,21 @@ int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2,
+     p[13] = unifs6;
+     p[14] = unifs7;
+     p[15] = unifs8;
++
++    p[16] = qpu_codeb;
++    p[17] = unifs1b;
++    p[18] = unifs2b;
++    p[19] = unifs3b;
++    p[20] = unifs4b;
++    p[21] = unifs5b;
++    p[22] = unifs6b;
++    p[23] = unifs7b;
++    p[24] = unifs8b;
++    p[25] = unifs9b;
++    p[26] = unifs10b;
++    p[27] = unifs11b;
++    p[28] = unifs12b;
++
+     if (num<=1)
+       pthread_cond_broadcast(&post_cond_tail); // Otherwise the vpu thread must already be awake
+     pthread_mutex_unlock(&post_mutex);
+@@ -544,27 +626,27 @@ void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int un
+   off_time += start_time-last_time;
+ #endif
+   for(i=0;i<num;i++) {
+-    gpu->mail[i*2 + 1] = code;
++    gpu->mail2[i*2 + 1] = code;
+   }
+   for(;i<num+num2;i++) {
+-    gpu->mail[i*2 + 1] = code2;
++    gpu->mail2[i*2 + 1] = code2;
+   }
+-  gpu->mail[0 ] = unifs1;
+-  gpu->mail[2 ] = unifs2;
+-  gpu->mail[4 ] = unifs3;
+-  gpu->mail[6 ] = unifs4;
+-  gpu->mail[8 ] = unifs5;
+-  gpu->mail[10] = unifs6;
+-	gpu->mail[12] = unifs7;
+-	gpu->mail[14] = unifs8;
+-	gpu->mail[16] = unifs9;
+-	gpu->mail[18] = unifs10;
+-	gpu->mail[20] = unifs11;
+-	gpu->mail[22] = unifs12;
++  gpu->mail2[0 ] = unifs1;
++  gpu->mail2[2 ] = unifs2;
++  gpu->mail2[4 ] = unifs3;
++  gpu->mail2[6 ] = unifs4;
++  gpu->mail2[8 ] = unifs5;
++  gpu->mail2[10] = unifs6;
++	gpu->mail2[12] = unifs7;
++	gpu->mail2[14] = unifs8;
++	gpu->mail2[16] = unifs9;
++	gpu->mail2[18] = unifs10;
++	gpu->mail2[20] = unifs11;
++	gpu->mail2[22] = unifs12;
+ 	execute_qpu(
+ 		gpu->mb,
+ 		12 /* Number of QPUs */,
+-		gpu->vc + offsetof(struct GPU, mail),
++		gpu->vc + offsetof(struct GPU, mail2),
+ 		1 /* no flush */,  // Don't flush VPU L1 cache
+ 		5000 /* timeout ms */);
+ #ifdef RPI_TIME_TOTAL_QPU
+@@ -635,21 +717,21 @@ unsigned int qpu_get_fn(int num) {
+       gpu_unlock();
+     }
+     switch(num) {
+-    //case QPU_MC_SETUP:
+-    //  fn = mc_setup;
+-    //  break;
+-    //case QPU_MC_FILTER:
+-    //  fn = mc_filter;
+-    //  break;
++    case QPU_MC_SETUP:
++      fn = mc_setup;
++      break;
++    case QPU_MC_FILTER:
++      fn = mc_filter;
++      break;
+     case QPU_MC_EXIT:
+       fn = mc_exit;
+       break;
+-    //case QPU_MC_INTERRUPT_EXIT:
+-    //  fn = mc_interrupt_exit;
+-    //  break;
+-    //case QPU_MC_FILTER_B:
+-    //  fn = mc_filter_b;
+-    //  break;
++    case QPU_MC_INTERRUPT_EXIT12:
++      fn = mc_interrupt_exit12;
++      break;
++    case QPU_MC_FILTER_B:
++      fn = mc_filter_b;
++      break;
+     //case QPU_MC_FILTER_HONLY:
+     //  fn = mc_filter_honly;
+     //  break;
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index 0565a60..81c2bb1 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -1,6 +1,7 @@
+ #ifndef RPI_QPU_H
+ #define RPI_QPU_H
+ 
++// Define RPI_FAST_CACHEFLUSH to use the VCSM cache flush code
+ #define RPI_FAST_CACHEFLUSH
+ 
+ typedef struct gpu_mem_ptr_s {
+@@ -16,6 +17,7 @@ extern int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p);
+ extern int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p);
+ extern void gpu_free(GPU_MEM_PTR_T *p);
+ extern void gpu_cache_flush(GPU_MEM_PTR_T *p);
++extern void gpu_cache_flush3(GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2);
+ 
+ // QPU specific functions
+ extern void qpu_run_shader8(int code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
+@@ -26,7 +28,7 @@ enum {
+   QPU_MC_SETUP,
+   QPU_MC_FILTER,
+   QPU_MC_EXIT,
+-  QPU_MC_INTERRUPT_EXIT,
++  QPU_MC_INTERRUPT_EXIT12,
+   QPU_MC_FILTER_B,
+   QPU_MC_FILTER_HONLY,
+   QPU_MC_SETUP_UV,
+@@ -44,7 +46,9 @@ extern unsigned int vpu_get_constants(void);
+ extern unsigned vpu_execute_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+ extern int vpu_post_code( unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, GPU_MEM_PTR_T *buf);
+ int vpu_qpu_post_code(unsigned vpu_code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5,
+-                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
++                      int qpu_code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8,
++                      int qpu_codeb, int unifs1b, int unifs2b, int unifs3b, int unifs4b, int unifs5b, int unifs6b, int unifs7b, int unifs8b, int unifs9b, int unifs10b, int unifs11b, int unifs12b
++                      );
+ extern void vpu_wait( int id);
+ 
+ // Simple test of shader code
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index a0f0282..e86eb30 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -48,693 +48,674 @@ unsigned int rpi_shader[] = {
+ /* [0x000000b8] */ 0x00000000, 0xe0020367, // mov ra13, 0
+ /* [0x000000c0] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+ /* [0x000000c8] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x000000d0] */ 0x15827d80, 0x100208e7, // mov r3, unif
+-/* [0x000000d8] */ 0x119c17c0, 0xd00208a7, // shl r2, r3, 1
+-/* [0x000000e0] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x000000e8] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x000000f0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x000000f8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000100] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000108] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000110] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000118] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+-/* [0x00000120] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+-/* [0x00000128] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+-/* [0x00000130] */ 0x119c17c0, 0xd00208a7, // shl r2, r3, 1
+-/* [0x00000138] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
+-/* [0x00000140] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000148] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000150] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000158] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000160] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000168] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000170] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x00000178] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x00000180] */ 0x0f9c11c0, 0xd0020827, // asr r0, r0, 1
+-/* [0x00000188] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
+-/* [0x00000190] */ 0x0c9e7040, 0x10021567, // add rb21, r0, r1
+-/* [0x00000198] */ 0x15427d80, 0x10020827, // mov r0, ra_x
+-/* [0x000001a0] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
+-/* [0x000001a8] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
+-/* [0x000001b0] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
+-/* [0x000001b8] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x000001c0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000001c8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x000001d0] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
++/* [0x000000d0] */ 0x15427d80, 0x10020827, // mov r0, ra_x
++/* [0x000000d8] */ 0x937401f6, 0xd0024821, // max r0, r0, 0; mov r1, ra_y
++/* [0x000000e0] */ 0x926191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, ra_frame_base
++/* [0x000000e8] */ 0x916431f6, 0xd00244e2, // shl ra_xshift_next, r0, 3 ; mov r2, ra_u2v_ref_offset
++/* [0x000000f0] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x000000f8] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000100] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000108] */ 0x939c03c0, 0xd0025850, // max r1, r1, 0 ; mov ra_x, r0
++/* [0x00000110] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000118] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
++/* [0x00000120] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
++/* [0x00000128] */ 0x0c9e7440, 0x10020f27, // add t1s, r2, r1
++/* [0x00000130] */ 0x00000008, 0xe00208a7, // mov r2,8
++/* [0x00000138] */ 0x11827c80, 0x10021327, // shl rb12,unif, r2
++/* [0x00000140] */ 0x0c827c80, 0x10021367, // add rb13,unif,r2
++/* [0x00000148] */ 0x15827d80, 0x100208a7, // mov r2, unif
++/* [0x00000150] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
++/* [0x00000158] */ 0x149cf5c0, 0xd00208a7, // and r2, r2, 15
++/* [0x00000160] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000168] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000170] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000178] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000180] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000188] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000190] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000198] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x000001a0] */ 0x0f9c11c0, 0xd00208a7, // asr r2, r0, 1
++/* [0x000001a8] */ 0x00002900, 0xe0020867, // mov r1, vpm_setup(0, 2, h16p(0, 0))
++/* [0x000001b0] */ 0x0c9e7440, 0x10021567, // add rb21, r2, r1
++/* [0x000001b8] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x000001c0] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x000001c8] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x000001d0] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+ /* [0x000001d8] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x000001e0] */ 0x4c9d040f, 0x100248a1, // add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+-/* [0x000001e8] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
+-/* [0x000001f0] */ 0x0c9e7440, 0x10020e27, // add t0s, r2, r1
+-/* [0x000001f8] */ 0x15827d80, 0x10021327, // mov rb12,unif
+-/* [0x00000200] */ 0x15827d80, 0x10021367, // mov rb13,unif
+-/* [0x00000208] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000210] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000218] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000220] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000228] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000230] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
+-/* [0x00000238] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
++/* [0x000001e0] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x000001e8] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000001f0] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x000001f8] */ 0x0c427380, 0x10020e27, // add t0s, r1, ra_x
++/* [0x00000200] */ 0x0c627380, 0x10020f27, // add t1s, r1, ra_frame_base
+ // ::mc_filter_uv
+-/* [0x00000240] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000248] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000250] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000258] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000260] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000268] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000270] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000278] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000280] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+-/* [0x00000288] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000290] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+-/* [0x00000298] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000002a0] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000002a8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000002b0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000002b8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000002c0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000002c8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000002d0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000002d8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000002e0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000002e8] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000002f0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000002f8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000300] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000308] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000310] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000318] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000320] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000328] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000330] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000338] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x00000340] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000348] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000350] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+-/* [0x00000358] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000360] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+-/* [0x00000368] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000370] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
+-/* [0x00000378] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000380] */ 0x0f9e7080, 0x100613a7, // asr.ifnz rb14, r0, r2
+-/* [0x00000388] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000390] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000208] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000210] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000218] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000220] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000228] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000230] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000238] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000240] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000248] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
++/* [0x00000250] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000258] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
++/* [0x00000260] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000268] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000270] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000278] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000280] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000288] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000290] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000298] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000002a0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000002a8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x000002b0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x000002b8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x000002c0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000002c8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000002d0] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000002d8] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000002e0] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000002e8] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000002f0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000002f8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000300] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000308] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000310] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000318] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
++/* [0x00000320] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000328] */ 0x0f9e7080, 0x100208e7, // asr r3, r0, r2
++/* [0x00000330] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000338] */ 0x0f9e7080, 0x100613e7, // asr.ifnz rb15, r0, r2
++/* [0x00000340] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000348] */ 0x0f9e7080, 0x100608e7, // asr.ifnz r3, r0, r2
++/* [0x00000350] */ 0x119c87c0, 0xd00213a7, // shl rb14,r3,8
++/* [0x00000358] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop
+-/* [0x00000398] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000003a0] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+-/* [0x000003a8] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x000003b0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x000003b8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x000003c0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x000003c8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000003d0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000003d8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+-/* [0x000003e0] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+-/* [0x000003e8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000003f0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000003f8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000400] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000408] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000410] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000418] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000420] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000428] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000430] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000438] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000440] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x00000448] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000450] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000458] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000460] */ 0x00000020, 0xe0021327, // mov rb12,32
+-/* [0x00000468] */ 0x00000006, 0xe0021367, // mov rb13,6
+-/* [0x00000470] */ 0x00000001, 0xe00213a7, // mov rb14,1
+-/* [0x00000478] */ 0x00000000, 0xe00213e7, // mov rb15,0
+-/* [0x00000480] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000488] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000490] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000498] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000004a0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000004a8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000004b0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000004b8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+-/* [0x000004c0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+-/* [0x000004c8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+-/* [0x000004d0] */ 0xfffffea8, 0xf06809e7, // brr.anyn -, r:uvloop
+-/* [0x000004d8] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+-/* [0x000004e0] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x000004e8] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x000004f0] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x000004f8] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000500] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000508] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000510] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000518] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000520] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000528] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000530] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000360] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000368] */ 0x8e4539bf, 0xb0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1
++/* [0x00000370] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00000378] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000380] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000388] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000390] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000398] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000003a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++/* [0x000003a8] */ 0x0c627c80, 0x10020f27, // add t1s, ra_frame_base, r2
++/* [0x000003b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000003b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000003c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000003c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000003d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000003d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000003e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x000003e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x000003f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000003f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000400] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000408] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000410] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000418] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000420] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000428] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000430] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000438] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000440] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000448] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000450] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000458] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000460] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
++/* [0x00000468] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
++/* [0x00000470] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
++/* [0x00000478] */ 0xfffffec8, 0xf06809e7, // brr.anyn -, r:uvloop
++/* [0x00000480] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
++/* [0x00000488] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00000490] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00000498] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000004a0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000004a8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000004b0] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000004b8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000004c0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000004c8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000004d0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000004d8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_uv_b0
+-/* [0x00000538] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000540] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00000548] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000550] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000558] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x00000560] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000568] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x00000570] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x00000578] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+-/* [0x00000580] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000588] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+-/* [0x00000590] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
+-/* [0x00000598] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000005a0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005a8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000005b0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000005b8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x000005c0] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x000005c8] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x000005d0] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x000005d8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x000005e0] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x000005e8] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x000005f0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000005f8] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000600] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000608] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000610] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000618] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000620] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000628] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000630] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x00000638] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000640] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000648] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x00000650] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000658] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x000004e0] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x000004e8] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x000004f0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x000004f8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000500] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000508] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000510] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000518] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000520] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
++/* [0x00000528] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000530] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
++/* [0x00000538] */ 0x159d5fc0, 0x10021c67, // mov vw_setup, rb21
++/* [0x00000540] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x00000548] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000550] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x00000558] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000560] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000568] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x00000570] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x00000578] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000580] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000588] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000590] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000598] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005a0] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005a8] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005b0] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005b8] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x000005c0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000005c8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x000005d0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x000005d8] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x000005e0] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005e8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000005f0] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x000005f8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000600] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b0
+-/* [0x00000660] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x00000668] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+-/* [0x00000670] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x00000678] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000680] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000688] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000690] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000698] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x000006a0] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+-/* [0x000006a8] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+-/* [0x000006b0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000006b8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000006c0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000006c8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000006d0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000006d8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000006e0] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000006e8] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000006f0] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x000006f8] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000700] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000708] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000710] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000718] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00000720] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00000728] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00000730] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x00000738] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x00000740] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x00000748] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x00000750] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
+-/* [0x00000758] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
+-/* [0x00000760] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
+-/* [0x00000768] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000770] */ 0x009e7000, 0x100009e7, // nop
+-/* [0x00000778] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000780] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000788] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000790] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000608] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000610] */ 0x8e4539bf, 0xb0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1
++/* [0x00000618] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00000620] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00000628] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x00000630] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00000638] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00000640] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x00000648] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++/* [0x00000650] */ 0x0c627c80, 0x10020f27, // add t1s, ra_frame_base, r2
++/* [0x00000658] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000660] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x00000668] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x00000670] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x00000678] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000680] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000688] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000690] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000698] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x000006a0] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x000006a8] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x000006b0] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x000006b8] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x000006c0] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x000006c8] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000006d0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000006d8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000006e0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000006e8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000006f0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000006f8] */ 0x0d9d27c0, 0x100229e7, // sub.setf -, r3, rb18
++/* [0x00000700] */ 0xfffffee8, 0xf06809e7, // brr.anyn -, r:uvloop_b0
++/* [0x00000708] */ 0x0f9c63c0, 0xd0020c27, // asr vpm, r1, 6
++/* [0x00000710] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000718] */ 0x009e7000, 0x100009e7, // nop
++/* [0x00000720] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000728] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000730] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000738] */ 0x009e7000, 0x100009e7, // nop
+ // ::mc_filter_uv_b
+-/* [0x00000798] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x000007a0] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x000007a8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000007b0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x000007b8] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
+-/* [0x000007c0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x000007c8] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
+-/* [0x000007d0] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
+-/* [0x000007d8] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
+-/* [0x000007e0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x000007e8] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
+-/* [0x000007f0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000007f8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000800] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000808] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000810] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000818] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000820] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
+-/* [0x00000828] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
+-/* [0x00000830] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000838] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
+-/* [0x00000840] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
+-/* [0x00000848] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
+-/* [0x00000850] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000858] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000860] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000868] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
+-/* [0x00000870] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000878] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000880] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000888] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000890] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000898] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008a0] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000008a8] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000008b0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
+-/* [0x000008b8] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000008c0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000008c8] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
+-/* [0x000008d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000008d8] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000740] */ 0x15827d80, 0x100207e7, // mov ra31, unif
++/* [0x00000748] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
++/* [0x00000750] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
++/* [0x00000758] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
++/* [0x00000760] */ 0x928191f6, 0x10024823, // min r0, r0, rb_frame_width_minus_1 ; mov r3, unif
++/* [0x00000768] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000770] */ 0x0d827cc0, 0x100208a7, // sub r2, unif, r3
++/* [0x00000778] */ 0x0c9e70c0, 0x10020827, // add r0, r0, r3
++/* [0x00000780] */ 0x149dc1c0, 0xd00214e7, // and rb_x_next, r0, ~3
++/* [0x00000788] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000790] */ 0x0c9d3e80, 0x100206a7, // add ra_frame_base_next, rb_x_next, r2
++/* [0x00000798] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x000007a0] */ 0x00000010, 0xe00208a7, // mov r2, 16
++/* [0x000007a8] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x000007b0] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
++/* [0x000007b8] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x000007c0] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x000007c8] */ 0x0c9c11c0, 0xd0021467, // add rb17, r0, 1
++/* [0x000007d0] */ 0x0c9c31c0, 0xd00214a7, // add rb18, r0, 3
++/* [0x000007d8] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x000007e0] */ 0x119cd1c0, 0xd00208e7, // shl r3, r0, 13
++/* [0x000007e8] */ 0x119c87c0, 0xd00208e7, // shl r3, r3, 8
++/* [0x000007f0] */ 0x0e9c87c0, 0xd00208e7, // shr r3, r3, 8
++/* [0x000007f8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000800] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
++/* [0x00000808] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000810] */ 0x0c9d57c0, 0x10020c67, // add vr_setup, r3, rb21
++/* [0x00000818] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000820] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000828] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000830] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000838] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
++/* [0x00000840] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000848] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
++/* [0x00000850] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000858] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000860] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000868] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000870] */ 0xfffffff8, 0xe0021967, // mov r5rep, -8
++/* [0x00000878] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x00000880] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :uvloop_b
+-/* [0x000008e0] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
+-/* [0x000008e8] */ 0x8e4539bf, 0xa0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
+-/* [0x000008f0] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x000008f8] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000900] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
+-/* [0x00000908] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000910] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000918] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+-/* [0x00000920] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+-/* [0x00000928] */ 0x0c627c80, 0x10020e27, // add t0s, ra_frame_base, r2
+-/* [0x00000930] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000938] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000940] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000948] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000950] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000958] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000960] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000968] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000970] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00000978] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00000980] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
+-/* [0x00000988] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x00000990] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00000998] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x000009a0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x000009a8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x000009b0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000009b8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000009c0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000009c8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000009d0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000009d8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000009e0] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
+-/* [0x000009e8] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
+-/* [0x000009f0] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
+-/* [0x000009f8] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00000a00] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00000a08] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00000a10] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00000a18] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a20] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+-/* [0x00000a28] */ 0x00000010, 0xe0020827, // mov r0, 16
+-/* [0x00000a30] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
+-/* [0x00000a38] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00000a40] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
+-/* [0x00000a48] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00000a50] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00000888] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0
++/* [0x00000890] */ 0x8e4539bf, 0xb0029810, // shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1
++/* [0x00000898] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x000008a0] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x000008a8] */ 0xee454987, 0x10024860, // shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20
++/* [0x000008b0] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x000008b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000008c0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1         ; mul24 r2, r2, r3
++/* [0x000008c8] */ 0xec414c8f, 0x10024e21, // add t0s, ra_x, r2    ; v8subs r1, r1, rb20
++/* [0x000008d0] */ 0x0c627c80, 0x10020f27, // add t1s, ra_frame_base, r2
++/* [0x000008d8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000008e0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000008e8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000008f0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000008f8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x00000900] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00000908] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00000910] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00000918] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00000920] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00000928] */ 0x8d3447f6, 0xd00279cc, // sub.setf -, r3, 4    ; mov ra12, ra13
++/* [0x00000930] */ 0xffffff38, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x00000938] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00000940] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00000948] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x00000950] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x00000958] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x00000960] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x00000968] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x00000970] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x00000978] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x00000980] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00000988] */ 0x0cc27380, 0x10020867, // add r1, r1, vpm
++/* [0x00000990] */ 0x0c7a7380, 0x10020867, // add r1, r1, ra30
++/* [0x00000998] */ 0xfffffed0, 0xf06809e7, // brr.anyn -, r:uvloop_b
++/* [0x000009a0] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
++/* [0x000009a8] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x000009b0] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x000009b8] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x000009c0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000009c8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x000009d0] */ 0x00000010, 0xe0020827, // mov r0, 16
++/* [0x000009d8] */ 0x159f2fc0, 0x100009e7, // mov -, vw_wait
++/* [0x000009e0] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x000009e8] */ 0x0c9dae00, 0x10021c67, // add vw_setup, rb26, r0
++/* [0x000009f0] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x000009f8] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_exit
+-/* [0x00000a58] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000a60] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
+-/* [0x00000a68] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a70] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a78] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a80] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000a88] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000a90] */ 0x009e7000, 0x100009e7, // nop        ; nop
+-/* [0x00000a98] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a00] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a08] */ 0x00000000, 0xe80009e7, // mov -,srel(0)
++/* [0x00000a10] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a18] */ 0x009e7000, 0xb00009e7, // ldtmu1
++/* [0x00000a20] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a28] */ 0x009e7000, 0xb00009e7, // ldtmu1
++/* [0x00000a30] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000a38] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a40] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_interrupt_exit8
+-/* [0x00000aa0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00000aa8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ab0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ab8] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ac0] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00000ac8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ad0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ad8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ae0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000ae8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000af0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000af8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00000b00] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x00000b08] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x00000b10] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00000a48] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00000a50] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a58] */ 0x009e7000, 0xb00009e7, // ldtmu1
++/* [0x00000a60] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00000a68] */ 0x009e7000, 0xb00009e7, // ldtmu1
++/* [0x00000a70] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a78] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a80] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a88] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a90] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000a98] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000aa0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00000aa8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00000ab0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00000ab8] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_setup
+-/* [0x00000b18] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000b20] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00000b28] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000b30] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000b38] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00000b40] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000b48] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
+-/* [0x00000b50] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00000b58] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+-/* [0x00000b60] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x00000b68] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000b70] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+-/* [0x00000b78] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
+-/* [0x00000b80] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000b88] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000b90] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00000b98] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+-/* [0x00000ba0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
+-/* [0x00000ba8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00000bb0] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
+-/* [0x00000bb8] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
+-/* [0x00000bc0] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000bc8] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
+-/* [0x00000bd0] */ 0x8c9e7452, 0x10025e19, // add t0s, r2, r1 ; mov ra_frame_base2, r2
+-/* [0x00000bd8] */ 0x0d801dc0, 0xd0021667, // sub rb25,unif,1
+-/* [0x00000be0] */ 0x0d801dc0, 0xd00217a7, // sub rb30,unif,1
+-/* [0x00000be8] */ 0x15827d80, 0x10021427, // mov rb16, unif
+-/* [0x00000bf0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000bf8] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
+-/* [0x00000c00] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
+-/* [0x00000c08] */ 0x00000001, 0xe0020527, // mov ra20, 1
+-/* [0x00000c10] */ 0x00000100, 0xe00205a7, // mov ra22, 256
+-/* [0x00000c18] */ 0x00000040, 0xe00207a7, // mov ra30, 64
+-/* [0x00000c20] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
+-/* [0x00000c28] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
+-/* [0x00000c30] */ 0x00000018, 0xe00215e7, // mov rb23, 24
+-/* [0x00000c38] */ 0x00000000, 0xe0020227, // mov ra8, 0
+-/* [0x00000c40] */ 0x00000000, 0xe0020267, // mov ra9, 0
+-/* [0x00000c48] */ 0x00000000, 0xe00202a7, // mov ra10, 0
+-/* [0x00000c50] */ 0x00000000, 0xe00202e7, // mov ra11, 0
+-/* [0x00000c58] */ 0x00000000, 0xe0020327, // mov ra12, 0
+-/* [0x00000c60] */ 0x00000000, 0xe0020367, // mov ra13, 0
+-/* [0x00000c68] */ 0x00000000, 0xe00203a7, // mov ra14, 0
+-/* [0x00000c70] */ 0x00000000, 0xe00203e7, // mov ra15, 0
+-/* [0x00000c78] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00000c80] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000c88] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000c90] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000c98] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000ca0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000ca8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000cb0] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
+-/* [0x00000cb8] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
+-/* [0x00000cc0] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
+-/* [0x00000cc8] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
+-/* [0x00000cd0] */ 0x159e7480, 0x10020867, // mov r1, r2
+-/* [0x00000cd8] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
+-/* [0x00000ce0] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
+-/* [0x00000ce8] */ 0x159e7480, 0x10020827, // mov r0, r2
+-/* [0x00000cf0] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
+-/* [0x00000cf8] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000d00] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
+-/* [0x00000d08] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
+-/* [0x00000d10] */ 0x15827d80, 0x10021327, // mov rb12,unif
+-/* [0x00000d18] */ 0x15827d80, 0x10021367, // mov rb13,unif
+-/* [0x00000d20] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000d28] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
+-/* [0x00000d30] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000d38] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
+-/* [0x00000d40] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000d48] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
+-/* [0x00000d50] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
+-/* [0x00000d58] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+-/* [0x00000d60] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00000ac0] */ 0x00000010, 0xe00208e7, // mov r3, 16
++/* [0x00000ac8] */ 0x15827d80, 0x10020227, // mov ra8, unif
++/* [0x00000ad0] */ 0x15827d80, 0x10020267, // mov ra9, unif
++/* [0x00000ad8] */ 0x15827d80, 0x100202a7, // mov ra10, unif
++/* [0x00000ae0] */ 0x15827d80, 0x100202e7, // mov ra11, unif
++/* [0x00000ae8] */ 0x15827d80, 0x10020867, // mov r1, unif
++/* [0x00000af0] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
++/* [0x00000af8] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
++/* [0x00000b00] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
++/* [0x00000b08] */ 0x0d9c13c0, 0xd0021667, // sub rb_frame_width_minus_1,r1,1
++/* [0x00000b10] */ 0x0d9c11c0, 0xd00217a7, // sub rb_frame_height_minus_1,r0,1
++/* [0x00000b18] */ 0x15827d80, 0x10021427, // mov rb_pitch, unif
++/* [0x00000b20] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000b28] */ 0xc0000000, 0xe0020867, // mov r1, vdw_setup_1(0)
++/* [0x00000b30] */ 0x0c9e7200, 0x10021627, // add rb24, r1, r0
++/* [0x00000b38] */ 0x15227d80, 0x10020867, // mov r1, ra8
++/* [0x00000b40] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
++/* [0x00000b48] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
++/* [0x00000b50] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
++/* [0x00000b58] */ 0x0c9a7180, 0x10020827, // add r0, r0, elem_num
++/* [0x00000b60] */ 0x139c01c0, 0xd0020827, // max r0, r0, 0
++/* [0x00000b68] */ 0x922591f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, ra9
++/* [0x00000b70] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000b78] */ 0x0c9c13c0, 0xd0020767, // add ra_y, r1, 1
++/* [0x00000b80] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000b88] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
++/* [0x00000b90] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x00000b98] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000ba0] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
++/* [0x00000ba8] */ 0x8c9e7452, 0x10025e18, // add t0s, r2, r1 ; mov ra_frame_base, r2
++/* [0x00000bb0] */ 0x152a7d80, 0x10020867, // mov r1, ra10
++/* [0x00000bb8] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
++/* [0x00000bc0] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
++/* [0x00000bc8] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
++/* [0x00000bd0] */ 0x0c9a7180, 0x10020827, // add r0, r0, elem_num
++/* [0x00000bd8] */ 0x139c01c0, 0xd0020827, // max r0, r0, 0
++/* [0x00000be0] */ 0x922d91f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, ra11
++/* [0x00000be8] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
++/* [0x00000bf0] */ 0x0c9c13c0, 0xd0020567, // add ra_y2, r1, 1
++/* [0x00000bf8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000c00] */ 0x0c9e7400, 0x100208a7, // add r2, r2, r0
++/* [0x00000c08] */ 0x139c03c0, 0xd0020867, // max r1, r1, 0
++/* [0x00000c10] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000c18] */ 0x409d000f, 0x100049e1, // nop             ; mul24 r1, r1, rb_pitch
++/* [0x00000c20] */ 0x8c9e7452, 0x10025f19, // add t1s, r2, r1 ; mov ra_frame_base2, r2
++/* [0x00000c28] */ 0x00000001, 0xe0020527, // mov ra20, 1
++/* [0x00000c30] */ 0x00000100, 0xe00205a7, // mov ra22, 256
++/* [0x00000c38] */ 0x00000040, 0xe00207a7, // mov ra30, 64
++/* [0x00000c40] */ 0xffffff00, 0xe0021527, // mov rb20, 0xffffff00
++/* [0x00000c48] */ 0x000000ff, 0xe00215a7, // mov rb22, 255
++/* [0x00000c50] */ 0x00000018, 0xe00215e7, // mov rb23, 24
++/* [0x00000c58] */ 0x00000000, 0xe0020227, // mov ra8, 0
++/* [0x00000c60] */ 0x00000000, 0xe0020267, // mov ra9, 0
++/* [0x00000c68] */ 0x00000000, 0xe00202a7, // mov ra10, 0
++/* [0x00000c70] */ 0x00000000, 0xe00202e7, // mov ra11, 0
++/* [0x00000c78] */ 0x00000000, 0xe0020327, // mov ra12, 0
++/* [0x00000c80] */ 0x00000000, 0xe0020367, // mov ra13, 0
++/* [0x00000c88] */ 0x00000000, 0xe00203a7, // mov ra14, 0
++/* [0x00000c90] */ 0x00000000, 0xe00203e7, // mov ra15, 0
++/* [0x00000c98] */ 0x00004000, 0xe00204a7, // mov ra18, 0x4000
++/* [0x00000ca0] */ 0x159e6fc0, 0x100208a7, // mov r2, qpu_num
++/* [0x00000ca8] */ 0x159e7480, 0x10020867, // mov r1, r2
++/* [0x00000cb0] */ 0x0f9c23c0, 0xd0020867, // asr r1, r1, 2
++/* [0x00000cb8] */ 0x119c63c0, 0xd0020867, // shl r1, r1, 6
++/* [0x00000cc0] */ 0x159e7480, 0x10020827, // mov r0, r2
++/* [0x00000cc8] */ 0x149c31c0, 0xd0020827, // and r0, r0, 3
++/* [0x00000cd0] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000cd8] */ 0x00004800, 0xe0020867, // mov r1, vpm_setup(0, 4, h8p(0, 0))
++/* [0x00000ce0] */ 0x0c9e7040, 0x10021727, // add rb28, r0, r1
++/* [0x00000ce8] */ 0x80004004, 0xe0020867, // mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0))
++/* [0x00000cf0] */ 0x119c51c0, 0xd0020827, // shl r0, r0, 5
++/* [0x00000cf8] */ 0x0c9e7040, 0x100216e7, // add rb27, r0, r1
++/* [0x00000d00] */ 0x15827d80, 0x10020867, // mov r1, unif
++/* [0x00000d08] */ 0x919c82ff, 0xd0024822, // shl r0,r1,r3 ; mov r2,8
++/* [0x00000d10] */ 0x0f9e70c0, 0x10021367, // asr rb13,r0,r3
++/* [0x00000d18] */ 0x0f9e72c0, 0x10021327, // asr rb12,r1,r3
++/* [0x00000d20] */ 0x0c9cde80, 0x10021367, // add rb13,rb13,r2
++/* [0x00000d28] */ 0x119cce80, 0x10021327, // shl rb12, rb12, r2
++/* [0x00000d30] */ 0x13740dc0, 0xd0020867, // max r1, ra_y, 0
++/* [0x00000d38] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
++/* [0x00000d40] */ 0x0c741dc0, 0xd0020767, // add ra_y, ra_y, 1
++/* [0x00000d48] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
++/* [0x00000d50] */ 0x0c627380, 0x10020e27, // add t0s, r1, ra_frame_base
++/* [0x00000d58] */ 0x13540dc0, 0xd0020867, // max r1, ra_y2, 0
++/* [0x00000d60] */ 0x129de3c0, 0x10020867, // min r1, r1, rb_frame_height_minus_1
+ /* [0x00000d68] */ 0x0c541dc0, 0xd0020567, // add ra_y2, ra_y2, 1
+ /* [0x00000d70] */ 0x409d000f, 0x100049e1, // nop ; mul24 r1, r1, rb_pitch
+-/* [0x00000d78] */ 0x0c667380, 0x10020e27, // add t0s, r1, ra_frame_base2
+-// ::mc_filter
++/* [0x00000d78] */ 0x0c667380, 0x10020f27, // add t1s, r1, ra_frame_base2
++// :per_block_setup
+ /* [0x00000d80] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ /* [0x00000d88] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+ /* [0x00000d90] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+ /* [0x00000d98] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
+-/* [0x00000da0] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000da8] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00000db0] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00000db8] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00000dc0] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00000dc8] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00000dd0] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
+-/* [0x00000dd8] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00000de0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
+-/* [0x00000de8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00000df0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+-/* [0x00000df8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
+-/* [0x00000e00] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00000e08] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
+-/* [0x00000e10] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x00000e18] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x00000e20] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000e28] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x00000e30] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x00000e38] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00000e40] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00000e48] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00000e50] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00000e58] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00000e60] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000e68] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00000e70] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000e78] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000e80] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000e88] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000e90] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000e98] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00000ea0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000ea8] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000eb0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000eb8] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ec0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x00000ec8] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000ed0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000ed8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x00000ee0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000ee8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x00000ef0] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000ef8] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f00] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00000f08] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000da0] */ 0x00000010, 0xe00208e7, // mov r3, 16
++/* [0x00000da8] */ 0x15827d80, 0x10020867, // mov r1, unif
++/* [0x00000db0] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
++/* [0x00000db8] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
++/* [0x00000dc0] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
++/* [0x00000dc8] */ 0x0c9a7180, 0x10020827, // add r0, r0, elem_num
++/* [0x00000dd0] */ 0x139c01c0, 0xd0020827, // max r0, r0, 0
++/* [0x00000dd8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000de0] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
++/* [0x00000de8] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
++/* [0x00000df0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000df8] */ 0x8c827436, 0x100246a1, // add ra_frame_base_next, r2, r0 ; mov r1, unif
++/* [0x00000e00] */ 0x119e72c0, 0x10020827, // shl r0,r1,r3
++/* [0x00000e08] */ 0x0f9e72c0, 0x10020867, // asr r1,r1,r3
++/* [0x00000e10] */ 0x0f9e70c0, 0x10020827, // asr r0,r0,r3
++/* [0x00000e18] */ 0x0c9a7180, 0x10020827, // add r0, r0, elem_num
++/* [0x00000e20] */ 0x139c01c0, 0xd0020827, // max r0, r0, 0
++/* [0x00000e28] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
++/* [0x00000e30] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
++/* [0x00000e38] */ 0x159e7240, 0x10021067, // mov ra_y2_next, r1
++/* [0x00000e40] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
++/* [0x00000e48] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
++/* [0x00000e50] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
++/* [0x00000e58] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00000e60] */ 0x0e9e70c0, 0x10020867, // shr r1, r0, r3
++/* [0x00000e68] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
++/* [0x00000e70] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
++/* [0x00000e78] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
++/* [0x00000e80] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
++/* [0x00000e88] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
++/* [0x00000e90] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
++/* [0x00000e98] */ 0x119e70c0, 0x10020827, // shl r0, r0, r3
++/* [0x00000ea0] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
++/* [0x00000ea8] */ 0x95801dbf, 0xd0024821, // mov r0, unif ; mov r1,1
++/* [0x00000eb0] */ 0x4f5971c6, 0x10024260, // asr ra9, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000eb8] */ 0x4f5971c6, 0x10024220, // asr ra8, r0, rb23;      mul24 r0, r0, ra22
++/* [0x00000ec0] */ 0x4f5971c6, 0x10044260, // asr.ifz ra9, r0, rb23;  mul24 r0, r0, ra22
++/* [0x00000ec8] */ 0x0f9d71c0, 0x10040227, // asr.ifz ra8, r0, rb23
++/* [0x00000ed0] */ 0x0d243f80, 0xd0020267, // sub ra9,3,ra9
++/* [0x00000ed8] */ 0x0d203f80, 0xd0020227, // sub ra8,3,ra8
++/* [0x00000ee0] */ 0x11243dc0, 0xd0020267, // shl ra9,ra9,3
++/* [0x00000ee8] */ 0x11203dc0, 0xd0020227, // shl ra8,ra8,3
++/* [0x00000ef0] */ 0x00ffff00, 0xe0020867, // mov r1,0xffff00
++/* [0x00000ef8] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
++/* [0x00000f00] */ 0x0f9d71c0, 0x10020027, // asr ra0, r0, rb23
++/* [0x00000f08] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
+ /* [0x00000f10] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
+-/* [0x00000f18] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00000f20] */ 0x15827d80, 0x100009e7, // mov.ifnz -, unif
+-/* [0x00000f28] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+-/* [0x00000f30] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00000f38] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+-/* [0x00000f40] */ 0x00000000, 0xe00208e7, // mov r3, 0
++/* [0x00000f18] */ 0x01040400, 0xe0020867, // mov r1,0x1040400
++/* [0x00000f20] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
++/* [0x00000f28] */ 0x0f9d71c0, 0x10020067, // asr ra1, r0, rb23
++/* [0x00000f30] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
++/* [0x00000f38] */ 0x0f9d71c0, 0x10021167, // asr rb5, r0, rb23
++/* [0x00000f40] */ 0xfbf5f600, 0xe0020867, // mov r1,0xfbf5f600
++/* [0x00000f48] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
++/* [0x00000f50] */ 0x0f9d71c0, 0x100200a7, // asr ra2, r0, rb23
++/* [0x00000f58] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
++/* [0x00000f60] */ 0x0f9d71c0, 0x100211a7, // asr rb6, r0, rb23
++/* [0x00000f68] */ 0x11283a40, 0xe0020867, // mov r1,0x11283a40
++/* [0x00000f70] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
++/* [0x00000f78] */ 0x0f9d71c0, 0x100200e7, // asr ra3, r0, rb23
++/* [0x00000f80] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
++/* [0x00000f88] */ 0x0f9d71c0, 0x100211e7, // asr rb7, r0, rb23
++/* [0x00000f90] */ 0x3a281100, 0xe0020867, // mov r1,0x3a281100
++/* [0x00000f98] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
++/* [0x00000fa0] */ 0x0f9d71c0, 0x10020127, // asr ra4, r0, rb23
++/* [0x00000fa8] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
++/* [0x00000fb0] */ 0x0f9d71c0, 0x10021227, // asr rb8, r0, rb23
++/* [0x00000fb8] */ 0xf6f5fb00, 0xe0020867, // mov r1,0xf6f5fb00
++/* [0x00000fc0] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
++/* [0x00000fc8] */ 0x0f9d71c0, 0x10020167, // asr ra5, r0, rb23
++/* [0x00000fd0] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
++/* [0x00000fd8] */ 0x0f9d71c0, 0x10021267, // asr rb9, r0, rb23
++/* [0x00000fe0] */ 0x04040100, 0xe0020867, // mov r1,0x4040100
++/* [0x00000fe8] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
++/* [0x00000ff0] */ 0x0f9d71c0, 0x100201a7, // asr ra6, r0, rb23
++/* [0x00000ff8] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
++/* [0x00001000] */ 0x0f9d71c0, 0x100212a7, // asr rb10, r0, rb23
++/* [0x00001008] */ 0xffff0000, 0xe0020867, // mov r1,0xffff0000
++/* [0x00001010] */ 0x11227380, 0x10020827, // shl r0, r1, ra8
++/* [0x00001018] */ 0x0f9d71c0, 0x100201e7, // asr ra7, r0, rb23
++/* [0x00001020] */ 0x11267380, 0x10020827, // shl r0, r1, ra9
++/* [0x00001028] */ 0x0f9d71c0, 0x100212e7, // asr rb11, r0, rb23
++/* [0x00001030] */ 0x15827d80, 0x10020827, // mov r0, unif
++/* [0x00001038] */ 0x0f9e70c0, 0x100213e7, // asr rb15, r0, r3
++/* [0x00001040] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
++/* [0x00001048] */ 0x119e70c0, 0x10020827, // shl r0, r0, r3
++/* [0x00001050] */ 0x8f9c00ff, 0xd0024823, // asr r0, r0, r3 ; mov r3, 0
++/* [0x00001058] */ 0x119c81c0, 0xd00213a7, // shl rb14, r0, 8
++// ::mc_filter
+ // :yloop
+-/* [0x00000f48] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+-/* [0x00000f50] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+-/* [0x00000f58] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x00000f60] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00000f68] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+-/* [0x00000f70] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+-/* [0x00000f78] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00000f80] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000f88] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+-/* [0x00000f90] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+-/* [0x00000f98] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+-/* [0x00000fa0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00000fa8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+-/* [0x00000fb0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+-/* [0x00000fb8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00000fc0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x00000fc8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x00000fd0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x00000fd8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x00000fe0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x00000fe8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x00000ff0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x00000ff8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00001000] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00001008] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00001010] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00001018] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00001020] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00001028] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00001030] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00001038] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00001040] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00001048] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
+-/* [0x00001050] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00001058] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00001060] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00001068] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00001070] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
+-/* [0x00001078] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00001080] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00001088] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00001090] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00001098] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000010a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000010a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000010b0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+-/* [0x000010b8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+-/* [0x000010c0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+-/* [0x000010c8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+-/* [0x000010d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000010d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000010e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000010e8] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
+-/* [0x000010f0] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
+-/* [0x000010f8] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
+-/* [0x00001100] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
+-/* [0x00001108] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
+-/* [0x00001110] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00001118] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00001120] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001128] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00001130] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00001138] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00001060] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++/* [0x00001068] */ 0x8e4539bf, 0xb0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu1
++/* [0x00001070] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00001078] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00001080] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
++/* [0x00001088] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
++/* [0x00001090] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00001098] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000010a0] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++/* [0x000010a8] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
++/* [0x000010b0] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
++/* [0x000010b8] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000010c0] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++/* [0x000010c8] */ 0xec654c8f, 0x10024f21, // add t1s, ra_frame_base2, r2   ; v8subs r1, r1, rb20
++/* [0x000010d0] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000010d8] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000010e0] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000010e8] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000010f0] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000010f8] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x00001100] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00001108] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00001110] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00001118] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00001120] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00001128] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00001130] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00001138] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00001140] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00001148] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00001150] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00001158] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00001160] */ 0x8d2487f6, 0xd00279c8, // sub.setf -, r3, 8    ; mov ra8, ra9
++/* [0x00001168] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00001170] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00001178] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00001180] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00001188] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloop
++/* [0x00001190] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00001198] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x000011a0] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000011a8] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000011b0] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000011b8] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000011c0] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000011c8] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
++/* [0x000011d0] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
++/* [0x000011d8] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
++/* [0x000011e0] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
++/* [0x000011e8] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000011f0] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000011f8] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
++/* [0x00001200] */ 0x409ce00f, 0x100049e1, // nop                     ; mul24 r1, r1, rb14
++/* [0x00001208] */ 0x0c9cc3c0, 0x10020867, // add r1, r1, rb12
++/* [0x00001210] */ 0x0f9cd3c0, 0x10020867, // asr r1, r1, rb13
++/* [0x00001218] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloop
++/* [0x00001220] */ 0x0c9cf3c0, 0x10020867, // add r1, r1, rb15
++/* [0x00001228] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00001230] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00001238] */ 0xfffffb28, 0xf0f809e7, // brr -, r:per_block_setup
++/* [0x00001240] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00001248] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001250] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_filter_b
+-/* [0x00001140] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x00001148] */ 0x15827d80, 0x100207e7, // mov ra31, unif
+-/* [0x00001150] */ 0x154e7d80, 0x10020467, // mov ra_xshift, ra_xshift_next
+-/* [0x00001158] */ 0x155e7d80, 0x10021027, // mov rx_xshift2, rx_xshift2_next
+-/* [0x00001160] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x00001168] */ 0x938001f6, 0xd0024821, // max r0, r0, 0; mov r1, unif
+-/* [0x00001170] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x00001178] */ 0x119c31c0, 0xd00204e7, // shl ra_xshift_next, r0, 3
+-/* [0x00001180] */ 0x159e7240, 0x10020727, // mov ra_y_next, r1
+-/* [0x00001188] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x00001190] */ 0x0c9e7400, 0x100206a7, // add ra_frame_base_next, r2, r0
+-/* [0x00001198] */ 0x0c9a0f80, 0x10020827, // add r0, unif, elem_num
+-/* [0x000011a0] */ 0x938001f6, 0xd0024821, // max r0, r0, 0   ; mov r1, unif
+-/* [0x000011a8] */ 0x928191f6, 0x10024822, // min r0, r0, rb_frame_width_minus_1 ; mov r2, unif
+-/* [0x000011b0] */ 0x119c31c0, 0xd00205e7, // shl rx_xshift2_next, r0, 3
+-/* [0x000011b8] */ 0x0c9c13c0, 0xd0021067, // add ra_y2_next, r1, 1
+-/* [0x000011c0] */ 0x149dc1c0, 0xd0020827, // and r0, r0, ~3
+-/* [0x000011c8] */ 0x0c9e7400, 0x100214e7, // add rx_frame_base2_next, r2, r0
+-/* [0x000011d0] */ 0x159dcfc0, 0x10021c67, // mov vw_setup, rb28
+-/* [0x000011d8] */ 0x00000010, 0xe00208a7, // mov r2, 16
+-/* [0x000011e0] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x000011e8] */ 0x0e9e7080, 0x10020867, // shr r1, r0, r2
+-/* [0x000011f0] */ 0x0d9d8e40, 0x10021767, // sub rb29, rb24, r1
+-/* [0x000011f8] */ 0x149d61c0, 0x10020827, // and r0, r0, rb22
+-/* [0x00001200] */ 0x0c9c51c0, 0xd0021467, // add rb17, r0, 5
+-/* [0x00001208] */ 0x0c9c71c0, 0xd00214a7, // add rb18, r0, 7
+-/* [0x00001210] */ 0x119c71c0, 0xd0020827, // shl r0, r0, 7
+-/* [0x00001218] */ 0x0c9e7040, 0x10020827, // add r0, r0, r1
+-/* [0x00001220] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00001228] */ 0x0c9db1c0, 0x100216a7, // add rb26, r0, rb27
+-/* [0x00001230] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001238] */ 0x00000001, 0xe0020867, // mov r1, 1
+-/* [0x00001240] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x00001248] */ 0x409f3001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 13, r1 << 13
+-/* [0x00001250] */ 0x4f5971c6, 0x100240e0, // asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001258] */ 0x409f2001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 14, r1 << 14
+-/* [0x00001260] */ 0x4f5971c6, 0x100240a0, // asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001268] */ 0x409f1001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 15, r1 << 15
+-/* [0x00001270] */ 0x4f5971c6, 0x10024060, // asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001278] */ 0x8f8171f6, 0x10024020, // asr ra0, r0, rb23;      mov r0, unif
+-/* [0x00001280] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x00001288] */ 0x409f7001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 9, r1 << 9
+-/* [0x00001290] */ 0x4f5971c6, 0x100241e0, // asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001298] */ 0x409f6001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 10, r1 << 10
+-/* [0x000012a0] */ 0x4f5971c6, 0x100241a0, // asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000012a8] */ 0x409f5001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 11, r1 << 11
+-/* [0x000012b0] */ 0x4f5971c6, 0x10024160, // asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000012b8] */ 0x409f4001, 0xd00049e0, // nop              ;      mul24 r0, r0 << 12, r1 << 12
+-/* [0x000012c0] */ 0x8f8171f6, 0x10024120, // asr ra4, r0, rb23;      mov r0, unif
+-/* [0x000012c8] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x000012d0] */ 0x4f5971c6, 0x100252e0, // asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000012d8] */ 0x4f5971c6, 0x100252a0, // asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-/* [0x000012e0] */ 0x4f5971c6, 0x10025260, // asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x000012e8] */ 0x8f8171f6, 0x10025220, // asr rb8, r0, rb23;      mov r0, unif
+-/* [0x000012f0] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x000012f8] */ 0x4f5971c6, 0x100251e0, // asr rb7, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001300] */ 0x4f5971c6, 0x100251a0, // asr rb6, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001308] */ 0x4f5971c6, 0x10025160, // asr rb5, r0, rb23;      mul24 r0, r0, ra22
+-/* [0x00001310] */ 0x0f9d71c0, 0x10021127, // asr rb4, r0, rb23
+-/* [0x00001318] */ 0x15827d80, 0x10020827, // mov r0, unif
+-/* [0x00001320] */ 0x15827d80, 0x10060827, // mov.ifnz r0, unif
+-/* [0x00001328] */ 0x0f9e7080, 0x100213e7, // asr rb15, r0, r2
+-/* [0x00001330] */ 0x119e7080, 0x10020827, // shl r0, r0, r2
+-/* [0x00001338] */ 0x0f9e7080, 0x100213a7, // asr rb14, r0, r2
+-/* [0x00001340] */ 0x00000000, 0xe00208e7, // mov r3, 0
+ // :yloopb
+-/* [0x00001348] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+-/* [0x00001350] */ 0x8e4539bf, 0xa0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+-/* [0x00001358] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-/* [0x00001360] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-/* [0x00001368] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
+-/* [0x00001370] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
+-/* [0x00001378] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
+-/* [0x00001380] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x00001388] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+-/* [0x00001390] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
+-/* [0x00001398] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
+-/* [0x000013a0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
+-/* [0x000013a8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+-/* [0x000013b0] */ 0xec654c87, 0x10024e20, // add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
+-/* [0x000013b8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-/* [0x000013c0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
+-/* [0x000013c8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-/* [0x000013d0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-/* [0x000013d8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-/* [0x000013e0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-/* [0x000013e8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-/* [0x000013f0] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-/* [0x000013f8] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-/* [0x00001400] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-/* [0x00001408] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-/* [0x00001410] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-/* [0x00001418] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-/* [0x00001420] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-/* [0x00001428] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-/* [0x00001430] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-/* [0x00001438] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-/* [0x00001440] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
+-/* [0x00001448] */ 0x8d3487f6, 0xd00279cc, // sub.setf -, r3, 8    ; mov ra12, ra13
+-/* [0x00001450] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
+-/* [0x00001458] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
+-/* [0x00001460] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
+-/* [0x00001468] */ 0x15367d80, 0x10020327, // mov ra12, ra13
+-/* [0x00001470] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
+-/* [0x00001478] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
+-/* [0x00001480] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
+-/* [0x00001488] */ 0x159e7000, 0x100203e7, // mov ra15, r0
+-/* [0x00001490] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
+-/* [0x00001498] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
+-/* [0x000014a0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
+-/* [0x000014a8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
+-/* [0x000014b0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
+-/* [0x000014b8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
+-/* [0x000014c0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
+-/* [0x000014c8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
+-/* [0x000014d0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
+-/* [0x000014d8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-/* [0x000014e0] */ 0x0f9ce3c0, 0xd0020867, // asr r1, r1, 14
+-/* [0x000014e8] */ 0x4053800e, 0xd00049e1, // nop                     ; mul24 r1, r1 << 8, ra20 << 8
+-/* [0x000014f0] */ 0x4c78e38f, 0x10024860, // add r1, r1, ra30        ; mul24 r0, r1, rb14
+-/* [0x000014f8] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
+-/* [0x00001500] */ 0xfffffe28, 0xf06809e7, // brr.anyn -, r:yloopb
+-/* [0x00001508] */ 0x0f9c73c0, 0xd0020867, // asr r1, r1, 7
+-/* [0x00001510] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
+-/* [0x00001518] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
+-/* [0x00001520] */ 0x00000000, 0xf0f7e9e7, // bra -, ra31
+-/* [0x00001528] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
+-/* [0x00001530] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
+-/* [0x00001538] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
++/* [0x00001258] */ 0xcd5117de, 0xa00269e3, // sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++/* [0x00001260] */ 0x8e4539bf, 0xb0029819, // shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu1
++/* [0x00001268] */ 0x956a7d9b, 0x1004461f, // mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++/* [0x00001270] */ 0x95710dbf, 0x10044763, // mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++/* [0x00001278] */ 0x0e9c09c0, 0x10020867, // shr r1, r4, rx_xshift2
++/* [0x00001280] */ 0x159c1fc0, 0x10040567, // mov.ifz ra_y2, ra_y2_next
++/* [0x00001288] */ 0x13740dc0, 0xd00208a7, // max r2, ra_y, 0
++/* [0x00001290] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x00001298] */ 0x4c741dd3, 0xd0024762, // add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++/* [0x000012a0] */ 0xec614c87, 0x10024e20, // add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20
++/* [0x000012a8] */ 0x13540dc0, 0xd00208a7, // max r2, ra_y2, 0
++/* [0x000012b0] */ 0x129de5c0, 0x100208a7, // min r2, r2, rb_frame_height_minus_1
++/* [0x000012b8] */ 0x4c541dd3, 0xd0024562, // add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++/* [0x000012c0] */ 0xec654c8f, 0x10024f21, // add t1s, ra_frame_base2, r2   ; v8subs r1, r1, rb20
++/* [0x000012c8] */ 0x0000ff00, 0xe20229e7, // mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++/* [0x000012d0] */ 0x40027006, 0x100049e2, // nop                  ; mul24 r2, r0, ra0
++/* [0x000012d8] */ 0x40038031, 0xd000c9e2, // nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++/* [0x000012e0] */ 0x4007f030, 0xd00049e3, // nop                  ; mul24      r3, ra1 << 1, r0 << 1
++/* [0x000012e8] */ 0x40077031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++/* [0x000012f0] */ 0x4c0be4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++/* [0x000012f8] */ 0x400b6031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++/* [0x00001300] */ 0x4c0fd4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++/* [0x00001308] */ 0x400f5031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++/* [0x00001310] */ 0x4c13c4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++/* [0x00001318] */ 0x40134031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++/* [0x00001320] */ 0x4c17b4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++/* [0x00001328] */ 0x40173031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++/* [0x00001330] */ 0x4c1ba4f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++/* [0x00001338] */ 0x401b2031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++/* [0x00001340] */ 0x4c1f94f0, 0xd00248a3, // add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++/* [0x00001348] */ 0x401f1031, 0xd000c9e3, // nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++/* [0x00001350] */ 0x8c9df4ff, 0x10024823, // add r0, r2, r3       ; mov r3, rb31
++/* [0x00001358] */ 0x8d2487f6, 0xd00279c8, // sub.setf -, r3, 8    ; mov ra8, ra9
++/* [0x00001360] */ 0x152a7d80, 0x10020267, // mov ra9, ra10
++/* [0x00001368] */ 0x152e7d80, 0x100202a7, // mov ra10, ra11
++/* [0x00001370] */ 0x15327d80, 0x100202e7, // mov ra11, ra12
++/* [0x00001378] */ 0x15367d80, 0x10020327, // mov ra12, ra13
++/* [0x00001380] */ 0xfffffeb8, 0xf06809e7, // brr.anyn -, r:yloopb
++/* [0x00001388] */ 0x153a7d80, 0x10020367, // mov ra13, ra14
++/* [0x00001390] */ 0x153e7d80, 0x100203a7, // mov ra14, ra15
++/* [0x00001398] */ 0x159e7000, 0x100203e7, // mov ra15, r0
++/* [0x000013a0] */ 0x4038a037, 0x100049e1, // nop                     ; mul24 r1, ra14, rb10
++/* [0x000013a8] */ 0x40349037, 0x100049e0, // nop                     ; mul24 r0, ra13, rb9
++/* [0x000013b0] */ 0x4c308237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra12, rb8
++/* [0x000013b8] */ 0x4c3cb237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra15, rb11
++/* [0x000013c0] */ 0x4c204237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra8, rb4
++/* [0x000013c8] */ 0x4c245237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra9, rb5
++/* [0x000013d0] */ 0x4c286237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra10, rb6
++/* [0x000013d8] */ 0x4c2c7237, 0x10024860, // add r1, r1, r0          ; mul24 r0, ra11, rb7
++/* [0x000013e0] */ 0x8c9f223f, 0x10020867, // add r1, r1, r0          ; mov -, vw_wait
++/* [0x000013e8] */ 0x4d5927ce, 0x100269e1, // sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++/* [0x000013f0] */ 0x0f9ce3c0, 0xd0020827, // asr r0, r1, 14
++/* [0x000013f8] */ 0x0f9c63c0, 0xd0020867, // asr r1, r1, 6
++/* [0x00001400] */ 0x405b8006, 0xd00049e0, // nop                     ; mul24 r0, r0 << 8, ra22 << 8
++/* [0x00001408] */ 0x0c4a7380, 0x10020867, // add r1, r1, ra18
++/* [0x00001410] */ 0x0c9e7200, 0x10020867, // add r1, r1, r0
++/* [0x00001418] */ 0xfffffe20, 0xf06809e7, // brr.anyn -, r:yloopb
++/* [0x00001420] */ 0x0f9cf3c0, 0xd0020867, // asr r1, r1, 15
++/* [0x00001428] */ 0x129d63c0, 0x10020867, // min r1, r1, rb22
++/* [0x00001430] */ 0x139c03c0, 0xd0020c27, // max vpm, r1, 0
++/* [0x00001438] */ 0xfffff928, 0xf0f809e7, // brr -, r:per_block_setup
++/* [0x00001440] */ 0x159dafc0, 0x10021c67, // mov vw_setup, rb26
++/* [0x00001448] */ 0x159ddfc0, 0x10021c67, // mov vw_setup, rb29
++/* [0x00001450] */ 0x15827d80, 0x10021ca7, // mov vw_addr, unif
+ // ::mc_interrupt_exit12
+-/* [0x00001540] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
+-/* [0x00001548] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001550] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001558] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001560] */ 0x009e7000, 0xa00009e7, // ldtmu0
+-/* [0x00001568] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001570] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001578] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001580] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001588] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001590] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x00001598] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000015a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000015a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000015b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000015b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
+-/* [0x000015c0] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
+-/* [0x000015c8] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
+-/* [0x000015d0] */ 0x009e7000, 0x100009e7, // nop        ; nop
++/* [0x00001458] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x00001460] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001468] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001470] */ 0x009e7000, 0xb00009e7, // ldtmu1
++/* [0x00001478] */ 0x009e7000, 0xb00009e7, // ldtmu1
++/* [0x00001480] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001488] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001490] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x00001498] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000014a0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000014a8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000014b0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000014b8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000014c0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000014c8] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000014d0] */ 0x00000010, 0xe80009e7, // mov -,sacq(0)
++/* [0x000014d8] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x000014e0] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x000014e8] */ 0x009e7000, 0x100009e7, // nop        ; nop
++// ::mc_exit1
++/* [0x000014f0] */ 0x159f2fc0, 0x100009e7, // mov  -, vw_wait
++/* [0x000014f8] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001500] */ 0x009e7000, 0xb00009e7, // ldtmu1
++/* [0x00001508] */ 0x009e7000, 0xa00009e7, // ldtmu0
++/* [0x00001510] */ 0x009e7000, 0xb00009e7, // ldtmu1
++/* [0x00001518] */ 0x009e7000, 0x300009e7, // nop        ; nop ; thrend
++/* [0x00001520] */ 0x00000001, 0xe00209a7, // mov interrupt, 1; nop
++/* [0x00001528] */ 0x009e7000, 0x100009e7, // nop        ; nop
+ // ::mc_end
+ };
+ #ifdef __HIGHC__
+diff --git a/libavcodec/rpi_shader.h b/libavcodec/rpi_shader.h
+index 6e552d9..760bd17 100644
+--- a/libavcodec/rpi_shader.h
++++ b/libavcodec/rpi_shader.h
+@@ -4,15 +4,16 @@
+ extern unsigned int rpi_shader[];
+ 
+ #define mc_setup_uv (rpi_shader + 0)
+-#define mc_filter_uv (rpi_shader + 144)
+-#define mc_filter_uv_b0 (rpi_shader + 334)
+-#define mc_filter_uv_b (rpi_shader + 486)
+-#define mc_exit (rpi_shader + 662)
+-#define mc_interrupt_exit8 (rpi_shader + 680)
+-#define mc_setup (rpi_shader + 710)
+-#define mc_filter (rpi_shader + 864)
+-#define mc_filter_b (rpi_shader + 1104)
+-#define mc_interrupt_exit12 (rpi_shader + 1360)
+-#define mc_end (rpi_shader + 1398)
++#define mc_filter_uv (rpi_shader + 130)
++#define mc_filter_uv_b0 (rpi_shader + 312)
++#define mc_filter_uv_b (rpi_shader + 464)
++#define mc_exit (rpi_shader + 640)
++#define mc_interrupt_exit8 (rpi_shader + 658)
++#define mc_setup (rpi_shader + 688)
++#define mc_filter (rpi_shader + 1048)
++#define mc_filter_b (rpi_shader + 1174)
++#define mc_interrupt_exit12 (rpi_shader + 1302)
++#define mc_exit1 (rpi_shader + 1340)
++#define mc_end (rpi_shader + 1356)
+ 
+ #endif
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index a0b8e5a..60d1ec2 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -21,6 +21,7 @@
+ #
+ # ra16                                          clipped(row start address+elem_num)&~3
+ # ra17                                          per-channel shifts
++# ra18                                          0x4000
+ # ra19                                          next ra17
+ #
+ # rb16                                          pitch
+@@ -86,7 +87,7 @@
+ 
+ 
+ ################################################################################
+-# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, pad0, pad1, pad2)
++# mc_setup_uv(next_kernel, x, y, ref_u_base, ref_v_base, frame_width, frame_height, pitch, dst_pitch, offset, denom, vpm_id)
+ ::mc_setup_uv
+ 
+ # Read starting kernel
+@@ -132,36 +133,6 @@ mov ra13, 0
+ mov ra14, 0
+ mov ra15, 0
+ 
+-# Compute part of VPM to use for DMA output
+-mov r3, unif
+-shl r2, r3, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
+-and r2, r2, 15
+-mov r1, r2
+-asr r1, r1, 2
+-shl r1, r1, 6
+-mov r0, r2
+-and r0, r0, 3
+-add r0, r0, r1
+-mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+-shl r0, r0, 5
+-add rb27, r0, r1
+-
+-# Compute part of VPM to save data into
+-shl r2, r3, 1
+-and r2, r2, 15    # r2 = bcd0
+-mov r1, r2        # r1 = bcd0
+-asr r1, r1, 2     # r1 = bc
+-shl r1, r1, 6     # r1 = bc000000
+-mov r0, r2        # r0 = bcd0
+-and r0, r0, 3     # r0 = d0
+-add r0, r0, r1    # r0 = bc0000d0
+-mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
+-add rb28, r0, r1
+-asr r0, r0, 1     # r0 = bc0000d
+-# Prepare VPM command for 16bit intermediates
+-mov r1, vpm_setup(0, 2, h16p(0, 0))  # 2 is stride - stride acts on ADDR which is Y[5:0],H[0] for 16 bit
+-add rb21, r0, r1
+-
+ # Compute base address for first and second access
+ mov r0, ra_x           # Load x
+ max r0, r0, 0; mov r1, ra_y # Load y
+@@ -175,10 +146,31 @@ min r1, r1, rb_frame_height_minus_1
+ # submit texture requests for first line
+ add r2, r2, r0 ; mul24 r1, r1, rb_pitch
+ add t0s, r0, r1 ; mov ra_frame_base, r2
+-add t0s, r2, r1
++add t1s, r2, r1
++
++mov r2,8
++shl rb12,unif, r2 # offset before shift
++add rb13,unif,r2  # offset after shift
++
++# Compute part of VPM to use for DMA output
++mov r2, unif
++shl r2, r2, 1   # Convert QPU numbers to be even (this means we can only use 8 QPUs, but is necessary as we need to save 16bit intermediate results)
++and r2, r2, 15
++mov r1, r2
++asr r1, r1, 2
++shl r1, r1, 6
++mov r0, r2
++and r0, r0, 3
++add r0, r0, r1
+ 
+-mov rb12,unif # offset before shift
+-mov rb13,unif # offset after shift
++mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
++add rb28, r0, r1  # VPM 8bit storage
++asr r2, r0, 1     # r0 = bc0000d
++mov r1, vpm_setup(0, 2, h16p(0, 0))  # 2 is stride - stride acts on ADDR which is Y[5:0],H[0] for 16 bit
++add rb21, r2, r1  # VPM for 16bit intermediates
++mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
++shl r0, r0, 5
++add rb27, r0, r1  # DMA out
+ 
+ # submit texture requests for second line
+ max r1, ra_y, 0
+@@ -187,7 +179,7 @@ add ra_y, ra_y, 1
+ bra -, ra31
+ nop ; mul24 r1, r1, rb_pitch
+ add t0s, r1, ra_x
+-add t0s, r1, ra_frame_base
++add t1s, r1, ra_frame_base
+ 
+ 
+ 
+@@ -248,17 +240,15 @@ mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ mov r0, unif # U offset/weight
+ asr rb15, r0, r2  # Compute offset from MSBs
+ shl r0, r0, r2
+-asr rb14, r0, r2  # Compute weight from LSBs
++asr r3, r0, r2  # Compute weight from LSBs
+ mov r0, unif # V offset/weight
+ asr.ifnz rb15, r0, r2
+ shl r0, r0, r2
+-asr.ifnz rb14, r0, r2
++asr.ifnz r3, r0, r2
++shl rb14,r3,8 # Scale up weights so we can use mul24 in signed fashion
+ 
+ # r2 is elem_num
+ # r3 is loop counter
+-
+-mov r5rep, -8
+-
+ # retrieve texture results and pick out bytes
+ # then submit two more texture requests
+ 
+@@ -269,7 +259,7 @@ mov r3, 0
+ # then submit two more texture requests
+ 
+ sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1
+ mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+ mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+ shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+@@ -278,7 +268,7 @@ max r2, ra_y, 0  # y
+ min r2, r2, rb_frame_height_minus_1
+ add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+ add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+-add t0s, ra_frame_base, r2
++add t1s, ra_frame_base, r2
+ 
+ # generate seven shifted versions
+ # interleave with scroll of vertical context
+@@ -301,11 +291,6 @@ mov ra13, ra14       # Delay slot 1
+ mov ra14, ra15       # Delay slot 2
+ mov ra15, r0         # Delay slot 3
+ 
+-mov rb12,32 # TODO remove these to make P weighted prediction work properly
+-mov rb13,6
+-mov rb14,1
+-mov rb15,0
+-
+ # apply vertical filter and write to VPM
+ 
+ nop                     ; mul24 r1, ra14, rb10
+@@ -412,7 +397,7 @@ mov r3, 0
+ # then submit two more texture requests
+ 
+ sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1
+ mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+ mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+ shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+@@ -421,7 +406,7 @@ max r2, ra_y, 0  # y
+ min r2, r2, rb_frame_height_minus_1
+ add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+ add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+-add t0s, ra_frame_base, r2
++add t1s, ra_frame_base, r2
+ 
+ # generate seven shifted versions
+ # interleave with scroll of vertical context
+@@ -542,7 +527,7 @@ mov r3, 0
+ # then submit two more texture requests
+ 
+ sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                     ; ldtmu0     # loop counter increment
+-shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu0
++shr r0, r4, ra_xshift     ; mov.ifz ra_x, rb_x_next       ; ldtmu1
+ mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+ mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+ shr r1, r4, ra_xshift    ; v8subs r0, r0, rb20  # v8subs masks out all but bottom byte
+@@ -551,7 +536,7 @@ max r2, ra_y, 0  # y
+ min r2, r2, rb_frame_height_minus_1
+ add ra_y, ra_y, 1         ; mul24 r2, r2, r3
+ add t0s, ra_x, r2    ; v8subs r1, r1, rb20
+-add t0s, ra_frame_base, r2
++add t1s, ra_frame_base, r2
+ 
+ # generate seven shifted versions
+ # interleave with scroll of vertical context
+@@ -617,9 +602,9 @@ mov  -, vw_wait # wait on the VDW
+ mov -,srel(0)
+ 
+ ldtmu0
++ldtmu1
+ ldtmu0
+-ldtmu0
+-ldtmu0
++ldtmu1
+ 
+ nop        ; nop ; thrend
+ nop        ; nop # delay slot 1
+@@ -630,9 +615,9 @@ nop        ; nop # delay slot 2
+ mov  -, vw_wait # wait on the VDW
+ 
+ ldtmu0
++ldtmu1
+ ldtmu0
+-ldtmu0
+-ldtmu0
++ldtmu1
+ 
+ mov -,sacq(0) # 1
+ mov -,sacq(0) # 2
+@@ -656,200 +641,249 @@ nop        ; nop # delay slot 2
+ # For P frames we make the second x,y coordinates offset by +8
+ 
+ ################################################################################
+-# mc_setup(next_kernel, x, y, ref_y_base, x2, y2, ref_y2_base, frame_width, frame_height, pitch, dst_pitch, offset, shift, pad2)
++# mc_setup(y_x, ref_y_base, y2_x2, ref_y2_base, frame_width_height, pitch, dst_pitch, offset_shift, next_kernel)
+ ::mc_setup
++  mov r3, 16
+ 
+-# Read starting kernel
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-mov ra31, unif
+-
+-# Compute base address for first and second access
+-add r0, unif, elem_num # Load x
+-max r0, r0, 0; mov r1, unif # Load y
+-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+-shl ra_xshift_next, r0, 3 # Compute shifts
+-add ra_y, r1, 1
+-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+-add r2, r2, r0  # r2 is address for frame0 (not including y offset)
+-max r1, r1, 0
+-min r1, r1, rb_frame_height_minus_1
+-nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
+-add t0s, r2, r1 ; mov ra_frame_base, r2
+-
+-add r0, unif, elem_num # Load x
+-max r0, r0, 0; mov r1, unif # Load y
+-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+-shl rx_xshift2_next, r0, 3 # Compute shifts
+-add ra_y2, r1, 1
+-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+-add r2, r2, r0  # r2 is address for frame1 (not including y offset)
+-max r1, r1, 0
+-min r1, r1, rb_frame_height_minus_1
+-nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
+-add t0s, r2, r1 ; mov ra_frame_base2, r2
+-
++  # Need to save these because we need to know the frame dimensions before computing texture coordinates
++  mov ra8, unif
++  mov ra9, unif
++  mov ra10, unif
++  mov ra11, unif
+ 
+ # Read image dimensions
+-sub rb25,unif,1
+-sub rb30,unif,1
++  mov r1, unif # width_height
++  shl r0,r1,r3
++  asr r1,r1,r3 # width
++  asr r0,r0,r3 # height
++  sub rb_frame_width_minus_1,r1,1
++  sub rb_frame_height_minus_1,r0,1
+ 
+ # get source pitch
+-mov rb16, unif
++  mov rb_pitch, unif
+ 
+ # get destination pitch
+-mov r0, unif
+-mov r1, vdw_setup_1(0)
+-add rb24, r1, r0
++  mov r0, unif
++  mov r1, vdw_setup_1(0)
++  add rb24, r1, r0
+ 
+-# load constants
+-
+-mov ra20, 1
+-mov ra22, 256
+-mov ra30, 64
+-
+-mov rb20, 0xffffff00
+-mov rb22, 255
+-mov rb23, 24
++# Compute base address for first and second access
++  mov r1, ra8 # y_x
++  shl r0,r1,r3 # r0 is x<<16
++  asr r1,r1,r3 # r1 is y
++  asr r0,r0,r3 # r0 is x
++  add r0, r0, elem_num # Load x
++  max r0, r0, 0
++  min r0, r0, rb_frame_width_minus_1 ; mov r2, ra9  # Load the frame base
++  shl ra_xshift_next, r0, 3 # Compute shifts
++  add ra_y, r1, 1
++  and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++  add r2, r2, r0  # r2 is address for frame0 (not including y offset)
++  max r1, r1, 0
++  min r1, r1, rb_frame_height_minus_1
++  nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
++  add t0s, r2, r1 ; mov ra_frame_base, r2
++
++  mov r1, ra10 # y_x
++  shl r0,r1,r3 # r0 is x<<16
++  asr r1,r1,r3 # r1 is y
++  asr r0,r0,r3 # r0 is x
++  add r0, r0, elem_num # Load x
++  max r0, r0, 0
++  min r0, r0, rb_frame_width_minus_1 ; mov r2, ra11  # Load the frame base
++  shl rx_xshift2_next, r0, 3 # Compute shifts
++  add ra_y2, r1, 1
++  and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++  add r2, r2, r0  # r2 is address for frame1 (not including y offset)
++  max r1, r1, 0
++  min r1, r1, rb_frame_height_minus_1
++  nop             ; mul24 r1, r1, rb_pitch   # r2 contains the addresses (not including y offset) for frame0
++  add t1s, r2, r1 ; mov ra_frame_base2, r2
+ 
+-# touch vertical context to keep simulator happy
+ 
+-mov ra8, 0
+-mov ra9, 0
+-mov ra10, 0
+-mov ra11, 0
+-mov ra12, 0
+-mov ra13, 0
+-mov ra14, 0
+-mov ra15, 0
++# load constants
+ 
+-# Compute part of VPM to use for DMA output
+-mov r2, qpu_num
+-mov r1, r2
+-asr r1, r1, 2
+-shl r1, r1, 6
+-mov r0, r2
+-and r0, r0, 3
+-add r0, r0, r1
+-mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
+-shl r0, r0, 5
+-add rb27, r0, r1
++  mov ra20, 1
++  mov ra22, 256
++  mov ra30, 64
+ 
+-# Compute part of VPM to save data into
+-mov r2, qpu_num   # qpu_num = abcd
+-mov r1, r2
+-asr r1, r1, 2
+-shl r1, r1, 6
+-mov r0, r2
+-and r0, r0, 3
+-add r0, r0, r1
+-mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
+-add rb28, r0, r1
++  mov rb20, 0xffffff00
++  mov rb22, 255
++  mov rb23, 24
+ 
+-mov rb12,unif # offset before shift
+-mov rb13,unif # shift
++# touch vertical context to keep simulator happy
+ 
+-# Dump padding words
+-mov r0, unif
++  mov ra8, 0
++  mov ra9, 0
++  mov ra10, 0
++  mov ra11, 0
++  mov ra12, 0
++  mov ra13, 0
++  mov ra14, 0
++  mov ra15, 0
++  mov ra18, 0x4000
++
++# Compute part of VPM to use
++  mov r2, qpu_num
++  mov r1, r2
++  asr r1, r1, 2
++  shl r1, r1, 6
++  mov r0, r2
++  and r0, r0, 3
++  add r0, r0, r1
++  mov r1, vpm_setup(0, 4, h8p(0, 0))   # 4 is stride - stride acts on ADDR which is Y[5:0],B[1:0] for 8 bit
++  add rb28, r0, r1  # VPM for saving data
++  mov r1, vdw_setup_0(0, 0, dma_h8p(0,0,0)) # height,width added later
++  shl r0, r0, 5
++  add rb27, r0, r1  # Command for dma output
++
++# Weighted prediction denom
++
++  mov r1, unif # offset_shift
++  shl r0,r1,r3 ; mov r2,8
++  asr rb13,r0,r3 # shift
++  asr rb12,r1,r3 # offset
++  add rb13,rb13,r2    # mul24 is unsigned so scale up into high bits
++  shl rb12, rb12, r2 # Account for larger shift
+ 
+ # submit texture requests for second line
+-max r1, ra_y, 0
+-min r1, r1, rb_frame_height_minus_1
+-add ra_y, ra_y, 1
+-nop ; mul24 r1, r1, rb_pitch
+-add t0s, r1, ra_frame_base
+-
+-max r1, ra_y2, 0
+-min r1, r1, rb_frame_height_minus_1
+-bra -, ra31
+-add ra_y2, ra_y2, 1           # Delay 1
+-nop ; mul24 r1, r1, rb_pitch  # Delay 2
+-add t0s, r1, ra_frame_base2   # Delay 3
+-
+-
+-################################################################################
+-
+-# mc_filter(next_kernel, x, y, frame_base, x2, y2, frame_base2, height, hcoeffs[0], hcoeffs2[0], hcoeffs[1], hcoeffs2[1], vcoeffs[0], vcoeffs2[0], vcoeffs[1], vcoeffs2[1], offsetweight0, offsetweight1, this_dst)
+-# In a P block, only the first half of coefficients contain used information.
+-# At this point we have already issued two pairs of texture requests for the current block
+-# ra_x, ra_x16_base point to the current coordinates for this block
+-::mc_filter
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-mov ra31, unif
++  max r1, ra_y, 0
++  min r1, r1, rb_frame_height_minus_1
++  add ra_y, ra_y, 1
++  nop ; mul24 r1, r1, rb_pitch
++  add t0s, r1, ra_frame_base
++
++  max r1, ra_y2, 0
++  min r1, r1, rb_frame_height_minus_1
++  add ra_y2, ra_y2, 1
++  nop ; mul24 r1, r1, rb_pitch
++  add t1s, r1, ra_frame_base2
++
++# FALL THROUGHT TO PER-BLOCK SETUP
++
++# Start of per-block setup code
++# P and B blocks share the same setup code to save on Icache space
++:per_block_setup
++  mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++  mov ra31, unif
+ 
+ # per-channel shifts were calculated on the *previous* invocation
+-
+-mov ra_xshift, ra_xshift_next
+-mov rx_xshift2, rx_xshift2_next
++  mov ra_xshift, ra_xshift_next
++  mov rx_xshift2, rx_xshift2_next
+ 
+ # get base addresses and per-channel shifts for *next* invocation
+-add r0, unif, elem_num # Load x
+-max r0, r0, 0; mov r1, unif # Load y
+-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+-shl ra_xshift_next, r0, 3 # Compute shifts
+-mov ra_y_next, r1
+-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+-add ra_frame_base_next, r2, r0  # r2 is address for frame0 (not including y offset)
+-
+-add r0, unif, elem_num # Load x
+-max r0, r0, 0   ; mov r1, unif # Load y
+-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+-shl rx_xshift2_next, r0, 3 # Compute shifts
+-add ra_y2_next, r1, 1
+-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+-add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
+-
++  mov r3, 16
++  mov r1, unif # y_x
++  shl r0,r1,r3 # r0 is x<<16
++  asr r1,r1,r3 # r1 is y
++  asr r0,r0,r3 # r0 is x
++  add r0, r0, elem_num # Load x
++  max r0, r0, 0
++  min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
++  shl ra_xshift_next, r0, 3 # Compute shifts
++  mov ra_y_next, r1
++  and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++  add ra_frame_base_next, r2, r0 ; mov r1, unif # y2_x2
++
++  shl r0,r1,r3 # r0 is x2<<16
++  asr r1,r1,r3 # r1 is y2
++  asr r0,r0,r3 # r0 is x2
++  add r0, r0, elem_num # Load x
++  max r0, r0, 0
++  min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
++  shl rx_xshift2_next, r0, 3 # Compute shifts
++  mov ra_y2_next, r1
++  and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
++  add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
+ 
+ # set up VPM write
+-mov vw_setup, rb28
++  mov vw_setup, rb28
+ 
+ # get width,height of block
+-mov r2, 16
+-mov r0, unif
+-shr r1, r0, r2 # Extract width
+-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+-and r0, r0, rb22 # Extract height
+-add rb17, r0, 5
+-add rb18, r0, 7
+-shl r0, r0, 7
+-add r0, r0, r1 # Combine width and height of destination area
+-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+-add rb26, r0, rb27
++  mov r0, unif
++  shr r1, r0, r3 # Extract width
++  sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
++  and r0, r0, rb22 # Extract height
++  add rb17, r0, 5
++  add rb18, r0, 7
++  shl r0, r0, 7
++  add r0, r0, r1 # Combine width and height of destination area
++  shl r0, r0, r3 # Shift into bits 16 upwards of the vdw_setup0 register
++  add rb26, r0, rb27
+ 
+ # get filter coefficients and discard unused B frame values
+-mov r0, unif
+-mov.ifnz -, unif # Alternate coefficients are unused for P frames
+-asr ra3, r0, rb23;      mul24 r0, r0, ra22 # These may need some pre-rotation to be used in B frames correctly
+-asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-asr ra0, r0, rb23;      mov r0, unif
+-mov.ifnz -, unif
+-asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-asr ra4, r0, rb23;      mov r0, unif
+-mov.ifnz -, unif
+-asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-asr rb8, r0, rb23;      mov r0, unif
+-mov.ifnz -, unif
+-asr rb7, r0, rb23;      mul24 r0, r0, ra22
+-asr rb6, r0, rb23;      mul24 r0, r0, ra22
+-asr rb5, r0, rb23;      mul24 r0, r0, ra22
+-asr rb4, r0, rb23
+-
+-mov r0, unif # Frame0 offset/weight
+-mov.ifnz -, unif # Frame1 offset/weight unused
+-asr rb15, r0, r2  # Compute offset from MSBs
+-shl r0, r0, r2
+-asr rb14, r0, r2  # Compute weight from LSBs
+-
+-# r3 is loop counter
++  mov r0, unif ; mov r1,1  # Packed filter offsets, unpack into ra8... (to be used for vertical context later)
++  asr ra9, r0, rb23;      mul24 r0, r0, ra22 # my2
++  asr ra8, r0, rb23;      mul24 r0, r0, ra22 # mx2
++  asr.ifz ra9, r0, rb23;  mul24 r0, r0, ra22 # my:my2
++  asr.ifz ra8, r0, rb23                      # mx:mx2
++  sub ra9,3,ra9
++  sub ra8,3,ra8
++  shl ra9,ra9,3   # Scale up by 8
++  shl ra8,ra8,3   # Scale up by 8
++# Now if we want aligned we have a mul of 1, so put 0 coefficients at the top
++  mov r1,0xffff00
++  shl r0, r1, ra8
++  asr ra0, r0, rb23
++  shl r0, r1, ra9
++  asr rb4, r0, rb23
++
++  mov r1,0x1040400
++  shl r0, r1, ra8
++  asr ra1, r0, rb23
++  shl r0, r1, ra9
++  asr rb5, r0, rb23
++
++  mov r1,0xfbf5f600
++  shl r0, r1, ra8
++  asr ra2, r0, rb23
++  shl r0, r1, ra9
++  asr rb6, r0, rb23
++
++  mov r1,0x11283a40
++  shl r0, r1, ra8
++  asr ra3, r0, rb23
++  shl r0, r1, ra9
++  asr rb7, r0, rb23
++
++  mov r1,0x3a281100
++  shl r0, r1, ra8
++  asr ra4, r0, rb23
++  shl r0, r1, ra9
++  asr rb8, r0, rb23
++
++  mov r1,0xf6f5fb00
++  shl r0, r1, ra8
++  asr ra5, r0, rb23
++  shl r0, r1, ra9
++  asr rb9, r0, rb23
++
++  mov r1,0x4040100
++  shl r0, r1, ra8
++  asr ra6, r0, rb23
++  shl r0, r1, ra9
++  asr rb10, r0, rb23
++
++  mov r1,0xffff0000
++  shl r0, r1, ra8
++  asr ra7, r0, rb23
++  shl r0, r1, ra9
++  asr rb11, r0, rb23
++
++# Extract weighted prediction information
++  mov r0, unif      # offset/weight  TODO move up
++  asr rb15, r0, r3  # Compute offset from MSBs
++  bra -, ra31
++  shl r0, r0, r3    #                                                            Delay 1
++  asr r0, r0, r3 ; mov r3, 0 # Compute weight from LSBs and reset loop counter   Delay 2
++  shl rb14, r0, 8 # Use a larger shift to avoid unsigned multiply problem        Delay 3
+ 
+-# retrieve texture results and pick out bytes
+-# then submit two more texture requests
++################################################################################
++# mc_filter(y_x, frame_base, y2_x2, frame_base2, width_height, my2_mx2_my_mx, offsetweight0, this_dst, next_kernel)
++# In a P block, y2_x2 should be y_x+8
++# At this point we have already issued two pairs of texture requests for the current block
+ 
+-mov r3, 0
++::mc_filter
+ 
+ :yloop
+ # retrieve texture results and pick out bytes
+@@ -858,91 +892,90 @@ mov r3, 0
+ # If we knew there was no clipping then this code would get simpler.
+ # Perhaps we could add on the pitch and clip using larger values?
+ 
+-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+-shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+-mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-shr r1, r4, rx_xshift2
+-mov.ifz ra_y2, ra_y2_next
++  sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++  shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu1
++  mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++  mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++  shr r1, r4, rx_xshift2
++  mov.ifz ra_y2, ra_y2_next
+ 
+-max r2, ra_y, 0  # y
+-min r2, r2, rb_frame_height_minus_1
+-add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+-add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
+-
+-max r2, ra_y2, 0  # y
+-min r2, r2, rb_frame_height_minus_1
+-add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+-add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
++  max r2, ra_y, 0  # y
++  min r2, r2, rb_frame_height_minus_1
++  add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++  add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
+ 
++  max r2, ra_y2, 0  # y
++  min r2, r2, rb_frame_height_minus_1
++  add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++  add t1s, ra_frame_base2, r2   ; v8subs r1, r1, rb20
+ 
+ # generate seven shifted versions
+ # interleave with scroll of vertical context
+ 
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++  mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ 
+ # apply horizontal filter
+-nop                  ; mul24 r2, r0, ra0
+-nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-add r0, r2, r3       ; mov r3, rb31
+-sub.setf -, r3, 8    ; mov ra12, ra13
+-mov ra9, ra10
+-mov ra10, ra11
+-mov ra11, ra12
+-mov ra12, ra13
+-brr.anyn -, r:yloop
+-mov ra13, ra14       # Delay slot 1
+-mov ra14, ra15       # Delay slot 2
+-mov ra15, r0         # Delay slot 3
++  nop                  ; mul24 r2, r0, ra0
++  nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++  nop                  ; mul24      r3, ra1 << 1, r0 << 1
++  nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++  add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++  nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++  add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++  nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++  add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++  nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++  add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++  nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++  add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++  nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++  add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++  nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++  add r0, r2, r3       ; mov r3, rb31
++  sub.setf -, r3, 8    ; mov ra8, ra9
++  mov ra9, ra10
++  mov ra10, ra11
++  mov ra11, ra12
++  mov ra12, ra13
++  brr.anyn -, r:yloop
++  mov ra13, ra14       # Delay slot 1
++  mov ra14, ra15       # Delay slot 2
++  mov ra15, r0         # Delay slot 3
+ 
+ # apply vertical filter and write to VPM
+ 
+-nop                     ; mul24 r1, ra14, rb10
+-nop                     ; mul24 r0, ra13, rb9
+-add r1, r1, r0          ; mul24 r0, ra12, rb8
+-add r1, r1, r0          ; mul24 r0, ra15, rb11
+-add r1, r1, r0          ; mul24 r0, ra8, rb4
+-add r1, r1, r0          ; mul24 r0, ra9, rb5
+-add r1, r1, r0          ; mul24 r0, ra10, rb6
+-add r1, r1, r0          ; mul24 r0, ra11, rb7
+-
+-add r1, r1, r0          ; mov -, vw_wait
+-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-asr r1, r1, 14
+-nop                     ; mul24 r1, r1, rb14
+-add r1, r1, rb12
+-asr r1, r1, rb13
+-brr.anyn -, r:yloop
+-add r1, r1, rb15       # Delay 1
+-min r1, r1, rb22       # Delay 2
+-max vpm, r1, 0         # Delay 3
++  nop                     ; mul24 r1, ra14, rb10
++  nop                     ; mul24 r0, ra13, rb9
++  add r1, r1, r0          ; mul24 r0, ra12, rb8
++  add r1, r1, r0          ; mul24 r0, ra15, rb11
++  add r1, r1, r0          ; mul24 r0, ra8, rb4
++  add r1, r1, r0          ; mul24 r0, ra9, rb5
++  add r1, r1, r0          ; mul24 r0, ra10, rb6
++  add r1, r1, r0          ; mul24 r0, ra11, rb7
++
++  add r1, r1, r0          ; mov -, vw_wait
++  sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++  asr r1, r1, 14
++  nop                     ; mul24 r1, r1, rb14
++  add r1, r1, rb12
++  asr r1, r1, rb13
++  brr.anyn -, r:yloop
++  add r1, r1, rb15       # Delay 1
++  min r1, r1, rb22       # Delay 2
++  max vpm, r1, 0         # Delay 3
+ 
+ # DMA out
+ 
+-bra -, ra31
+-mov vw_setup, rb26 # VDW setup 0    Delay 1
+-mov vw_setup, rb29 # Stride         Delay 2
+-mov vw_addr, unif # start the VDW   Delay 3
++  brr -, r:per_block_setup
++  mov vw_setup, rb26 # VDW setup 0    Delay 1
++  mov vw_setup, rb29 # Stride         Delay 2
++  mov vw_addr, unif # start the VDW   Delay 3
+ 
+ 
+ 
+ ################################################################################
+ 
+-# mc_filter_b(next_kernel, x, y, frame_base, x2, y2, frame_base2, width_height, hcoeffs[0], hcoeffs2[0], hcoeffs[1], hcoeffs2[1], vcoeffs[0], vcoeffs2[0], vcoeffs[1], vcoeffs2[1], offsetweight0, offsetweight1, this_dst)
++# mc_filter_b(y_x, frame_base, y2_x2, frame_base2, width_height, my2_mx2_my_mx, offsetweight0, this_dst, next_kernel)
+ # In a P block, only the first half of coefficients contain used information.
+ # At this point we have already issued two pairs of texture requests for the current block
+ # May be better to just send 16.16 motion vector and figure out the coefficients inside this block (only 4 cases so can compute hcoeffs in around 24 cycles?)
+@@ -952,92 +985,6 @@ mov vw_addr, unif # start the VDW   Delay 3
+ # Or possibly by taking advantage of symmetry?
+ # From 19->7 32bits per command.
+ ::mc_filter_b
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+-mov ra31, unif
+-
+-# per-channel shifts were calculated on the *previous* invocation
+-
+-mov ra_xshift, ra_xshift_next
+-mov rx_xshift2, rx_xshift2_next
+-
+-# get base addresses and per-channel shifts for *next* invocation
+-add r0, unif, elem_num # Load x
+-max r0, r0, 0; mov r1, unif # Load y
+-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+-shl ra_xshift_next, r0, 3 # Compute shifts
+-mov ra_y_next, r1
+-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+-add ra_frame_base_next, r2, r0  # r2 is address for frame0 (not including y offset)
+-
+-add r0, unif, elem_num # Load x
+-max r0, r0, 0   ; mov r1, unif # Load y
+-min r0, r0, rb_frame_width_minus_1 ; mov r2, unif  # Load the frame base
+-shl rx_xshift2_next, r0, 3 # Compute shifts
+-add ra_y2_next, r1, 1
+-and r0, r0, ~3  # r0 gives the clipped and aligned x coordinate
+-add rx_frame_base2_next, r2, r0  # r2 is address for frame1 (not including y offset)
+-
+-
+-# set up VPM write
+-mov vw_setup, rb28
+-
+-# get width,height of block
+-mov r2, 16
+-mov r0, unif
+-shr r1, r0, r2 # Extract width
+-sub rb29, rb24, r1 # Compute vdw_setup1(dst_pitch-width)
+-and r0, r0, rb22 # Extract height
+-add rb17, r0, 5
+-add rb18, r0, 7
+-shl r0, r0, 7
+-add r0, r0, r1 # Combine width and height of destination area
+-shl r0, r0, r2 # Shift into bits 16 upwards of the vdw_setup0 register
+-add rb26, r0, rb27
+-
+-# get filter coefficients and discard unused B frame values
+-mov r0, unif
+-mov r1, 1
+-mov.ifnz r0, unif # Alternate coefficients are unused for P frames
+-nop              ;      mul24 r0, r0 << 13, r1 << 13
+-asr ra3, r0, rb23;      mul24 r0, r0, ra22
+-nop              ;      mul24 r0, r0 << 14, r1 << 14
+-asr ra2, r0, rb23;      mul24 r0, r0, ra22
+-nop              ;      mul24 r0, r0 << 15, r1 << 15 # Adjust such that a rotate of 1 will produce the values with first 8 on left, second 8 on right
+-asr ra1, r0, rb23;      mul24 r0, r0, ra22
+-asr ra0, r0, rb23;      mov r0, unif
+-mov.ifnz r0, unif
+-nop              ;      mul24 r0, r0 << 9, r1 << 9
+-asr ra7, r0, rb23;      mul24 r0, r0, ra22
+-nop              ;      mul24 r0, r0 << 10, r1 << 10
+-asr ra6, r0, rb23;      mul24 r0, r0, ra22
+-nop              ;      mul24 r0, r0 << 11, r1 << 11
+-asr ra5, r0, rb23;      mul24 r0, r0, ra22
+-nop              ;      mul24 r0, r0 << 12, r1 << 12
+-asr ra4, r0, rb23;      mov r0, unif
+-mov.ifnz r0, unif
+-asr rb11, r0, rb23;     mul24 r0, r0, ra22
+-asr rb10, r0, rb23;     mul24 r0, r0, ra22
+-asr rb9, r0, rb23;      mul24 r0, r0, ra22
+-asr rb8, r0, rb23;      mov r0, unif
+-mov.ifnz r0, unif
+-asr rb7, r0, rb23;      mul24 r0, r0, ra22
+-asr rb6, r0, rb23;      mul24 r0, r0, ra22
+-asr rb5, r0, rb23;      mul24 r0, r0, ra22
+-asr rb4, r0, rb23
+-
+-mov r0, unif # Frame0 offset/weight
+-mov.ifnz r0, unif # Frame1 offset/weight unused
+-asr rb15, r0, r2  # Compute offset from MSBs
+-shl r0, r0, r2
+-asr rb14, r0, r2  # Compute weight from LSBs
+-
+-# r3 is loop counter
+-
+-# retrieve texture results and pick out bytes
+-# then submit two more texture requests
+-
+-mov r3, 0
+-
+ :yloopb
+ # retrieve texture results and pick out bytes
+ # then submit two more texture requests
+@@ -1045,111 +992,123 @@ mov r3, 0
+ # If we knew there was no clipping then this code would get simpler.
+ # Perhaps we could add on the pitch and clip using larger values?
+ 
+-sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
+-shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu0
+-mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
+-mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
+-shr r1, r4, rx_xshift2
+-mov.ifz ra_y2, ra_y2_next
++  sub.setf -, r3, rb17      ; v8adds r3, r3, ra20                            ; ldtmu0
++  shr r0, r4, ra_xshift     ; mov.ifz ra_frame_base2, rx_frame_base2_next    ; ldtmu1
++  mov.ifz ra_frame_base, ra_frame_base_next ; mov rb31, r3
++  mov.ifz ra_y, ra_y_next   ; mov r3, rb_pitch
++  shr r1, r4, rx_xshift2
++  mov.ifz ra_y2, ra_y2_next
+ 
+-max r2, ra_y, 0  # y
+-min r2, r2, rb_frame_height_minus_1
+-add ra_y, ra_y, 1            ; mul24 r2, r2, r3
+-add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
+-
+-max r2, ra_y2, 0  # y
+-min r2, r2, rb_frame_height_minus_1
+-add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
+-add t0s, ra_frame_base2, r2   ; v8subs r0, r0, rb20
++  max r2, ra_y, 0  # y
++  min r2, r2, rb_frame_height_minus_1
++  add ra_y, ra_y, 1            ; mul24 r2, r2, r3
++  add t0s, ra_frame_base, r2   ; v8subs r0, r0, rb20 # v8subs masks out all but bottom byte
+ 
++  max r2, ra_y2, 0  # y
++  min r2, r2, rb_frame_height_minus_1
++  add ra_y2, ra_y2, 1            ; mul24 r2, r2, r3
++  add t1s, ra_frame_base2, r2   ; v8subs r1, r1, rb20
+ 
+ # generate seven shifted versions
+ # interleave with scroll of vertical context
+ 
+-mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
++  mov.setf -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
+ 
+ # apply horizontal filter
+-nop                  ; mul24 r2, r0, ra0
+-nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
+-nop                  ; mul24      r3, ra1 << 1, r0 << 1
+-nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
+-add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
+-nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
+-add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
+-nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
+-add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
+-nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
+-add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
+-nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
+-add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
+-nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
+-add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
+-nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
+-add r0, r2, r3       ; mov r3, rb31
+-sub.setf -, r3, 8    ; mov ra12, ra13
+-mov ra9, ra10
+-mov ra10, ra11
+-mov ra11, ra12
+-mov ra12, ra13
+-brr.anyn -, r:yloopb
+-mov ra13, ra14       # Delay slot 1
+-mov ra14, ra15       # Delay slot 2
+-mov ra15, r0         # Delay slot 3
+-
+-# apply vertical filter and write to VPM
+-
+-nop                     ; mul24 r1, ra14, rb10
+-nop                     ; mul24 r0, ra13, rb9
+-add r1, r1, r0          ; mul24 r0, ra12, rb8
+-add r1, r1, r0          ; mul24 r0, ra15, rb11
+-add r1, r1, r0          ; mul24 r0, ra8, rb4
+-add r1, r1, r0          ; mul24 r0, ra9, rb5
+-add r1, r1, r0          ; mul24 r0, ra10, rb6
+-add r1, r1, r0          ; mul24 r0, ra11, rb7
+-
+-add r1, r1, r0          ; mov -, vw_wait
+-sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
+-asr r1, r1, 14
+-nop                     ; mul24 r1, r1 << 8, ra20 << 8 # Rotate to align left and right halves
+-add r1, r1, ra30        ; mul24 r0, r1, rb14
+-add r1, r1, r0
+-brr.anyn -, r:yloopb
+-asr r1, r1, 7          # Delay 1
+-min r1, r1, rb22       # Delay 2
+-max vpm, r1, 0         # Delay 3
++  nop                  ; mul24 r2, r0, ra0
++  nop                  ; mul24.ifnz r2, ra0 << 8, r1 << 8
++  nop                  ; mul24      r3, ra1 << 1, r0 << 1
++  nop                  ; mul24.ifnz r3, ra1 << 9, r1 << 9
++  add r2, r2, r3       ; mul24    r3, ra2 << 2, r0 << 2
++  nop                  ; mul24.ifnz r3, ra2 << 10, r1 << 10
++  add r2, r2, r3       ; mul24    r3, ra3 << 3, r0 << 3
++  nop                  ; mul24.ifnz r3, ra3 << 11, r1 << 11
++  add r2, r2, r3       ; mul24    r3, ra4 << 4, r0 << 4
++  nop                  ; mul24.ifnz r3, ra4 << 12, r1 << 12
++  add r2, r2, r3       ; mul24    r3, ra5 << 5, r0 << 5
++  nop                  ; mul24.ifnz r3, ra5 << 13, r1 << 13
++  add r2, r2, r3       ; mul24    r3, ra6 << 6, r0 << 6
++  nop                  ; mul24.ifnz r3, ra6 << 14, r1 << 14
++  add r2, r2, r3       ; mul24    r3, ra7 << 7, r0 << 7
++  nop                  ; mul24.ifnz r3, ra7 << 15, r1 << 15
++  add r0, r2, r3       ; mov r3, rb31
++  sub.setf -, r3, 8    ; mov ra8, ra9
++  mov ra9, ra10
++  mov ra10, ra11
++  mov ra11, ra12
++  mov ra12, ra13
++  brr.anyn -, r:yloopb
++  mov ra13, ra14       # Delay slot 1
++  mov ra14, ra15       # Delay slot 2
++  mov ra15, r0         # Delay slot 3
++
++  # apply vertical filter and write to VPM
++
++  nop                     ; mul24 r1, ra14, rb10
++  nop                     ; mul24 r0, ra13, rb9
++  add r1, r1, r0          ; mul24 r0, ra12, rb8
++  add r1, r1, r0          ; mul24 r0, ra15, rb11
++  add r1, r1, r0          ; mul24 r0, ra8, rb4
++  add r1, r1, r0          ; mul24 r0, ra9, rb5
++  add r1, r1, r0          ; mul24 r0, ra10, rb6
++  add r1, r1, r0          ; mul24 r0, ra11, rb7
++
++  add r1, r1, r0          ; mov -, vw_wait
++  sub.setf -, r3, rb18    ; mul24 r1, r1, ra22
++  asr r0, r1, 14
++  asr r1, r1, 6           # Wait state so we can use the rotate instruction
++  nop                     ; mul24 r0, r0 << 8, ra22 << 8 # Rotate to align left and right halves
++  add r1, r1, ra18
++  add r1, r1, r0
++  brr.anyn -, r:yloopb
++  asr r1, r1, 15         # Delay 1
++  min r1, r1, rb22       # Delay 2
++  max vpm, r1, 0         # Delay 3
+ 
+ # DMA out
+-bra -, ra31
+-mov vw_setup, rb26 # VDW setup 0    Delay 1
+-mov vw_setup, rb29 # Stride         Delay 2
+-mov vw_addr, unif # start the VDW   Delay 3
++  brr -, r:per_block_setup
++  mov vw_setup, rb26 # VDW setup 0    Delay 1
++  mov vw_setup, rb29 # Stride         Delay 2
++  mov vw_addr, unif # start the VDW   Delay 3
+ 
+ ################################################################################
+ 
+ # mc_interrupt_exit12()
+ ::mc_interrupt_exit12
+-mov  -, vw_wait # wait on the VDW
+-
+-ldtmu0
+-ldtmu0
+-ldtmu0
+-ldtmu0
+-
+-mov -,sacq(0) # 1
+-mov -,sacq(0) # 2
+-mov -,sacq(0) # 3
+-mov -,sacq(0) # 4
+-mov -,sacq(0) # 5
+-mov -,sacq(0) # 6
+-mov -,sacq(0) # 7
+-mov -,sacq(0) # 8
+-mov -,sacq(0) # 9
+-mov -,sacq(0) # 10
+-mov -,sacq(0) # 11
+-
+-nop        ; nop ; thrend
+-mov interrupt, 1; nop # delay slot 1
+-nop        ; nop # delay slot 2
++  mov  -, vw_wait # wait on the VDW
++
++  ldtmu0
++  ldtmu0
++  ldtmu1
++  ldtmu1
++
++  mov -,sacq(0) # 1
++  mov -,sacq(0) # 2
++  mov -,sacq(0) # 3
++  mov -,sacq(0) # 4
++  mov -,sacq(0) # 5
++  mov -,sacq(0) # 6
++  mov -,sacq(0) # 7
++  mov -,sacq(0) # 8
++  mov -,sacq(0) # 9
++  mov -,sacq(0) # 10
++  mov -,sacq(0) # 11
++
++  nop        ; nop ; thrend
++  mov interrupt, 1; nop # delay slot 1
++  nop        ; nop # delay slot 2
++
++
++::mc_exit1
++  mov  -, vw_wait # wait on the VDW
++
++  ldtmu0
++  ldtmu1
++  ldtmu0
++  ldtmu1
++  nop        ; nop ; thrend
++  mov interrupt, 1; nop # delay slot 1
++  nop        ; nop # delay slot 2
+ 
+ 
+ ::mc_end
+-- 
+2.7.4
+
+
+From f02ec34c772aad3caa17432c6a4860f9ed0d5dc6 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Tue, 2 Jun 2015 10:58:25 +0100
+Subject: [PATCH 48/68] Added option to simulate QPUs
+
+---
+ libavcodec/hevc.c          | 288 +++++++++++++++++++++++++++++++++++++++++++--
+ libavcodec/rpi_qpu.c       |  24 ++--
+ libavcodec/rpi_shader.qasm |   6 +-
+ 3 files changed, 295 insertions(+), 23 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 2da88ec..34d92e2 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -56,6 +56,8 @@
+   // Define RPI_CACHE_UNIF_MVS to write motion vector uniform stream to cached memory
+   // RPI_CACHE_UNIF_MVS doesn't seem to make much difference, so left undefined.
+ 
++  // Define RPI_SIMULATE_QPUS for debugging to run QPU code on the ARMs
++  //#define RPI_SIMULATE_QPUS
+ 
+ #endif
+ 
+@@ -124,7 +126,6 @@ static void pic_arrays_free(HEVCContext *s)
+ 
+ #ifdef EARLY_MALLOC
+ #else
+-    printf("pic_arrays_free\n");
+     if (s->coeffs_buf_arm[0]) {
+       gpu_free(&s->coeffs_buf_default);
+       s->coeffs_buf_arm[0] = 0;
+@@ -174,11 +175,9 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
+ #ifdef RPI
+ #ifdef EARLY_MALLOC
+ #else
+-    assert(sps);
++    av_assert0(sps);
+     int coeffs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
+     int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
+-    printf("pic_arrays_init\n");
+-    printf("Allocated %d\n",coefs_per_row);
+     gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
+     s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
+     if (!s->coeffs_buf_arm[0])
+@@ -2988,6 +2987,274 @@ static void rpi_inter_clear(HEVCContext *s)
+ #endif
+ }
+ 
++
++#ifdef RPI_SIMULATE_QPUS
++
++static int32_t clipx(int x,int FRAME_WIDTH)
++{
++	if (x<=0) return 0;
++	if (x>=FRAME_WIDTH) return FRAME_WIDTH-1;
++	return x;
++}
++
++static int32_t clipy(int y,int FRAME_HEIGHT)
++{
++	if (y<=0) return 0;
++	if (y>=FRAME_HEIGHT) return FRAME_HEIGHT-1;
++	return y;
++}
++
++/*static int32_t filter8(uint8_t *data, int x0, int y0, int pitch, int mx, int my,int round,int denom,int weight,int offset)
++{
++   int32_t vsum = 0;
++   int x, y;
++
++   for (y = 0; y < 8; y++) {
++      int32_t hsum = 0;
++
++      for (x = 0; x < 8; x++)
++         hsum += lumaFilter[mx][x]*data[clipx(x + x0) + clipy(y + y0) * pitch];
++
++      vsum += lumaFilter[my][y]*hsum;
++   }
++   vsum >>= 6;
++   vsum = (((vsum*weight)+round)>>denom)+offset;
++
++   return av_clip_uint8( vsum );
++}*/
++
++static int32_t filter8_chroma(uint8_t *data, int x0, int y0, int pitch, int hcoeffs, int vcoeffs,int offset_weight,int offset_before,int denom,int pic_width, int pic_height)
++{
++  int32_t vsum = 0;
++  int x, y;
++  int chromaFilterH[4];
++  int chromaFilterV[4];
++  int i;
++  int offset_after = offset_weight>>16;
++  int weight = (offset_weight<<16)>>16;
++  for(i=0;i<4;i++) {
++    chromaFilterH[i] = ((hcoeffs>>(8*i))<<24)>>24;
++    chromaFilterV[i] = ((vcoeffs>>(8*i))<<24)>>24;
++  }
++
++   for (y = 0; y < 4; y++) {
++      int32_t hsum = 0;
++
++      for (x = 0; x < 4; x++)
++         hsum += chromaFilterH[x]*data[clipx(x + x0,pic_width) + clipy(y + y0,pic_height) * pitch];
++
++      vsum += chromaFilterV[y]*hsum;
++   }
++   vsum >>= 6;
++   vsum = (((vsum*weight)+offset_before)>>denom)+offset_after;
++
++   return vsum;
++}
++
++int lumaFilter[4][8]={ {0,0,0,64,0,0,0,0},{-1,4,-10,58,17,-5,1,0},{-1,4,-11,40,40,-11,4,-1},{0,1,-5,17,58,-10,4,-1} };
++
++static int32_t filter8_luma(uint8_t *data, int x0, int y0, int pitch, int my_mx,int offset_weight,int offset_before,int denom,int pic_width, int pic_height)
++{
++  int32_t vsum = 0;
++  int x, y;
++  int i;
++  int offset_after = offset_weight>>16;
++  int weight = (offset_weight<<16)>>16;
++
++   for (y = 0; y < 8; y++) {
++      int32_t hsum = 0;
++
++      for (x = 0; x < 8; x++)
++         hsum += lumaFilter[my_mx&3][x]*data[clipx(x + x0,pic_width) + clipy(y + y0,pic_height) * pitch];
++
++      vsum += lumaFilter[(my_mx>>8)&3][y]*hsum;
++   }
++   vsum >>= 6;
++   vsum = (((vsum*weight)+offset_before)>>denom)+offset_after;
++
++   return vsum;
++}
++
++static uint8_t *test_frame(HEVCContext *s,uint32_t p, AVFrame *frame, int cIdx)
++{
++  //int pic_width        = s->ps.sps->width >> s->ps.sps->hshift[cIdx];
++  int pic_height       = s->ps.sps->height >> s->ps.sps->vshift[cIdx];
++  int pitch = frame->linesize[cIdx];
++  uint32_t base = get_vc_address(frame->buf[cIdx]);
++  if (p>=base && p<base+pitch*pic_height) {
++    return frame->data[cIdx] + (p-base);
++  }
++  return NULL;
++}
++
++static uint8_t *compute_arm_addr(HEVCContext *s,uint32_t p, int cIdx)
++{
++  SliceHeader *sh   = &s->sh;
++  uint8_t *arm = test_frame(s,p,s->frame,cIdx);
++  int i;
++  if (arm) return arm;
++  if (sh->slice_type == P_SLICE || sh->slice_type == B_SLICE)
++  {
++    for(i=0;i<sh->nb_refs[L0];i++) {
++      arm = test_frame(s,p,s->ref->refPicList[0].ref[i]->frame,cIdx);
++      if (arm) return arm;
++    }
++  }
++  if (sh->slice_type == B_SLICE) {
++    for(i=0;i<sh->nb_refs[L1];i++) {
++      arm = test_frame(s,p,s->ref->refPicList[1].ref[i]->frame,cIdx);
++      if (arm) return arm;
++    }
++  }
++  printf("Frame 0x%x not found! Exit=%x\n",p,qpu_get_fn(QPU_MC_EXIT));
++  exit(-1);
++  return NULL;
++}
++
++static void rpi_simulate_inter_chroma(HEVCContext *s,uint32_t *p)
++{
++  uint32_t next_kernel;
++  uint32_t x0;
++  uint32_t y0;
++  uint8_t *ref_u_base;
++  uint8_t *ref_v_base;
++  uint32_t frame_width = p[5];
++  uint32_t frame_height = p[6];
++  uint32_t pitch = p[7];
++  uint32_t dst_pitch = p[8];
++  int32_t offset_before = p[9];
++  int32_t denom = p[10];
++  uint32_t vpm_id = p[11];
++  uint32_t tmp_u_dst[256];
++  uint32_t tmp_v_dst[256];
++  while(1) {
++    p += 12;
++    next_kernel = p[0-12];
++    x0 = p[1-12];
++    y0 = p[2-12];
++    if (next_kernel==s->mc_filter_uv || next_kernel==s->mc_filter_uv_b0 || next_kernel==s->mc_filter_uv_b) {
++      int x,y;
++      uint32_t width_height = p[5];
++      uint32_t hcoeffs = p[6];
++      uint32_t vcoeffs = p[7];
++      uint32_t offset_weight_u = p[8];
++      uint32_t offset_weight_v = p[9];
++      uint8_t *this_u_dst;
++      uint8_t *this_v_dst;
++      uint32_t width = width_height >> 16;
++      uint32_t height = (width_height << 16) >> 16;
++      ref_u_base = compute_arm_addr(s,p[3-12],1);
++      ref_v_base = compute_arm_addr(s,p[4-12],2);
++      if (next_kernel!=s->mc_filter_uv_b0)
++      {
++        this_u_dst = compute_arm_addr(s,p[10],1);
++        this_v_dst = compute_arm_addr(s,p[11],2);
++      }
++      for (y=0; y<height; ++y) {
++        for (x=0; x<width; ++x) {
++          if (next_kernel==s->mc_filter_uv) {
++            int32_t refa = filter8_chroma(ref_u_base,x+x0, y+y0, pitch, hcoeffs, vcoeffs, offset_weight_u,offset_before,denom,frame_width,frame_height);
++            int32_t refb = filter8_chroma(ref_v_base,x+x0, y+y0, pitch, hcoeffs, vcoeffs, offset_weight_v,offset_before,denom,frame_width,frame_height);
++            this_u_dst[x+y*dst_pitch] = av_clip_uint8(refa);
++            this_v_dst[x+y*dst_pitch] = av_clip_uint8(refb);
++          } else if (next_kernel==s->mc_filter_uv_b0) {
++            int32_t refa = filter8_chroma(ref_u_base, x+x0, y+y0, pitch, hcoeffs, vcoeffs, 1,0,0,frame_width,frame_height);
++            int32_t refb = filter8_chroma(ref_v_base, x+x0, y+y0, pitch, hcoeffs, vcoeffs, 1,0,0,frame_width,frame_height);
++            tmp_u_dst[x+y*16] = refa;
++            tmp_v_dst[x+y*16] = refb;
++          } else {
++            int32_t refa = filter8_chroma(ref_u_base, x+x0, y+y0, pitch, hcoeffs, vcoeffs, 1, 64 + tmp_u_dst[x+y*16], 7, frame_width, frame_height);
++            int32_t refb = filter8_chroma(ref_v_base, x+x0, y+y0, pitch, hcoeffs, vcoeffs, 1, 64 + tmp_v_dst[x+y*16], 7, frame_width, frame_height);
++            this_u_dst[x+y*dst_pitch] = av_clip_uint8(refa);
++            this_v_dst[x+y*dst_pitch] = av_clip_uint8(refb);
++          }
++        }
++      }
++    } else {
++      av_assert0(next_kernel==qpu_get_fn(QPU_MC_INTERRUPT_EXIT8) || next_kernel==qpu_get_fn(QPU_MC_EXIT) );
++      break;
++    }
++  }
++}
++
++// mc_setup(y_x, ref_y_base, y2_x2, ref_y2_base, frame_width_height, pitch, dst_pitch, offset_shift, next_kernel)
++static void rpi_simulate_inter_luma(HEVCContext *s,uint32_t *p)
++{
++  uint32_t next_kernel;
++  int y_x,y2_x2;
++  uint32_t x0;
++  uint32_t y0;
++  uint32_t x2;
++  uint32_t y2;
++  uint8_t *ref_y_base;
++  uint8_t *ref_y2_base;
++  uint32_t frame_width_height = p[4];
++  uint32_t frame_width = frame_width_height>>16;
++  uint32_t frame_height = (frame_width_height<<16)>>16;
++  uint32_t pitch = p[5];
++  uint32_t dst_pitch = p[6];
++  int offset_shift = p[7];
++  int32_t offset_before = offset_shift>>16;
++  int32_t denom = (offset_shift<<16)>>16;
++  while(1) {
++    p += 9;
++    next_kernel = p[8-9];
++    y_x = p[0-9];
++    x0 = (y_x<<16)>>16;
++    y0 = y_x>>16;
++    y2_x2 = p[2-9];
++    x2 = (y2_x2<<16)>>16;
++    y2 = y2_x2>>16;
++
++    if (next_kernel==s->mc_filter || next_kernel==s->mc_filter_b) {
++      // y_x, frame_base, y2_x2, frame_base2, width_height, my2_mx2_my_mx, offsetweight0, this_dst, next_kernel)
++      int x,y;
++      uint32_t width_height = p[4];
++      uint32_t my2_mx2_my_mx = p[5];
++      uint32_t offset_weight = p[6];
++      uint8_t *this_dst = compute_arm_addr(s,p[7],0);
++      uint32_t width = width_height >> 16;
++      uint32_t height = (width_height << 16) >> 16;
++      ref_y_base = compute_arm_addr(s,p[1-9],0);
++      ref_y2_base = compute_arm_addr(s,p[3-9],0);
++      for (y=0; y<height; ++y) {
++        for (x=0; x<width; ++x) {
++          if (next_kernel==s->mc_filter) {
++            int32_t refa = filter8_luma(ref_y_base,x+x0, y+y0, pitch, my2_mx2_my_mx, offset_weight,offset_before,denom,frame_width,frame_height);
++            this_dst[x+y*dst_pitch] = av_clip_uint8(refa);
++          }
++          else {
++            int32_t refa = filter8_luma(ref_y_base, x+x0, y+y0, pitch, my2_mx2_my_mx, 1, 0, 0, frame_width, frame_height);
++            int32_t refb = filter8_luma(ref_y2_base, x+x2, y+y2, pitch, my2_mx2_my_mx>>16, 1, 64 + refa, 7, frame_width, frame_height);
++            this_dst[x+y*dst_pitch] = av_clip_uint8(refb);
++          }
++        }
++      }
++    } else {
++      av_assert0(next_kernel==qpu_get_fn(QPU_MC_INTERRUPT_EXIT12) || next_kernel==qpu_get_fn(QPU_MC_EXIT) );
++      break;
++    }
++  }
++}
++
++static void rpi_simulate_inter_qpu(HEVCContext *s)
++{
++  // First run the transform as normal
++  int i;
++  rpi_execute_transform(s);
++  for(i=0;i<8;i++)
++  {
++    rpi_simulate_inter_chroma(s,s->mvs_base[i]);
++  }
++  for(i=0;i<12;i++)
++  {
++    rpi_simulate_inter_luma(s,s->y_mvs_base[i]);
++  }
++}
++
++#endif
++
++
+ static void rpi_execute_inter_qpu(HEVCContext *s)
+ {
+     int k;
+@@ -3006,7 +3273,7 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
+         s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for V
+-        assert(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
++        av_assert0(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
+     }
+ 
+     s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+@@ -3016,11 +3283,16 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+         s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+1] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
+         s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for second request
+         s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+-        assert(s->y_mvs[k] - s->y_mvs_base[k] < Y_COMMANDS_PER_QPU);
++        av_assert0(s->y_mvs[k] - s->y_mvs_base[k] < Y_COMMANDS_PER_QPU);
+     }
+     s->y_mvs[12-1][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT12); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+ #endif
+ 
++#ifdef RPI_SIMULATE_QPUS
++    rpi_simulate_inter_qpu(s);
++    s->vpu_id = -1;
++    return;
++#endif
+ 
+ #ifdef RPI_MULTI_MAILBOX
+ #ifdef RPI_CACHE_UNIF_MVS
+@@ -3101,7 +3373,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+                     && s->ps.pps->num_tile_rows <= 1 && s->ps.pps->num_tile_columns <= 1;
+ #endif
+ 
+-    /*if (!s->enable_rpi) {
++    if (!s->enable_rpi) {
+       if (s->ps.pps->cross_component_prediction_enabled_flag)
+         printf("Cross component\n");
+       if (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)
+@@ -3110,7 +3382,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         printf("Weighted P slice\n");
+       if (s->ps.pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE)
+         printf("Weighted B slice\n");
+-    }*/
++    }
+ 
+ #endif
+ 
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index e12304b..4480f72 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -13,7 +13,7 @@
+ #include <stdlib.h>
+ #include <string.h>
+ #include <stddef.h>
+-#include <assert.h>
++#include "libavutil/avassert.h"
+ 
+ #include "config.h"
+ 
+@@ -160,13 +160,13 @@ static int gpu_init(volatile struct GPU **gpu) {
+   // Now copy over the QPU code into GPU memory
+   {
+     int num_bytes = qpu_get_fn(QPU_MC_END) - qpu_get_fn(QPU_MC_SETUP_UV);
+-    assert(num_bytes<=QPU_CODE_SIZE*sizeof(unsigned int));
++    av_assert0(num_bytes<=QPU_CODE_SIZE*sizeof(unsigned int));
+     memcpy((void*)ptr->qpu_code, rpi_shader, num_bytes);
+   }
+   // And the VPU code
+   {
+     int num_bytes = sizeof(rpi_hevc_transform);
+-    assert(num_bytes<=VPU_CODE_SIZE*sizeof(unsigned int));
++    av_assert0(num_bytes<=VPU_CODE_SIZE*sizeof(unsigned int));
+     memcpy((void*)ptr->vpu_code, rpi_hevc_transform, num_bytes);
+   }
+   // And the transform coefficients
+@@ -216,13 +216,13 @@ static void gpu_unlock(void) {
+ static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb) {
+   p->numbytes = numbytes;
+   p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
+-  assert(p->vcsm_handle);
++  av_assert0(p->vcsm_handle);
+   p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
+-  assert(p->vc_handle);
++  av_assert0(p->vc_handle);
+   p->arm = vcsm_lock(p->vcsm_handle);
+-  assert(p->arm);
++  av_assert0(p->arm);
+   p->vc = mem_lock(mb, p->vc_handle);
+-  assert(p->vc);
++  av_assert0(p->vc);
+   return 0;
+ }
+ 
+@@ -243,7 +243,7 @@ int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p)
+ 
+ int gpu_get_mailbox(void)
+ {
+-  assert(gpu);
++  av_assert0(gpu);
+   return gpu->mb;
+ }
+ 
+@@ -297,13 +297,13 @@ static int gpu_malloc_cached_internal(int numbytes, GPU_MEM_PTR_T *p) {
+   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_VC, (char *)"Video Frame" );
+   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Video Frame" );
+   //p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_HOST_AND_VC, (char *)"Video Frame" );
+-  assert(p->vcsm_handle);
++  av_assert0(p->vcsm_handle);
+   p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
+-  assert(p->vc_handle);
++  av_assert0(p->vc_handle);
+   p->arm = vcsm_lock(p->vcsm_handle);
+-  assert(p->arm);
++  av_assert0(p->arm);
+   p->vc = mem_lock(gpu->mb, p->vc_handle);
+-  assert(p->vc);
++  av_assert0(p->vc);
+   return 0;
+ }
+ 
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 60d1ec2..0686249 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -149,8 +149,8 @@ add t0s, r0, r1 ; mov ra_frame_base, r2
+ add t1s, r2, r1
+ 
+ mov r2,8
+-shl rb12,unif, r2 # offset before shift
+-add rb13,unif,r2  # offset after shift
++shl rb12,unif,r2 # offset before shift
++add rb13,unif,r2  # denominator
+ 
+ # Compute part of VPM to use for DMA output
+ mov r2, unif
+@@ -185,7 +185,7 @@ add t1s, r1, ra_frame_base
+ 
+ ################################################################################
+ 
+-# mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, height, hcoeffs[0], hcoeffs[1], vcoeffs[0], vcoeffs[1], this_u_dst, this_v_dst)
++# mc_filter_uv(next_kernel, x, y, frame_u_base, frame_v_base, width_height, hcoeffs, vcoeffs, offset_weight_u, offset_weight_v, this_u_dst, this_v_dst)
+ 
+ # At this point we have already issued two pairs of texture requests for the current block
+ # ra_x, ra_x16_base point to the current coordinates for this block
+-- 
+2.7.4
+
+
+From 8bdf6b06c612ff4971c2ce99a62d093cf92468ca Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Tue, 2 Jun 2015 13:17:50 +0100
+Subject: [PATCH 49/68] Increased motion vector memory and fixed block size
+ computation for non-multiple of 2 block sizes
+
+---
+ libavcodec/hevc.c | 50 +++++++++++++++++++++++++++++++-------------------
+ 1 file changed, 31 insertions(+), 19 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 34d92e2..3fb1e2a 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -83,11 +83,9 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ 
+ // Split image of 2048 into parts 64 wide
+ // So some QPUs will have 3 blocks of 64 to do, and others 2 blocks for an image 2048 wide with 32 blocks across
+-// Each block of 64*64
+-// Smallest CTU size is 16x16, so smallest block is 8x8
+-// Corresponds to a total of 83kbytes over all 12 QPUs
++// For each block of 64*64 the smallest block size is 8x4
+ #define RPI_LUMA_COMMAND_WORDS 9
+-#define Y_COMMANDS_PER_QPU ((1+3*(64*64)/(8*8)) * RPI_LUMA_COMMAND_WORDS)
++#define Y_COMMANDS_PER_QPU ((1+3*(64*64)/(8*4)) * RPI_LUMA_COMMAND_WORDS)
+ 
+ #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
+ 
+@@ -2042,11 +2040,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+             uint32_t *y = s->y_mvs[chan % 12];
+             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+               for(int start_x=0;start_x < nPbW;start_x+=16) {
++                  int bw = nPbW-start_x;
++                  int bh = nPbH-start_y;
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
+-                  *y++ = ( (nPbW<16 ? nPbW : 16) << 16 ) + (nPbH<16 ? nPbH : 16);
++                  *y++ = ( (bw<16 ? bw : 16) << 16 ) + (bh<16 ? bh : 16);
+                   *y++ = my2_mx2_my_mx;
+                   if (weight_flag) {
+                       *y++ = (s->sh.luma_offset_l0[current_mv.ref_idx[reflist]] << 16) + (s->sh.luma_weight_l0[current_mv.ref_idx[reflist]] & 0xffff);
+@@ -2089,12 +2089,14 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 uint32_t *u = s->u_mvs[chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
++                      int bw = nPbW_c-start_x;
++                      int bh = nPbH_c-start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
+-                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
++                      *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
+                       *u++ = rpi_filter_coefs[_mx][0];
+                       *u++ = rpi_filter_coefs[_my][0];
+                       if (weight_flag) {
+@@ -2141,11 +2143,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+             uint32_t *y = s->y_mvs[chan % 12];
+             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+               for(int start_x=0;start_x < nPbW;start_x+=16) {
++                  int bw = nPbW-start_x;
++                  int bh = nPbH-start_y;
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
+-                  *y++ = ( (nPbW<16 ? nPbW : 16) << 16 ) + (nPbH<16 ? nPbH : 16);
++                  *y++ = ( (bw<16 ? bw : 16) << 16 ) + (bh<16 ? bh : 16);
+                   *y++ = my2_mx2_my_mx;
+                   if (weight_flag) {
+                       *y++ = (s->sh.luma_offset_l0[current_mv.ref_idx[reflist]] << 16) + (s->sh.luma_weight_l0[current_mv.ref_idx[reflist]] & 0xffff);
+@@ -2189,12 +2193,14 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 uint32_t *u = s->u_mvs[chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
++                      int bw = nPbW_c-start_x;
++                      int bh = nPbH_c-start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
+-                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
++                      *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
+                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                       *u++ = rpi_filter_coefs[_mx][0];
+                       *u++ = rpi_filter_coefs[_my][0];
+@@ -2246,11 +2252,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+             uint32_t *y = s->y_mvs[chan % 12];
+             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+               for(int start_x=0;start_x < nPbW;start_x+=8) { // B blocks work 8 at a time
++                  int bw = nPbW-start_x;
++                  int bh = nPbH-start_y;
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y2 - 3 + start_y) << 16) + ( (x2 - 3 + start_x) & 0xffff); // Second fetch is for ref1
+                   y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
+-                  *y++ = ( (nPbW<8 ? nPbW : 8) << 16 ) + (nPbH<16 ? nPbH : 16);
++                  *y++ = ( (bw<8 ? bw : 8) << 16 ) + (bh<16 ? bh : 16);
+                   *y++ = my2_mx2_my_mx;
+                   *y++ = 1; // B frame weighted prediction not supported
+                   *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
+@@ -2293,12 +2301,14 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 uint32_t *u = s->u_mvs[chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
++                      int bw = nPbW_c-start_x;
++                      int bh = nPbH_c-start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b0;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
+-                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
++                      *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
+                       *u++ = rpi_filter_coefs[_mx][0];
+                       *u++ = rpi_filter_coefs[_my][0];
+                       u+=2; // Weights not supported in B slices
+@@ -2309,7 +2319,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = y2_c - 1 + start_y;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
+-                      *u++ = ( (nPbW_c<RPI_CHROMA_BLOCK_WIDTH ? nPbW_c : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (nPbH_c<16 ? nPbH_c : 16);
++                      *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
+                       *u++ = rpi_filter_coefs[_mx2][0];
+                       *u++ = rpi_filter_coefs[_my2][0];
+                       u+=2; // Weights not supported in B slices
+@@ -3178,14 +3188,15 @@ static void rpi_simulate_inter_chroma(HEVCContext *s,uint32_t *p)
+ }
+ 
+ // mc_setup(y_x, ref_y_base, y2_x2, ref_y2_base, frame_width_height, pitch, dst_pitch, offset_shift, next_kernel)
+-static void rpi_simulate_inter_luma(HEVCContext *s,uint32_t *p)
++static void rpi_simulate_inter_luma(HEVCContext *s,uint32_t *p,int chan)
+ {
+   uint32_t next_kernel;
+   int y_x,y2_x2;
+-  uint32_t x0;
+-  uint32_t y0;
+-  uint32_t x2;
+-  uint32_t y2;
++  int x0;
++  int y0;
++  int x2;
++  int y2;
++  uint32_t *p0 = p;
+   uint8_t *ref_y_base;
+   uint8_t *ref_y2_base;
+   uint32_t frame_width_height = p[4];
+@@ -3215,13 +3226,15 @@ static void rpi_simulate_inter_luma(HEVCContext *s,uint32_t *p)
+       uint8_t *this_dst = compute_arm_addr(s,p[7],0);
+       uint32_t width = width_height >> 16;
+       uint32_t height = (width_height << 16) >> 16;
++      uint8_t *dst_base = s->frame->data[0];
+       ref_y_base = compute_arm_addr(s,p[1-9],0);
+       ref_y2_base = compute_arm_addr(s,p[3-9],0);
+       for (y=0; y<height; ++y) {
+         for (x=0; x<width; ++x) {
+           if (next_kernel==s->mc_filter) {
+             int32_t refa = filter8_luma(ref_y_base,x+x0, y+y0, pitch, my2_mx2_my_mx, offset_weight,offset_before,denom,frame_width,frame_height);
+-            this_dst[x+y*dst_pitch] = av_clip_uint8(refa);
++            refa = av_clip_uint8(refa);
++            this_dst[x+y*dst_pitch] = refa;
+           }
+           else {
+             int32_t refa = filter8_luma(ref_y_base, x+x0, y+y0, pitch, my2_mx2_my_mx, 1, 0, 0, frame_width, frame_height);
+@@ -3248,7 +3261,7 @@ static void rpi_simulate_inter_qpu(HEVCContext *s)
+   }
+   for(i=0;i<12;i++)
+   {
+-    rpi_simulate_inter_luma(s,s->y_mvs_base[i]);
++    rpi_simulate_inter_luma(s,s->y_mvs_base[i],i);
+   }
+ }
+ 
+@@ -3290,7 +3303,6 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+ 
+ #ifdef RPI_SIMULATE_QPUS
+     rpi_simulate_inter_qpu(s);
+-    s->vpu_id = -1;
+     return;
+ #endif
+ 
+-- 
+2.7.4
+
+
+From da5ae7e96dd961ccc7bc162c8acf336d54a50092 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Tue, 2 Jun 2015 14:36:54 +0100
+Subject: [PATCH 50/68] Added support for skip deblock
+
+---
+ libavcodec/hevc.c        |  5 +++++
+ libavcodec/hevc.h        |  2 ++
+ libavcodec/hevc_filter.c | 14 ++++----------
+ 3 files changed, 11 insertions(+), 10 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 3fb1e2a..0ac4f4c 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -3397,6 +3397,11 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     }
+ 
+ #endif
++    s->used_for_ref = !(s->nal_unit_type == NAL_TRAIL_N ||
++                        s->nal_unit_type == NAL_TSA_N   ||
++                        s->nal_unit_type == NAL_STSA_N  ||
++                        s->nal_unit_type == NAL_RADL_N  ||
++                        s->nal_unit_type == NAL_RASL_N);
+ 
+     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
+         av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n");
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 5df9dcd..5cb90b5 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -890,6 +890,8 @@ typedef struct HEVCContext {
+     int                 width;
+     int                 height;
+ 
++    int used_for_ref;
++
+ #ifdef RPI
+     int enable_rpi;
+     HEVCMvCmd *unif_mv_cmds;
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 11629e4..14a0952 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -512,16 +512,14 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
+                s->ps.pps->transquant_bypass_enable_flag;
+ 
+ #ifdef DISABLE_DEBLOCK_NONREF
+-    if (    s->nal_unit_type == NAL_TRAIL_N ||
+-            s->nal_unit_type == NAL_TSA_N   ||
+-            s->nal_unit_type == NAL_STSA_N  ||
+-            s->nal_unit_type == NAL_RADL_N  ||
+-            s->nal_unit_type == NAL_RASL_N )
++    if (!s->used_for_ref)
+       return; // Don't deblock non-reference frames
+ #endif
+ #ifdef DISABLE_DEBLOCK
+     return;
+ #endif
++    if (!s->used_for_ref && s->avctx->skip_loop_filter >= AVDISCARD_NONREF)
++        return;
+ 
+     if (x0) {
+         left_tc_offset   = s->deblock[ctb - 1].tc_offset;
+@@ -885,11 +883,7 @@ static int ff_hevc_buf_base(AVBufferRef *bref) {
+ 
+ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+ {
+-    if (s->enable_rpi && !(  s->nal_unit_type == NAL_TRAIL_N ||
+-            s->nal_unit_type == NAL_TSA_N   ||
+-            s->nal_unit_type == NAL_STSA_N  ||
+-            s->nal_unit_type == NAL_RADL_N  ||
+-            s->nal_unit_type == NAL_RASL_N )) {
++    if (s->enable_rpi && s->used_for_ref) {
+ #ifdef RPI_FAST_CACHEFLUSH
+         struct vcsm_user_clean_invalid_s iocache = {};
+         int curr_y = ((int *)f->progress->data)[0];
+-- 
+2.7.4
+
+
+From 6401d88c310cd3bfec7be94bf3ceb6d0c5736c7e Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Tue, 2 Jun 2015 15:22:52 +0100
+Subject: [PATCH 51/68] Added support for skip_frame
+
+---
+ libavcodec/hevc.c | 15 ++++++++++-----
+ 1 file changed, 10 insertions(+), 5 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 0ac4f4c..639e4df 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -3397,11 +3397,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     }
+ 
+ #endif
+-    s->used_for_ref = !(s->nal_unit_type == NAL_TRAIL_N ||
+-                        s->nal_unit_type == NAL_TSA_N   ||
+-                        s->nal_unit_type == NAL_STSA_N  ||
+-                        s->nal_unit_type == NAL_RADL_N  ||
+-                        s->nal_unit_type == NAL_RASL_N);
+ 
+     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
+         av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n");
+@@ -3925,6 +3920,16 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
+         if (ret < 0)
+             return ret;
+ 
++        s->used_for_ref = !(s->nal_unit_type == NAL_TRAIL_N ||
++                        s->nal_unit_type == NAL_TSA_N   ||
++                        s->nal_unit_type == NAL_STSA_N  ||
++                        s->nal_unit_type == NAL_RADL_N  ||
++                        s->nal_unit_type == NAL_RASL_N);
++
++        if (!s->used_for_ref && s->avctx->skip_frame >= AVDISCARD_NONREF) {
++            s->is_decoded = 0;
++            break;
++        }
+         if (s->max_ra == INT_MAX) {
+             if (s->nal_unit_type == NAL_CRA_NUT || IS_BLA(s)) {
+                 s->max_ra = s->poc;
+-- 
+2.7.4
+
+
+From d2951e2ca73e234d1b775621e3993948a4a2c8ea Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 3 Jun 2015 09:15:38 +0100
+Subject: [PATCH 52/68] Fixed cache flushing of luma when using old method
+
+---
+ libavcodec/hevc_filter.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 14a0952..b286bbf 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -919,7 +919,7 @@ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+         flush_buffer(s->frame->buf[1]);
+         flush_buffer(s->frame->buf[2]);
+ #ifdef RPI_LUMA_QPU
+-        flush_buffer(s->frame->buf[1]);
++        flush_buffer(s->frame->buf[0]);
+ #endif
+ 
+ #endif
+-- 
+2.7.4
+
+
+From 7ae612e69c1cabcc7d0b37b65efa8c5bdcfa7bf5 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 3 Jun 2015 11:37:27 +0100
+Subject: [PATCH 53/68] Option to parallelise coefficient decode and inter
+ prediction and deblock for each frame
+
+---
+ libavcodec/hevc.c              | 701 +++++++++++++++++++++++++++--------------
+ libavcodec/hevc.h              |  74 +++--
+ libavcodec/hevc_cabac.c        |  12 +-
+ libavcodec/hevcpred_template.c |   5 +-
+ 4 files changed, 522 insertions(+), 270 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 639e4df..12aacc5 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -43,8 +43,6 @@
+ 
+ #ifdef RPI
+   #include "rpi_qpu.h"
+-  // For some unknown reason, the code seems to crash if I do a late malloc
+-  //#define EARLY_MALLOC
+   // Move Inter prediction into separate pass
+   #define RPI_INTER
+ 
+@@ -58,6 +56,21 @@
+ 
+   // Define RPI_SIMULATE_QPUS for debugging to run QPU code on the ARMs
+   //#define RPI_SIMULATE_QPUS
++  #ifdef RPI_WORKER
++    #include "pthread.h"
++  #endif
++
++  static void rpi_execute_dblk_cmds(HEVCContext *s);
++  static void rpi_execute_transform(HEVCContext *s);
++  static void rpi_execute_inter_qpu(HEVCContext *s);
++  static void rpi_execute_pred_cmds(HEVCContext *s);
++  static void rpi_execute_inter_cmds(HEVCContext *s);
++  static void rpi_inter_clear(HEVCContext *s);
++
++  // Define INTER_PASS0 to do inter prediction in first pass
++  //#define INTER_PASS0
++  // Define LAUNCH_PASS0 to launch QPU/VPU from pass0
++  //#define LAUNCH_PASS0
+ 
+ #endif
+ 
+@@ -105,6 +118,143 @@ static uint32_t get_vc_address(AVBufferRef *bref) {
+   GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+   return p->vc;
+ }
++#endif
++
++
++#ifdef RPI_WORKER
++
++//#define LOG_ENTER printf("Enter %s: p0=%d p1=%d (%d jobs) %p\n", __func__,s->pass0_job,s->pass1_job,s->worker_tail-s->worker_head,s);
++//#define LOG_EXIT printf("Exit %s: p0=%d p1=%d (%d jobs) %p\n", __func__,s->pass0_job,s->pass1_job,s->worker_tail-s->worker_head,s);
++
++#define LOG_ENTER
++#define LOG_EXIT
++
++// Call this when we have completed pass0 and wish to trigger pass1 for the current job
++static void worker_submit_job(HEVCContext *s)
++{
++  LOG_ENTER
++  //pthread_mutex_lock(&s->worker_mutex);
++  s->worker_tail++; // This is the only place that can change tail so we do not need the mutex
++  s->pass0_job = (s->pass0_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
++  pthread_cond_broadcast(&s->worker_cond_tail); // Let people know that the tail has moved
++  //pthread_mutex_unlock(&s->worker_mutex);
++  LOG_EXIT
++}
++
++// Call this to say we have completed pass1
++static void worker_complete_middle_job(HEVCContext *s)
++{
++  LOG_ENTER
++  //pthread_mutex_lock(&s->worker_mutex);
++  s->worker_middle++; // This is the only place that can change head so we do not need the mutex
++  s->pass1_job = (s->pass1_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
++  pthread_cond_broadcast(&s->worker_cond_middle); // Let people know that the tail has moved
++  //pthread_mutex_unlock(&s->worker_mutex);
++  LOG_EXIT
++}
++
++// Call this to say we have completed pass2
++static void worker_complete_job(HEVCContext *s)
++{
++  LOG_ENTER
++  //pthread_mutex_lock(&s->worker_mutex);
++  s->worker_head++; // This is the only place that can change head so we do not need the mutex
++  s->pass2_job = (s->pass2_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
++  pthread_cond_broadcast(&s->worker_cond_head); // Let people know that the tail has moved
++  //pthread_mutex_unlock(&s->worker_mutex);
++  LOG_EXIT
++}
++
++// Call this to wait for all jobs to have completed at the end of a frame
++static void worker_wait(HEVCContext *s)
++{
++  LOG_ENTER
++  pthread_mutex_lock(&s->worker_mutex);
++  while( s->worker_head !=s->worker_tail)
++  {
++    pthread_cond_wait(&s->worker_cond_head, &s->worker_mutex);
++  }
++  pthread_mutex_unlock(&s->worker_mutex);
++  LOG_EXIT
++}
++
++// Call worker_pass0_ready to wait until the s->pass0_job slot becomes
++// available to receive the next job.
++static void worker_pass0_ready(HEVCContext *s)
++{
++  LOG_ENTER
++    pthread_mutex_lock(&s->worker_mutex);
++    // tail is number of submitted jobs
++    // head is number of completed jobs
++    // tail-head is number of outstanding jobs in the queue
++    // we need to ensure there is at least 1 space left for us to use
++    while( s->worker_tail - s->worker_head >= RPI_MAX_JOBS)
++    {
++      // Wait until another job is completed
++      pthread_cond_wait(&s->worker_cond_head, &s->worker_mutex);
++    }
++    pthread_mutex_unlock(&s->worker_mutex);
++  LOG_EXIT
++}
++
++static void *worker_start(void *arg)
++{
++  HEVCContext *s = (HEVCContext *)arg;
++  while(1) {
++    pthread_mutex_lock(&s->worker_mutex);
++
++    while( !s->kill_worker && s->worker_tail - s->worker_middle <= 0)
++    {
++      pthread_cond_wait(&s->worker_cond_tail, &s->worker_mutex);
++    }
++    pthread_mutex_unlock(&s->worker_mutex);
++
++    if (s->kill_worker) {
++      break;
++    }
++    LOG_ENTER
++    // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
++#ifndef LAUNCH_PASS0
++    rpi_execute_inter_qpu(s);
++#endif
++#ifndef INTER_PASS0
++    // Perform inter prediction
++    rpi_execute_inter_cmds(s);
++#endif
++    // Wait for transform completion
++    vpu_wait(s->vpu_id);
++
++    worker_complete_middle_job(s);
++    LOG_EXIT
++  }
++  return NULL;
++}
++
++static void *worker_deblock_start(void *arg)
++{
++  HEVCContext *s = (HEVCContext *)arg;
++  while(1) {
++    pthread_mutex_lock(&s->worker_mutex);
++    while( !s->kill_worker && s->worker_middle - s->worker_head <= 0)
++    {
++      pthread_cond_wait(&s->worker_cond_middle, &s->worker_mutex);
++    }
++    pthread_mutex_unlock(&s->worker_mutex);
++
++    if (s->kill_worker) {
++      break;
++    }
++    LOG_ENTER
++    // Perform intra prediction and residual reconstruction
++    rpi_execute_pred_cmds(s);
++    // Perform deblocking for CTBs in this row
++    rpi_execute_dblk_cmds(s);
++
++    worker_complete_job(s);
++    LOG_EXIT
++  }
++  return NULL;
++}
+ 
+ #endif
+ 
+@@ -121,19 +271,18 @@ static uint32_t get_vc_address(AVBufferRef *bref) {
+ static void pic_arrays_free(HEVCContext *s)
+ {
+ #ifdef RPI
+-
+-#ifdef EARLY_MALLOC
+-#else
+-    if (s->coeffs_buf_arm[0]) {
+-      gpu_free(&s->coeffs_buf_default);
+-      s->coeffs_buf_arm[0] = 0;
+-    }
+-    if (s->coeffs_buf_arm[2]) {
+-      gpu_free(&s->coeffs_buf_accelerated);
+-      s->coeffs_buf_arm[2] = 0;
++    int job;
++    for(job=0;job<RPI_MAX_JOBS;job++) {
++      if (s->coeffs_buf_arm[job][0]) {
++        gpu_free(&s->coeffs_buf_default[job]);
++        s->coeffs_buf_arm[job][0] = 0;
++      }
++      if (s->coeffs_buf_arm[job][2]) {
++        gpu_free(&s->coeffs_buf_accelerated[job]);
++        s->coeffs_buf_arm[job][2] = 0;
++      }
+     }
+ #endif
+-#endif
+     av_freep(&s->sao);
+     av_freep(&s->deblock);
+ 
+@@ -171,24 +320,26 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
+     int min_pu_size      = sps->min_pu_width * sps->min_pu_height;
+ 
+ #ifdef RPI
+-#ifdef EARLY_MALLOC
+-#else
+     av_assert0(sps);
+     int coeffs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
+     int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
+-    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
+-    s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
+-    if (!s->coeffs_buf_arm[0])
+-        goto fail;
+-    gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
+-    s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
+-    s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
+-    if (!s->coeffs_buf_arm[2])
+-        goto fail;
+-    s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
+-    s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
+-    printf("Done\n");
+-#endif
++    int job;
++    for(job=0;job<RPI_MAX_JOBS;job++) {
++      printf("Allocated %d\n",coefs_per_row);
++      for(job=0;job<RPI_MAX_JOBS;job++) {
++        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default[job]);
++        s->coeffs_buf_arm[job][0] = (int16_t*) s->coeffs_buf_default[job].arm;
++        if (!s->coeffs_buf_arm[job][0])
++            goto fail;
++        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated[job]);
++        s->coeffs_buf_arm[job][2] = (int16_t*) s->coeffs_buf_accelerated[job].arm;
++        s->coeffs_buf_vc[job][2] = s->coeffs_buf_accelerated[job].vc;
++        if (!s->coeffs_buf_arm[job][2])
++            goto fail;
++        s->coeffs_buf_arm[job][3] = coefs_per_row + s->coeffs_buf_arm[job][2];
++        s->coeffs_buf_vc[job][3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[job][2];
++      }
++    }
+ #endif
+ 
+     s->bs_width  = (width  >> 2) + 1;
+@@ -1036,7 +1187,7 @@ static void rpi_intra_pred(HEVCContext *s, int log2_trafo_size, int x0, int y0,
+ {
+     if (s->enable_rpi) {
+         HEVCLocalContext *lc = s->HEVClc;
+-        HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
++        HEVCPredCmd *cmd = s->univ_pred_cmds[s->pass0_job] + s->num_pred_cmds[s->pass0_job]++;
+         cmd->type = RPI_PRED_INTRA;
+         cmd->size = log2_trafo_size;
+         cmd->c_idx = c_idx;
+@@ -1496,7 +1647,7 @@ static void rpi_luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                         AVFrame *ref, const Mv *mv, int x_off, int y_off,
+                         int block_w, int block_h, int luma_weight, int luma_offset)
+ {
+-    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
++    HEVCMvCmd *cmd = s->unif_mv_cmds[s->pass0_job] + s->num_mv_cmds[s->pass0_job]++;
+     cmd->cmd = RPI_CMD_LUMA_UNI;
+     cmd->dst = dst;
+     cmd->dststride = dststride;
+@@ -1515,7 +1666,7 @@ static void rpi_luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
+                        AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
+                        int block_w, int block_h, AVFrame *ref1, const Mv *mv1, struct MvField *current_mv)
+ {
+-    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
++    HEVCMvCmd *cmd = s->unif_mv_cmds[s->pass0_job] + s->num_mv_cmds[s->pass0_job]++;
+     cmd->cmd = RPI_CMD_LUMA_BI;
+     cmd->dst = dst;
+     cmd->dststride = dststride;
+@@ -1537,7 +1688,7 @@ static void rpi_chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
+                           ptrdiff_t dststride, uint8_t *src0, ptrdiff_t srcstride, int reflist,
+                           int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int chroma_weight, int chroma_offset)
+ {
+-    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
++    HEVCMvCmd *cmd = s->unif_mv_cmds[s->pass0_job] + s->num_mv_cmds[s->pass0_job]++;
+     cmd->cmd = RPI_CMD_CHROMA_UNI;
+     cmd->dst = dst0;
+     cmd->dststride = dststride;
+@@ -1555,7 +1706,7 @@ static void rpi_chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
+ static void rpi_chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVFrame *ref0, AVFrame *ref1,
+                          int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int cidx)
+ {
+-    HEVCMvCmd *cmd = s->unif_mv_cmds + s->num_mv_cmds++;
++    HEVCMvCmd *cmd = s->unif_mv_cmds[s->pass0_job] + s->num_mv_cmds[s->pass0_job]++;
+     cmd->cmd = RPI_CMD_CHROMA_BI+cidx;
+     cmd->dst = dst0;
+     cmd->dststride = dststride;
+@@ -2037,7 +2188,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+             int chan = x0>>6; // 64 wide blocks per QPU
+             int weight_flag = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
+                               (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+-            uint32_t *y = s->y_mvs[chan % 12];
++            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];
+             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+               for(int start_x=0;start_x < nPbW;start_x+=16) {
+                   int bw = nPbW-start_x;
+@@ -2057,7 +2208,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
+                 }
+             }
+-            s->y_mvs[chan % 12] = y;
++            s->y_mvs[s->pass0_job][chan % 12] = y;
+         } else
+ #endif
+         {
+@@ -2086,7 +2237,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 int weight_flag      = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
+                                        (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+ 
+-                uint32_t *u = s->u_mvs[chan & 7];
++                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                       int bw = nPbW_c-start_x;
+@@ -2110,7 +2261,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+                 }
+-                s->u_mvs[chan & 7] = u;
++                s->u_mvs[s->pass0_job][chan & 7] = u;
+                 return;
+             }
+ #endif
+@@ -2140,7 +2291,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+             int chan = x0>>6; // 64 wide blocks per QPU
+             int weight_flag = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
+                               (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+-            uint32_t *y = s->y_mvs[chan % 12];
++            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];
+             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+               for(int start_x=0;start_x < nPbW;start_x+=16) {
+                   int bw = nPbW-start_x;
+@@ -2160,7 +2311,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
+                 }
+             }
+-            s->y_mvs[chan % 12] = y;
++            s->y_mvs[s->pass0_job][chan % 12] = y;
+         } else
+ #endif
+ 
+@@ -2190,7 +2341,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 int weight_flag      = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
+                                        (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+ 
+-                uint32_t *u = s->u_mvs[chan & 7];
++                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                       int bw = nPbW_c-start_x;
+@@ -2215,7 +2366,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+                 }
+-                s->u_mvs[chan & 7] = u;
++                s->u_mvs[s->pass0_job][chan & 7] = u;
+                 return;
+             }
+ #endif
+@@ -2249,7 +2400,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+             int x2 = x0 + (mv2->x >> 2);
+             int y2 = y0 + (mv2->y >> 2);
+             int chan = x0>>6; // 64 wide blocks per QPU
+-            uint32_t *y = s->y_mvs[chan % 12];
++            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];
+             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+               for(int start_x=0;start_x < nPbW;start_x+=8) { // B blocks work 8 at a time
+                   int bw = nPbW-start_x;
+@@ -2265,7 +2416,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter_b;
+                 }
+             }
+-            s->y_mvs[chan % 12] = y;
++            s->y_mvs[s->pass0_job][chan % 12] = y;
+         } else
+ #endif
+         {
+@@ -2298,7 +2449,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+ 
+                 int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+ 
+-                uint32_t *u = s->u_mvs[chan & 7];
++                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                       int bw = nPbW_c-start_x;
+@@ -2327,7 +2478,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+                 }
+-                s->u_mvs[chan & 7] = u;
++                s->u_mvs[s->pass0_job][chan & 7] = u;
+                 return;
+             }
+ #endif
+@@ -2832,40 +2983,54 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
+ static void rpi_execute_dblk_cmds(HEVCContext *s)
+ {
+     int n;
++    int job = s->pass2_job;
+     int ctb_size    = 1 << s->ps.sps->log2_ctb_size;
+-    int (*p)[2] = s->dblk_cmds;
+-    for(n = s->num_dblk_cmds; n>0 ;n--,p++) {
++    int (*p)[2] = s->dblk_cmds[job];
++    for(n = s->num_dblk_cmds[job]; n>0 ;n--,p++) {
+         ff_hevc_hls_filters(s, (*p)[0], (*p)[1], ctb_size);
+     }
+-    s->num_dblk_cmds = 0;
++    s->num_dblk_cmds[job] = 0;
+ }
+ 
+ static void rpi_execute_transform(HEVCContext *s)
+ {
+     int i=2;
++#ifdef LAUNCH_PASS0
++    int job = s->pass0_job;
++#else
++    int job = s->pass1_job;
++#endif
+     //int j;
+     //int16_t *coeffs = s->coeffs_buf_arm[i];
+     //for(j=s->num_coeffs[i]; j > 0; j-= 16*16, coeffs+=16*16) {
+     //    s->hevcdsp.idct[4-2](coeffs, 16);
+     //}
+ 
+-    gpu_cache_flush(&s->coeffs_buf_accelerated);
+-    s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0, &s->coeffs_buf_accelerated);
++    gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
++    s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2],
++                               s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3],
++                               s->num_coeffs[job][3] >> 10, 0, &s->coeffs_buf_accelerated[job]);
+     //vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
+     //gpu_cache_flush(&s->coeffs_buf_accelerated);
+     //vpu_wait(s->vpu_id);
+ 
+     for(i=0;i<4;i++)
+-        s->num_coeffs[i] = 0;
++        s->num_coeffs[job][i] = 0;
+ }
+ 
+ static void rpi_execute_pred_cmds(HEVCContext *s)
+ {
+   int i;
+-  HEVCPredCmd *cmd = s->univ_pred_cmds;
++  int job = s->pass2_job;
++  HEVCPredCmd *cmd = s->univ_pred_cmds[job];
++#ifdef RPI_WORKER
++  HEVCLocalContextIntra *lc = &s->HEVClcIntra;
++#else
+   HEVCLocalContext *lc = s->HEVClc;
++#endif
+ 
+-  for(i = s->num_pred_cmds; i > 0; i--, cmd++) {
++  for(i = s->num_pred_cmds[job]; i > 0; i--, cmd++) {
++      //printf("i=%d cmd=%p job1=%d job0=%d\n",i,cmd,s->pass1_job,s->pass0_job);
+       if (cmd->type == RPI_PRED_INTRA) {
+           lc->tu.intra_pred_mode_c = lc->tu.intra_pred_mode = cmd->mode;
+           lc->na.cand_bottom_left  = (cmd->na >> 4) & 1;
+@@ -2884,21 +3049,26 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
+ #endif
+       }
+   }
+-  s->num_pred_cmds = 0;
++  s->num_pred_cmds[job] = 0;
+ }
+ 
+ static void rpi_execute_inter_cmds(HEVCContext *s)
+ {
+-    HEVCMvCmd *cmd = s->unif_mv_cmds;
++#ifdef INTER_PASS0
++    int job = s->pass0_job;
++#else
++    int job = s->pass1_job;
++#endif
++    HEVCMvCmd *cmd = s->unif_mv_cmds[job];
+     int n,cidx;
+     AVFrame myref;
+     AVFrame myref1;
+     struct MvField mymv;
+-    if (s->num_mv_cmds > RPI_MAX_MV_CMDS) {
++    if (s->num_mv_cmds[job] > RPI_MAX_MV_CMDS) {
+         printf("Overflow inter_cmds\n");
+         exit(-1);
+     }
+-    for(n = s->num_mv_cmds; n>0 ; n--, cmd++) {
++    for(n = s->num_mv_cmds[job]; n>0 ; n--, cmd++) {
+         switch(cmd->cmd) {
+         case RPI_CMD_LUMA_UNI:
+             myref.data[0] = cmd->src;
+@@ -2938,7 +3108,28 @@ static void rpi_execute_inter_cmds(HEVCContext *s)
+             break;
+         }
+     }
+-    s->num_mv_cmds = 0;
++    s->num_mv_cmds[job] = 0;
++}
++
++static void rpi_do_all_passes(HEVCContext *s)
++{
++#ifdef RPI_INTER_QPU
++    // Kick off inter prediction on QPUs
++    rpi_execute_inter_qpu(s);
++#else
++    rpi_execute_transform(s);
++#endif
++    // Perform luma inter prediction
++    rpi_execute_inter_cmds(s);
++    // Wait for transform completion
++    vpu_wait(s->vpu_id);
++    // Perform intra prediction and residual reconstruction
++    rpi_execute_pred_cmds(s);
++    // Perform deblocking for CTBs in this row
++    rpi_execute_dblk_cmds(s);
++#ifdef RPI_INTER_QPU
++    rpi_inter_clear(s);
++#endif
+ }
+ 
+ #endif
+@@ -2946,6 +3137,7 @@ static void rpi_execute_inter_cmds(HEVCContext *s)
+ #ifdef RPI_INTER_QPU
+ static void rpi_inter_clear(HEVCContext *s)
+ {
++    int job = s->pass0_job;
+     int i;
+     int pic_width        = s->ps.sps->width >> s->ps.sps->hshift[1];
+     int pic_height       = s->ps.sps->height >> s->ps.sps->vshift[1];
+@@ -2953,51 +3145,50 @@ static void rpi_inter_clear(HEVCContext *s)
+                            (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+ 
+     for(i=0;i<8;i++) {
+-        s->u_mvs[i] = s->mvs_base[i];
+-        *s->u_mvs[i]++ = 0;
+-        *s->u_mvs[i]++ = 0;
+-        *s->u_mvs[i]++ = 0;
+-        *s->u_mvs[i]++ = 0;
+-        *s->u_mvs[i]++ = 0;
+-        *s->u_mvs[i]++ = pic_width;
+-        *s->u_mvs[i]++ = pic_height;
+-        *s->u_mvs[i]++ = s->frame->linesize[1];
+-        *s->u_mvs[i]++ = s->frame->linesize[2];
++        s->u_mvs[job][i] = s->mvs_base[job][i];
++        *s->u_mvs[job][i]++ = 0;
++        *s->u_mvs[job][i]++ = 0;
++        *s->u_mvs[job][i]++ = 0;
++        *s->u_mvs[job][i]++ = 0;
++        *s->u_mvs[job][i]++ = 0;
++        *s->u_mvs[job][i]++ = pic_width;
++        *s->u_mvs[job][i]++ = pic_height;
++        *s->u_mvs[job][i]++ = s->frame->linesize[1];
++        *s->u_mvs[job][i]++ = s->frame->linesize[2];
+         if (weight_flag) {
+-            *s->u_mvs[i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
+-            *s->u_mvs[i]++ = s->sh.chroma_log2_weight_denom + 6;
++            *s->u_mvs[job][i]++ = 1 << (s->sh.chroma_log2_weight_denom + 6 - 1);
++            *s->u_mvs[job][i]++ = s->sh.chroma_log2_weight_denom + 6;
+         } else {
+-            *s->u_mvs[i]++ = 1 << 5;
+-            *s->u_mvs[i]++ = 6;
++            *s->u_mvs[job][i]++ = 1 << 5;
++            *s->u_mvs[job][i]++ = 6;
+         }
+-        *s->u_mvs[i]++ = i;  // Select section of VPM (avoid collisions with 3d unit)
++        *s->u_mvs[job][i]++ = i;  // Select section of VPM (avoid collisions with 3d unit)
+     }
+ 
+ #ifdef RPI_LUMA_QPU
+     for(i=0;i<12;i++) {
+-        s->y_mvs[i] = s->y_mvs_base[i];
+-        *s->y_mvs[i]++ = 0; // y_x
+-        *s->y_mvs[i]++ = 0; // ref_y_base
+-        *s->y_mvs[i]++ = 0; // y2_x2
+-        *s->y_mvs[i]++ = 0; // ref_y2_base
+-        *s->y_mvs[i]++ = (s->ps.sps->width << 16) + s->ps.sps->height;
+-        *s->y_mvs[i]++ = s->frame->linesize[0]; // pitch
+-        *s->y_mvs[i]++ = s->frame->linesize[0]; // dst_pitch
++        s->y_mvs[job][i] = s->y_mvs_base[job][i];
++        *s->y_mvs[job][i]++ = 0; // y_x
++        *s->y_mvs[job][i]++ = 0; // ref_y_base
++        *s->y_mvs[job][i]++ = 0; // y2_x2
++        *s->y_mvs[job][i]++ = 0; // ref_y2_base
++        *s->y_mvs[job][i]++ = (s->ps.sps->width << 16) + s->ps.sps->height;
++        *s->y_mvs[job][i]++ = s->frame->linesize[0]; // pitch
++        *s->y_mvs[job][i]++ = s->frame->linesize[0]; // dst_pitch
+         if (weight_flag) {
+             int offset = 1 << (s->sh.luma_log2_weight_denom + 6 - 1);
+             int shift = s->sh.luma_log2_weight_denom + 6;
+-            *s->y_mvs[i]++ = (offset << 16) + shift;
++            *s->y_mvs[job][i]++ = (offset << 16) + shift;
+         } else {
+             int offset = 1 << 5;
+             int shift = 6;
+-            *s->y_mvs[i]++ = (offset << 16) + shift;
++            *s->y_mvs[job][i]++ = (offset << 16) + shift;
+         }
+-        *s->y_mvs[i]++ = 0; // Next kernel
++        *s->y_mvs[job][i]++ = 0; // Next kernel
+     }
+ #endif
+ }
+ 
+-
+ #ifdef RPI_SIMULATE_QPUS
+ 
+ static int32_t clipx(int x,int FRAME_WIDTH)
+@@ -3271,10 +3462,15 @@ static void rpi_simulate_inter_qpu(HEVCContext *s)
+ static void rpi_execute_inter_qpu(HEVCContext *s)
+ {
+     int k;
++#ifdef LAUNCH_PASS0
++    int job = s->pass0_job;
++#else
++    int job = s->pass1_job;
++#endif
+     int i;
+-    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr.vc;
++    uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr[job].vc;
+ #ifdef RPI_LUMA_QPU
+-    uint32_t *y_unif_vc = (uint32_t *)s->y_unif_mvs_ptr.vc;
++    uint32_t *y_unif_vc = (uint32_t *)s->y_unif_mvs_ptr[job].vc;
+ #endif
+     if (s->sh.slice_type == I_SLICE) {
+ #ifdef RPI_MULTI_MAILBOX
+@@ -3283,22 +3479,22 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+ #endif
+     }
+     for(k=0;k<8;k++) {
+-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
+-        s->u_mvs[k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for V
+-        av_assert0(s->u_mvs[k] - s->mvs_base[k] < UV_COMMANDS_PER_QPU);
++        s->u_mvs[job][k][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
++        s->u_mvs[job][k][-RPI_CHROMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
++        s->u_mvs[job][k][-RPI_CHROMA_COMMAND_WORDS+4] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for V
++        av_assert0(s->u_mvs[job][k] - s->mvs_base[job][k] < UV_COMMANDS_PER_QPU);
+     }
+ 
+-    s->u_mvs[8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
++    s->u_mvs[job][8-1][-RPI_CHROMA_COMMAND_WORDS] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT8); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+ 
+ #ifdef RPI_LUMA_QPU
+     for(k=0;k<12;k++) {
+-        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+1] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
+-        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for second request
+-        s->y_mvs[k][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
+-        av_assert0(s->y_mvs[k] - s->y_mvs_base[k] < Y_COMMANDS_PER_QPU);
++        s->y_mvs[job][k][-RPI_LUMA_COMMAND_WORDS+1] = qpu_get_fn(QPU_MC_SETUP_UV); // A dummy texture location (maps to our code) - this is needed as the texture requests are pipelined
++        s->y_mvs[job][k][-RPI_LUMA_COMMAND_WORDS+3] = qpu_get_fn(QPU_MC_SETUP_UV); // Also need a dummy for second request
++        s->y_mvs[job][k][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_EXIT); // Add exit command
++        av_assert0(s->y_mvs[job][k] - s->y_mvs_base[job][k] < Y_COMMANDS_PER_QPU);
+     }
+-    s->y_mvs[12-1][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT12); // This QPU will signal interrupt when all others are done and have acquired a semaphore
++    s->y_mvs[job][12-1][-RPI_LUMA_COMMAND_WORDS+8] = qpu_get_fn(QPU_MC_INTERRUPT_EXIT12); // This QPU will signal interrupt when all others are done and have acquired a semaphore
+ #endif
+ 
+ #ifdef RPI_SIMULATE_QPUS
+@@ -3308,34 +3504,34 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+ 
+ #ifdef RPI_MULTI_MAILBOX
+ #ifdef RPI_CACHE_UNIF_MVS
+-    gpu_cache_flush3(&s->coeffs_buf_accelerated,&s->y_unif_mvs_ptr, &s->unif_mvs_ptr);
++    gpu_cache_flush3(&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job]);
+ #else
+-    gpu_cache_flush(&s->coeffs_buf_accelerated);
++    gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
+ #endif
+-    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0,
++    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
+                                    qpu_get_fn(QPU_MC_SETUP_UV),
+-                                   (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-                                   (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-                                   (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-                                   (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-                                   (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-                                   (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-                                   (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-                                   (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[job][1 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[job][2 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[job][3 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[job][4 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[job][5 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[job][6 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(unif_vc+(s->mvs_base[job][7 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+ #ifdef RPI_LUMA_QPU
+                                    qpu_get_fn(QPU_MC_SETUP),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[0 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[1 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[2 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[3 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[4 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[5 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[6 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[7 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[8 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[9 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[10 ] - (uint32_t*)s->y_unif_mvs_ptr.arm)),
+-                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[11 ] - (uint32_t*)s->y_unif_mvs_ptr.arm))
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][0 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][1 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][2 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][3 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][4 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][5 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][6 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][7 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][8 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][9 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][10 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm)),
++                                   (uint32_t)(y_unif_vc+(s->y_mvs_base[job][11 ] - (uint32_t*)s->y_unif_mvs_ptr[job].arm))
+ #else
+                                    0,
+                                    0,0,0,0,
+@@ -3344,17 +3540,17 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+ #endif
+                                  );
+     for(i=0;i<4;i++)
+-        s->num_coeffs[i] = 0;
++        s->num_coeffs[job][i] = 0;
+ #else
+     qpu_run_shader8(qpu_get_fn(QPU_MC_SETUP_UV),
+-      (uint32_t)(unif_vc+(s->mvs_base[0 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-      (uint32_t)(unif_vc+(s->mvs_base[1 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-      (uint32_t)(unif_vc+(s->mvs_base[2 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-      (uint32_t)(unif_vc+(s->mvs_base[3 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-      (uint32_t)(unif_vc+(s->mvs_base[4 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-      (uint32_t)(unif_vc+(s->mvs_base[5 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-      (uint32_t)(unif_vc+(s->mvs_base[6 ] - (uint32_t*)s->unif_mvs_ptr.arm)),
+-      (uint32_t)(unif_vc+(s->mvs_base[7 ] - (uint32_t*)s->unif_mvs_ptr.arm))
++      (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[job][1 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[job][2 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[job][3 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[job][4 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[job][5 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[job][6 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
++      (uint32_t)(unif_vc+(s->mvs_base[job][7 ] - (uint32_t*)s->unif_mvs_ptr[job].arm))
+       );
+ #endif
+ 
+@@ -3411,6 +3607,11 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         }
+     }
+ 
++#ifdef RPI_WORKER
++    s->pass0_job = 0;
++    s->pass1_job = 0;
++    s->pass2_job = 0;
++#endif
+ #ifdef RPI_INTER_QPU
+     rpi_inter_clear(s);
+ #endif
+@@ -3431,46 +3632,42 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;
+ 
+         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
++
+ #ifdef RPI
+         if (s->enable_rpi) {
+-          s->dblk_cmds[s->num_dblk_cmds][0] = x_ctb;
+-          s->dblk_cmds[s->num_dblk_cmds++][1] = y_ctb;
++          s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]][0] = x_ctb;
++          s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]++][1] = y_ctb;
+           if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->ps.sps->width) {
+-            // Transform all blocks
+-            // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+-#ifdef RPI_MULTI_MAILBOX
+-            // Kick off inter prediction on QPUs
+-            rpi_execute_inter_qpu(s);
+-            // Perform luma inter prediction
+-            rpi_execute_inter_cmds(s);
+-#else
+-            rpi_execute_transform(s);
+-            // Perform inter prediction
+-            rpi_execute_inter_cmds(s);
+-#ifdef RPI_INTER_QPU
+-            // Kick off inter prediction on QPUs
+-            rpi_execute_inter_qpu(s);
+-#endif
+-#endif
+-
+-            // Wait for transform completion
+-            vpu_wait(s->vpu_id);
+-
+-            // Copy back reconstructed data
+-            //memcpy(s->frame->data[0],s->dummy.arm,2048*64);
+-            //memcpy(s->frame->data[1],s->dummy.arm,1024*32);
+-            //memcpy(s->frame->data[2],s->dummy.arm,1024*32);
++#ifdef RPI_WORKER
++            if (s->used_for_ref) {
++              // Split work load onto separate threads so we make as rapid progress as possible with this frame
++  #ifdef INTER_PASS0
++              rpi_execute_inter_cmds(s);
++  #endif
++  #ifdef LAUNCH_PASS0
++              rpi_execute_inter_qpu(s);
++  #endif
++              // Pass on this job to worker thread
++              worker_submit_job(s);
++              // Make sure we have space to prepare the next job
++              worker_pass0_ready(s);
+ 
+-            // Perform intra prediction and residual reconstruction
+-            rpi_execute_pred_cmds(s);
+-            // Perform deblocking for CTBs in this row
+-            rpi_execute_dblk_cmds(s);
++              // Prepare the next batch of commands
+ #ifdef RPI_INTER_QPU
+-            rpi_inter_clear(s);
++              rpi_inter_clear(s);
++#endif
++            } else {
++              // Non-ref frame so do it all on this thread
++              rpi_do_all_passes(s);
++            }
++#else
++            rpi_do_all_passes(s);
+ #endif
+           }
+         }
+ #endif
++
++
+         if (more_data < 0) {
+             s->tab_slice_address[ctb_addr_rs] = -1;
+             return more_data;
+@@ -3487,18 +3684,21 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     }
+ 
+ #ifdef RPI
+-    if (s->enable_rpi && s->num_dblk_cmds) {
+-#ifdef RPI_INTER_QPU
+-        rpi_execute_inter_qpu(s);
+-#endif
+-#ifndef RPI_MULTI_MAILBOX
+-        rpi_execute_transform(s);
++
++#ifdef RPI_WORKER
++    // Wait for the worker to finish all its jobs
++    if (s->enable_rpi) {
++        worker_wait(s);
++        av_assert0(s->pass0_job==s->pass1_job);
++        av_assert0(s->pass1_job==s->pass2_job);
++    }
+ #endif
+-        rpi_execute_inter_cmds(s);
+-        vpu_wait(s->vpu_id);
+-        rpi_execute_pred_cmds(s);
+-        rpi_execute_dblk_cmds(s);
++
++    // Finish off any half-completed rows
++    if (s->enable_rpi && s->num_dblk_cmds[s->pass0_job]) {
++        rpi_do_all_passes(s);
+     }
++
+ #endif
+ 
+     if (x_ctb + ctb_size >= s->ps.sps->width &&
+@@ -4230,6 +4430,48 @@ fail:
+     return AVERROR(ENOMEM);
+ }
+ 
++#ifdef RPI_WORKER
++static av_cold void hevc_init_worker(HEVCContext *s)
++{
++    int err;
++    pthread_cond_init(&s->worker_cond_head, NULL);
++    pthread_cond_init(&s->worker_cond_middle, NULL);
++    pthread_cond_init(&s->worker_cond_tail, NULL);
++    pthread_mutex_init(&s->worker_mutex, NULL);
++
++    s->worker_tail=0;
++    s->worker_middle=0;
++    s->worker_head=0;
++    s->kill_worker=0;
++    err = pthread_create(&s->worker_thread, NULL, worker_start, s);
++    err = pthread_create(&s->worker_deblock_thread, NULL, worker_deblock_start, s);
++    if (err) {
++        printf("Failed to create worker thread\n");
++        exit(-1);
++    }
++}
++
++static av_cold void hevc_exit_worker(HEVCContext *s)
++{
++    void *res;
++    s->kill_worker=1;
++    pthread_cond_broadcast(&s->worker_cond_tail);
++    pthread_cond_broadcast(&s->worker_cond_middle);
++    pthread_join(s->worker_thread, &res);
++    pthread_join(s->worker_deblock_thread, &res);
++
++    pthread_cond_destroy(&s->worker_cond_head);
++    pthread_cond_destroy(&s->worker_cond_middle);
++    pthread_cond_destroy(&s->worker_cond_tail);
++    pthread_mutex_destroy(&s->worker_mutex);
++
++    s->worker_tail=0;
++    s->worker_middle=0;
++    s->worker_head=0;
++    s->kill_worker=0;
++}
++#endif
++
+ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+ {
+     HEVCContext       *s = avctx->priv_data;
+@@ -4242,33 +4484,29 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
+     av_freep(&s->cabac_state);
+ 
+ #ifdef RPI
+-    av_freep(&s->unif_mv_cmds);
+-    av_freep(&s->univ_pred_cmds);
++
++#ifdef RPI_WORKER
++    hevc_exit_worker(s);
++#endif
++
++    for(i=0;i<RPI_MAX_JOBS;i++) {
++      av_freep(&s->unif_mv_cmds[i]);
++      av_freep(&s->univ_pred_cmds[i]);
+ 
+ #ifdef RPI_INTER_QPU
+-    if (s->unif_mvs) {
+-        gpu_free( &s->unif_mvs_ptr );
+-        s->unif_mvs = 0;
+-    }
++      if (s->unif_mvs[i]) {
++        gpu_free( &s->unif_mvs_ptr[i] );
++        s->unif_mvs[i] = 0;
++      }
+ #endif
+ #ifdef RPI_LUMA_QPU
+-    if (s->y_unif_mvs) {
+-        gpu_free( &s->y_unif_mvs_ptr );
+-        s->y_unif_mvs = 0;
+-    }
++      if (s->y_unif_mvs[i]) {
++        gpu_free( &s->y_unif_mvs_ptr[i] );
++        s->y_unif_mvs[i] = 0;
++      }
+ #endif
+-
+-#ifdef EARLY_MALLOC
+-    printf("hevc_decode_free\n");
+-    if (s->coeffs_buf_arm[0]) {
+-      gpu_free(&s->coeffs_buf_default);
+-      s->coeffs_buf_arm[0] = 0;
+-    }
+-    if (s->coeffs_buf_arm[2]) {
+-      gpu_free(&s->coeffs_buf_accelerated);
+-      s->coeffs_buf_arm[2] = 0;
+     }
+-#endif
++
+ #endif
+ 
+     for (i = 0; i < 3; i++) {
+@@ -4328,6 +4566,7 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+ {
+     HEVCContext *s = avctx->priv_data;
+     int i;
++    int job;
+ 
+     s->avctx = avctx;
+ 
+@@ -4338,12 +4577,14 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     s->sList[0] = s;
+ 
+ #ifdef RPI
+-    s->unif_mv_cmds = av_mallocz(sizeof(HEVCMvCmd)*RPI_MAX_MV_CMDS);
+-    if (!s->unif_mv_cmds)
+-        goto fail;
+-    s->univ_pred_cmds = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
+-    if (!s->univ_pred_cmds)
+-        goto fail;
++    for(job=0;job<RPI_MAX_JOBS;job++) {
++        s->unif_mv_cmds[job] = av_mallocz(sizeof(HEVCMvCmd)*RPI_MAX_MV_CMDS);
++        if (!s->unif_mv_cmds[job])
++            goto fail;
++        s->univ_pred_cmds[job] = av_mallocz(sizeof(HEVCPredCmd)*RPI_MAX_PRED_CMDS);
++        if (!s->univ_pred_cmds[job])
++            goto fail;
++    }
+ 
+ #ifdef RPI_INTER_QPU
+     // We divide the image into blocks 256 wide and 64 high
+@@ -4354,18 +4595,20 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     {
+         int uv_commands_per_qpu = UV_COMMANDS_PER_QPU;
+         uint32_t *p;
++		for(job=0;job<RPI_MAX_JOBS;job++) {
+ #ifdef RPI_CACHE_UNIF_MVS
+-        gpu_malloc_cached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
++          gpu_malloc_cached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr[job] );
+ #else
+-        gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr );
++          gpu_malloc_uncached( 8 * uv_commands_per_qpu * sizeof(uint32_t), &s->unif_mvs_ptr[job] );
+ #endif
+-        s->unif_mvs = (uint32_t *) s->unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
++          s->unif_mvs[job] = (uint32_t *) s->unif_mvs_ptr[job].arm;
+ 
+-        // Set up initial locations for uniform streams
+-        p = s->unif_mvs;
+-        for(i = 0; i < 8; i++) {
+-            s->mvs_base[i] = p;
++          // Set up initial locations for uniform streams
++          p = s->unif_mvs[job];
++          for(i = 0; i < 8; i++) {
++            s->mvs_base[job][i] = p;
+             p += uv_commands_per_qpu;
++          }
+         }
+         s->mc_filter_uv = qpu_get_fn(QPU_MC_FILTER_UV);
+         s->mc_filter_uv_b0 = qpu_get_fn(QPU_MC_FILTER_UV_B0);
+@@ -4374,61 +4617,35 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
+     }
+ #endif
+ #ifdef RPI_LUMA_QPU
++    for(job=0;job<RPI_MAX_JOBS;job++)
+     {
+         int y_commands_per_qpu = Y_COMMANDS_PER_QPU;
+         uint32_t *p;
+ #ifdef RPI_CACHE_UNIF_MVS
+-        gpu_malloc_cached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr );
++        gpu_malloc_cached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr[job] );
+ #else
+-        gpu_malloc_uncached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr );
++        gpu_malloc_uncached( 12 * y_commands_per_qpu * sizeof(uint32_t), &s->y_unif_mvs_ptr[job] );
+ #endif
+-        s->y_unif_mvs = (uint32_t *) s->y_unif_mvs_ptr.arm; // TODO support this allocation in non EARLY_MALLOC
++        s->y_unif_mvs[job] = (uint32_t *) s->y_unif_mvs_ptr[job].arm;
+ 
+         // Set up initial locations for uniform streams
+-        p = s->y_unif_mvs;
++        p = s->y_unif_mvs[job];
+         for(i = 0; i < 12; i++) {
+-            s->y_mvs_base[i] = p;
++            s->y_mvs_base[job][i] = p;
+             p += y_commands_per_qpu;
+         }
+-        s->mc_filter = qpu_get_fn(QPU_MC_FILTER);
+-        s->mc_filter_b = qpu_get_fn(QPU_MC_FILTER_B);
+-
+     }
++    s->mc_filter = qpu_get_fn(QPU_MC_FILTER);
++    s->mc_filter_b = qpu_get_fn(QPU_MC_FILTER_B);
+ #endif
+     //gpu_malloc_uncached(2048*64,&s->dummy);
+ 
+-#ifdef EARLY_MALLOC
+-    {
+-        int coeffs_in_ctb = 64*64;
+-        int coefs_per_row = (2048/64) * coeffs_in_ctb * 3;  // Allow space for chroma
+-        s->coeffs_buf_arm[0] = 0;
+-        s->coeffs_buf_arm[2] = 0;
+-        printf("Allocated %d\n",coefs_per_row);
+-        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row, &s->coeffs_buf_default);
+-        s->coeffs_buf_arm[0] = (int16_t*) s->coeffs_buf_default.arm;
+-        if (!s->coeffs_buf_arm[0])
+-            goto fail;
+-        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated);
+-        s->coeffs_buf_arm[2] = (int16_t*) s->coeffs_buf_accelerated.arm;
+-        s->coeffs_buf_vc[2] = s->coeffs_buf_accelerated.vc;
+-        if (!s->coeffs_buf_arm[2])
+-            goto fail;
+-        s->coeffs_buf_arm[3] = coefs_per_row + s->coeffs_buf_arm[2];
+-        s->coeffs_buf_vc[3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[2];
+-        printf("Done\n");
+-#ifdef RPI_PRECLEAR
+-        //memset(s->coeffs_buf_arm[0],0, sizeof(int16_t) * coefs_per_row);
+-        memclear16(s->coeffs_buf_arm[0], coefs_per_row);
+-        //memset(s->coeffs_buf_arm[2],0, sizeof(int16_t) * coefs_per_row);
+-        memclear16(s->coeffs_buf_arm[2], coefs_per_row);
+-        //memset(s->coeffs_buf_arm[3],0, sizeof(int16_t) * coefs_per_row);
+-        memclear16(s->coeffs_buf_arm[3], coefs_per_row);
+-#endif
+-    }
+-#endif
+-
+     s->enable_rpi = 0;
+ 
++#ifdef RPI_WORKER
++    hevc_init_worker(s);
++#endif
++
+ #endif
+ 
+     s->cabac_state = av_malloc(HEVC_CONTEXTS);
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 5cb90b5..7bd295a 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -51,6 +51,12 @@
+     // Define RPI_LUMA_QPU to also use QPU for luma inter prediction
+     #define RPI_LUMA_QPU
+   #endif
++
++  // By passing jobs to a worker thread we hope to be able to catch up during slow frames
++  #define RPI_MAX_JOBS 2
++  // Define RPI_WORKER to launch a worker thread for pixel processing tasks
++  #define RPI_WORKER
++
+ #endif
+ 
+ #define MAX_DPB_SIZE 16 // A.4.1
+@@ -806,6 +812,13 @@ typedef struct HEVCLocalContext {
+     int boundary_flags;
+ } HEVCLocalContext;
+ 
++#ifdef RPI_WORKER
++typedef struct HEVCLocalContextIntra {
++    TransformUnit tu;
++    NeighbourAvailable na;
++} HEVCLocalContextIntra;
++#endif
++
+ #ifdef RPI
+ 
+ // RPI_MAX_WIDTH is maximum width in pixels supported by the accelerated code
+@@ -874,7 +887,7 @@ typedef struct HEVCPredCmd {
+ 
+ typedef struct HEVCContext {
+ #ifdef RPI
+-    int dblk_cmds[RPI_MAX_DEBLOCK_CMDS][2];
++    int dblk_cmds[RPI_MAX_JOBS][RPI_MAX_DEBLOCK_CMDS][2];
+ #endif
+     const AVClass *c;  // needed by private avoptions
+     AVCodecContext *avctx;
+@@ -883,7 +896,9 @@ typedef struct HEVCContext {
+ 
+     HEVCLocalContext    *HEVClcList[MAX_NB_THREADS];
+     HEVCLocalContext    *HEVClc;
+-
++#ifdef RPI_WORKER
++    HEVCLocalContextIntra HEVClcIntra;
++#endif
+     uint8_t             threads_type;
+     uint8_t             threads_number;
+ 
+@@ -894,43 +909,60 @@ typedef struct HEVCContext {
+ 
+ #ifdef RPI
+     int enable_rpi;
+-    HEVCMvCmd *unif_mv_cmds;
+-    HEVCPredCmd *univ_pred_cmds;
++    HEVCMvCmd *unif_mv_cmds[RPI_MAX_JOBS];
++    HEVCPredCmd *univ_pred_cmds[RPI_MAX_JOBS];
+     int buf_width;
+-    GPU_MEM_PTR_T coeffs_buf_default;
+-    GPU_MEM_PTR_T coeffs_buf_accelerated;
+-    int16_t *coeffs_buf_arm[4];
+-    unsigned int coeffs_buf_vc[4];
+-    int num_coeffs[4];
+-    int num_xfm_cmds;
+-    int num_mv_cmds;
+-    int num_pred_cmds;
+-    int num_dblk_cmds;
++    GPU_MEM_PTR_T coeffs_buf_default[RPI_MAX_JOBS];
++    GPU_MEM_PTR_T coeffs_buf_accelerated[RPI_MAX_JOBS];
++    int16_t *coeffs_buf_arm[RPI_MAX_JOBS][4];
++    unsigned int coeffs_buf_vc[RPI_MAX_JOBS][4];
++    int num_coeffs[RPI_MAX_JOBS][4];
++    int num_xfm_cmds[RPI_MAX_JOBS];
++    int num_mv_cmds[RPI_MAX_JOBS];
++    int num_pred_cmds[RPI_MAX_JOBS];
++    int num_dblk_cmds[RPI_MAX_JOBS];
+     int vpu_id;
+     //GPU_MEM_PTR_T dummy;
++    int pass0_job; // Pass0 does coefficient decode
++    int pass1_job; // Pass1 does pixel processing
++    int pass2_job; // Pass2 does reconstruction and deblocking
+ #ifdef RPI_INTER_QPU
+-    GPU_MEM_PTR_T unif_mvs_ptr;
+-    uint32_t *unif_mvs; // Base of memory for motion vector commands
++    GPU_MEM_PTR_T unif_mvs_ptr[RPI_MAX_JOBS];
++    uint32_t *unif_mvs[RPI_MAX_JOBS]; // Base of memory for motion vector commands
+ 
+     // _base pointers are to the start of the row
+-    uint32_t *mvs_base[8];
++    uint32_t *mvs_base[RPI_MAX_JOBS][8];
+     // these pointers are to the next free space
+-    uint32_t *u_mvs[8];
++    uint32_t *u_mvs[RPI_MAX_JOBS][8];
+     // Function pointers
+     uint32_t mc_filter_uv;
+     uint32_t mc_filter_uv_b0;
+     uint32_t mc_filter_uv_b;
+ #endif
+ #ifdef RPI_LUMA_QPU
+-    GPU_MEM_PTR_T y_unif_mvs_ptr;
+-    uint32_t *y_unif_mvs; // Base of memory for motion vector commands
+-    uint32_t *y_mvs_base[12];
+-    uint32_t *y_mvs[12];
++    GPU_MEM_PTR_T y_unif_mvs_ptr[RPI_MAX_JOBS];
++    uint32_t *y_unif_mvs[RPI_MAX_JOBS]; // Base of memory for motion vector commands
++    uint32_t *y_mvs_base[RPI_MAX_JOBS][12];
++    uint32_t *y_mvs[RPI_MAX_JOBS][12];
+     // Function pointers
+     uint32_t mc_filter;
+     uint32_t mc_filter_b;
+ #endif
+ 
++#ifdef RPI_WORKER
++    pthread_t worker_thread;
++    pthread_t worker_deblock_thread;
++    pthread_cond_t worker_cond_head;
++    pthread_cond_t worker_cond_tail;
++    pthread_cond_t worker_cond_middle;
++    pthread_mutex_t worker_mutex;
++
++    int worker_tail; // Contains the number of posted jobs
++    int worker_head; // Contains the number of completed jobs
++    int worker_middle; // Contains the number of completed jobs
++    int kill_worker; // set to 1 to terminate the worker
++#endif
++
+ #endif
+ 
+     uint8_t *cabac_state;
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index 38f53de..f0982cd 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -1051,11 +1051,11 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+     if (s->enable_rpi) {
+         int n = trafo_size * trafo_size;
+         if (use_vpu) {
+-            coeffs = s->coeffs_buf_arm[log2_trafo_size - 2] + s->num_coeffs[log2_trafo_size - 2];
+-            s->num_coeffs[log2_trafo_size - 2] += n;
++            coeffs = s->coeffs_buf_arm[s->pass0_job][log2_trafo_size - 2] + s->num_coeffs[s->pass0_job][log2_trafo_size - 2];
++            s->num_coeffs[s->pass0_job][log2_trafo_size - 2] += n;
+         } else {
+-            coeffs = s->coeffs_buf_arm[0] + s->num_coeffs[0];
+-            s->num_coeffs[0] += n;
++            coeffs = s->coeffs_buf_arm[s->pass0_job][0] + s->num_coeffs[s->pass0_job][0];
++            s->num_coeffs[s->pass0_job][0] += n;
+         }
+     }
+     // We now do the memset after transform_add while we know the data is cached.
+@@ -1508,7 +1508,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+                 s->hevcdsp.transform_rdpcm(coeffs, log2_trafo_size, mode);
+             }
+         } else if (lc->cu.pred_mode == MODE_INTRA && c_idx == 0 && log2_trafo_size == 2) {
+-            s->hevcdsp.idct_4x4_luma(coeffs);
++           s->hevcdsp.idct_4x4_luma(coeffs);
+         } else {
+ #ifdef RPI
+             if (!use_vpu) {
+@@ -1553,7 +1553,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+     }
+ #ifdef RPI
+     if (s->enable_rpi) {
+-        HEVCPredCmd *cmd = s->univ_pred_cmds + s->num_pred_cmds++;
++        HEVCPredCmd *cmd = s->univ_pred_cmds[s->pass0_job] + s->num_pred_cmds[s->pass0_job]++;
+         cmd->type = RPI_PRED_TRANSFORM_ADD;
+         cmd->size = log2_trafo_size;
+         cmd->buf = coeffs;
+diff --git a/libavcodec/hevcpred_template.c b/libavcodec/hevcpred_template.c
+index 71c6d52..344e021 100644
+--- a/libavcodec/hevcpred_template.c
++++ b/libavcodec/hevcpred_template.c
+@@ -71,8 +71,11 @@ do {                                  \
+                 AV_WN4P(&ptr[i], a);                                           \
+             else                                                               \
+                 a = PIXEL_SPLAT_X4(ptr[i + 3])
+-
++#ifdef RPI_WORKER
++    HEVCLocalContextIntra *lc = &s->HEVClcIntra;
++#else
+     HEVCLocalContext *lc = s->HEVClc;
++#endif
+     int i;
+     int hshift = s->ps.sps->hshift[c_idx];
+     int vshift = s->ps.sps->vshift[c_idx];
+-- 
+2.7.4
+
+
+From 1e0885f8d98175777fff65b4cedd708176c2abcf Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 3 Jun 2015 13:43:48 +0100
+Subject: [PATCH 54/68] Avoid lockup bug with RPI_WORKER enabled
+
+---
+ libavcodec/hevc.c       | 22 +++++++++++-----------
+ libavcodec/hevc_cabac.c |  1 -
+ 2 files changed, 11 insertions(+), 12 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 12aacc5..182a82f 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -133,11 +133,11 @@ static uint32_t get_vc_address(AVBufferRef *bref) {
+ static void worker_submit_job(HEVCContext *s)
+ {
+   LOG_ENTER
+-  //pthread_mutex_lock(&s->worker_mutex);
+-  s->worker_tail++; // This is the only place that can change tail so we do not need the mutex
++  pthread_mutex_lock(&s->worker_mutex);
++  s->worker_tail++;
+   s->pass0_job = (s->pass0_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
+   pthread_cond_broadcast(&s->worker_cond_tail); // Let people know that the tail has moved
+-  //pthread_mutex_unlock(&s->worker_mutex);
++  pthread_mutex_unlock(&s->worker_mutex);
+   LOG_EXIT
+ }
+ 
+@@ -145,11 +145,11 @@ static void worker_submit_job(HEVCContext *s)
+ static void worker_complete_middle_job(HEVCContext *s)
+ {
+   LOG_ENTER
+-  //pthread_mutex_lock(&s->worker_mutex);
+-  s->worker_middle++; // This is the only place that can change head so we do not need the mutex
++  pthread_mutex_lock(&s->worker_mutex);
++  s->worker_middle++;
+   s->pass1_job = (s->pass1_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
+-  pthread_cond_broadcast(&s->worker_cond_middle); // Let people know that the tail has moved
+-  //pthread_mutex_unlock(&s->worker_mutex);
++  pthread_cond_broadcast(&s->worker_cond_middle); // Let people know that the middle has moved
++  pthread_mutex_unlock(&s->worker_mutex);
+   LOG_EXIT
+ }
+ 
+@@ -157,11 +157,11 @@ static void worker_complete_middle_job(HEVCContext *s)
+ static void worker_complete_job(HEVCContext *s)
+ {
+   LOG_ENTER
+-  //pthread_mutex_lock(&s->worker_mutex);
+-  s->worker_head++; // This is the only place that can change head so we do not need the mutex
++  pthread_mutex_lock(&s->worker_mutex);
++  s->worker_head++;
+   s->pass2_job = (s->pass2_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
+-  pthread_cond_broadcast(&s->worker_cond_head); // Let people know that the tail has moved
+-  //pthread_mutex_unlock(&s->worker_mutex);
++  pthread_cond_broadcast(&s->worker_cond_head); // Let people know that the head has moved
++  pthread_mutex_unlock(&s->worker_mutex);
+   LOG_EXIT
+ }
+ 
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index f0982cd..6523e66 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -1497,7 +1497,6 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+                 for (i = 0; i < 8; i++)
+                     FFSWAP(int16_t, coeffs[i], coeffs[16 - i - 1]);
+             }
+-
+             s->hevcdsp.transform_skip(coeffs, log2_trafo_size);
+ 
+             if (explicit_rdpcm_flag || (s->ps.sps->implicit_rdpcm_enabled_flag &&
+-- 
+2.7.4
+
+
+From 1d7ad81069dec6914ec7e9983855d7a1b5e4b123 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 3 Jun 2015 15:37:19 +0100
+Subject: [PATCH 55/68] Added code to flush buffers at start of frame
+
+---
+ libavcodec/hevc.c | 72 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 72 insertions(+)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 182a82f..e5b9f1e 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -43,6 +43,7 @@
+ 
+ #ifdef RPI
+   #include "rpi_qpu.h"
++  #include "rpi_user_vcsm.h"
+   // Move Inter prediction into separate pass
+   #define RPI_INTER
+ 
+@@ -3508,6 +3509,7 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+ #else
+     gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
+ #endif
++
+     s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
+                                    qpu_get_fn(QPU_MC_SETUP_UV),
+                                    (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+@@ -3558,6 +3560,71 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+ }
+ #endif
+ 
++#ifdef RPI
++
++static void flush_buffer(AVBufferRef *bref) {
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
++    gpu_cache_flush(p);
++}
++
++static void flush_frame(HEVCContext *s,AVFrame *frame)
++{
++#if 1
++    struct vcsm_user_clean_invalid_s iocache = {};
++    int n = s->ps.sps->height;
++    int curr_y = 0;
++    int curr_uv = 0;
++    int n_uv = n >> s->ps.sps->vshift[1];
++    int sz,base;
++    sz = s->frame->linesize[1] * (n_uv-curr_uv);
++    base = s->frame->linesize[1] * curr_uv;
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
++    iocache.s[0].handle = p->vcsm_handle;
++    iocache.s[0].cmd = 3; // clean+invalidate
++    iocache.s[0].addr = p->arm + base;
++    iocache.s[0].size  = sz;
++    p = av_buffer_pool_opaque(frame->buf[2]);
++    iocache.s[1].handle = p->vcsm_handle;
++    iocache.s[1].cmd = 3; // clean+invalidate
++    iocache.s[1].addr = p->arm + base;
++    iocache.s[1].size  = sz;
++    p = av_buffer_pool_opaque(frame->buf[0]);
++    sz = s->frame->linesize[0] * (n-curr_y);
++    base = s->frame->linesize[0] * curr_y;
++    iocache.s[2].handle = p->vcsm_handle;
++    iocache.s[2].cmd = 3; // clean+invalidate
++    iocache.s[2].addr = p->arm + base;
++    iocache.s[2].size  = sz;
++    vcsm_clean_invalid( &iocache );
++#else
++    flush_buffer(frame->buf[0]);
++    flush_buffer(frame->buf[1]);
++    flush_buffer(frame->buf[2]);
++#endif
++}
++
++static void flush_all(HEVCContext *s)
++{
++#if 0
++    struct vcsm_user_clean_invalid_s iocache = {};
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(s->frame->buf[0]);
++    iocache.s[0].handle = p->vcsm_handle;
++    iocache.s[0].cmd = 4; // Flush all
++    iocache.s[0].addr = p->arm;
++    iocache.s[0].size  = 4096;
++    vcsm_clean_invalid( &iocache );
++#else
++  int i,k;
++  for(i=0;i<2;i++) {
++    for (k = 0; k < s->sh.nb_refs[i]; k++) {
++      flush_frame(s,s->ref->refPicList[i].ref[k]->frame);
++    }
++  }
++  flush_frame(s,s->frame);
++#endif
++}
++#endif
++
+ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ {
+     HEVCContext *s  = avctxt->priv_data;
+@@ -3592,8 +3659,12 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         printf("Weighted B slice\n");
+     }
+ 
++    // Now flush all reference frames and our destination frame to get everything ready for decode
++    flush_all(s);
+ #endif
+ 
++    //printf("L0=%d L1=%d\n",s->sh.nb_refs[L1],s->sh.nb_refs[L1]);
++
+     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
+         av_log(s->avctx, AV_LOG_ERROR, "Impossible initial tile.\n");
+         return AVERROR_INVALIDDATA;
+@@ -3664,6 +3735,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+             rpi_do_all_passes(s);
+ #endif
+           }
++
+         }
+ #endif
+ 
+-- 
+2.7.4
+
+
+From 7a57f233dcd4048e20a0b5bc06bc20abb589d3fa Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 3 Jun 2015 16:42:24 +0100
+Subject: [PATCH 56/68] Reduce the amount that needs to be flushed
+
+---
+ libavcodec/hevc.c | 35 +++++++++++------------------------
+ 1 file changed, 11 insertions(+), 24 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index e5b9f1e..73d7f74 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -3569,7 +3569,7 @@ static void flush_buffer(AVBufferRef *bref) {
+ 
+ static void flush_frame(HEVCContext *s,AVFrame *frame)
+ {
+-#if 1
++#ifdef RPI_FAST_CACHEFLUSH
+     struct vcsm_user_clean_invalid_s iocache = {};
+     int n = s->ps.sps->height;
+     int curr_y = 0;
+@@ -3603,26 +3603,6 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
+ #endif
+ }
+ 
+-static void flush_all(HEVCContext *s)
+-{
+-#if 0
+-    struct vcsm_user_clean_invalid_s iocache = {};
+-    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(s->frame->buf[0]);
+-    iocache.s[0].handle = p->vcsm_handle;
+-    iocache.s[0].cmd = 4; // Flush all
+-    iocache.s[0].addr = p->arm;
+-    iocache.s[0].size  = 4096;
+-    vcsm_clean_invalid( &iocache );
+-#else
+-  int i,k;
+-  for(i=0;i<2;i++) {
+-    for (k = 0; k < s->sh.nb_refs[i]; k++) {
+-      flush_frame(s,s->ref->refPicList[i].ref[k]->frame);
+-    }
+-  }
+-  flush_frame(s,s->frame);
+-#endif
+-}
+ #endif
+ 
+ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+@@ -3658,9 +3638,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+       if (s->ps.pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE)
+         printf("Weighted B slice\n");
+     }
+-
+-    // Now flush all reference frames and our destination frame to get everything ready for decode
+-    flush_all(s);
+ #endif
+ 
+     //printf("L0=%d L1=%d\n",s->sh.nb_refs[L1],s->sh.nb_refs[L1]);
+@@ -4130,6 +4107,11 @@ static int hevc_frame_start(HEVCContext *s)
+     if (!s->avctx->hwaccel)
+         ff_thread_finish_setup(s->avctx);
+ 
++#ifdef RPI_INTER_QPU
++    // Invalidate the output data buffer so it is ready for the QPUs to write into it.
++    flush_frame(s,s->frame);
++#endif
++
+     return 0;
+ 
+ fail:
+@@ -4331,6 +4313,11 @@ fail:
+         ff_hevc_flush_buffer(s, &s->ref->tf, s->ps.sps->height);
+ #endif
+         ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);
++    } else if (s->ref) {
++#ifdef RPI_INTER_QPU
++      // When running single threaded we need to flush the whole frame
++      flush_frame(s,s->frame);
++#endif
+     }
+     return ret;
+ }
+-- 
+2.7.4
+
+
+From 26eba8e3266cc5f2120e8284a1ce486d6a402010 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 4 Jun 2015 07:59:28 +0100
+Subject: [PATCH 57/68] Corrected support for disabled rpi when using
+ RPI_WORKER
+
+---
+ libavcodec/hevc.h              | 18 ++++++++++--------
+ libavcodec/hevcpred_template.c |  2 +-
+ 2 files changed, 11 insertions(+), 9 deletions(-)
+
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 7bd295a..3cb34bd 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -769,7 +769,17 @@ typedef struct HEVCFrame {
+     uint8_t flags;
+ } HEVCFrame;
+ 
++#ifdef RPI_WORKER
++typedef struct HEVCLocalContextIntra {
++    TransformUnit tu;
++    NeighbourAvailable na;
++} HEVCLocalContextIntra;
++#endif
++
+ typedef struct HEVCLocalContext {
++    TransformUnit tu;
++    NeighbourAvailable na;  // WARNING tu and na must be the first two fields to match HEVCLocalContextIntra
++
+     uint8_t cabac_state[HEVC_CONTEXTS];
+ 
+     uint8_t stat_coeff[4];
+@@ -784,7 +794,6 @@ typedef struct HEVCLocalContext {
+ 
+     int qPy_pred;
+ 
+-    TransformUnit tu;
+ 
+     uint8_t ctb_left_flag;
+     uint8_t ctb_up_flag;
+@@ -801,7 +810,6 @@ typedef struct HEVCLocalContext {
+     int ct_depth;
+     CodingUnit cu;
+     PredictionUnit pu;
+-    NeighbourAvailable na;
+ 
+ #define BOUNDARY_LEFT_SLICE     (1 << 0)
+ #define BOUNDARY_LEFT_TILE      (1 << 1)
+@@ -812,12 +820,6 @@ typedef struct HEVCLocalContext {
+     int boundary_flags;
+ } HEVCLocalContext;
+ 
+-#ifdef RPI_WORKER
+-typedef struct HEVCLocalContextIntra {
+-    TransformUnit tu;
+-    NeighbourAvailable na;
+-} HEVCLocalContextIntra;
+-#endif
+ 
+ #ifdef RPI
+ 
+diff --git a/libavcodec/hevcpred_template.c b/libavcodec/hevcpred_template.c
+index 344e021..325b60e 100644
+--- a/libavcodec/hevcpred_template.c
++++ b/libavcodec/hevcpred_template.c
+@@ -72,7 +72,7 @@ do {                                  \
+             else                                                               \
+                 a = PIXEL_SPLAT_X4(ptr[i + 3])
+ #ifdef RPI_WORKER
+-    HEVCLocalContextIntra *lc = &s->HEVClcIntra;
++    HEVCLocalContextIntra *lc = s->enable_rpi ? &s->HEVClcIntra : (HEVCLocalContextIntra *)s->HEVClc ;
+ #else
+     HEVCLocalContext *lc = s->HEVClc;
+ #endif
+-- 
+2.7.4
+
+
+From 5b3eee9be88a5326df7621de95095def969e05a8 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 4 Jun 2015 11:52:55 +0100
+Subject: [PATCH 58/68] Draft support for tiles
+
+---
+ libavcodec/hevc.c              | 140 +++++++++++++++++++++++------------------
+ libavcodec/hevc.h              |  21 +++++--
+ libavcodec/hevc_filter.c       |   2 +-
+ libavcodec/hevcpred_template.c |   2 +-
+ 4 files changed, 99 insertions(+), 66 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 73d7f74..ec67252 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -63,10 +63,10 @@
+ 
+   static void rpi_execute_dblk_cmds(HEVCContext *s);
+   static void rpi_execute_transform(HEVCContext *s);
+-  static void rpi_execute_inter_qpu(HEVCContext *s);
++  static void rpi_launch_vpu_qpu(HEVCContext *s);
+   static void rpi_execute_pred_cmds(HEVCContext *s);
+   static void rpi_execute_inter_cmds(HEVCContext *s);
+-  static void rpi_inter_clear(HEVCContext *s);
++  static void rpi_begin(HEVCContext *s);
+ 
+   // Define INTER_PASS0 to do inter prediction in first pass
+   //#define INTER_PASS0
+@@ -90,16 +90,18 @@ const uint8_t ff_hevc_pel_weight[65] = { [2] = 0, [4] = 1, [6] = 2, [8] = 3, [12
+ 
+ #ifdef RPI_INTER_QPU
+ 
++// Each luma QPU processes 2*RPI_NUM_CHUNKS 64x64 blocks
++// Each chroma QPU processes 3*RPI_NUM_CHUNKS 64x64 blocks, but requires two commands for B blocks
++// For each block of 64*64 the smallest block size is 8x4
++// We also need an extra command for the setup information
++
+ #define RPI_CHROMA_COMMAND_WORDS 12
+-#define UV_COMMANDS_PER_QPU ((1 + (256*64*2)/(4*4)) * RPI_CHROMA_COMMAND_WORDS)
++#define UV_COMMANDS_PER_QPU ((1 + 3*RPI_NUM_CHUNKS*(64*64)*2/(8*4)) * RPI_CHROMA_COMMAND_WORDS)
+ // The QPU code for UV blocks only works up to a block width of 8
+ #define RPI_CHROMA_BLOCK_WIDTH 8
+ 
+-// Split image of 2048 into parts 64 wide
+-// So some QPUs will have 3 blocks of 64 to do, and others 2 blocks for an image 2048 wide with 32 blocks across
+-// For each block of 64*64 the smallest block size is 8x4
+ #define RPI_LUMA_COMMAND_WORDS 9
+-#define Y_COMMANDS_PER_QPU ((1+3*(64*64)/(8*4)) * RPI_LUMA_COMMAND_WORDS)
++#define Y_COMMANDS_PER_QPU ((1+2*RPI_NUM_CHUNKS*(64*64)/(8*4)) * RPI_LUMA_COMMAND_WORDS)
+ 
+ #define ENCODE_COEFFS(c0, c1, c2, c3) (((c0) & 0xff) | ((c1) & 0xff) << 8 | ((c2) & 0xff) << 16 | ((c3) & 0xff) << 24)
+ 
+@@ -216,7 +218,7 @@ static void *worker_start(void *arg)
+     LOG_ENTER
+     // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+ #ifndef LAUNCH_PASS0
+-    rpi_execute_inter_qpu(s);
++    rpi_launch_vpu_qpu(s);
+ #endif
+ #ifndef INTER_PASS0
+     // Perform inter prediction
+@@ -322,9 +324,14 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
+ 
+ #ifdef RPI
+     av_assert0(sps);
+-    int coeffs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
+-    int coefs_per_row = sps->ctb_width * coeffs_in_ctb * 3;  // Allow space for chroma
++    int coefs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
++    int coefs_per_luma = 64*64*24*RPI_NUM_CHUNKS;
++    int coefs_per_chroma = (coefs_per_luma * 2) >> sps->vshift[1] >> sps->hshift[1];
++    int coefs_per_row = coefs_per_luma + coefs_per_chroma;
+     int job;
++    s->max_ctu_count = coefs_per_luma / coefs_in_ctb;
++    s->ctu_per_y_chan = s->max_ctu_count / 12;
++    s->ctu_per_uv_chan = s->max_ctu_count / 8;
+     for(job=0;job<RPI_MAX_JOBS;job++) {
+       printf("Allocated %d\n",coefs_per_row);
+       for(job=0;job<RPI_MAX_JOBS;job++) {
+@@ -2186,10 +2193,9 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+             int my2_mx2_my_mx = (my_mx << 16) + my_mx;
+             int x1 = x0 + (mv->x >> 2);
+             int y1 = y0 + (mv->y >> 2);
+-            int chan = x0>>6; // 64 wide blocks per QPU
+             int weight_flag = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
+                               (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+-            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];
++            uint32_t *y = s->curr_y_mvs;
+             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+               for(int start_x=0;start_x < nPbW;start_x+=16) {
+                   int bw = nPbW-start_x;
+@@ -2209,7 +2215,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
+                 }
+             }
+-            s->y_mvs[s->pass0_job][chan % 12] = y;
++            s->curr_y_mvs = y;
+         } else
+ #endif
+         {
+@@ -2233,12 +2239,10 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+ 
+                 int x1_c = x0_c + (mv->x >> (2 + hshift));
+                 int y1_c = y0_c + (mv->y >> (2 + hshift));
+-                //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+-                int chan = x0>>8;
+                 int weight_flag      = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
+                                        (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+ 
+-                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];
++                uint32_t *u = s->curr_u_mvs;
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                       int bw = nPbW_c-start_x;
+@@ -2262,7 +2266,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+                 }
+-                s->u_mvs[s->pass0_job][chan & 7] = u;
++                s->curr_u_mvs = u;
+                 return;
+             }
+ #endif
+@@ -2289,10 +2293,9 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+             int my2_mx2_my_mx = (my_mx << 16) + my_mx;
+             int x1 = x0 + (mv->x >> 2);
+             int y1 = y0 + (mv->y >> 2);
+-            int chan = x0>>6; // 64 wide blocks per QPU
+             int weight_flag = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
+                               (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+-            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];
++            uint32_t *y = s->curr_y_mvs;
+             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+               for(int start_x=0;start_x < nPbW;start_x+=16) {
+                   int bw = nPbW-start_x;
+@@ -2312,7 +2315,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
+                 }
+             }
+-            s->y_mvs[s->pass0_job][chan % 12] = y;
++            s->curr_y_mvs = y;
+         } else
+ #endif
+ 
+@@ -2337,12 +2340,10 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+ 
+                 int x1_c = x0_c + (mv->x >> (2 + hshift));
+                 int y1_c = y0_c + (mv->y >> (2 + hshift));
+-                //int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+-                int chan = x0>>8;
+                 int weight_flag      = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
+                                        (s->sh.slice_type == B_SLICE && s->ps.pps->weighted_bipred_flag);
+ 
+-                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];
++                uint32_t *u = s->curr_u_mvs;
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                       int bw = nPbW_c-start_x;
+@@ -2367,7 +2368,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+                 }
+-                s->u_mvs[s->pass0_job][chan & 7] = u;
++                s->curr_u_mvs = u;
+                 return;
+             }
+ #endif
+@@ -2400,8 +2401,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+             int y1 = y0 + (mv->y >> 2);
+             int x2 = x0 + (mv2->x >> 2);
+             int y2 = y0 + (mv2->y >> 2);
+-            int chan = x0>>6; // 64 wide blocks per QPU
+-            uint32_t *y = s->y_mvs[s->pass0_job][chan % 12];
++            uint32_t *y = s->curr_y_mvs;
+             for(int start_y=0;start_y < nPbH;start_y+=16) {  // Potentially we could change the assembly code to support taller sizes in one go
+               for(int start_x=0;start_x < nPbW;start_x+=8) { // B blocks work 8 at a time
+                   int bw = nPbW-start_x;
+@@ -2417,7 +2417,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter_b;
+                 }
+             }
+-            s->y_mvs[s->pass0_job][chan % 12] = y;
++            s->curr_y_mvs = y;
+         } else
+ #endif
+         {
+@@ -2448,9 +2448,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                 int x2_c = x0_c + (mv2->x >> (2 + hshift));
+                 int y2_c = y0_c + (mv2->y >> (2 + hshift));
+ 
+-                int chan = x0>>8; // Allocate commands for the first 256 luma pixels across to the first QPU.  This is optimised for images around 1920 width
+ 
+-                uint32_t *u = s->u_mvs[s->pass0_job][chan & 7];
++                uint32_t *u = s->curr_u_mvs;
+                 for(int start_y=0;start_y < nPbH_c;start_y+=16) {
+                   for(int start_x=0;start_x < nPbW_c;start_x+=RPI_CHROMA_BLOCK_WIDTH) {
+                       int bw = nPbW_c-start_x;
+@@ -2479,7 +2478,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+                 }
+-                s->u_mvs[s->pass0_job][chan & 7] = u;
++                s->curr_u_mvs = u;
+                 return;
+             }
+ #endif
+@@ -3114,12 +3113,8 @@ static void rpi_execute_inter_cmds(HEVCContext *s)
+ 
+ static void rpi_do_all_passes(HEVCContext *s)
+ {
+-#ifdef RPI_INTER_QPU
+-    // Kick off inter prediction on QPUs
+-    rpi_execute_inter_qpu(s);
+-#else
+-    rpi_execute_transform(s);
+-#endif
++    // Kick off QPUs and VPUs
++    rpi_launch_vpu_qpu(s);
+     // Perform luma inter prediction
+     rpi_execute_inter_cmds(s);
+     // Wait for transform completion
+@@ -3128,18 +3123,18 @@ static void rpi_do_all_passes(HEVCContext *s)
+     rpi_execute_pred_cmds(s);
+     // Perform deblocking for CTBs in this row
+     rpi_execute_dblk_cmds(s);
+-#ifdef RPI_INTER_QPU
+-    rpi_inter_clear(s);
+-#endif
++    // Prepare next batch
++    rpi_begin(s);
+ }
+ 
+ #endif
+ 
+-#ifdef RPI_INTER_QPU
+-static void rpi_inter_clear(HEVCContext *s)
++#ifdef RPI
++static void rpi_begin(HEVCContext *s)
+ {
+     int job = s->pass0_job;
+     int i;
++#ifdef RPI_INTER_QPU
+     int pic_width        = s->ps.sps->width >> s->ps.sps->hshift[1];
+     int pic_height       = s->ps.sps->height >> s->ps.sps->vshift[1];
+     int weight_flag      = (s->sh.slice_type == P_SLICE && s->ps.pps->weighted_pred_flag) ||
+@@ -3165,6 +3160,8 @@ static void rpi_inter_clear(HEVCContext *s)
+         }
+         *s->u_mvs[job][i]++ = i;  // Select section of VPM (avoid collisions with 3d unit)
+     }
++    s->curr_u_mvs = s->u_mvs[job][0];
++#endif
+ 
+ #ifdef RPI_LUMA_QPU
+     for(i=0;i<12;i++) {
+@@ -3187,8 +3184,11 @@ static void rpi_inter_clear(HEVCContext *s)
+         }
+         *s->y_mvs[job][i]++ = 0; // Next kernel
+     }
++    s->curr_y_mvs = s->y_mvs[job][0];
+ #endif
++    s->ctu_count = 0;
+ }
++#endif
+ 
+ #ifdef RPI_SIMULATE_QPUS
+ 
+@@ -3459,8 +3459,9 @@ static void rpi_simulate_inter_qpu(HEVCContext *s)
+ 
+ #endif
+ 
++#ifdef RPI_INTER_QPU
+ 
+-static void rpi_execute_inter_qpu(HEVCContext *s)
++static void rpi_launch_vpu_qpu(HEVCContext *s)
+ {
+     int k;
+ #ifdef LAUNCH_PASS0
+@@ -3558,6 +3559,15 @@ static void rpi_execute_inter_qpu(HEVCContext *s)
+ 
+ 
+ }
++#else
++
++#ifdef RPI
++static void rpi_launch_vpu_qpu(HEVCContext *s)
++{
++  rpi_execute_transform(s);
++}
++#endif
++
+ #endif
+ 
+ #ifdef RPI
+@@ -3617,29 +3627,20 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ #ifdef RPI
+ #ifdef RPI_INTER_QPU
+     s->enable_rpi = s->ps.sps->bit_depth == 8
+-                    && s->ps.sps->width <= RPI_MAX_WIDTH
+                     && !s->ps.pps->cross_component_prediction_enabled_flag
+-                    && s->ps.pps->num_tile_rows <= 1 && s->ps.pps->num_tile_columns <= 1
+                     && !(s->ps.pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE);
+ #else
+     s->enable_rpi = s->ps.sps->bit_depth == 8
+-                    && s->ps.sps->width <= RPI_MAX_WIDTH
+-                    && !s->ps.pps->cross_component_prediction_enabled_flag
+-                    && s->ps.pps->num_tile_rows <= 1 && s->ps.pps->num_tile_columns <= 1;
++                    && !s->ps.pps->cross_component_prediction_enabled_flag;
+ #endif
+ 
+     if (!s->enable_rpi) {
+       if (s->ps.pps->cross_component_prediction_enabled_flag)
+         printf("Cross component\n");
+-      if (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)
+-        printf("Tiles\n");
+-      if (s->ps.pps->weighted_pred_flag && s->sh.slice_type == P_SLICE)
+-        printf("Weighted P slice\n");
+       if (s->ps.pps->weighted_bipred_flag && s->sh.slice_type == B_SLICE)
+         printf("Weighted B slice\n");
+     }
+ #endif
+-
+     //printf("L0=%d L1=%d\n",s->sh.nb_refs[L1],s->sh.nb_refs[L1]);
+ 
+     if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {
+@@ -3660,8 +3661,8 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     s->pass1_job = 0;
+     s->pass2_job = 0;
+ #endif
+-#ifdef RPI_INTER_QPU
+-    rpi_inter_clear(s);
++#ifdef RPI
++    rpi_begin(s);
+ #endif
+ 
+     while (more_data && ctb_addr_ts < s->ps.sps->ctb_size) {
+@@ -3679,13 +3680,34 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;
+         s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;
+ 
++#ifdef RPI_INTER_QPU
++        s->curr_u_mvs = s->u_mvs[s->pass0_job][s->ctu_count / s->ctu_per_uv_chan];
++#endif
++#ifdef RPI_LUMA_QPU
++        s->curr_y_mvs = s->y_mvs[s->pass0_job][s->ctu_count / s->ctu_per_y_chan];
++#endif
++
+         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
+ 
++#ifdef RPI_INTER_QPU
++        s->u_mvs[s->pass0_job][s->ctu_count / s->ctu_per_uv_chan] = s->curr_u_mvs;
++#endif
++#ifdef RPI_LUMA_QPU
++        s->y_mvs[s->pass0_job][s->ctu_count / s->ctu_per_y_chan] = s->curr_y_mvs;
++#endif
++
+ #ifdef RPI
+         if (s->enable_rpi) {
++          //av_assert0(s->num_dblk_cmds[s->pass0_job]>=0);
++          //av_assert0(s->num_dblk_cmds[s->pass0_job]<RPI_MAX_DEBLOCK_CMDS);
++          //av_assert0(s->pass0_job<RPI_MAX_JOBS);
++          //av_assert0(s->pass0_job>=0);
+           s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]][0] = x_ctb;
+           s->dblk_cmds[s->pass0_job][s->num_dblk_cmds[s->pass0_job]++][1] = y_ctb;
+-          if ( (((y_ctb + ctb_size)&63) == 0) && x_ctb + ctb_size >= s->ps.sps->width) {
++          s->ctu_count++;
++          //printf("%d %d/%d job=%d\n",s->ctu_count,s->num_dblk_cmds[s->pass0_job],RPI_MAX_DEBLOCK_CMDS,s->pass0_job);
++
++          if ( s->ctu_count >= s->max_ctu_count ) {
+ #ifdef RPI_WORKER
+             if (s->used_for_ref) {
+               // Split work load onto separate threads so we make as rapid progress as possible with this frame
+@@ -3693,7 +3715,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+               rpi_execute_inter_cmds(s);
+   #endif
+   #ifdef LAUNCH_PASS0
+-              rpi_execute_inter_qpu(s);
++              rpi_launch_vpu_qpu(s);
+   #endif
+               // Pass on this job to worker thread
+               worker_submit_job(s);
+@@ -3701,9 +3723,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+               worker_pass0_ready(s);
+ 
+               // Prepare the next batch of commands
+-#ifdef RPI_INTER_QPU
+-              rpi_inter_clear(s);
+-#endif
++              rpi_begin(s);
+             } else {
+               // Non-ref frame so do it all on this thread
+               rpi_do_all_passes(s);
+@@ -3744,7 +3764,7 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ #endif
+ 
+     // Finish off any half-completed rows
+-    if (s->enable_rpi && s->num_dblk_cmds[s->pass0_job]) {
++    if (s->enable_rpi && s->ctu_count) {
+         rpi_do_all_passes(s);
+     }
+ 
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 3cb34bd..a141316 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -823,8 +823,15 @@ typedef struct HEVCLocalContext {
+ 
+ #ifdef RPI
+ 
++// The processing is done in chunks
++// Each chunk corresponds to 24 64x64 luma blocks (24 so it is divisible by 8 for chroma and 12 for luma)
++// This is a distance of 1536 pixels across the screen
++// Increasing RPI_NUM_CHUNKS will reduce time spent activating QPUs and cache flushing,
++// but allocate more memory and increase the latency before data in the next frame can be processed
++#define RPI_NUM_CHUNKS 1
++
+ // RPI_MAX_WIDTH is maximum width in pixels supported by the accelerated code
+-#define RPI_MAX_WIDTH 2048
++#define RPI_MAX_WIDTH (RPI_NUM_CHUNKS*64*24)
+ 
+ // Worst case is for 4:4:4 4x4 blocks with 64 high coding tree blocks, so 16 MV cmds per 4 pixels across for each colour plane, * 2 for bi
+ #define RPI_MAX_MV_CMDS   (2*16*3*(RPI_MAX_WIDTH/4))
+@@ -888,9 +895,6 @@ typedef struct HEVCPredCmd {
+ #endif
+ 
+ typedef struct HEVCContext {
+-#ifdef RPI
+-    int dblk_cmds[RPI_MAX_JOBS][RPI_MAX_DEBLOCK_CMDS][2];
+-#endif
+     const AVClass *c;  // needed by private avoptions
+     AVCodecContext *avctx;
+ 
+@@ -928,6 +932,10 @@ typedef struct HEVCContext {
+     int pass0_job; // Pass0 does coefficient decode
+     int pass1_job; // Pass1 does pixel processing
+     int pass2_job; // Pass2 does reconstruction and deblocking
++    int ctu_count; // Number of CTUs done in pass0 so far
++    int max_ctu_count; // Number of CTUs when we trigger a round of processing
++    int ctu_per_y_chan; // Number of CTUs per luma QPU
++    int ctu_per_uv_chan; // Number of CTUs per chroma QPU
+ #ifdef RPI_INTER_QPU
+     GPU_MEM_PTR_T unif_mvs_ptr[RPI_MAX_JOBS];
+     uint32_t *unif_mvs[RPI_MAX_JOBS]; // Base of memory for motion vector commands
+@@ -936,6 +944,7 @@ typedef struct HEVCContext {
+     uint32_t *mvs_base[RPI_MAX_JOBS][8];
+     // these pointers are to the next free space
+     uint32_t *u_mvs[RPI_MAX_JOBS][8];
++    uint32_t *curr_u_mvs; // Current uniform stream to use for chroma
+     // Function pointers
+     uint32_t mc_filter_uv;
+     uint32_t mc_filter_uv_b0;
+@@ -946,6 +955,7 @@ typedef struct HEVCContext {
+     uint32_t *y_unif_mvs[RPI_MAX_JOBS]; // Base of memory for motion vector commands
+     uint32_t *y_mvs_base[RPI_MAX_JOBS][12];
+     uint32_t *y_mvs[RPI_MAX_JOBS][12];
++    uint32_t *curr_y_mvs; // Current uniform stream for luma
+     // Function pointers
+     uint32_t mc_filter;
+     uint32_t mc_filter_b;
+@@ -1084,6 +1094,9 @@ typedef struct HEVCContext {
+     uint32_t max_mastering_luminance;
+     uint32_t min_mastering_luminance;
+ 
++#ifdef RPI
++    int dblk_cmds[RPI_MAX_JOBS][RPI_MAX_DEBLOCK_CMDS][2];
++#endif
+ } HEVCContext;
+ 
+ int ff_hevc_decode_short_term_rps(GetBitContext *gb, AVCodecContext *avctx,
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index b286bbf..1f04790 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -891,7 +891,7 @@ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+         int n_uv = n >> s->ps.sps->vshift[1];
+         int sz,base;
+         if (curr_uv < 0) curr_uv = 0;
+-        if (n_uv<=curr_uv) { assert(0); return; } // Should not happen
++        if (n_uv<=curr_uv) { return; }
+         sz = s->frame->linesize[1] * (n_uv-curr_uv);
+         base = s->frame->linesize[1] * curr_uv;
+         GPU_MEM_PTR_T *p = av_buffer_pool_opaque(s->frame->buf[1]);
+diff --git a/libavcodec/hevcpred_template.c b/libavcodec/hevcpred_template.c
+index 325b60e..28d2653 100644
+--- a/libavcodec/hevcpred_template.c
++++ b/libavcodec/hevcpred_template.c
+@@ -72,7 +72,7 @@ do {                                  \
+             else                                                               \
+                 a = PIXEL_SPLAT_X4(ptr[i + 3])
+ #ifdef RPI_WORKER
+-    HEVCLocalContextIntra *lc = s->enable_rpi ? &s->HEVClcIntra : (HEVCLocalContextIntra *)s->HEVClc ;
++    HEVCLocalContextIntra *lc = (s->enable_rpi) ? &s->HEVClcIntra : (HEVCLocalContextIntra *)s->HEVClc ;
+ #else
+     HEVCLocalContext *lc = s->HEVClc;
+ #endif
+-- 
+2.7.4
+
+
+From 1674a80d147e5342ef6ea9a4fb4ddfc640c15a05 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Thu, 4 Jun 2015 15:48:10 +0100
+Subject: [PATCH 59/68] Move deblocker into second pass
+
+---
+ libavcodec/hevc.c | 79 +++++++++++++++++++++++++++++++++++++++++++++----------
+ 1 file changed, 65 insertions(+), 14 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index ec67252..6cecbdd 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -67,6 +67,8 @@
+   static void rpi_execute_pred_cmds(HEVCContext *s);
+   static void rpi_execute_inter_cmds(HEVCContext *s);
+   static void rpi_begin(HEVCContext *s);
++  static void flush_frame(HEVCContext *s,AVFrame *frame);
++  static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2);
+ 
+   // Define INTER_PASS0 to do inter prediction in first pass
+   //#define INTER_PASS0
+@@ -227,6 +229,11 @@ static void *worker_start(void *arg)
+     // Wait for transform completion
+     vpu_wait(s->vpu_id);
+ 
++    // Perform intra prediction and residual reconstruction
++    rpi_execute_pred_cmds(s);
++    // Perform deblocking for CTBs in this row
++    rpi_execute_dblk_cmds(s);
++
+     worker_complete_middle_job(s);
+     LOG_EXIT
+   }
+@@ -248,10 +255,6 @@ static void *worker_deblock_start(void *arg)
+       break;
+     }
+     LOG_ENTER
+-    // Perform intra prediction and residual reconstruction
+-    rpi_execute_pred_cmds(s);
+-    // Perform deblocking for CTBs in this row
+-    rpi_execute_dblk_cmds(s);
+ 
+     worker_complete_job(s);
+     LOG_EXIT
+@@ -2983,7 +2986,7 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
+ static void rpi_execute_dblk_cmds(HEVCContext *s)
+ {
+     int n;
+-    int job = s->pass2_job;
++    int job = s->pass1_job;
+     int ctb_size    = 1 << s->ps.sps->log2_ctb_size;
+     int (*p)[2] = s->dblk_cmds[job];
+     for(n = s->num_dblk_cmds[job]; n>0 ;n--,p++) {
+@@ -3021,7 +3024,7 @@ static void rpi_execute_transform(HEVCContext *s)
+ static void rpi_execute_pred_cmds(HEVCContext *s)
+ {
+   int i;
+-  int job = s->pass2_job;
++  int job = s->pass1_job;
+   HEVCPredCmd *cmd = s->univ_pred_cmds[job];
+ #ifdef RPI_WORKER
+   HEVCLocalContextIntra *lc = &s->HEVClcIntra;
+@@ -3506,11 +3509,10 @@ static void rpi_launch_vpu_qpu(HEVCContext *s)
+ 
+ #ifdef RPI_MULTI_MAILBOX
+ #ifdef RPI_CACHE_UNIF_MVS
+-    gpu_cache_flush3(&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job]);
++    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job]);
+ #else
+-    gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
++    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],NULL,NULL);
+ #endif
+-
+     s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
+                                    qpu_get_fn(QPU_MC_SETUP_UV),
+                                    (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+@@ -3613,6 +3615,60 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
+ #endif
+ }
+ 
++static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2)
++{
++#ifdef RPI_FAST_CACHEFLUSH
++    struct vcsm_user_clean_invalid_s iocache = {};
++    int n = s->ps.sps->height;
++    int curr_y = 0;
++    int curr_uv = 0;
++    int n_uv = n >> s->ps.sps->vshift[1];
++    int sz,base;
++    sz = s->frame->linesize[1] * (n_uv-curr_uv);
++    base = s->frame->linesize[1] * curr_uv;
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
++    iocache.s[0].handle = p->vcsm_handle;
++    iocache.s[0].cmd = 3; // clean+invalidate
++    iocache.s[0].addr = p->arm + base;
++    iocache.s[0].size  = sz;
++    p = av_buffer_pool_opaque(frame->buf[2]);
++    iocache.s[1].handle = p->vcsm_handle;
++    iocache.s[1].cmd = 3; // clean+invalidate
++    iocache.s[1].addr = p->arm + base;
++    iocache.s[1].size  = sz;
++    p = av_buffer_pool_opaque(frame->buf[0]);
++    sz = s->frame->linesize[0] * (n-curr_y);
++    base = s->frame->linesize[0] * curr_y;
++    iocache.s[2].handle = p->vcsm_handle;
++    iocache.s[2].cmd = 3; // clean+invalidate
++    iocache.s[2].addr = p->arm + base;
++    iocache.s[2].size  = sz;
++
++    iocache.s[3].handle = p0->vcsm_handle;
++    iocache.s[3].cmd = 3; // clean+invalidate
++    iocache.s[3].addr = (int) p0->arm;
++    iocache.s[3].size  = p0->numbytes;
++    if (p1) {
++      iocache.s[4].handle = p1->vcsm_handle;
++      iocache.s[4].cmd = 3; // clean+invalidate
++      iocache.s[4].addr = (int) p1->arm;
++      iocache.s[4].size  = p1->numbytes;
++    }
++    if (p2) {
++      iocache.s[5].handle = p2->vcsm_handle;
++      iocache.s[5].cmd = 3; // clean+invalidate
++      iocache.s[5].addr = (int) p2->arm;
++      iocache.s[5].size  = p2->numbytes;
++    }
++    vcsm_clean_invalid( &iocache );
++#else
++    flush_buffer(frame->buf[0]);
++    flush_buffer(frame->buf[1]);
++    flush_buffer(frame->buf[2]);
++    gpu_cache_flush3(p0, p1, p2);
++#endif
++}
++
+ #endif
+ 
+ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+@@ -4127,11 +4183,6 @@ static int hevc_frame_start(HEVCContext *s)
+     if (!s->avctx->hwaccel)
+         ff_thread_finish_setup(s->avctx);
+ 
+-#ifdef RPI_INTER_QPU
+-    // Invalidate the output data buffer so it is ready for the QPUs to write into it.
+-    flush_frame(s,s->frame);
+-#endif
+-
+     return 0;
+ 
+ fail:
+-- 
+2.7.4
+
+
+From a453fe438c4ab311d6476955d0a40a5d2ed8a1c6 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Thu, 4 Jun 2015 16:10:23 +0100
+Subject: [PATCH 60/68] Change order of ctu accesses to improve qpu performance
+
+---
+ libavcodec/hevc.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 6cecbdd..ec17e64 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -3737,19 +3737,19 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+         s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;
+ 
+ #ifdef RPI_INTER_QPU
+-        s->curr_u_mvs = s->u_mvs[s->pass0_job][s->ctu_count / s->ctu_per_uv_chan];
++        s->curr_u_mvs = s->u_mvs[s->pass0_job][s->ctu_count % 8];
+ #endif
+ #ifdef RPI_LUMA_QPU
+-        s->curr_y_mvs = s->y_mvs[s->pass0_job][s->ctu_count / s->ctu_per_y_chan];
++        s->curr_y_mvs = s->y_mvs[s->pass0_job][s->ctu_count % 12];
+ #endif
+ 
+         more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
+ 
+ #ifdef RPI_INTER_QPU
+-        s->u_mvs[s->pass0_job][s->ctu_count / s->ctu_per_uv_chan] = s->curr_u_mvs;
++        s->u_mvs[s->pass0_job][s->ctu_count % 8]= s->curr_u_mvs;
+ #endif
+ #ifdef RPI_LUMA_QPU
+-        s->y_mvs[s->pass0_job][s->ctu_count / s->ctu_per_y_chan] = s->curr_y_mvs;
++        s->y_mvs[s->pass0_job][s->ctu_count % 12] = s->curr_y_mvs;
+ #endif
+ 
+ #ifdef RPI
+-- 
+2.7.4
+
+
+From 504de0435e8f660c1b7b2d6ec053dc922a2d2896 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Mon, 8 Jun 2015 09:36:59 +0100
+Subject: [PATCH 61/68] Removed deblocker thread
+
+---
+ libavcodec/hevc.c | 77 +++----------------------------------------------------
+ libavcodec/hevc.h |  4 ---
+ 2 files changed, 4 insertions(+), 77 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index ec17e64..1868532 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -70,11 +70,6 @@
+   static void flush_frame(HEVCContext *s,AVFrame *frame);
+   static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2);
+ 
+-  // Define INTER_PASS0 to do inter prediction in first pass
+-  //#define INTER_PASS0
+-  // Define LAUNCH_PASS0 to launch QPU/VPU from pass0
+-  //#define LAUNCH_PASS0
+-
+ #endif
+ 
+ // #define DISABLE_MC
+@@ -147,24 +142,12 @@ static void worker_submit_job(HEVCContext *s)
+ }
+ 
+ // Call this to say we have completed pass1
+-static void worker_complete_middle_job(HEVCContext *s)
+-{
+-  LOG_ENTER
+-  pthread_mutex_lock(&s->worker_mutex);
+-  s->worker_middle++;
+-  s->pass1_job = (s->pass1_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
+-  pthread_cond_broadcast(&s->worker_cond_middle); // Let people know that the middle has moved
+-  pthread_mutex_unlock(&s->worker_mutex);
+-  LOG_EXIT
+-}
+-
+-// Call this to say we have completed pass2
+ static void worker_complete_job(HEVCContext *s)
+ {
+   LOG_ENTER
+   pthread_mutex_lock(&s->worker_mutex);
+   s->worker_head++;
+-  s->pass2_job = (s->pass2_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
++  s->pass1_job = (s->pass1_job + 1) % RPI_MAX_JOBS; // Move onto the next slot
+   pthread_cond_broadcast(&s->worker_cond_head); // Let people know that the head has moved
+   pthread_mutex_unlock(&s->worker_mutex);
+   LOG_EXIT
+@@ -208,7 +191,7 @@ static void *worker_start(void *arg)
+   while(1) {
+     pthread_mutex_lock(&s->worker_mutex);
+ 
+-    while( !s->kill_worker && s->worker_tail - s->worker_middle <= 0)
++    while( !s->kill_worker && s->worker_tail - s->worker_head <= 0)
+     {
+       pthread_cond_wait(&s->worker_cond_tail, &s->worker_mutex);
+     }
+@@ -219,13 +202,9 @@ static void *worker_start(void *arg)
+     }
+     LOG_ENTER
+     // printf("%d %d %d : %d %d %d %d\n",s->poc, x_ctb, y_ctb, s->num_pred_cmds,s->num_mv_cmds,s->num_coeffs[2] >> 8,s->num_coeffs[3] >> 10);
+-#ifndef LAUNCH_PASS0
+     rpi_launch_vpu_qpu(s);
+-#endif
+-#ifndef INTER_PASS0
+     // Perform inter prediction
+     rpi_execute_inter_cmds(s);
+-#endif
+     // Wait for transform completion
+     vpu_wait(s->vpu_id);
+ 
+@@ -234,28 +213,6 @@ static void *worker_start(void *arg)
+     // Perform deblocking for CTBs in this row
+     rpi_execute_dblk_cmds(s);
+ 
+-    worker_complete_middle_job(s);
+-    LOG_EXIT
+-  }
+-  return NULL;
+-}
+-
+-static void *worker_deblock_start(void *arg)
+-{
+-  HEVCContext *s = (HEVCContext *)arg;
+-  while(1) {
+-    pthread_mutex_lock(&s->worker_mutex);
+-    while( !s->kill_worker && s->worker_middle - s->worker_head <= 0)
+-    {
+-      pthread_cond_wait(&s->worker_cond_middle, &s->worker_mutex);
+-    }
+-    pthread_mutex_unlock(&s->worker_mutex);
+-
+-    if (s->kill_worker) {
+-      break;
+-    }
+-    LOG_ENTER
+-
+     worker_complete_job(s);
+     LOG_EXIT
+   }
+@@ -2998,11 +2955,7 @@ static void rpi_execute_dblk_cmds(HEVCContext *s)
+ static void rpi_execute_transform(HEVCContext *s)
+ {
+     int i=2;
+-#ifdef LAUNCH_PASS0
+-    int job = s->pass0_job;
+-#else
+     int job = s->pass1_job;
+-#endif
+     //int j;
+     //int16_t *coeffs = s->coeffs_buf_arm[i];
+     //for(j=s->num_coeffs[i]; j > 0; j-= 16*16, coeffs+=16*16) {
+@@ -3057,11 +3010,7 @@ static void rpi_execute_pred_cmds(HEVCContext *s)
+ 
+ static void rpi_execute_inter_cmds(HEVCContext *s)
+ {
+-#ifdef INTER_PASS0
+-    int job = s->pass0_job;
+-#else
+     int job = s->pass1_job;
+-#endif
+     HEVCMvCmd *cmd = s->unif_mv_cmds[job];
+     int n,cidx;
+     AVFrame myref;
+@@ -3467,11 +3416,7 @@ static void rpi_simulate_inter_qpu(HEVCContext *s)
+ static void rpi_launch_vpu_qpu(HEVCContext *s)
+ {
+     int k;
+-#ifdef LAUNCH_PASS0
+-    int job = s->pass0_job;
+-#else
+     int job = s->pass1_job;
+-#endif
+     int i;
+     uint32_t *unif_vc = (uint32_t *)s->unif_mvs_ptr[job].vc;
+ #ifdef RPI_LUMA_QPU
+@@ -3574,10 +3519,12 @@ static void rpi_launch_vpu_qpu(HEVCContext *s)
+ 
+ #ifdef RPI
+ 
++#ifndef RPI_FAST_CACHEFLUSH
+ static void flush_buffer(AVBufferRef *bref) {
+     GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+     gpu_cache_flush(p);
+ }
++#endif
+ 
+ static void flush_frame(HEVCContext *s,AVFrame *frame)
+ {
+@@ -3715,7 +3662,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ #ifdef RPI_WORKER
+     s->pass0_job = 0;
+     s->pass1_job = 0;
+-    s->pass2_job = 0;
+ #endif
+ #ifdef RPI
+     rpi_begin(s);
+@@ -3767,12 +3713,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+ #ifdef RPI_WORKER
+             if (s->used_for_ref) {
+               // Split work load onto separate threads so we make as rapid progress as possible with this frame
+-  #ifdef INTER_PASS0
+-              rpi_execute_inter_cmds(s);
+-  #endif
+-  #ifdef LAUNCH_PASS0
+-              rpi_launch_vpu_qpu(s);
+-  #endif
+               // Pass on this job to worker thread
+               worker_submit_job(s);
+               // Make sure we have space to prepare the next job
+@@ -3814,8 +3754,6 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
+     // Wait for the worker to finish all its jobs
+     if (s->enable_rpi) {
+         worker_wait(s);
+-        av_assert0(s->pass0_job==s->pass1_job);
+-        av_assert0(s->pass1_job==s->pass2_job);
+     }
+ #endif
+ 
+@@ -4565,16 +4503,13 @@ static av_cold void hevc_init_worker(HEVCContext *s)
+ {
+     int err;
+     pthread_cond_init(&s->worker_cond_head, NULL);
+-    pthread_cond_init(&s->worker_cond_middle, NULL);
+     pthread_cond_init(&s->worker_cond_tail, NULL);
+     pthread_mutex_init(&s->worker_mutex, NULL);
+ 
+     s->worker_tail=0;
+-    s->worker_middle=0;
+     s->worker_head=0;
+     s->kill_worker=0;
+     err = pthread_create(&s->worker_thread, NULL, worker_start, s);
+-    err = pthread_create(&s->worker_deblock_thread, NULL, worker_deblock_start, s);
+     if (err) {
+         printf("Failed to create worker thread\n");
+         exit(-1);
+@@ -4586,17 +4521,13 @@ static av_cold void hevc_exit_worker(HEVCContext *s)
+     void *res;
+     s->kill_worker=1;
+     pthread_cond_broadcast(&s->worker_cond_tail);
+-    pthread_cond_broadcast(&s->worker_cond_middle);
+     pthread_join(s->worker_thread, &res);
+-    pthread_join(s->worker_deblock_thread, &res);
+ 
+     pthread_cond_destroy(&s->worker_cond_head);
+-    pthread_cond_destroy(&s->worker_cond_middle);
+     pthread_cond_destroy(&s->worker_cond_tail);
+     pthread_mutex_destroy(&s->worker_mutex);
+ 
+     s->worker_tail=0;
+-    s->worker_middle=0;
+     s->worker_head=0;
+     s->kill_worker=0;
+ }
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index a141316..ef5bfb1 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -931,7 +931,6 @@ typedef struct HEVCContext {
+     //GPU_MEM_PTR_T dummy;
+     int pass0_job; // Pass0 does coefficient decode
+     int pass1_job; // Pass1 does pixel processing
+-    int pass2_job; // Pass2 does reconstruction and deblocking
+     int ctu_count; // Number of CTUs done in pass0 so far
+     int max_ctu_count; // Number of CTUs when we trigger a round of processing
+     int ctu_per_y_chan; // Number of CTUs per luma QPU
+@@ -963,15 +962,12 @@ typedef struct HEVCContext {
+ 
+ #ifdef RPI_WORKER
+     pthread_t worker_thread;
+-    pthread_t worker_deblock_thread;
+     pthread_cond_t worker_cond_head;
+     pthread_cond_t worker_cond_tail;
+-    pthread_cond_t worker_cond_middle;
+     pthread_mutex_t worker_mutex;
+ 
+     int worker_tail; // Contains the number of posted jobs
+     int worker_head; // Contains the number of completed jobs
+-    int worker_middle; // Contains the number of completed jobs
+     int kill_worker; // set to 1 to terminate the worker
+ #endif
+ 
+-- 
+2.7.4
+
+
+From 74892301cdb0829de959b798debac6ffe1c71603 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Mon, 8 Jun 2015 11:04:43 +0100
+Subject: [PATCH 62/68] Reduced amount of output frame that is invalidated
+
+---
+ libavcodec/hevc.c | 45 +++++++++++++++++++++++++++++----------------
+ 1 file changed, 29 insertions(+), 16 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 1868532..cbb4f46 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -68,7 +68,7 @@
+   static void rpi_execute_inter_cmds(HEVCContext *s);
+   static void rpi_begin(HEVCContext *s);
+   static void flush_frame(HEVCContext *s,AVFrame *frame);
+-  static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2);
++  static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2, int job);
+ 
+ #endif
+ 
+@@ -3454,9 +3454,9 @@ static void rpi_launch_vpu_qpu(HEVCContext *s)
+ 
+ #ifdef RPI_MULTI_MAILBOX
+ #ifdef RPI_CACHE_UNIF_MVS
+-    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job]);
++    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],&s->y_unif_mvs_ptr[job], &s->unif_mvs_ptr[job], job);
+ #else
+-    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],NULL,NULL);
++    flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],NULL,NULL, job);
+ #endif
+     s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
+                                    qpu_get_fn(QPU_MC_SETUP_UV),
+@@ -3530,6 +3530,7 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
+ {
+ #ifdef RPI_FAST_CACHEFLUSH
+     struct vcsm_user_clean_invalid_s iocache = {};
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
+     int n = s->ps.sps->height;
+     int curr_y = 0;
+     int curr_uv = 0;
+@@ -3537,22 +3538,21 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
+     int sz,base;
+     sz = s->frame->linesize[1] * (n_uv-curr_uv);
+     base = s->frame->linesize[1] * curr_uv;
+-    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
+     iocache.s[0].handle = p->vcsm_handle;
+     iocache.s[0].cmd = 3; // clean+invalidate
+-    iocache.s[0].addr = p->arm + base;
++    iocache.s[0].addr = (int)(p->arm) + base;
+     iocache.s[0].size  = sz;
+     p = av_buffer_pool_opaque(frame->buf[2]);
+     iocache.s[1].handle = p->vcsm_handle;
+     iocache.s[1].cmd = 3; // clean+invalidate
+-    iocache.s[1].addr = p->arm + base;
++    iocache.s[1].addr = (int)(p->arm) + base;
+     iocache.s[1].size  = sz;
+     p = av_buffer_pool_opaque(frame->buf[0]);
+     sz = s->frame->linesize[0] * (n-curr_y);
+     base = s->frame->linesize[0] * curr_y;
+     iocache.s[2].handle = p->vcsm_handle;
+     iocache.s[2].cmd = 3; // clean+invalidate
+-    iocache.s[2].addr = p->arm + base;
++    iocache.s[2].addr = (int)(p->arm) + base;
+     iocache.s[2].size  = sz;
+     vcsm_clean_invalid( &iocache );
+ #else
+@@ -3562,33 +3562,46 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
+ #endif
+ }
+ 
+-static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2)
++static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2, int job)
+ {
+ #ifdef RPI_FAST_CACHEFLUSH
+     struct vcsm_user_clean_invalid_s iocache = {};
+-    int n = s->ps.sps->height;
+-    int curr_y = 0;
+-    int curr_uv = 0;
+-    int n_uv = n >> s->ps.sps->vshift[1];
++    int n;
++    int curr_y;
++    int curr_uv;
++    int n_uv;
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
+     int sz,base;
++    int (*d)[2] = s->dblk_cmds[job];
++    int low=(*d)[1];
++    int high=(*d)[1];
++    for(n = s->num_dblk_cmds[job]; n>0 ;n--,d++) {
++        int y = (*d)[1];
++        low=FFMIN(low,y);
++        high=FFMAX(high,y);
++    }
++    curr_y = low;
++    n = high+(1 << s->ps.sps->log2_ctb_size);
++    curr_uv = curr_y >> s->ps.sps->vshift[1];
++    n_uv = n >> s->ps.sps->vshift[1];
++
+     sz = s->frame->linesize[1] * (n_uv-curr_uv);
+     base = s->frame->linesize[1] * curr_uv;
+-    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
+     iocache.s[0].handle = p->vcsm_handle;
+     iocache.s[0].cmd = 3; // clean+invalidate
+-    iocache.s[0].addr = p->arm + base;
++    iocache.s[0].addr = (int)(p->arm) + base;
+     iocache.s[0].size  = sz;
+     p = av_buffer_pool_opaque(frame->buf[2]);
+     iocache.s[1].handle = p->vcsm_handle;
+     iocache.s[1].cmd = 3; // clean+invalidate
+-    iocache.s[1].addr = p->arm + base;
++    iocache.s[1].addr = (int)(p->arm) + base;
+     iocache.s[1].size  = sz;
+     p = av_buffer_pool_opaque(frame->buf[0]);
+     sz = s->frame->linesize[0] * (n-curr_y);
+     base = s->frame->linesize[0] * curr_y;
+     iocache.s[2].handle = p->vcsm_handle;
+     iocache.s[2].cmd = 3; // clean+invalidate
+-    iocache.s[2].addr = p->arm + base;
++    iocache.s[2].addr = (int)(p->arm) + base;
+     iocache.s[2].size  = sz;
+ 
+     iocache.s[3].handle = p0->vcsm_handle;
+-- 
+2.7.4
+
+
+From 090b6be5b501bd3c547700926e540397f0b39e69 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Mon, 8 Jun 2015 11:55:29 +0100
+Subject: [PATCH 63/68] Packed 16x16 and 32x32 into the same buffer
+
+---
+ libavcodec/hevc.c       | 24 +++++++++++++++---------
+ libavcodec/hevc_cabac.c |  9 ++++++++-
+ libavcodec/rpi_qpu.c    |  2 +-
+ 3 files changed, 24 insertions(+), 11 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index cbb4f46..a596534 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -299,12 +299,12 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
+         s->coeffs_buf_arm[job][0] = (int16_t*) s->coeffs_buf_default[job].arm;
+         if (!s->coeffs_buf_arm[job][0])
+             goto fail;
+-        gpu_malloc_cached(sizeof(int16_t) * coefs_per_row * 2, &s->coeffs_buf_accelerated[job]);
++        gpu_malloc_cached(sizeof(int16_t) * (coefs_per_row + 32*32), &s->coeffs_buf_accelerated[job]);  // We prefetch past the end so provide an extra blocks worth of data
+         s->coeffs_buf_arm[job][2] = (int16_t*) s->coeffs_buf_accelerated[job].arm;
+         s->coeffs_buf_vc[job][2] = s->coeffs_buf_accelerated[job].vc;
+         if (!s->coeffs_buf_arm[job][2])
+             goto fail;
+-        s->coeffs_buf_arm[job][3] = coefs_per_row + s->coeffs_buf_arm[job][2];
++        s->coeffs_buf_arm[job][3] = coefs_per_row + s->coeffs_buf_arm[job][2];  // This points to just beyond the end of the buffer.  Coefficients fill in backwards.
+         s->coeffs_buf_vc[job][3] = sizeof(int16_t) * coefs_per_row + s->coeffs_buf_vc[job][2];
+       }
+     }
+@@ -2956,15 +2956,20 @@ static void rpi_execute_transform(HEVCContext *s)
+ {
+     int i=2;
+     int job = s->pass1_job;
+-    //int j;
+-    //int16_t *coeffs = s->coeffs_buf_arm[i];
+-    //for(j=s->num_coeffs[i]; j > 0; j-= 16*16, coeffs+=16*16) {
+-    //    s->hevcdsp.idct[4-2](coeffs, 16);
+-    //}
++    /*int j;
++    int16_t *coeffs = s->coeffs_buf_arm[job][i];
++    for(j=s->num_coeffs[job][i]; j > 0; j-= 16*16, coeffs+=16*16) {
++        s->hevcdsp.idct[4-2](coeffs, 16);
++    }
++    i=3;
++    coeffs = s->coeffs_buf_arm[job][i] - s->num_coeffs[job][i];
++    for(j=s->num_coeffs[job][i]; j > 0; j-= 32*32, coeffs+=32*32) {
++        s->hevcdsp.idct[5-2](coeffs, 32);
++    }*/
+ 
+     gpu_cache_flush(&s->coeffs_buf_accelerated[job]);
+     s->vpu_id = vpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2],
+-                               s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3],
++                               s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3] - sizeof(int16_t) * s->num_coeffs[job][3],
+                                s->num_coeffs[job][3] >> 10, 0, &s->coeffs_buf_accelerated[job]);
+     //vpu_execute_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[2], s->num_coeffs[2] >> 8, s->coeffs_buf_vc[3], s->num_coeffs[3] >> 10, 0);
+     //gpu_cache_flush(&s->coeffs_buf_accelerated);
+@@ -3458,7 +3463,8 @@ static void rpi_launch_vpu_qpu(HEVCContext *s)
+ #else
+     flush_frame3(s, s->frame,&s->coeffs_buf_accelerated[job],NULL,NULL, job);
+ #endif
+-    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8, s->coeffs_buf_vc[job][3], s->num_coeffs[job][3] >> 10, 0,
++    s->vpu_id = vpu_qpu_post_code( vpu_get_fn(), vpu_get_constants(), s->coeffs_buf_vc[job][2], s->num_coeffs[job][2] >> 8,
++                                                                      s->coeffs_buf_vc[job][3] - sizeof(int16_t) * s->num_coeffs[job][3], s->num_coeffs[job][3] >> 10, 0,
+                                    qpu_get_fn(QPU_MC_SETUP_UV),
+                                    (uint32_t)(unif_vc+(s->mvs_base[job][0 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+                                    (uint32_t)(unif_vc+(s->mvs_base[job][1 ] - (uint32_t*)s->unif_mvs_ptr[job].arm)),
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index 6523e66..8656917 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -1051,7 +1051,14 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+     if (s->enable_rpi) {
+         int n = trafo_size * trafo_size;
+         if (use_vpu) {
+-            coeffs = s->coeffs_buf_arm[s->pass0_job][log2_trafo_size - 2] + s->num_coeffs[s->pass0_job][log2_trafo_size - 2];
++            // We support size 4 and size 5.
++            // Size 4 grows from the front  (Coeffs_buf_arm[2] points to start of buf)
++            // Size 5 grows from the back   (Coeffs_buf_arm[3] points to end of buf)
++            // num_coeffs is indexed by log2_trafo_size-2
++            if (log2_trafo_size == 4)
++                coeffs = s->coeffs_buf_arm[s->pass0_job][log2_trafo_size - 2] + s->num_coeffs[s->pass0_job][log2_trafo_size - 2];
++            else
++                coeffs = s->coeffs_buf_arm[s->pass0_job][log2_trafo_size - 2] - s->num_coeffs[s->pass0_job][log2_trafo_size - 2] - n;
+             s->num_coeffs[s->pass0_job][log2_trafo_size - 2] += n;
+         } else {
+             coeffs = s->coeffs_buf_arm[s->pass0_job][0] + s->num_coeffs[s->pass0_job][0];
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 4480f72..0121fca 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -5,7 +5,7 @@
+ // define RPI_TIME_TOTAL_VPU to print out how much time is spent in the VPI code
+ //#define RPI_TIME_TOTAL_VPU
+ // define RPI_TIME_TOTAL_POSTED to print out how much time is spent in the multi execute QPU/VPU combined
+-//#define RPI_TIME_TOTAL_POSTED
++#define RPI_TIME_TOTAL_POSTED
+ // define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
+ #define RPI_ASYNC
+ 
+-- 
+2.7.4
+
+
+From ed359bbce56817bf9db0e54701103bd0505c353b Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Thu, 25 Jun 2015 09:02:47 +0100
+Subject: [PATCH 64/68] Moved luma deblock to VPU
+
+---
+ libavcodec/hevc.c               |   18 +-
+ libavcodec/hevc.h               |   11 +
+ libavcodec/hevc_filter.c        |  120 ++-
+ libavcodec/rpi_hevc_transform.h | 1802 ++++++++++++++++++++++++++++++++++++++-
+ libavcodec/rpi_hevc_transform.s |  426 +++++++++
+ libavcodec/rpi_qpu.c            |   12 +-
+ libavcodec/rpi_shader.c         |    2 +-
+ 7 files changed, 2378 insertions(+), 13 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index a596534..4ce94a7 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -246,6 +246,12 @@ static void pic_arrays_free(HEVCContext *s)
+       }
+     }
+ #endif
++#ifdef RPI_DEBLOCK_VPU
++    if (s->y_setup_arm) {
++      gpu_free(&s->y_setup_ptr);
++      s->y_setup_arm = 0;
++    }
++#endif
+     av_freep(&s->sao);
+     av_freep(&s->deblock);
+ 
+@@ -283,12 +289,12 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
+     int min_pu_size      = sps->min_pu_width * sps->min_pu_height;
+ 
+ #ifdef RPI
+-    av_assert0(sps);
+     int coefs_in_ctb = (1 << sps->log2_ctb_size) * (1 << sps->log2_ctb_size);
+     int coefs_per_luma = 64*64*24*RPI_NUM_CHUNKS;
+     int coefs_per_chroma = (coefs_per_luma * 2) >> sps->vshift[1] >> sps->hshift[1];
+     int coefs_per_row = coefs_per_luma + coefs_per_chroma;
+     int job;
++    av_assert0(sps);
+     s->max_ctu_count = coefs_per_luma / coefs_in_ctb;
+     s->ctu_per_y_chan = s->max_ctu_count / 12;
+     s->ctu_per_uv_chan = s->max_ctu_count / 8;
+@@ -309,6 +315,16 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
+       }
+     }
+ #endif
++#ifdef RPI_DEBLOCK_VPU
++    s->enable_rpi_deblock = !sps->sao_enabled;
++    s->setup_width = (sps->width+15) / 16;
++    s->setup_height = (sps->height+15) / 16;
++    gpu_malloc_uncached(sizeof(*s->y_setup_arm) * s->setup_width * s->setup_height, &s->y_setup_ptr); // TODO make this cached
++    s->y_setup_arm = (void*)s->y_setup_ptr.arm;
++    s->y_setup_vc = (void*)s->y_setup_ptr.vc;
++    memset(s->y_setup_arm, 0, s->y_setup_ptr.numbytes);
++    printf("Setup %d by %d by %d\n",s->setup_width,s->setup_height,sizeof(*s->y_setup_arm));
++#endif
+ 
+     s->bs_width  = (width  >> 2) + 1;
+     s->bs_height = (height >> 2) + 1;
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index ef5bfb1..cf08489 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -57,6 +57,8 @@
+   // Define RPI_WORKER to launch a worker thread for pixel processing tasks
+   #define RPI_WORKER
+ 
++  #define RPI_DEBLOCK_VPU
++
+ #endif
+ 
+ #define MAX_DPB_SIZE 16 // A.4.1
+@@ -971,6 +973,15 @@ typedef struct HEVCContext {
+     int kill_worker; // set to 1 to terminate the worker
+ #endif
+ 
++#ifdef RPI_DEBLOCK_VPU
++    int enable_rpi_deblock;
++    GPU_MEM_PTR_T y_setup_ptr;
++    uint8_t (*y_setup_arm)[2][2][2][4];
++    uint8_t (*y_setup_vc)[2][2][2][4];
++    int setup_width; // Number of 16x16 blocks across the image
++    int setup_height; // Number of 16x16 blocks down the image
++#endif
++
+ #endif
+ 
+     uint8_t *cabac_state;
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 1f04790..06371da 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -564,6 +564,19 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
+                                                          s->frame->linesize[LUMA],
+                                                          beta, tc, no_p, no_q);
+                 } else
++#ifdef RPI_DEBLOCK_VPU
++                if (s->enable_rpi_deblock) {
++                    uint8_t (*setup)[2][2][4];
++                    int num16 = (y>>4)*s->setup_width + (x>>4);
++                    int a = ((y>>3) & 1) << 1;
++                    int b = (x>>3) & 1;
++                    setup = s->y_setup_arm[num16];
++                    setup[0][b][0][a] = beta;
++                    setup[0][b][0][a + 1] = beta;
++                    setup[0][b][1][a] = tc[0];
++                    setup[0][b][1][a + 1] = tc[1];
++                } else
++#endif
+                     s->hevcdsp.hevc_v_loop_filter_luma(src,
+                                                        s->frame->linesize[LUMA],
+                                                        beta, tc, no_p, no_q);
+@@ -596,6 +609,19 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
+                                                          s->frame->linesize[LUMA],
+                                                          beta, tc, no_p, no_q);
+                 } else
++#ifdef RPI_DEBLOCK_VPU
++                if (s->enable_rpi_deblock) {
++                    uint8_t (*setup)[2][2][4];
++                    int num16 = (y>>4)*s->setup_width + (x>>4);
++                    int a = ((x>>3) & 1) << 1;
++                    int b = (y>>3) & 1;
++                    setup = s->y_setup_arm[num16];
++                    setup[1][b][0][a] = beta;
++                    setup[1][b][0][a + 1] = beta;
++                    setup[1][b][1][a] = tc[0];
++                    setup[1][b][1][a + 1] = tc[1];
++                } else
++#endif
+                     s->hevcdsp.hevc_h_loop_filter_luma(src,
+                                                        s->frame->linesize[LUMA],
+                                                        beta, tc, no_p, no_q);
+@@ -876,33 +902,85 @@ static void flush_buffer(AVBufferRef *bref) {
+ }
+ 
+ // Return Physical address for this image
+-static int ff_hevc_buf_base(AVBufferRef *bref) {
++static uint32_t get_vc_address(AVBufferRef *bref) {
+   GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+-  return p->vc & 0x3fffffff;
++  return p->vc;
+ }
+ 
++// ff_hevc_flush_buffer_lines
++// flushes and invalidates all pixel rows in [start,end-1]
++static void ff_hevc_flush_buffer_lines(HEVCContext *s, int start, int end, int flush_luma, int flush_chroma)
++{
++#ifdef RPI_FAST_CACHEFLUSH
++        struct vcsm_user_clean_invalid_s iocache = {};
++        int curr_y = start;
++        int n = end;
++        int curr_uv = curr_y >> s->ps.sps->vshift[1];
++        int n_uv = n >> s->ps.sps->vshift[1];
++        int sz,base;
++        GPU_MEM_PTR_T *p;
++        if (curr_uv < 0) curr_uv = 0;
++        if (n_uv<=curr_uv) { return; }
++        sz = s->frame->linesize[1] * (n_uv-curr_uv);
++        base = s->frame->linesize[1] * curr_uv;
++        if (flush_chroma) {
++          p = av_buffer_pool_opaque(s->frame->buf[1]);
++          iocache.s[0].handle = p->vcsm_handle;
++          iocache.s[0].cmd = 3; // clean+invalidate
++          iocache.s[0].addr = (int)p->arm + base;
++          iocache.s[0].size  = sz;
++          p = av_buffer_pool_opaque(s->frame->buf[2]);
++          iocache.s[1].handle = p->vcsm_handle;
++          iocache.s[1].cmd = 3; // clean+invalidate
++          iocache.s[1].addr = (int)p->arm + base;
++          iocache.s[1].size  = sz;
++        }
++        if (flush_luma) {
++          p = av_buffer_pool_opaque(s->frame->buf[0]);
++          sz = s->frame->linesize[0] * (n-curr_y);
++          base = s->frame->linesize[0] * curr_y;
++          iocache.s[2].handle = p->vcsm_handle;
++          iocache.s[2].cmd = 3; // clean+invalidate
++          iocache.s[2].addr = (int)p->arm + base;
++          iocache.s[2].size  = sz;
++        }
++        vcsm_clean_invalid( &iocache );
++#else
++        if (flush_chroma) {
++          flush_buffer(s->frame->buf[1]);
++          flush_buffer(s->frame->buf[2]);
++        }
++        if (flush_luma) {
++          flush_buffer(s->frame->buf[0]);
++        }
++#endif
++}
++
++
+ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+ {
+     if (s->enable_rpi && s->used_for_ref) {
++      // TODO make this use ff_hevc_flush_buffer_lines
+ #ifdef RPI_FAST_CACHEFLUSH
+         struct vcsm_user_clean_invalid_s iocache = {};
+         int curr_y = ((int *)f->progress->data)[0];
+         int curr_uv = curr_y >> s->ps.sps->vshift[1];
+         int n_uv = n >> s->ps.sps->vshift[1];
+         int sz,base;
++        GPU_MEM_PTR_T *p;
+         if (curr_uv < 0) curr_uv = 0;
+         if (n_uv<=curr_uv) { return; }
+         sz = s->frame->linesize[1] * (n_uv-curr_uv);
+         base = s->frame->linesize[1] * curr_uv;
+-        GPU_MEM_PTR_T *p = av_buffer_pool_opaque(s->frame->buf[1]);
++        p = av_buffer_pool_opaque(s->frame->buf[1]);
+         iocache.s[0].handle = p->vcsm_handle;
+         iocache.s[0].cmd = 3; // clean+invalidate
+-        iocache.s[0].addr = p->arm + base;
++        iocache.s[0].addr = (int)p->arm + base;
+         iocache.s[0].size  = sz;
+         p = av_buffer_pool_opaque(s->frame->buf[2]);
+         iocache.s[1].handle = p->vcsm_handle;
+         iocache.s[1].cmd = 3; // clean+invalidate
+-        iocache.s[1].addr = p->arm + base;
++        iocache.s[1].addr = (int)p->arm + base;
+         iocache.s[1].size  = sz;
+ 
+ #ifdef RPI_LUMA_QPU
+@@ -911,7 +989,7 @@ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+         base = s->frame->linesize[0] * curr_y;
+         iocache.s[2].handle = p->vcsm_handle;
+         iocache.s[2].cmd = 3; // clean+invalidate
+-        iocache.s[2].addr = p->arm + base;
++        iocache.s[2].addr = (int)p->arm + base;
+         iocache.s[2].size  = sz;
+ #endif
+         vcsm_clean_invalid( &iocache );
+@@ -930,11 +1008,40 @@ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+ }
+ #endif
+ 
++#ifdef RPI_DEBLOCK_VPU
++/* rpi_deblock deblocks an entire row of ctbs using the VPU */
++static void rpi_deblock(HEVCContext *s, int y, int ctb_size)
++{
++  // Flush image, 4 lines above to bottom of ctb stripe
++  ff_hevc_flush_buffer_lines(s, FFMAX(y-4,0), y+ctb_size, 1, 0);
++  // TODO flush buffer of beta/tc setup when it becomes cached
++  // Call VPU
++  // TODO add this to a separate pipeline of VPU jobs that can be run in parallel and wait for completion
++  vpu_wait(vpu_post_code( vpu_get_fn(), get_vc_address(s->frame->buf[0]) + s->frame->linesize[0] * y, s->frame->linesize[0],
++                               s->setup_width, (int) ( s->y_setup_vc + s->setup_width * (y>>4) ),
++                               ctb_size>>4, 2, 0)); // 2 means to do the deblocking code
++}
++
++static void rpi_deblock2(HEVCContext *s, int y, int ctb_size)
++{
++   int y2;
++   for(y2=y;y2<y+ctb_size;y2+=16) {
++      rpi_deblock(s,y2,16);
++   }
++}
++#endif
++
+ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+ {
+     int x_end = x >= s->ps.sps->width  - ctb_size;
+     if (s->avctx->skip_loop_filter < AVDISCARD_ALL)
+         deblocking_filter_CTB(s, x, y);
++#ifdef RPI_DEBLOCK_VPU
++    if (s->enable_rpi_deblock && x_end)
++    {
++      rpi_deblock(s, y, ctb_size);
++    }
++#endif
+     if (s->ps.sps->sao_enabled) {
+         int y_end = y >= s->ps.sps->height - ctb_size;
+         if (y && x)
+@@ -965,6 +1072,7 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+         //if (((y + ctb_size)&63)==0)
+ #ifdef RPI_INTER_QPU
+         ff_hevc_flush_buffer(s, &s->ref->tf, y + ctb_size - 4);
++        // TODO we no longer need to flush the luma buffer as it is in GPU memory when using deblocking on the rpi
+ #endif
+         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
+     }
+diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
+index 4f13622..b3f155f 100644
+--- a/libavcodec/rpi_hevc_transform.h
++++ b/libavcodec/rpi_hevc_transform.h
+@@ -3,7 +3,13 @@ unsigned char rpi_hevc_transform [] = {
+ 106,
+ 0,
+ 144,
+-35,
++38,
++1,
++37,
++106,
++0,
++144,
++57,
+ 1,
+ 169,
+ 3,
+@@ -627,4 +633,1798 @@ unsigned char rpi_hevc_transform [] = {
+ 30,
+ 90,
+ 0,
++169,
++3,
++73,
++64,
++52,
++64,
++45,
++64,
++2,
++64,
++10,
++64,
++64,
++198,
++1,
++7,
++8,
++232,
++63,
++0,
++0,
++0,
++6,
++232,
++253,
++255,
++255,
++255,
++0,
++246,
++0,
++0,
++0,
++4,
++215,
++64,
++3,
++96,
++2,
++248,
++0,
++35,
++0,
++0,
++64,
++56,
++0,
++0,
++4,
++248,
++0,
++36,
++0,
++0,
++64,
++56,
++8,
++0,
++0,
++240,
++64,
++0,
++132,
++3,
++128,
++240,
++0,
++0,
++132,
++3,
++128,
++144,
++137,
++0,
++131,
++98,
++0,
++255,
++64,
++0,
++0,
++20,
++200,
++243,
++0,
++0,
++128,
++144,
++129,
++0,
++131,
++102,
++0,
++158,
++67,
++0,
++2,
++248,
++0,
++35,
++0,
++0,
++64,
++56,
++0,
++0,
++4,
++248,
++0,
++36,
++0,
++0,
++64,
++56,
++8,
++0,
++0,
++240,
++64,
++0,
++132,
++3,
++128,
++240,
++0,
++0,
++132,
++3,
++128,
++144,
++108,
++0,
++131,
++98,
++0,
++255,
++64,
++0,
++0,
++20,
++200,
++243,
++0,
++0,
++128,
++144,
++100,
++0,
++131,
++102,
++0,
++248,
++64,
++0,
++112,
++0,
++192,
++243,
++211,
++31,
++128,
++248,
++0,
++0,
++112,
++0,
++192,
++243,
++211,
++31,
++128,
++144,
++161,
++0,
++188,
++64,
++67,
++232,
++0,
++2,
++0,
++0,
++0,
++255,
++64,
++0,
++0,
++20,
++200,
++243,
++0,
++0,
++128,
++144,
++150,
++0,
++195,
++232,
++0,
++2,
++0,
++0,
++12,
++128,
++7,
++192,
++130,
++248,
++0,
++0,
++112,
++192,
++224,
++16,
++195,
++31,
++132,
++248,
++1,
++0,
++112,
++0,
++224,
++16,
++203,
++31,
++3,
++99,
++131,
++71,
++68,
++232,
++32,
++0,
++0,
++0,
++0,
++99,
++2,
++99,
++23,
++102,
++7,
++106,
++127,
++156,
++182,
++255,
++0,
++248,
++64,
++0,
++112,
++0,
++192,
++243,
++211,
++31,
++128,
++248,
++0,
++0,
++112,
++0,
++192,
++243,
++211,
++31,
++128,
++144,
++112,
++0,
++188,
++64,
++67,
++232,
++0,
++2,
++0,
++0,
++0,
++255,
++64,
++0,
++0,
++20,
++200,
++243,
++0,
++0,
++128,
++144,
++101,
++0,
++195,
++232,
++0,
++2,
++0,
++0,
++12,
++128,
++7,
++192,
++130,
++248,
++0,
++0,
++112,
++192,
++224,
++16,
++195,
++31,
++132,
++248,
++1,
++0,
++112,
++0,
++224,
++16,
++203,
++31,
++25,
++102,
++9,
++106,
++2,
++30,
++41,
++3,
++26,
++87,
++162,
++64,
++64,
++198,
++1,
++23,
++127,
++158,
++103,
++255,
++239,
++3,
++0,
++254,
++0,
++143,
++92,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++64,
++143,
++93,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++128,
++143,
++94,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++192,
++143,
++95,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++192,
++142,
++208,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++128,
++142,
++209,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++64,
++142,
++210,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++0,
++142,
++211,
++0,
++0,
++240,
++12,
++0,
++128,
++144,
++107,
++0,
++8,
++255,
++99,
++23,
++0,
++212,
++192,
++51,
++0,
++0,
++8,
++255,
++163,
++23,
++0,
++228,
++192,
++51,
++0,
++0,
++8,
++255,
++227,
++23,
++0,
++244,
++192,
++51,
++0,
++0,
++8,
++255,
++35,
++52,
++0,
++180,
++192,
++51,
++0,
++0,
++8,
++255,
++99,
++52,
++0,
++164,
++192,
++51,
++0,
++0,
++8,
++255,
++163,
++52,
++0,
++148,
++192,
++51,
++0,
++0,
++111,
++3,
++239,
++3,
++0,
++254,
++0,
++143,
++12,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++64,
++143,
++13,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++128,
++143,
++14,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++192,
++143,
++15,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++192,
++142,
++16,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++128,
++142,
++17,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++64,
++142,
++18,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++0,
++142,
++19,
++0,
++0,
++240,
++12,
++0,
++128,
++144,
++33,
++0,
++8,
++255,
++99,
++3,
++0,
++212,
++192,
++51,
++0,
++0,
++8,
++255,
++163,
++3,
++0,
++228,
++192,
++51,
++0,
++0,
++8,
++255,
++227,
++3,
++0,
++244,
++192,
++51,
++0,
++0,
++8,
++255,
++35,
++4,
++0,
++180,
++192,
++51,
++0,
++0,
++8,
++255,
++99,
++4,
++0,
++164,
++192,
++51,
++0,
++0,
++8,
++255,
++163,
++4,
++0,
++148,
++192,
++51,
++0,
++0,
++111,
++3,
++32,
++246,
++192,
++11,
++1,
++16,
++32,
++246,
++2,
++137,
++47,
++240,
++40,
++246,
++2,
++140,
++47,
++240,
++128,
++245,
++99,
++140,
++5,
++4,
++0,
++247,
++99,
++140,
++1,
++20,
++88,
++246,
++99,
++140,
++1,
++20,
++0,
++247,
++35,
++136,
++62,
++226,
++32,
++247,
++35,
++136,
++32,
++210,
++0,
++247,
++34,
++136,
++63,
++2,
++208,
++246,
++34,
++136,
++0,
++4,
++0,
++247,
++99,
++136,
++58,
++162,
++32,
++247,
++99,
++136,
++33,
++146,
++0,
++247,
++98,
++136,
++59,
++18,
++208,
++246,
++98,
++136,
++0,
++20,
++0,
++247,
++162,
++136,
++33,
++2,
++88,
++246,
++98,
++137,
++2,
++68,
++88,
++246,
++162,
++137,
++3,
++68,
++208,
++254,
++227,
++136,
++60,
++242,
++192,
++243,
++188,
++11,
++208,
++254,
++227,
++136,
++56,
++178,
++192,
++243,
++188,
++10,
++32,
++255,
++226,
++136,
++38,
++58,
++192,
++243,
++60,
++0,
++208,
++254,
++227,
++136,
++59,
++242,
++192,
++243,
++60,
++128,
++32,
++255,
++226,
++136,
++49,
++58,
++192,
++243,
++60,
++128,
++0,
++255,
++226,
++136,
++34,
++34,
++192,
++243,
++60,
++128,
++32,
++255,
++226,
++136,
++37,
++58,
++192,
++243,
++60,
++128,
++0,
++254,
++192,
++136,
++1,
++4,
++0,
++240,
++0,
++160,
++0,
++255,
++194,
++8,
++0,
++52,
++195,
++243,
++0,
++128,
++0,
++255,
++202,
++40,
++0,
++52,
++195,
++243,
++0,
++128,
++0,
++254,
++0,
++240,
++35,
++10,
++0,
++240,
++60,
++0,
++0,
++254,
++192,
++136,
++1,
++4,
++0,
++240,
++0,
++160,
++0,
++255,
++226,
++140,
++34,
++34,
++195,
++243,
++60,
++0,
++32,
++255,
++227,
++140,
++36,
++58,
++192,
++243,
++60,
++0,
++0,
++254,
++192,
++136,
++0,
++4,
++0,
++240,
++0,
++160,
++16,
++246,
++226,
++136,
++35,
++50,
++16,
++246,
++226,
++136,
++35,
++50,
++32,
++246,
++226,
++136,
++35,
++50,
++32,
++254,
++226,
++136,
++35,
++58,
++192,
++243,
++60,
++0,
++11,
++96,
++0,
++254,
++0,
++240,
++1,
++4,
++0,
++240,
++64,
++115,
++5,
++106,
++0,
++144,
++173,
++1,
++27,
++96,
++0,
++254,
++0,
++240,
++1,
++4,
++0,
++240,
++64,
++147,
++5,
++106,
++0,
++144,
++227,
++0,
++64,
++246,
++163,
++140,
++1,
++4,
++0,
++246,
++192,
++175,
++63,
++2,
++0,
++246,
++192,
++174,
++59,
++2,
++0,
++246,
++128,
++175,
++62,
++2,
++0,
++246,
++128,
++174,
++58,
++2,
++0,
++246,
++64,
++175,
++61,
++2,
++0,
++246,
++64,
++174,
++57,
++2,
++0,
++255,
++43,
++240,
++4,
++212,
++192,
++243,
++128,
++11,
++64,
++254,
++43,
++240,
++1,
++228,
++192,
++243,
++128,
++10,
++64,
++254,
++43,
++240,
++1,
++244,
++192,
++243,
++128,
++10,
++64,
++254,
++43,
++240,
++1,
++180,
++192,
++243,
++128,
++10,
++64,
++254,
++43,
++141,
++0,
++164,
++192,
++243,
++128,
++10,
++88,
++246,
++35,
++141,
++3,
++68,
++32,
++247,
++35,
++141,
++191,
++66,
++240,
++246,
++35,
++141,
++50,
++66,
++0,
++255,
++235,
++143,
++52,
++242,
++192,
++243,
++60,
++128,
++0,
++255,
++43,
++240,
++2,
++212,
++192,
++243,
++128,
++11,
++0,
++255,
++43,
++240,
++191,
++226,
++192,
++243,
++188,
++10,
++64,
++254,
++43,
++141,
++0,
++180,
++192,
++243,
++128,
++10,
++88,
++246,
++35,
++141,
++2,
++68,
++32,
++247,
++35,
++141,
++190,
++66,
++240,
++246,
++35,
++141,
++50,
++66,
++0,
++255,
++171,
++143,
++52,
++226,
++192,
++243,
++60,
++128,
++0,
++255,
++43,
++240,
++4,
++180,
++192,
++243,
++128,
++11,
++0,
++255,
++43,
++240,
++191,
++226,
++192,
++243,
++188,
++10,
++128,
++253,
++43,
++240,
++3,
++212,
++192,
++243,
++128,
++10,
++64,
++254,
++35,
++141,
++1,
++196,
++192,
++243,
++128,
++10,
++88,
++246,
++35,
++141,
++3,
++68,
++32,
++247,
++35,
++141,
++189,
++66,
++240,
++246,
++35,
++141,
++50,
++66,
++0,
++255,
++107,
++143,
++52,
++210,
++192,
++243,
++60,
++128,
++0,
++255,
++43,
++240,
++4,
++148,
++192,
++243,
++128,
++11,
++64,
++254,
++43,
++240,
++1,
++164,
++192,
++243,
++128,
++10,
++64,
++254,
++43,
++240,
++1,
++180,
++192,
++243,
++128,
++10,
++64,
++254,
++43,
++240,
++1,
++244,
++192,
++243,
++128,
++10,
++64,
++254,
++43,
++141,
++0,
++228,
++192,
++243,
++128,
++10,
++88,
++246,
++35,
++141,
++3,
++68,
++32,
++247,
++35,
++141,
++187,
++66,
++240,
++246,
++35,
++141,
++50,
++66,
++0,
++255,
++235,
++142,
++52,
++178,
++192,
++243,
++60,
++128,
++0,
++255,
++43,
++240,
++2,
++148,
++192,
++243,
++128,
++11,
++0,
++255,
++43,
++240,
++187,
++162,
++192,
++243,
++188,
++10,
++64,
++254,
++43,
++141,
++0,
++244,
++192,
++243,
++128,
++10,
++88,
++246,
++35,
++141,
++2,
++68,
++32,
++247,
++35,
++141,
++186,
++66,
++240,
++246,
++35,
++141,
++50,
++66,
++0,
++255,
++171,
++142,
++52,
++162,
++192,
++243,
++60,
++128,
++0,
++255,
++43,
++240,
++4,
++244,
++192,
++243,
++128,
++11,
++0,
++255,
++43,
++240,
++187,
++162,
++192,
++243,
++188,
++10,
++128,
++253,
++43,
++240,
++3,
++148,
++192,
++243,
++128,
++10,
++64,
++254,
++35,
++141,
++1,
++132,
++192,
++243,
++128,
++10,
++88,
++246,
++35,
++141,
++3,
++68,
++32,
++247,
++35,
++141,
++185,
++66,
++240,
++246,
++35,
++141,
++50,
++66,
++0,
++255,
++107,
++142,
++52,
++146,
++192,
++243,
++60,
++128,
++64,
++255,
++98,
++141,
++0,
++52,
++192,
++243,
++0,
++0,
++0,
++254,
++0,
++240,
++53,
++10,
++0,
++240,
++60,
++0,
++0,
++254,
++0,
++240,
++1,
++4,
++0,
++240,
++64,
++147,
++5,
++106,
++0,
++144,
++177,
++0,
++88,
++246,
++163,
++140,
++1,
++4,
++128,
++245,
++99,
++141,
++10,
++4,
++88,
++246,
++162,
++138,
++1,
++68,
++0,
++247,
++162,
++138,
++36,
++162,
++88,
++254,
++162,
++138,
++3,
++164,
++192,
++243,
++128,
++11,
++0,
++255,
++226,
++137,
++32,
++2,
++195,
++243,
++60,
++0,
++32,
++247,
++226,
++137,
++42,
++114,
++0,
++255,
++34,
++138,
++33,
++18,
++195,
++243,
++60,
++0,
++32,
++247,
++34,
++138,
++42,
++130,
++16,
++246,
++98,
++138,
++40,
++114,
++16,
++246,
++98,
++138,
++41,
++146,
++32,
++246,
++98,
++138,
++41,
++146,
++32,
++246,
++226,
++137,
++41,
++146,
++40,
++246,
++34,
++138,
++41,
++146,
++32,
++247,
++163,
++141,
++63,
++178,
++32,
++247,
++227,
++141,
++62,
++162,
++0,
++254,
++0,
++240,
++8,
++4,
++0,
++240,
++128,
++11,
++128,
++253,
++35,
++240,
++9,
++100,
++192,
++243,
++128,
++10,
++128,
++253,
++163,
++141,
++128,
++115,
++192,
++243,
++152,
++10,
++88,
++246,
++163,
++141,
++4,
++100,
++208,
++246,
++35,
++139,
++0,
++100,
++32,
++255,
++34,
++139,
++53,
++202,
++192,
++243,
++60,
++128,
++0,
++254,
++0,
++139,
++0,
++4,
++0,
++240,
++0,
++160,
++240,
++246,
++163,
++141,
++48,
++98,
++0,
++247,
++99,
++139,
++63,
++210,
++0,
++247,
++98,
++139,
++1,
++212,
++88,
++254,
++98,
++139,
++1,
++212,
++192,
++243,
++128,
++11,
++32,
++255,
++99,
++139,
++62,
++98,
++192,
++243,
++188,
++10,
++88,
++246,
++98,
++139,
++1,
++212,
++240,
++246,
++98,
++139,
++50,
++210,
++0,
++247,
++163,
++128,
++59,
++146,
++0,
++247,
++160,
++128,
++1,
++36,
++88,
++254,
++160,
++128,
++1,
++36,
++192,
++243,
++128,
++11,
++0,
++247,
++163,
++128,
++58,
++98,
++64,
++255,
++35,
++240,
++0,
++100,
++192,
++243,
++128,
++10,
++64,
++255,
++163,
++128,
++0,
++164,
++192,
++243,
++128,
++10,
++88,
++246,
++160,
++128,
++1,
++36,
++240,
++246,
++160,
++128,
++50,
++34,
++8,
++255,
++227,
++143,
++54,
++242,
++192,
++243,
++60,
++128,
++40,
++255,
++227,
++142,
++54,
++178,
++192,
++243,
++60,
++128,
++0,
++254,
++0,
++240,
++39,
++10,
++0,
++240,
++60,
++128,
++8,
++255,
++163,
++143,
++45,
++226,
++192,
++243,
++60,
++128,
++0,
++254,
++0,
++240,
++44,
++10,
++0,
++240,
++60,
++0,
++0,
++254,
++0,
++240,
++40,
++10,
++0,
++240,
++60,
++128,
++8,
++255,
++163,
++142,
++2,
++162,
++192,
++243,
++60,
++128,
++90,
++0,
+ };
+diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
+index fd159bc..b055208 100644
+--- a/libavcodec/rpi_hevc_transform.s
++++ b/libavcodec/rpi_hevc_transform.s
+@@ -83,6 +83,8 @@
+ hevc_trans_16x16:
+   cmp r5,1
+   beq memclear16
++  cmp r5,2
++  beq hevc_deblock_16x16
+   push r6-r15, lr # TODO cut down number of used registers
+   mov r14,r3 # coeffs32
+   mov r15,r4 # num32
+@@ -282,3 +284,427 @@ loop:
+   cmp r1,0
+   bgt loop
+   b lr
++
++
++################################################################################
++# HEVC VPU Deblock
++#
++# Vertical edges before horizontal
++# Decision can change every 4 pixels, but only 8 pixel boundaries are deblocked
++#
++# ARM is responsible for storing beta and tc for each 4 pixels horiz and vert edge.
++# The VPU code works in units of 16x16 blocks.
++# We do vertical filtering for the current block followed by horizontal filtering for the previous (except for the first time).
++# One final horizontal filter is required at the end.
++# PCM is not allowed in this code.
++#
++#
++# H(16-4:16+15,0) contains previous block (note that we need 4 lines above of context that may get altered during filtering)
++# H(16:31,16) contains current block (note that we do not need the upper lines until the horizontal filtering.
++
++.set P0,63
++.set P1,62
++.set P2,61
++.set P3,60
++.set Q0,59
++.set Q1,58
++.set Q2,57
++.set Q3,56
++
++.set dp,32
++.set dq,33
++.set d,34
++.set decision,35
++.set beta,36
++.set beta2,37
++.set beta3,38
++.set ptest,39
++.set qtest,40
++.set pqtest,41
++.set thresh,42
++.set deltatest, 44
++.set deltap1, 45
++.set tc25, 46
++.set setup,47
++.set tc,48
++.set tc25,49
++.set tc2, 50
++.set do_filter, 51
++.set delta, 52
++.set tc10, 53
++.set delta0, 54
++.set delta1, 55
++.set zeros, 0
++.set setup_input, 1
++.set deltaq1, 2
++
++
++
++# hevc_deblock_16x16 deblocks an entire row that is 16 pixels high by the full width of the image.
++# Row has num16 16x16 blocks across
++# Beta goes from 0 to 64
++# tc goes from 0 to 24
++# setup[block_idx][0=vert,1=horz][0=first edge, 1=second edge][0=beta,1=tc][0..3=edge number]
++#   has 8 bytes per edge
++#   has 16 bytes per direction
++#   has 32 bytes per 16x16 block
++# hevc_deblock_16x16(uint8_t *img (r0), int stride (r1), int num16w (r2), uint8_t setup[num16][2][2][2][4](r3),int num16h(r4))
++hevc_deblock_16x16:
++  push r6-r15, lr
++  mov r9,r4
++  mov r4,r3
++  mov r13,r2
++  mov r2,r0
++  mov r10,r0
++  subscale4 r0,r1
++  mov r8,63
++  mov r6,-3
++  vmov H(zeros,0),0
++# r7 is number of blocks still to load
++# r0 is location of current block - 4 * stride
++# r1 is stride
++# r2 is location of current block
++# r3 is offset of start of block (actual edges start at H(16,16)+r3 for horizontal and H(16,0)+r3 for vertical
++# r4 is setup
++# r5 is for temporary calculations
++# r8 holds 63
++# r6 holds -3
++# r9 holds the number of 16 high rows to process
++# r10 holds the original img base
++# r11 returns 0 if no filtering was done on the edge
++# r12 saves a copy of this
++# r13 is copy of width
++
++process_row:
++  # First iteration does not do horizontal filtering on previous
++  mov r7, r13
++  mov r3,0
++  vldb H(12++,16)+r3,(r0 += r1) REP 4    # Load the current block
++  vldb H(16++,16)+r3,(r2 += r1) REP 16
++  vldb H(setup_input,0), (r4)  # We may wish to prefetch these
++  vstb H(zeros,0),(r4)
++  bl vert_filter
++  add r3,8
++  vadd H(setup_input,0),H(setup_input,8),0 # Rotate to second set of 8
++  bl vert_filter
++  sub r3,8
++  b start_deblock_loop
++deblock_loop:
++  # Middle iterations do vertical on current block and horizontal on preceding
++  vldb H(12++,16)+r3,(r0 += r1) REP 4  # load the current block
++  vldb H(16++,16)+r3,(r2 += r1) REP 16
++  vldb H(setup_input,0), (r4)
++  vstb H(zeros,0),(r4)
++  bl vert_filter
++  add r3,8
++  vadd H(setup_input,0),H(setup_input,8),0
++  bl vert_filter
++  sub r3,8
++  vldb H(setup_input,0), -16(r4)
++  vstb H(zeros,0),-16(r4)
++  bl horz_filter
++  mov r12,r11
++  add r3,8*64
++  vadd H(setup_input,0),H(setup_input,8),0
++  bl horz_filter
++  sub r3,8*64
++  addcmpbeq r12,0,0,skip_save_top
++  vstb H(12++,0)+r3,-16(r0 += r1) REP 4  # Save the deblocked pixels for the previous block
++skip_save_top:
++  vstb H(16++,0)+r3,-16(r2 += r1) REP 16
++start_deblock_loop:
++  # move onto next 16x16 (could do this with circular buffer support instead)
++  add r3,16
++  and r3,r8
++  add r4,32
++  # Perform loop counter operations (may work with an addcmpbgt as well?)
++  add r0,16
++  add r2,16
++  sub r7,1
++  cmp r7,0 # Are there still more blocks to load
++  bgt deblock_loop
++
++  # Final iteration needs to just do horizontal filtering
++  vldb H(setup_input,0), -16(r4)
++  vstb H(zeros,0),-16(r4)
++  bl horz_filter
++  mov r12,r11
++  add r3,8*64
++  vadd H(setup_input,0),H(setup_input,8),0
++  bl horz_filter
++  sub r3,64*8
++  addcmpbeq r12,0,0,skip_save_top2
++  vstb H(12++,0)+r3,-16(r0 += r1) REP 4  # Save the deblocked pixels for the previous block
++skip_save_top2:
++  vstb H(16++,0)+r3,-16(r2 += r1) REP 16
++
++# Now look to see if we should do another row
++  sub r9,1
++  cmp r9,0
++  bgt start_again
++  pop r6-r15, pc
++start_again:
++  # Need to sort out r0,r2 to point to next row down
++  addscale16 r10,r1
++  mov r2,r10
++  subscale4 r0,r2,r1
++  b process_row
++
++
++# At this stage H(16,16)+r3 points to the first pixel of the 16 high edge to be filtered
++# So we can reuse the code we move the parts to be filtered into HX(P0/P1/P2/P3/Q0/Q1/Q2/Q3,0) - we will perform a final saturation step on placing them back into the correct locations
++
++vert_filter:
++  push lr
++
++  vmov HX(P3,0), V(16,12)+r3
++  vmov HX(P2,0), V(16,13)+r3
++  vmov HX(P1,0), V(16,14)+r3
++  vmov HX(P0,0), V(16,15)+r3
++  vmov HX(Q0,0), V(16,16)+r3
++  vmov HX(Q1,0), V(16,17)+r3
++  vmov HX(Q2,0), V(16,18)+r3
++  vmov HX(Q3,0), V(16,19)+r3
++
++  bl do_luma_filter
++
++  vadds V(16,13)+r3, HX(P2,0), 0
++  vadds V(16,14)+r3, HX(P1,0), 0
++  vadds V(16,15)+r3, HX(P0,0), 0
++  # P3 and Q3 never change so don't bother saving back
++  vadds V(16,16)+r3, HX(Q0,0), 0
++  vadds V(16,17)+r3, HX(Q1,0), 0
++  vadds V(16,18)+r3, HX(Q2,0), 0
++
++  pop pc
++
++# Filter edge at H(16,0)+r3
++horz_filter:
++  push lr
++
++  vmov HX(P3,0), H(12,0)+r3
++  vmov HX(P2,0), H(13,0)+r3
++  vmov HX(P1,0), H(14,0)+r3
++  vmov HX(P0,0), H(15,0)+r3
++  vmov HX(Q0,0), H(16,0)+r3
++  vmov HX(Q1,0), H(17,0)+r3
++  vmov HX(Q2,0), H(18,0)+r3
++  vmov HX(Q3,0), H(19,0)+r3
++
++  bl do_luma_filter
++
++  vadds H(13,0)+r3, HX(P2,0), 0
++  vadds H(14,0)+r3, HX(P1,0), 0
++  vadds H(15,0)+r3, HX(P0,0), 0
++  # P3 and Q3 never change so don't bother saving back
++  vadds H(16,0)+r3, HX(Q0,0), 0
++  vadds H(17,0)+r3, HX(Q1,0), 0
++  vadds H(18,0)+r3, HX(Q2,0), 0
++
++  pop pc
++
++# r4 points to array of beta/tc for each 4 length edge
++do_luma_filter:
++  valtl H(setup,0),H(setup_input,0),H(setup_input,0) # b*8tc*8
++  valtl HX(beta,0),H(setup,0),H(setup,0)
++  valtu HX(tc,0),H(setup,0),H(setup,0)
++  vmul HX(tc25,0), HX(tc,0), 5
++  vadd HX(tc25,0),HX(tc25,0), 1
++  vasr HX(tc25,0), HX(tc25,0), 1
++
++  # Compute decision
++  vadd HX(dp,0),HX(P1,0),HX(P1,0) # 2*P1
++  vsub HX(dp,0),HX(P2,0),HX(dp,0) # P2-2*P1
++  vadd HX(dp,0),HX(dp,0),HX(P0,0) # P2-2*P1+P0
++  vdist HX(dp,0),HX(dp,0),0 # abs(P2-2*P1+P0) # dp0
++
++  vadd HX(dq,0),HX(Q1,0),HX(Q1,0) # 2*Q1
++  vsub HX(dq,0),HX(Q2,0),HX(dq,0) # Q2-2*Q1
++  vadd HX(dq,0),HX(dq,0),HX(Q0,0) # Q2-2*Q1+Q0
++  vdist HX(dq,0),HX(dq,0),0 # abs(Q2-2*Q1+Q0) # dq0
++
++  vadd HX(d,0), HX(dp,0), HX(dq,0)
++  vasr HX(beta2,0),HX(beta,0),2
++  vasr HX(beta3,0),HX(beta,0),3
++
++  # Compute flags that are negative if all conditions pass
++  vdist HX(decision,0), HX(P0,0), HX(P3,0) CLRA SACC
++  vdist HX(decision,0), HX(Q0,0), HX(Q3,0) SACC
++  vsub HX(decision,0), HX(decision,0), HX(beta3,0) SETF
++
++  vdist HX(decision,0), HX(P0,0), HX(Q0,0) IFN
++  vsub HX(decision,0), HX(decision,0), HX(tc25,0) IFN SETF
++  vadd HX(decision,0), HX(d,0), HX(d,0) IFN
++  vsub HX(decision,0), HX(decision,0), HX(beta2,0) IFN SETF
++  vmov HX(decision,0), 1 IFNN
++  vadd H(decision,0),H(decision,3),0 IFN
++  vadd H(decision,16),H(decision,19),0 IFN
++  vmov -,HX(decision,0) SETF   # N marks strong filter
++  vmov HX(decision,0), 1 IFNN  # NN marks normal filter
++
++  vadd HX(do_filter,0), HX(d,3), HX(d,0)
++  vsub HX(do_filter,0), HX(do_filter,0), HX(beta,0) SETF # IFNN means no filter
++  vmov HX(decision,0),0 IFNN # Z marks no filter
++
++  # Expand out decision (currently valid one every 4 pixels)  0...1...2...3
++  # First extract out even terms
++  vodd HX(decision,0),HX(decision,0),HX(decision,0)  # 0.1.2.3
++  vodd HX(decision,0),HX(decision,0),HX(decision,0)  # 0123
++  # Now expand back
++  valtl HX(decision,0),HX(decision,0),HX(decision,0) # 00112233
++  valtl HX(decision,0),HX(decision,0),HX(decision,0) SETF # 0000111122223333
++
++  # HX(decision,0) is negative if want strong filtering, 1 if want normal filtering, 0 if want no filtering
++
++  # Do a quick check to see if there is anything to do
++  mov r11, 0 # Signal no filtering
++  vmov -,1 IFNZ SUMS r5
++  cmp r5,0
++  beq filtering_done
++  mov r11, 1 # Signal some filtering
++  # And whether there is any strong filtering
++  vmov -,1 IFN SUMS r5
++  cmp r5,0
++  beq normal_filtering
++
++  ##############################################################################
++  # Strong filtering - could maybe fast case if all have same sign? (especially if all disabled!)
++  vshl HX(tc2,0), HX(tc,0), 1  # Note that in normal filtering tx2 is tc/2, while here it is tc*2
++
++  # Take a copy of the original pixels for use in decision calculation
++  vmov HX(P0,32),HX(P0,0)
++  vmov HX(Q0,32),HX(Q0,0)
++  vmov HX(P1,32),HX(P1,0)
++  vmov HX(Q1,32),HX(Q1,0)
++  vmov HX(P2,32),HX(P2,0)
++  vmov HX(Q2,32),HX(Q2,0)
++
++  vadd -,HX(P2,32),4 CLRA SACC
++  vshl -,HX(P1,32),1 SACC
++  vshl -,HX(P0,32),1 SACC
++  vshl -,HX(Q0,32),1 SACC
++  vshl HX(delta,0),HX(Q1,32),0 SACC
++  vasr HX(delta,0),HX(delta,0), 3
++  vsub HX(delta,0),HX(delta,0),HX(P0,32)
++  vclamps HX(delta,0), HX(delta,0), HX(tc2,0)
++  vadd HX(P0,0),HX(P0,32),HX(delta,0) IFN
++
++  vadd -,HX(P2,32),2 CLRA SACC
++  vadd -,HX(P1,32),HX(P0,32) SACC
++  vshl HX(delta,0),HX(Q0,32),0 SACC
++  vasr HX(delta,0),HX(delta,0), 2
++  vsub HX(delta,0),HX(delta,0),HX(P1,32)
++  vclamps HX(delta,0), HX(delta,0), HX(tc2,0)
++  vadd HX(P1,0),HX(P1,32),HX(delta,0) IFN
++
++  vadd -,HX(Q0,32),4 CLRA SACC
++  vadd -,HX(P1,32),HX(P0,32) SACC
++  vmul -,HX(P2,32),3 SACC
++  vshl HX(delta,0),HX(P3,0),1 SACC # Note that we have not made a copy of P3, so using P3,0 is correct
++  vasr HX(delta,0),HX(delta,0), 3
++  vsub HX(delta,0),HX(delta,0),HX(P2,32)
++  vclamps HX(delta,0), HX(delta,0), HX(tc2,0)
++  vadd HX(P2,0),HX(P2,32),HX(delta,0) IFN
++  #vmov HX(P2,0),3 IFN
++
++  # Now reverse all P/Qs
++
++  vadd -,HX(Q2,32),4 CLRA SACC
++  vshl -,HX(Q1,32),1 SACC
++  vshl -,HX(Q0,32),1 SACC
++  vshl -,HX(P0,32),1 SACC
++  vshl HX(delta,0),HX(P1,32),0 SACC
++  vasr HX(delta,0),HX(delta,0), 3
++  vsub HX(delta,0),HX(delta,0),HX(Q0,32)
++  vclamps HX(delta,0), HX(delta,0), HX(tc2,0)
++  vadd HX(Q0,0),HX(Q0,32),HX(delta,0) IFN
++
++  vadd -,HX(Q2,32),2 CLRA SACC
++  vadd -,HX(Q1,32),HX(Q0,32) SACC
++  vshl HX(delta,0),HX(P0,32),0 SACC
++  vasr HX(delta,0),HX(delta,0), 2
++  vsub HX(delta,0),HX(delta,0),HX(Q1,32)
++  vclamps HX(delta,0), HX(delta,0), HX(tc2,0)
++  vadd HX(Q1,0),HX(Q1,32),HX(delta,0) IFN
++
++  vadd -,HX(P0,32),4 CLRA SACC
++  vadd -,HX(Q1,32),HX(Q0,32) SACC
++  vmul -,HX(Q2,32),3 SACC
++  vshl HX(delta,0),HX(Q3,0),1 SACC # Note that we have not made a copy of Q3, so using Q3,0 is correct
++  vasr HX(delta,0),HX(delta,0), 3
++  vsub HX(delta,0),HX(delta,0),HX(Q2,32)
++  vclamps HX(delta,0), HX(delta,0), HX(tc2,0)
++  vadd HX(Q2,0),HX(Q2,32),HX(delta,0) IFN
++
++  ##############################################################################
++  # Normal filtering
++normal_filtering:
++  # Invert the decision flags
++  # make instruction more complicated as assembler has error and loses SETF
++  vrsub HX(tc10,0), HX(decision,0), 0 SETF # IFN means normal filtering
++  vmov  -, HX(tc10,0) SETF # IFN means normal filtering
++
++  vmov -,1 IFN SUMS r5
++  cmp r5,0
++  beq filtering_done
++
++  vasr HX(tc2,0), HX(tc,0), 1
++  vmul HX(tc10,0), HX(tc,0), 10
++
++  vasr HX(thresh,0), HX(beta,0), 1
++  vadd HX(thresh,0), HX(thresh,0), HX(beta,0)
++  vasr HX(thresh,0), HX(thresh,0), 3 CLRA SACC
++
++  vadd HX(ptest,0),HX(dp,3),HX(dp,0)
++  vsub HX(ptest,0),HX(ptest,0),HX(thresh,0) # ptest is negative if we need to do the P2 pixel
++  vadd HX(qtest,0),HX(dq,3),HX(dq,0)
++  vsub HX(qtest,0),HX(qtest,0),HX(thresh,0) # qtest is negative if we need to do the Q2 pixel
++  # Expand ptest and qtest together
++  vodd HX(pqtest,0),HX(ptest,0),HX(qtest,0)  # p.p.p.p.q.q.q.q
++  vodd HX(pqtest,0),HX(pqtest,0),HX(pqtest,0) # ppppqqqq........
++  valtl HX(pqtest,0),HX(pqtest,0),HX(pqtest,0) # ppppppppqqqqqqqq
++  valtl HX(ptest,0),HX(pqtest,0),HX(pqtest,0)
++  valtu HX(qtest,0),HX(pqtest,0),HX(pqtest,0)
++
++  vsub HX(delta0,0), HX(Q0,0), HX(P0,0)
++  vsub HX(delta1,0), HX(Q1,0), HX(P1,0)
++  vmov -,8 CLRA SACC
++  vmul -,HX(delta0,0), 9 SACC
++  vmul HX(delta0,0),HX(delta1,0), r6 SACC
++  vasr HX(delta0,0), HX(delta0,0), 4
++  vdist HX(deltatest,0), HX(delta0,0), 0
++  vsub HX(deltatest,0), HX(deltatest,0), HX(tc10,0) IFN SETF # negative if still need to do something
++  vmov HX(deltatest,0), 0 IFNN # clear if no need to do anything so we can reload flags later
++
++  vclamps HX(delta0,0), HX(delta0,0), HX(tc,0)
++
++  vadd HX(deltap1,0), HX(P2,0), HX(P0,0)
++  vadd HX(deltap1,0), HX(deltap1,0), 1
++  vasr HX(deltap1,0), HX(deltap1,0), 1 CLRA SACC
++  vsub HX(deltap1,0), HX(delta0,0), HX(P1,0) SACC
++  vasr HX(deltap1,0), HX(deltap1,0), 1
++  vclamps HX(deltap1,0), HX(deltap1,0), HX(tc2,0)
++
++  vadd HX(deltaq1,0), HX(Q2,0), HX(Q0,0)
++  vadd HX(deltaq1,0), HX(deltaq1,0), 1
++  vasr HX(deltaq1,0), HX(deltaq1,0), 1 CLRA SACC
++  vadd HX(deltaq1,0), HX(delta0,0), HX(Q1,0)
++  vrsub -, HX(delta0,0), 0 SACC
++  vrsub HX(deltaq1,0), HX(Q1,0), 0 SACC
++  vasr HX(deltaq1,0), HX(deltaq1,0), 1
++  vclamps HX(deltaq1,0), HX(deltaq1,0), HX(tc2,0)
++
++  vadds HX(P0,0), HX(P0,0), HX(delta0,0) IFN
++  vsubs HX(Q0,0), HX(Q0,0), HX(delta0,0) IFN
++
++  vmov -,HX(ptest,0) IFN SETF # Negative if need to do p1
++  vadds HX(P1,0), HX(P1,0), HX(deltap1,0) IFN
++
++  vmov -,HX(deltatest,0) SETF
++  vmov -,HX(qtest,0) IFN SETF # Negative if need to do q1
++  vadds HX(Q1,0), HX(Q1,0), HX(deltaq1,0) IFN
++
++  #vmov HX(P2,0),1 IFN
++
++filtering_done:
++  b lr
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 0121fca..05b2169 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -147,7 +147,7 @@ static int gpu_init(volatile struct GPU **gpu) {
+   vcsm_init();
+   gpu_malloc_uncached_internal(sizeof(struct GPU), &gpu_mem_ptr, mb);
+   ptr = (volatile struct GPU*)gpu_mem_ptr.arm;
+-  memset(ptr, 0, sizeof *ptr);
++  memset((void*)ptr, 0, sizeof *ptr);
+   vc = gpu_mem_ptr.vc;
+ 
+   ptr->mb = mb;
+@@ -254,7 +254,7 @@ void gpu_cache_flush(GPU_MEM_PTR_T *p)
+     struct vcsm_user_clean_invalid_s iocache = {};
+     iocache.s[0].handle = p->vcsm_handle;
+     iocache.s[0].cmd = 3; // clean+invalidate
+-    iocache.s[0].addr = p->arm;
++    iocache.s[0].addr = (int) p->arm;
+     iocache.s[0].size  = p->numbytes;
+     vcsm_clean_invalid( &iocache );
+ #else
+@@ -390,6 +390,7 @@ static void *vpu_start(void *arg) {
+ #ifdef RPI_TIME_TOTAL_POSTED
+   int last_time=0;
+   long long on_time=0;
++  long long on_time_deblock=0;
+   long long off_time=0;
+   int start_time;
+   int end_time;
+@@ -451,10 +452,13 @@ static void *vpu_start(void *arg) {
+ #ifdef RPI_TIME_TOTAL_POSTED
+     end_time = Microseconds();
+     last_time = end_time;
+-    on_time += end_time - start_time;
++    if (p[6]==2)
++      on_time_deblock += end_time - start_time;
++    else
++      on_time += end_time - start_time;
+     count++;
+     if ((count&0x7f)==0)
+-      printf("Posted %d On=%dms, Off=%dms\n",count,(int)(on_time/1000),(int)(off_time/1000));
++      printf("Posted %d On=%dms, On_deblock=%dms, Off=%dms\n",count,(int)(on_time/1000),(int)(on_time_deblock/1000),(int)(off_time/1000));
+ #endif
+     pthread_mutex_lock(&post_mutex);
+     vpu_async_head++;
+diff --git a/libavcodec/rpi_shader.c b/libavcodec/rpi_shader.c
+index e86eb30..c5d8b29 100644
+--- a/libavcodec/rpi_shader.c
++++ b/libavcodec/rpi_shader.c
+@@ -61,7 +61,7 @@ unsigned int rpi_shader[] = {
+ /* [0x00000120] */ 0x8c9e7052, 0x10025e18, // add t0s, r0, r1 ; mov ra_frame_base, r2
+ /* [0x00000128] */ 0x0c9e7440, 0x10020f27, // add t1s, r2, r1
+ /* [0x00000130] */ 0x00000008, 0xe00208a7, // mov r2,8
+-/* [0x00000138] */ 0x11827c80, 0x10021327, // shl rb12,unif, r2
++/* [0x00000138] */ 0x11827c80, 0x10021327, // shl rb12,unif,r2
+ /* [0x00000140] */ 0x0c827c80, 0x10021367, // add rb13,unif,r2
+ /* [0x00000148] */ 0x15827d80, 0x100208a7, // mov r2, unif
+ /* [0x00000150] */ 0x119c15c0, 0xd00208a7, // shl r2, r2, 1
+-- 
+2.7.4
+
+
+From e9c59f0d7b42dfb10d85ab2477f95b44484a8d70 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 1 Jul 2015 09:21:17 +0100
+Subject: [PATCH 65/68] Added ability to combine jobs
+
+---
+ libavcodec/rpi_qpu.c | 81 +++++++++++++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 80 insertions(+), 1 deletion(-)
+
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 05b2169..91777be 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -8,6 +8,8 @@
+ #define RPI_TIME_TOTAL_POSTED
+ // define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
+ #define RPI_ASYNC
++// Define RPI_COMBINE_JOBS to find jobs that can be executed in parallel
++#define RPI_COMBINE_JOBS
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+@@ -398,9 +400,15 @@ static void *vpu_start(void *arg) {
+ #endif
+   while(1) {
+     int i;
+-    int *p;
++    int *p; // Pointer for a QPU/VPU job
++#ifdef RPI_COMBINE_JOBS
++    int *q = NULL; // Pointer for a VPU only job
++    int have_qpu = 0;
++    int have_vpu = 0;
++#endif
+     int qpu_code;
+     int qpu_codeb;
++    int num_jobs; // Number of jobs available
+     pthread_mutex_lock(&post_mutex);
+     while( vpu_async_tail - vpu_async_head <= 0)
+     {
+@@ -408,13 +416,38 @@ static void *vpu_start(void *arg) {
+       pthread_cond_wait(&post_cond_tail, &post_mutex);
+     }
+     p = vpu_cmds[vpu_async_head%MAXCMDS];
++    num_jobs = vpu_async_tail - vpu_async_head;
+     pthread_mutex_unlock(&post_mutex);
+ 
+     if (p[6] == -1) {
+       break; // Last job
+     }
++    if (p[7] == 0 && p[0] == 0 && p[16]==0)
++      goto job_done_early;
++
++#ifdef RPI_COMBINE_JOBS
++    // First scan for a qpu job
++    for (int x=0;x<num_jobs;x++) {
++      p = vpu_cmds[(vpu_async_head+x)%MAXCMDS];
++      if (p[7]) {
++        have_qpu = 1;
++        break;
++      }
++    }
++    // Now scan for a non-qpu job
++    for (int x=0;x<num_jobs;x++) {
++      q = vpu_cmds[(vpu_async_head+x)%MAXCMDS];
++      if (!q[7]) {
++        have_vpu = 1;
++        break;
++      }
++    }
++    printf("Have_qpu = %d, have_vpu=%d\n",have_qpu,have_vpu);
++#endif
+     qpu_code = p[7];
+     qpu_codeb = p[16];
++
++
+     //if (p[7]) {
+         //GPU_MEM_PTR_T *buf = (GPU_MEM_PTR_T *)p[7];
+         //gpu_cache_flush(buf);
+@@ -427,6 +460,40 @@ static void *vpu_start(void *arg) {
+     off_time += start_time-last_time;
+ #endif
+ 
++#ifdef RPI_COMBINE_JOBS
++    if (have_qpu) {
++      for(i=0;i<8;i++) {
++        gpu->mail[i*2] = p[8+i];
++        gpu->mail[i*2 + 1] = qpu_code;
++      }
++      for(i=0;i<12;i++) {
++        gpu->mail2[i*2] = p[17+i];
++        gpu->mail2[i*2 + 1] = qpu_codeb;
++      }
++      if (have_vpu) {
++        execute_multi(gpu->mb,
++                              12,gpu->vc + offsetof(struct GPU, mail2), 1, 5000,
++                              8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
++                              p[0], p[1], p[2], p[3], p[4], p[5], p[6], // VPU0
++                              q[0], q[1], q[2], q[3], q[4], q[5], q[6]); // VPU1
++        q[0] = 0;
++      } else {
++        execute_multi(gpu->mb,
++                              12,gpu->vc + offsetof(struct GPU, mail2), 1, 5000,
++                              8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
++                              p[0], p[1], p[2], p[3], p[4], p[5], p[6], // VPU0
++                              0,    0   , 0   , 0   , 0   , 0   , 0); // VPU1
++      }
++      p[0] = 0;
++      p[7] = 0;
++      p[16] = 0;
++    } else {
++        av_assert0(have_vpu);
++        vpu_execute_code(q[0], q[1], q[2], q[3], q[4], q[5], q[6]);
++        q[0] = 0;
++    }
++#else
++
+     if (!qpu_code) {
+       vpu_execute_code(p[0], p[1], p[2], p[3], p[4], p[5], p[6]);
+     } else {
+@@ -449,17 +516,29 @@ static void *vpu_start(void *arg) {
+                               0,    0   , 0   , 0   , 0   , 0   , 0); // VPU1
+ #endif
+     }
++#endif
++
+ #ifdef RPI_TIME_TOTAL_POSTED
+     end_time = Microseconds();
+     last_time = end_time;
++#ifdef RPI_COMBINE_JOBS
++    // There are three cases we may wish to distinguish of VPU/QPU activity
++    on_time += end_time - start_time;
++#else
+     if (p[6]==2)
+       on_time_deblock += end_time - start_time;
+     else
+       on_time += end_time - start_time;
++#endif
+     count++;
+     if ((count&0x7f)==0)
++#ifdef RPI_COMBINE_JOBS
+       printf("Posted %d On=%dms, On_deblock=%dms, Off=%dms\n",count,(int)(on_time/1000),(int)(on_time_deblock/1000),(int)(off_time/1000));
++#else
++      printf("Posted %d On=%dms, Off=%dms\n",count,(int)(on_time/1000),(int)(off_time/1000));
++#endif
+ #endif
++job_done_early:
+     pthread_mutex_lock(&post_mutex);
+     vpu_async_head++;
+     pthread_cond_broadcast(&post_cond_head);
+-- 
+2.7.4
+
+
+From 0d54661f303b2a8903e806648ed54a34dcf315dc Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 1 Jul 2015 12:53:10 +0100
+Subject: [PATCH 66/68] Added chroma deblocking
+
+---
+ libavcodec/hevc.c               |  20 ++
+ libavcodec/hevc.h               |  12 +-
+ libavcodec/hevc_filter.c        |  92 +++++-
+ libavcodec/rpi_hevc_transform.h | 644 +++++++++++++++++++++++++++++++++++++++-
+ libavcodec/rpi_hevc_transform.s | 207 +++++++++++++
+ libavcodec/rpi_qpu.c            |  27 +-
+ libavcodec/rpi_shader.qasm      |  11 +
+ 7 files changed, 988 insertions(+), 25 deletions(-)
+
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 4ce94a7..8437e10 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -251,6 +251,14 @@ static void pic_arrays_free(HEVCContext *s)
+       gpu_free(&s->y_setup_ptr);
+       s->y_setup_arm = 0;
+     }
++    if (s->uv_setup_arm) {
++      gpu_free(&s->uv_setup_ptr);
++      s->uv_setup_arm = 0;
++    }
++    if (s->vpu_cmds_arm) {
++      gpu_free(&s->vpu_cmds_ptr);
++      s->vpu_cmds_arm = 0;
++    }
+ #endif
+     av_freep(&s->sao);
+     av_freep(&s->deblock);
+@@ -324,6 +332,18 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
+     s->y_setup_vc = (void*)s->y_setup_ptr.vc;
+     memset(s->y_setup_arm, 0, s->y_setup_ptr.numbytes);
+     printf("Setup %d by %d by %d\n",s->setup_width,s->setup_height,sizeof(*s->y_setup_arm));
++
++    s->uv_setup_width = ( (sps->width >> sps->hshift[1]) + 15) / 16;
++    s->uv_setup_height = ( (sps->height >> sps->vshift[1]) + 15) / 16;
++    gpu_malloc_uncached(sizeof(*s->uv_setup_arm) * s->uv_setup_width * s->uv_setup_height, &s->uv_setup_ptr); // TODO make this cached
++    s->uv_setup_arm = (void*)s->uv_setup_ptr.arm;
++    s->uv_setup_vc = (void*)s->uv_setup_ptr.vc;
++    memset(s->uv_setup_arm, 0, s->uv_setup_ptr.numbytes);
++    printf("Setup uv %d by %d by %d\n",s->uv_setup_width,s->uv_setup_height,sizeof(*s->uv_setup_arm));
++
++    gpu_malloc_uncached(sizeof(*s->vpu_cmds_arm) * 3,&s->vpu_cmds_ptr);
++    s->vpu_cmds_arm = (void*) s->vpu_cmds_ptr.arm;
++    s->vpu_cmds_vc = s->vpu_cmds_ptr.vc;
+ #endif
+ 
+     s->bs_width  = (width  >> 2) + 1;
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index cf08489..7eb37e6 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -56,7 +56,7 @@
+   #define RPI_MAX_JOBS 2
+   // Define RPI_WORKER to launch a worker thread for pixel processing tasks
+   #define RPI_WORKER
+-
++  // Define RPI_DEBLOCK_VPU to perform deblocking on the VPUs
+   #define RPI_DEBLOCK_VPU
+ 
+ #endif
+@@ -980,6 +980,16 @@ typedef struct HEVCContext {
+     uint8_t (*y_setup_vc)[2][2][2][4];
+     int setup_width; // Number of 16x16 blocks across the image
+     int setup_height; // Number of 16x16 blocks down the image
++
++    GPU_MEM_PTR_T uv_setup_ptr;
++    uint8_t (*uv_setup_arm)[2][2][2][4];  // Half of this is unused [][][1][], but easier for the VPU as it allows us to store with zeros and addresses are aligned
++    uint8_t (*uv_setup_vc)[2][2][2][4];
++    int uv_setup_width;
++    int uv_setup_height;
++
++    GPU_MEM_PTR_T vpu_cmds_ptr;
++    int (*vpu_cmds_arm)[6]; // r0-r5 for each command
++    int vpu_cmds_vc;
+ #endif
+ 
+ #endif
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 06371da..6367068 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -656,9 +656,23 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
+                                                                    s->frame->linesize[chroma],
+                                                                    c_tc, no_p, no_q);
+                         } else
++#ifdef RPI_DEBLOCK_VPU
++                        if (s->enable_rpi_deblock) {
++                            uint8_t (*setup)[2][2][4];
++                            int xc = x>>s->ps.sps->hshift[chroma];
++                            int yc = y>>s->ps.sps->vshift[chroma];
++                            int num16 = (yc>>4)*s->uv_setup_width + (xc>>4);
++                            int a = ((yc>>3) & 1) << 1;
++                            int b = (xc>>3) & 1;
++                            setup = s->uv_setup_arm[num16];
++                            setup[0][b][0][a] = c_tc[0];
++                            setup[0][b][0][a + 1] = c_tc[1];
++                        } else
++#endif
+                             s->hevcdsp.hevc_v_loop_filter_chroma(src,
+                                                                  s->frame->linesize[chroma],
+                                                                  c_tc, no_p, no_q);
++
+                     }
+                 }
+ 
+@@ -689,6 +703,19 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
+                                                                    s->frame->linesize[chroma],
+                                                                    c_tc, no_p, no_q);
+                         } else
++#ifdef RPI_DEBLOCK_VPU
++                        if (s->enable_rpi_deblock) {
++                            uint8_t (*setup)[2][2][4];
++                            int xc = x>>s->ps.sps->hshift[chroma];
++                            int yc = y>>s->ps.sps->vshift[chroma];
++                            int num16 = (yc>>4)*s->uv_setup_width + (xc>>4);
++                            int a = ((xc>>3) & 1) << 1;
++                            int b = (yc>>3) & 1;
++                            setup = s->uv_setup_arm[num16];
++                            setup[1][b][0][a] = c_tc[0];
++                            setup[1][b][0][a + 1] = c_tc[1];
++                        } else
++#endif
+                             s->hevcdsp.hevc_h_loop_filter_chroma(src,
+                                                                  s->frame->linesize[chroma],
+                                                                  c_tc, no_p, no_q);
+@@ -1013,33 +1040,56 @@ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+ static void rpi_deblock(HEVCContext *s, int y, int ctb_size)
+ {
+   // Flush image, 4 lines above to bottom of ctb stripe
+-  ff_hevc_flush_buffer_lines(s, FFMAX(y-4,0), y+ctb_size, 1, 0);
++  ff_hevc_flush_buffer_lines(s, FFMAX(y-4,0), y+ctb_size, 1, 1);
+   // TODO flush buffer of beta/tc setup when it becomes cached
++
++  // Prepare three commands at once to avoid calling overhead
++  s->vpu_cmds_arm[0][0] = get_vc_address(s->frame->buf[0]) + s->frame->linesize[0] * y;
++  s->vpu_cmds_arm[0][1] = s->frame->linesize[0];
++  s->vpu_cmds_arm[0][2] = s->setup_width;
++  s->vpu_cmds_arm[0][3] = (int) ( s->y_setup_vc + s->setup_width * (y>>4) );
++  s->vpu_cmds_arm[0][4] = ctb_size>>4;
++  s->vpu_cmds_arm[0][5] = 2;
++
++  s->vpu_cmds_arm[1][0] = get_vc_address(s->frame->buf[1]) + s->frame->linesize[1] * (y>> s->ps.sps->vshift[1]);
++  s->vpu_cmds_arm[1][1] = s->frame->linesize[1];
++  s->vpu_cmds_arm[1][2] = s->uv_setup_width;
++  s->vpu_cmds_arm[1][3] = (int) ( s->uv_setup_vc + s->uv_setup_width * ((y>>4)>> s->ps.sps->vshift[1]) );
++  s->vpu_cmds_arm[1][4] = (ctb_size>>4)>> s->ps.sps->vshift[1];
++  s->vpu_cmds_arm[1][5] = 3;
++
++  s->vpu_cmds_arm[2][0] = get_vc_address(s->frame->buf[2]) + s->frame->linesize[2] * (y>> s->ps.sps->vshift[2]);
++  s->vpu_cmds_arm[2][1] = s->frame->linesize[2];
++  s->vpu_cmds_arm[2][2] = s->uv_setup_width;
++  s->vpu_cmds_arm[2][3] = (int) ( s->uv_setup_vc + s->uv_setup_width * ((y>>4)>> s->ps.sps->vshift[1]) );
++  s->vpu_cmds_arm[2][4] = (ctb_size>>4)>> s->ps.sps->vshift[1];
++  s->vpu_cmds_arm[2][5] = 4;
++
+   // Call VPU
+-  // TODO add this to a separate pipeline of VPU jobs that can be run in parallel and wait for completion
+-  vpu_wait(vpu_post_code( vpu_get_fn(), get_vc_address(s->frame->buf[0]) + s->frame->linesize[0] * y, s->frame->linesize[0],
+-                               s->setup_width, (int) ( s->y_setup_vc + s->setup_width * (y>>4) ),
+-                               ctb_size>>4, 2, 0)); // 2 means to do the deblocking code
++  vpu_wait(vpu_post_code( vpu_get_fn(), s->vpu_cmds_vc, 3, 0, 0, 0, 5, 0)); // 5 means to do all the commands
+ }
+ 
+-static void rpi_deblock2(HEVCContext *s, int y, int ctb_size)
+-{
+-   int y2;
+-   for(y2=y;y2<y+ctb_size;y2+=16) {
+-      rpi_deblock(s,y2,16);
+-   }
+-}
+ #endif
+ 
+ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+ {
+     int x_end = x >= s->ps.sps->width  - ctb_size;
++#ifdef RPI_DEBLOCK_VPU
++    int done_deblock = 0;
++#endif
+     if (s->avctx->skip_loop_filter < AVDISCARD_ALL)
+         deblocking_filter_CTB(s, x, y);
+ #ifdef RPI_DEBLOCK_VPU
+     if (s->enable_rpi_deblock && x_end)
+     {
+-      rpi_deblock(s, y, ctb_size);
++      int y_at_end = y >= s->ps.sps->height - ctb_size;
++      int height = 64;  // Deblock in units 64 high to avoid too many VPU calls
++      int y_start = y&~63;
++      if (y_at_end) height = s->ps.sps->height - y_start;
++      if ((((y+ctb_size)&63)==0) || y_at_end) {
++        done_deblock = 1;
++        rpi_deblock(s, y_start, height);
++      }
+     }
+ #endif
+     if (s->ps.sps->sao_enabled) {
+@@ -1070,11 +1120,25 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+         //int newh = y + ctb_size - 4;
+         //int currh = s->ref->tf.progress->data[0];
+         //if (((y + ctb_size)&63)==0)
++#ifdef RPI_DEBLOCK_VPU
++        if (s->enable_rpi_deblock) {
++          // we no longer need to flush the luma buffer as it is in GPU memory when using deblocking on the rpi
++          if (done_deblock) {
++            ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
++          }
++        } else {
++#ifdef RPI_INTER_QPU
++          ff_hevc_flush_buffer(s, &s->ref->tf, y + ctb_size - 4);
++#endif
++          ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
++        }
++#else
+ #ifdef RPI_INTER_QPU
+         ff_hevc_flush_buffer(s, &s->ref->tf, y + ctb_size - 4);
+-        // TODO we no longer need to flush the luma buffer as it is in GPU memory when using deblocking on the rpi
++        // we no longer need to flush the luma buffer as it is in GPU memory when using deblocking on the rpi
+ #endif
+         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
++#endif
+     }
+ }
+ 
+diff --git a/libavcodec/rpi_hevc_transform.h b/libavcodec/rpi_hevc_transform.h
+index b3f155f..4309f1c 100644
+--- a/libavcodec/rpi_hevc_transform.h
++++ b/libavcodec/rpi_hevc_transform.h
+@@ -3,14 +3,32 @@ unsigned char rpi_hevc_transform [] = {
+ 106,
+ 0,
+ 144,
+-38,
++47,
+ 1,
+ 37,
+ 106,
+ 0,
+ 144,
+-57,
++66,
+ 1,
++53,
++106,
++0,
++144,
++192,
++4,
++69,
++106,
++0,
++144,
++192,
++4,
++85,
++106,
++0,
++144,
++220,
++5,
+ 169,
+ 3,
+ 62,
+@@ -2427,4 +2445,626 @@ unsigned char rpi_hevc_transform [] = {
+ 128,
+ 90,
+ 0,
++169,
++3,
++14,
++96,
++4,
++31,
++169,
++3,
++30,
++96,
++1,
++31,
++73,
++64,
++52,
++64,
++45,
++64,
++2,
++64,
++10,
++64,
++64,
++198,
++1,
++7,
++8,
++232,
++63,
++0,
++0,
++0,
++6,
++232,
++253,
++255,
++255,
++255,
++0,
++246,
++0,
++0,
++0,
++4,
++215,
++64,
++3,
++96,
++2,
++248,
++0,
++35,
++0,
++0,
++64,
++56,
++0,
++0,
++4,
++248,
++0,
++36,
++0,
++0,
++64,
++56,
++8,
++0,
++0,
++240,
++64,
++0,
++132,
++3,
++30,
++106,
++132,
++24,
++128,
++240,
++0,
++0,
++132,
++3,
++128,
++144,
++143,
++0,
++131,
++98,
++0,
++255,
++64,
++0,
++0,
++20,
++200,
++243,
++0,
++0,
++128,
++144,
++135,
++0,
++131,
++102,
++0,
++158,
++71,
++0,
++2,
++248,
++0,
++35,
++0,
++0,
++64,
++56,
++0,
++0,
++4,
++248,
++0,
++36,
++0,
++0,
++64,
++56,
++8,
++0,
++0,
++240,
++64,
++0,
++132,
++3,
++30,
++106,
++132,
++24,
++128,
++240,
++0,
++0,
++132,
++3,
++128,
++144,
++112,
++0,
++131,
++98,
++0,
++255,
++64,
++0,
++0,
++20,
++200,
++243,
++0,
++0,
++128,
++144,
++104,
++0,
++131,
++102,
++0,
++248,
++64,
++0,
++112,
++0,
++192,
++243,
++211,
++31,
++30,
++106,
++134,
++24,
++128,
++248,
++0,
++0,
++112,
++0,
++192,
++243,
++211,
++31,
++128,
++144,
++123,
++0,
++188,
++64,
++67,
++232,
++0,
++2,
++0,
++0,
++0,
++255,
++64,
++0,
++0,
++20,
++200,
++243,
++0,
++0,
++128,
++144,
++112,
++0,
++195,
++232,
++0,
++2,
++0,
++0,
++12,
++128,
++7,
++192,
++130,
++248,
++0,
++0,
++112,
++192,
++224,
++16,
++195,
++31,
++132,
++248,
++1,
++0,
++112,
++0,
++224,
++16,
++203,
++31,
++3,
++99,
++131,
++71,
++68,
++232,
++32,
++0,
++0,
++0,
++0,
++99,
++2,
++99,
++23,
++102,
++7,
++106,
++127,
++156,
++178,
++255,
++0,
++248,
++64,
++0,
++112,
++0,
++192,
++243,
++211,
++31,
++30,
++106,
++134,
++24,
++128,
++248,
++0,
++0,
++112,
++0,
++192,
++243,
++211,
++31,
++128,
++144,
++72,
++0,
++188,
++64,
++67,
++232,
++0,
++2,
++0,
++0,
++0,
++255,
++64,
++0,
++0,
++20,
++200,
++243,
++0,
++0,
++128,
++144,
++61,
++0,
++195,
++232,
++0,
++2,
++0,
++0,
++12,
++128,
++7,
++192,
++130,
++248,
++0,
++0,
++112,
++192,
++224,
++16,
++195,
++31,
++132,
++248,
++1,
++0,
++112,
++0,
++224,
++16,
++203,
++31,
++25,
++102,
++9,
++106,
++2,
++30,
++41,
++3,
++26,
++87,
++162,
++64,
++64,
++198,
++1,
++23,
++127,
++158,
++95,
++255,
++239,
++3,
++0,
++254,
++128,
++143,
++94,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++192,
++143,
++95,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++192,
++142,
++208,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++128,
++142,
++209,
++0,
++0,
++240,
++12,
++0,
++128,
++144,
++47,
++0,
++8,
++255,
++227,
++23,
++0,
++244,
++192,
++51,
++0,
++0,
++8,
++255,
++35,
++52,
++0,
++180,
++192,
++51,
++0,
++0,
++111,
++3,
++239,
++3,
++0,
++254,
++128,
++143,
++14,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++192,
++143,
++15,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++192,
++142,
++16,
++0,
++0,
++240,
++12,
++0,
++0,
++254,
++128,
++142,
++17,
++0,
++0,
++240,
++12,
++0,
++128,
++144,
++13,
++0,
++8,
++255,
++227,
++3,
++0,
++244,
++192,
++51,
++0,
++0,
++8,
++255,
++35,
++4,
++0,
++180,
++192,
++51,
++0,
++0,
++111,
++3,
++32,
++246,
++192,
++11,
++1,
++16,
++32,
++246,
++2,
++140,
++47,
++240,
++32,
++247,
++35,
++141,
++63,
++178,
++64,
++254,
++35,
++141,
++2,
++68,
++192,
++243,
++128,
++11,
++32,
++255,
++35,
++240,
++58,
++226,
++192,
++243,
++188,
++10,
++0,
++254,
++0,
++141,
++4,
++4,
++0,
++240,
++128,
++10,
++88,
++246,
++35,
++141,
++3,
++68,
++240,
++246,
++35,
++141,
++48,
++66,
++0,
++247,
++227,
++143,
++52,
++242,
++32,
++247,
++227,
++142,
++52,
++178,
++90,
++0,
++161,
++3,
++6,
++64,
++23,
++64,
++96,
++8,
++70,
++98,
++97,
++8,
++70,
++98,
++98,
++8,
++70,
++98,
++99,
++8,
++70,
++98,
++100,
++8,
++70,
++98,
++101,
++8,
++70,
++98,
++255,
++159,
++8,
++250,
++23,
++102,
++7,
++106,
++112,
++30,
++33,
++3,
+ };
+diff --git a/libavcodec/rpi_hevc_transform.s b/libavcodec/rpi_hevc_transform.s
+index b055208..5543093 100644
+--- a/libavcodec/rpi_hevc_transform.s
++++ b/libavcodec/rpi_hevc_transform.s
+@@ -85,6 +85,13 @@ hevc_trans_16x16:
+   beq memclear16
+   cmp r5,2
+   beq hevc_deblock_16x16
++  cmp r5,3
++  beq hevc_uv_deblock_16x16
++  cmp r5,4
++  beq hevc_uv_deblock_16x16_with_clear
++  cmp r5,5
++  beq hevc_run_command_list
++
+   push r6-r15, lr # TODO cut down number of used registers
+   mov r14,r3 # coeffs32
+   mov r15,r4 # num32
+@@ -708,3 +715,203 @@ normal_filtering:
+ 
+ filtering_done:
+   b lr
++
++
++hevc_uv_deblock_16x16:
++  push r6-r15, lr
++  mov r14,0
++  b hevc_uv_start
++hevc_uv_deblock_16x16_with_clear:
++  push r6-r15, lr
++  mov r14,1
++  b hevc_uv_start
++
++hevc_uv_start:
++  mov r9,r4
++  mov r4,r3
++  mov r13,r2
++  mov r2,r0
++  mov r10,r0
++  subscale4 r0,r1
++  mov r8,63
++  mov r6,-3
++  vmov H(zeros,0),0
++# r7 is number of blocks still to load
++# r0 is location of current block - 4 * stride
++# r1 is stride
++# r2 is location of current block
++# r3 is offset of start of block (actual edges start at H(16,16)+r3 for horizontal and H(16,0)+r3 for vertical
++# r4 is setup
++# r5 is for temporary calculations
++# r8 holds 63
++# r6 holds -3
++# r9 holds the number of 16 high rows to process
++# r10 holds the original img base
++# r11 returns 0 if no filtering was done on the edge
++# r12 saves a copy of this
++# r13 is copy of width
++# r14 is 1 if we should clear the old contents, or 0 if not
++
++uv_process_row:
++  # First iteration does not do horizontal filtering on previous
++  mov r7, r13
++  mov r3,0
++  vldb H(12++,16)+r3,(r0 += r1) REP 4    # Load the current block
++  vldb H(16++,16)+r3,(r2 += r1) REP 16
++  vldb H(setup_input,0), (r4)  # We may wish to prefetch these
++  cmp r14,1
++  bne uv_skip0
++  vstb H(zeros,0),(r4)
++uv_skip0:
++  bl uv_vert_filter
++  add r3,8
++  vadd H(setup_input,0),H(setup_input,8),0 # Rotate to second set of 8
++  bl uv_vert_filter
++  sub r3,8
++  b uv_start_deblock_loop
++uv_deblock_loop:
++  # Middle iterations do vertical on current block and horizontal on preceding
++  vldb H(12++,16)+r3,(r0 += r1) REP 4  # load the current block
++  vldb H(16++,16)+r3,(r2 += r1) REP 16
++  vldb H(setup_input,0), (r4)
++  cmp r14,1
++  bne uv_skip1
++  vstb H(zeros,0),(r4)
++uv_skip1:
++  bl uv_vert_filter
++  add r3,8
++  vadd H(setup_input,0),H(setup_input,8),0
++  bl uv_vert_filter
++  sub r3,8
++  vldb H(setup_input,0), -16(r4)
++  cmp r14,1
++  bne uv_skip3
++  vstb H(zeros,0),-16(r4)
++uv_skip3:
++  bl uv_horz_filter
++  mov r12,r11
++  add r3,8*64
++  vadd H(setup_input,0),H(setup_input,8),0
++  bl uv_horz_filter
++  sub r3,8*64
++  addcmpbeq r12,0,0,uv_skip_save_top
++  vstb H(12++,0)+r3,-16(r0 += r1) REP 4  # Save the deblocked pixels for the previous block
++uv_skip_save_top:
++  vstb H(16++,0)+r3,-16(r2 += r1) REP 16
++uv_start_deblock_loop:
++  # move onto next 16x16 (could do this with circular buffer support instead)
++  add r3,16
++  and r3,r8
++  add r4,32
++  # Perform loop counter operations (may work with an addcmpbgt as well?)
++  add r0,16
++  add r2,16
++  sub r7,1
++  cmp r7,0 # Are there still more blocks to load
++  bgt uv_deblock_loop
++
++  # Final iteration needs to just do horizontal filtering
++  vldb H(setup_input,0), -16(r4)
++  cmp r14,1
++  bne uv_skip2
++  vstb H(zeros,0),-16(r4)
++uv_skip2:
++  bl uv_horz_filter
++  mov r12,r11
++  add r3,8*64
++  vadd H(setup_input,0),H(setup_input,8),0
++  bl uv_horz_filter
++  sub r3,64*8
++  addcmpbeq r12,0,0,uv_skip_save_top2
++  vstb H(12++,0)+r3,-16(r0 += r1) REP 4  # Save the deblocked pixels for the previous block
++uv_skip_save_top2:
++  vstb H(16++,0)+r3,-16(r2 += r1) REP 16
++
++# Now look to see if we should do another row
++  sub r9,1
++  cmp r9,0
++  bgt uv_start_again
++  pop r6-r15, pc
++uv_start_again:
++  # Need to sort out r0,r2 to point to next row down
++  addscale16 r10,r1
++  mov r2,r10
++  subscale4 r0,r2,r1
++  b uv_process_row
++
++
++# At this stage H(16,16)+r3 points to the first pixel of the 16 high edge to be filtered
++# So we can reuse the code we move the parts to be filtered into HX(P0/P1/P2/P3/Q0/Q1/Q2/Q3,0) - we will perform a final saturation step on placing them back into the correct locations
++
++uv_vert_filter:
++  push lr
++
++  vmov HX(P1,0), V(16,14)+r3
++  vmov HX(P0,0), V(16,15)+r3
++  vmov HX(Q0,0), V(16,16)+r3
++  vmov HX(Q1,0), V(16,17)+r3
++
++  bl do_chroma_filter
++
++  vadds V(16,15)+r3, HX(P0,0), 0
++  vadds V(16,16)+r3, HX(Q0,0), 0
++
++  pop pc
++
++# Filter edge at H(16,0)+r3
++uv_horz_filter:
++  push lr
++
++  vmov HX(P1,0), H(14,0)+r3
++  vmov HX(P0,0), H(15,0)+r3
++  vmov HX(Q0,0), H(16,0)+r3
++  vmov HX(Q1,0), H(17,0)+r3
++
++  bl do_chroma_filter
++
++  vadds H(15,0)+r3, HX(P0,0), 0
++  # P3 and Q3 never change so don't bother saving back
++  vadds H(16,0)+r3, HX(Q0,0), 0
++
++  pop pc
++
++# r4 points to array of beta/tc for each 4 length edge
++do_chroma_filter:
++  valtl H(setup,0),H(setup_input,0),H(setup_input,0) # tc*8
++  valtl HX(tc,0),H(setup,0),H(setup,0)
++
++  vsub HX(delta,0),HX(Q0,0),HX(P0,0)
++  vshl HX(delta,0),HX(delta,0),2 CLRA SACC
++  vsub -,HX(P1,0),HX(Q1,0) SACC
++  vmov HX(delta,0),4 SACC
++  vasr HX(delta,0),HX(delta,0),3
++  vclamps HX(delta,0), HX(delta,0), HX(tc,0)
++  vadd HX(P0,0),HX(P0,0),HX(delta,0)
++  vsub HX(Q0,0),HX(Q0,0),HX(delta,0)
++  b lr
++
++# r0 = list
++# r1 = number
++hevc_run_command_list:
++  push r6-r7, lr
++  mov r6, r0
++  mov r7, r1
++loop_cmds:
++  ld r0,(r6) # How to encode r6++?
++  add r6,4
++  ld r1,(r6)
++  add r6,4
++  ld r2,(r6)
++  add r6,4
++  ld r3,(r6)
++  add r6,4
++  ld r4,(r6)
++  add r6,4
++  ld r5,(r6)
++  add r6,4
++  bl hevc_trans_16x16
++  sub r7,1
++  cmp r7,0
++  bgt loop_cmds
++
++  pop r6-r7, pc
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 91777be..5aa0432 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -397,6 +397,8 @@ static void *vpu_start(void *arg) {
+   int start_time;
+   int end_time;
+   int count=0;
++  int count_deblock=0;
++  int count_qpu=0;
+ #endif
+   while(1) {
+     int i;
+@@ -442,7 +444,7 @@ static void *vpu_start(void *arg) {
+         break;
+       }
+     }
+-    printf("Have_qpu = %d, have_vpu=%d\n",have_qpu,have_vpu);
++    //printf("Have_qpu = %d, have_vpu=%d\n",have_qpu,have_vpu);
+ #endif
+     qpu_code = p[7];
+     qpu_codeb = p[16];
+@@ -460,6 +462,12 @@ static void *vpu_start(void *arg) {
+     off_time += start_time-last_time;
+ #endif
+ 
++#define NO_FLUSH 1
++#define CLEAR_PROFILE 2
++#define OUTPUT_COUNTS 4
++
++#define FLAGS_FOR_PROFILING (NO_FLUSH)
++
+ #ifdef RPI_COMBINE_JOBS
+     if (have_qpu) {
+       for(i=0;i<8;i++) {
+@@ -472,14 +480,14 @@ static void *vpu_start(void *arg) {
+       }
+       if (have_vpu) {
+         execute_multi(gpu->mb,
+-                              12,gpu->vc + offsetof(struct GPU, mail2), 1, 5000,
++                              12,gpu->vc + offsetof(struct GPU, mail2), FLAGS_FOR_PROFILING, 5000,
+                               8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
+                               p[0], p[1], p[2], p[3], p[4], p[5], p[6], // VPU0
+                               q[0], q[1], q[2], q[3], q[4], q[5], q[6]); // VPU1
+         q[0] = 0;
+       } else {
+         execute_multi(gpu->mb,
+-                              12,gpu->vc + offsetof(struct GPU, mail2), 1, 5000,
++                              12,gpu->vc + offsetof(struct GPU, mail2), FLAGS_FOR_PROFILING, 5000,
+                               8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
+                               p[0], p[1], p[2], p[3], p[4], p[5], p[6], // VPU0
+                               0,    0   , 0   , 0   , 0   , 0   , 0); // VPU1
+@@ -510,7 +518,7 @@ static void *vpu_start(void *arg) {
+       execute_qpu(gpu->mb,8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */);
+ #else
+       execute_multi(gpu->mb,
+-                              12,gpu->vc + offsetof(struct GPU, mail2), 1, 5000,
++                              12,gpu->vc + offsetof(struct GPU, mail2), FLAGS_FOR_PROFILING , 5000,
+                               8,gpu->vc + offsetof(struct GPU, mail), 1 /* no flush */, 5000 /* timeout ms */,
+                               p[0], p[1], p[2], p[3], p[4], p[5], p[6], // VPU0
+                               0,    0   , 0   , 0   , 0   , 0   , 0); // VPU1
+@@ -525,17 +533,20 @@ static void *vpu_start(void *arg) {
+     // There are three cases we may wish to distinguish of VPU/QPU activity
+     on_time += end_time - start_time;
+ #else
+-    if (p[6]==2)
++    if (p[6]>1) {
++      count_deblock++;
+       on_time_deblock += end_time - start_time;
+-    else
++    } else {
+       on_time += end_time - start_time;
++      count_qpu++;
++    }
+ #endif
+     count++;
+     if ((count&0x7f)==0)
+ #ifdef RPI_COMBINE_JOBS
+-      printf("Posted %d On=%dms, On_deblock=%dms, Off=%dms\n",count,(int)(on_time/1000),(int)(on_time_deblock/1000),(int)(off_time/1000));
+-#else
+       printf("Posted %d On=%dms, Off=%dms\n",count,(int)(on_time/1000),(int)(off_time/1000));
++#else
++      printf("Posted %d On=%dms (%d calls), On_deblock=%dms (%d calls), Off=%dms\n",count,(int)(on_time/1000),count_qpu,(int)(on_time_deblock/1000),count_deblock,(int)(off_time/1000));
+ #endif
+ #endif
+ job_done_early:
+diff --git a/libavcodec/rpi_shader.qasm b/libavcodec/rpi_shader.qasm
+index 0686249..64bf5b0 100644
+--- a/libavcodec/rpi_shader.qasm
++++ b/libavcodec/rpi_shader.qasm
+@@ -1077,6 +1077,17 @@ nop        ; nop # delay slot 2
+ ::mc_interrupt_exit12
+   mov  -, vw_wait # wait on the VDW
+ 
++  # Dummy wait to test instructions
++#  mov r3,1000000
++#:dummy_loop
++#  sub.setf r3, r3, 1
++#  nop
++#  nop
++#  brr.anynn -, r:dummy_loop
++#  nop
++#  nop
++#  nop
++
+   ldtmu0
+   ldtmu0
+   ldtmu1
+-- 
+2.7.4
+
+
+From 12a194bddd049ab97154e9fbdd46b63b558a3bee Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Tue, 23 Jun 2015 23:42:03 +0100
+Subject: [PATCH 67/68] armv7/hevc: Optimise deblocking boundary strength
+ calculation
+
+---
+ libavcodec/arm/hevcdsp_deblock_neon.S | 115 +++++++++++++++++
+ libavcodec/arm/hevcdsp_init_neon.c    |   9 ++
+ libavcodec/hevc.h                     |  11 --
+ libavcodec/hevc_filter.c              | 224 ++++++++++++++--------------------
+ libavcodec/hevcdsp.c                  | 116 ++++++++++++++++++
+ libavcodec/hevcdsp.h                  |  14 +++
+ 6 files changed, 344 insertions(+), 145 deletions(-)
+
+diff --git a/libavcodec/arm/hevcdsp_deblock_neon.S b/libavcodec/arm/hevcdsp_deblock_neon.S
+index 166bddb..bad4589 100644
+--- a/libavcodec/arm/hevcdsp_deblock_neon.S
++++ b/libavcodec/arm/hevcdsp_deblock_neon.S
+@@ -383,3 +383,118 @@ function ff_hevc_h_loop_filter_chroma_neon, export=1
+         vst1.8   {d4}, [r0]
+         bx       lr
+ endfunc
++
++/* ff_hevc_deblocking_boundary_strengths_neon(int pus, int dup, int in_inc, int out_inc,
++ *                                            int *curr_rpl0, int *curr_rpl1, int *neigh_rpl0, int *neigh_rpl1,
++ *                                            MvField *curr, MvField *neigh, uint8_t *bs)
++ */
++function ff_hevc_deblocking_boundary_strengths_neon, export=1
++        add         ip, sp, #4*4
++        push        {a2-a4,v1-v8,lr}
++        ldmia       ip, {v5-v7}
++1:      ldmdb       ip, {v1-v4}
++        ldrsb       a3, [v5, #8]    @ curr->ref_idx
++        ldrsb       v8, [v5, #9]
++        ldrsb       ip, [v6, #8]    @ neigh->ref_idx
++        ldrsb       lr, [v6, #9]
++        ldr         v1, [v1, a3, lsl #2]
++        ldrb        a3, [v5, #10]   @ curr->pred_flag
++        ldr         v2, [v2, v8, lsl #2]
++        ldrb        v8, [v6, #10]   @ neigh->pred_flag
++        ldr         v3, [v3, ip, lsl #2]
++        ldr         v4, [v4, lr, lsl #2]
++        teq         a3, #3
++        beq         20f
++        teq         v8, #3
++        beq         90f
++
++        tst         a3, #1
++        ldrne       a3, [v5, #0]    @ curr->mv[0]
++        ldreq       a3, [v5, #4]    @ curr->mv[1]
++        moveq       v1, v2
++        tst         v8, #1
++        ldrne       v8, [v6, #0]    @ neigh->mv[0]
++        ldreq       v8, [v6, #4]    @ neigh->mv[1]
++        moveq       v3, v4
++        teq         v1, v3
++        bne         10f
++        ldr         lr, =0xFFFCFFFC
++        ssub16      ip, v8, a3
++        ssub16      a3, a3, v8
++        sel         a3, a3, ip
++        ands        a3, a3, lr
++        @ drop through
++10:     movne       a3, #1
++11:     subs        a2, a2, #1
++12:     strbhs      a3, [v7], a4
++        subs        a2, a2, #1
++        bhs         12b
++
++        ldm         sp, {a2, a3}
++        add         ip, sp, #16*4
++        subs        a1, a1, #1
++        add         v5, v5, a3
++        add         v6, v6, a3
++        bhi         1b
++        pop         {a2-a4,v1-v8,pc}
++
++20:     teq         v8, #3
++        bne         10b
++
++        teq         v1, v3
++        teqeq       v2, v4
++        bne         40f
++        teq         v1, v2
++        bne         30f
++
++        ldrd        v1, v2, [v5]    @ curr->mv
++        ldrd        v3, v4, [v6]    @ neigh->mv
++        ldr         lr, =0xFFFCFFFC
++        ssub16      ip, v3, v1
++        ssub16      a3, v1, v3
++        sel         a3, a3, ip
++        ands        a3, a3, lr
++        bne         25f
++        ssub16      ip, v4, v2
++        ssub16      a3, v2, v4
++        sel         a3, a3, ip
++        ands        a3, a3, lr
++        beq         11b
++        @ drop through
++25:     ssub16      ip, v4, v1
++        ssub16      a3, v1, v4
++        sel         a3, a3, ip
++        ands        a3, a3, lr
++        bne         10b
++        ssub16      ip, v3, v2
++        ssub16      a3, v2, v3
++        sel         a3, a3, ip
++        ands        a3, a3, lr
++        b           10b
++
++30:     ldrd        v1, v2, [v5]    @ curr->mv
++        ldrd        v3, v4, [v6]    @ neigh->mv
++        ldr         lr, =0xFFFCFFFC
++        ssub16      ip, v3, v1
++        ssub16      a3, v1, v3
++        sel         a3, a3, ip
++        ands        a3, a3, lr
++        bne         10b
++        ssub16      ip, v4, v2
++        ssub16      a3, v2, v4
++        sel         a3, a3, ip
++        ands        a3, a3, lr
++        b           10b
++
++40:     teq         v1, v4
++        teqeq       v2, v3
++        bne         10b
++
++        ldrd        v1, v2, [v5]    @ curr->mv
++        ldrd        v3, v4, [v6]    @ neigh->mv
++        ldr         lr, =0xFFFCFFFC
++        b           25b
++
++90:     mov         a3, #1
++        b           11b
++endfunc
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index e5da7e9..49c70dd 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -290,6 +290,10 @@ static void ff_hevc_sao_edge_neon_wrapper(uint8_t *_dst /* align 16 */, uint8_t
+ }
+ #undef CMP
+ 
++void ff_hevc_deblocking_boundary_strengths_neon(int pus, int dup, int in_inc, int out_inc,
++                                                int *curr_rpl0, int *curr_rpl1, int *neigh_rpl0, int *neigh_rpl1,
++                                                MvField *curr, MvField *neigh, uint8_t *bs);
++
+ av_cold void ff_hevcdsp_init_neon(HEVCDSPContext *c, const int bit_depth)
+ {
+     if (bit_depth == 8) {
+@@ -387,4 +391,9 @@ av_cold void ff_hevcdsp_init_neon(HEVCDSPContext *c, const int bit_depth)
+         c->put_hevc_qpel_uni[8][0][0]  = ff_hevc_put_qpel_uw_pixels_w48_neon_8;
+         c->put_hevc_qpel_uni[9][0][0]  = ff_hevc_put_qpel_uw_pixels_w64_neon_8;
+     }
++
++    assert(offsetof(MvField, mv) == 0);
++    assert(offsetof(MvField, ref_idx) == 8);
++    assert(offsetof(MvField, pred_flag) == 10);
++    c->hevc_deblocking_boundary_strengths = ff_hevc_deblocking_boundary_strengths_neon;
+ }
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 7eb37e6..496c0e1 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -684,17 +684,6 @@ typedef struct CodingUnit {
+     uint8_t cu_transquant_bypass_flag;
+ } CodingUnit;
+ 
+-typedef struct Mv {
+-    int16_t x;  ///< horizontal component of motion vector
+-    int16_t y;  ///< vertical component of motion vector
+-} Mv;
+-
+-typedef struct MvField {
+-    DECLARE_ALIGNED(4, Mv, mv)[2];
+-    int8_t ref_idx[2];
+-    int8_t pred_flag;
+-} MvField;
+-
+ typedef struct NeighbourAvailable {
+     int cand_bottom_left;
+     int cand_left;
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 6367068..826a82f 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -726,69 +726,6 @@ static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
+     }
+ }
+ 
+-static int boundary_strength(HEVCContext *s, MvField *curr, MvField *neigh,
+-                             RefPicList *neigh_refPicList)
+-{
+-    if (curr->pred_flag == PF_BI &&  neigh->pred_flag == PF_BI) {
+-        // same L0 and L1
+-        if (s->ref->refPicList[0].list[curr->ref_idx[0]] == neigh_refPicList[0].list[neigh->ref_idx[0]]  &&
+-            s->ref->refPicList[0].list[curr->ref_idx[0]] == s->ref->refPicList[1].list[curr->ref_idx[1]] &&
+-            neigh_refPicList[0].list[neigh->ref_idx[0]] == neigh_refPicList[1].list[neigh->ref_idx[1]]) {
+-            if ((FFABS(neigh->mv[0].x - curr->mv[0].x) >= 4 || FFABS(neigh->mv[0].y - curr->mv[0].y) >= 4 ||
+-                 FFABS(neigh->mv[1].x - curr->mv[1].x) >= 4 || FFABS(neigh->mv[1].y - curr->mv[1].y) >= 4) &&
+-                (FFABS(neigh->mv[1].x - curr->mv[0].x) >= 4 || FFABS(neigh->mv[1].y - curr->mv[0].y) >= 4 ||
+-                 FFABS(neigh->mv[0].x - curr->mv[1].x) >= 4 || FFABS(neigh->mv[0].y - curr->mv[1].y) >= 4))
+-                return 1;
+-            else
+-                return 0;
+-        } else if (neigh_refPicList[0].list[neigh->ref_idx[0]] == s->ref->refPicList[0].list[curr->ref_idx[0]] &&
+-                   neigh_refPicList[1].list[neigh->ref_idx[1]] == s->ref->refPicList[1].list[curr->ref_idx[1]]) {
+-            if (FFABS(neigh->mv[0].x - curr->mv[0].x) >= 4 || FFABS(neigh->mv[0].y - curr->mv[0].y) >= 4 ||
+-                FFABS(neigh->mv[1].x - curr->mv[1].x) >= 4 || FFABS(neigh->mv[1].y - curr->mv[1].y) >= 4)
+-                return 1;
+-            else
+-                return 0;
+-        } else if (neigh_refPicList[1].list[neigh->ref_idx[1]] == s->ref->refPicList[0].list[curr->ref_idx[0]] &&
+-                   neigh_refPicList[0].list[neigh->ref_idx[0]] == s->ref->refPicList[1].list[curr->ref_idx[1]]) {
+-            if (FFABS(neigh->mv[1].x - curr->mv[0].x) >= 4 || FFABS(neigh->mv[1].y - curr->mv[0].y) >= 4 ||
+-                FFABS(neigh->mv[0].x - curr->mv[1].x) >= 4 || FFABS(neigh->mv[0].y - curr->mv[1].y) >= 4)
+-                return 1;
+-            else
+-                return 0;
+-        } else {
+-            return 1;
+-        }
+-    } else if ((curr->pred_flag != PF_BI) && (neigh->pred_flag != PF_BI)){ // 1 MV
+-        Mv A, B;
+-        int ref_A, ref_B;
+-
+-        if (curr->pred_flag & 1) {
+-            A     = curr->mv[0];
+-            ref_A = s->ref->refPicList[0].list[curr->ref_idx[0]];
+-        } else {
+-            A     = curr->mv[1];
+-            ref_A = s->ref->refPicList[1].list[curr->ref_idx[1]];
+-        }
+-
+-        if (neigh->pred_flag & 1) {
+-            B     = neigh->mv[0];
+-            ref_B = neigh_refPicList[0].list[neigh->ref_idx[0]];
+-        } else {
+-            B     = neigh->mv[1];
+-            ref_B = neigh_refPicList[1].list[neigh->ref_idx[1]];
+-        }
+-
+-        if (ref_A == ref_B) {
+-            if (FFABS(A.x - B.x) >= 4 || FFABS(A.y - B.y) >= 4)
+-                return 1;
+-            else
+-                return 0;
+-        } else
+-            return 1;
+-    }
+-
+-    return 1;
+-}
+ 
+ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
+                                            int log2_trafo_size)
+@@ -799,10 +736,17 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
+     int log2_min_tu_size = s->ps.sps->log2_min_tb_size;
+     int min_pu_width     = s->ps.sps->min_pu_width;
+     int min_tu_width     = s->ps.sps->min_tb_width;
+-    int is_intra = tab_mvf[(y0 >> log2_min_pu_size) * min_pu_width +
+-                           (x0 >> log2_min_pu_size)].pred_flag == PF_INTRA;
+     int boundary_upper, boundary_left;
+-    int i, j, bs;
++    int i, j;
++    RefPicList *rpl      = s->ref->refPicList;
++    int min_pu_in_4pix   = (1 << log2_min_pu_size) >> 2;
++    int trafo_in_min_pus = (1 << log2_trafo_size) >> log2_min_pu_size;
++    int y_pu             = y0 >> log2_min_pu_size;
++    int x_pu             = x0 >> log2_min_pu_size;
++    MvField *curr        = &tab_mvf[y_pu * min_pu_width + x_pu];
++    int is_intra         = curr->pred_flag == PF_INTRA;
++    int inc              = log2_min_pu_size == 2 ? 2 : 1;
++    uint8_t *bs;
+ 
+ #ifdef DISABLE_STRENGTHS
+     return;
+@@ -818,34 +762,56 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
+           (y0 % (1 << s->ps.sps->log2_ctb_size)) == 0)))
+         boundary_upper = 0;
+ 
++    bs = &s->horizontal_bs[(x0 + y0 * s->bs_width) >> 2];
++
+     if (boundary_upper) {
+         RefPicList *rpl_top = (lc->boundary_flags & BOUNDARY_UPPER_SLICE) ?
+                               ff_hevc_get_ref_list(s, s->ref, x0, y0 - 1) :
+-                              s->ref->refPicList;
+-        int yp_pu = (y0 - 1) >> log2_min_pu_size;
+-        int yq_pu =  y0      >> log2_min_pu_size;
+-        int yp_tu = (y0 - 1) >> log2_min_tu_size;
+-        int yq_tu =  y0      >> log2_min_tu_size;
++                              rpl;
++        MvField *top = curr - min_pu_width;
++
++        if (is_intra) {
++            for (i = 0; i < (1 << log2_trafo_size); i += 4)
++                bs[i >> 2] = 2;
++
++        } else {
++            int y_tu = y0 >> log2_min_tu_size;
++            int x_tu = x0 >> log2_min_tu_size;
++            uint8_t *curr_cbf_luma = &s->cbf_luma[y_tu * min_tu_width + x_tu];
++            uint8_t *top_cbf_luma = curr_cbf_luma - min_tu_width;
++
++            s->hevcdsp.hevc_deblocking_boundary_strengths(trafo_in_min_pus,
++                    min_pu_in_4pix, sizeof (MvField), 4 >> 2,
++                    rpl[0].list, rpl[1].list, rpl_top[0].list, rpl_top[1].list,
++                    curr, top, bs);
+ 
+             for (i = 0; i < (1 << log2_trafo_size); i += 4) {
+-                int x_pu = (x0 + i) >> log2_min_pu_size;
+-                int x_tu = (x0 + i) >> log2_min_tu_size;
+-                MvField *top  = &tab_mvf[yp_pu * min_pu_width + x_pu];
+-                MvField *curr = &tab_mvf[yq_pu * min_pu_width + x_pu];
+-                uint8_t top_cbf_luma  = s->cbf_luma[yp_tu * min_tu_width + x_tu];
+-                uint8_t curr_cbf_luma = s->cbf_luma[yq_tu * min_tu_width + x_tu];
+-
+-                if (curr->pred_flag == PF_INTRA || top->pred_flag == PF_INTRA)
+-                    bs = 2;
+-                else if (curr_cbf_luma || top_cbf_luma)
+-                    bs = 1;
+-                else
+-                    bs = boundary_strength(s, curr, top, rpl_top);
+-                s->horizontal_bs[((x0 + i) + y0 * s->bs_width) >> 2] = bs;
++                int i_pu = i >> log2_min_pu_size;
++                int i_tu = i >> log2_min_tu_size;
++
++                if (top[i_pu].pred_flag == PF_INTRA)
++                    bs[i >> 2] = 2;
++                else if (curr_cbf_luma[i_tu] || top_cbf_luma[i_tu])
++                    bs[i >> 2] = 1;
+             }
++        }
++    }
++
++    if (!is_intra) {
++        for (j = inc; j < trafo_in_min_pus; j += inc) {
++            MvField *top;
++
++            curr += min_pu_width * inc;
++            top = curr - min_pu_width;
++            bs += s->bs_width * inc << log2_min_pu_size >> 2;
++
++            s->hevcdsp.hevc_deblocking_boundary_strengths(trafo_in_min_pus,
++                    min_pu_in_4pix, sizeof (MvField), 4 >> 2,
++                    rpl[0].list, rpl[1].list, rpl[0].list, rpl[1].list,
++                    curr, top, bs);
++        }
+     }
+ 
+-    // bs for vertical TU boundaries
+     boundary_left = x0 > 0 && !(x0 & 7);
+     if (boundary_left &&
+         ((!s->sh.slice_loop_filter_across_slices_enabled_flag &&
+@@ -856,64 +822,54 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
+           (x0 % (1 << s->ps.sps->log2_ctb_size)) == 0)))
+         boundary_left = 0;
+ 
++    curr = &tab_mvf[y_pu * min_pu_width + x_pu];
++    bs = &s->vertical_bs[(x0 + y0 * s->bs_width) >> 2];
++
+     if (boundary_left) {
+         RefPicList *rpl_left = (lc->boundary_flags & BOUNDARY_LEFT_SLICE) ?
+                                ff_hevc_get_ref_list(s, s->ref, x0 - 1, y0) :
+-                               s->ref->refPicList;
+-        int xp_pu = (x0 - 1) >> log2_min_pu_size;
+-        int xq_pu =  x0      >> log2_min_pu_size;
+-        int xp_tu = (x0 - 1) >> log2_min_tu_size;
+-        int xq_tu =  x0      >> log2_min_tu_size;
+-
+-            for (i = 0; i < (1 << log2_trafo_size); i += 4) {
+-                int y_pu      = (y0 + i) >> log2_min_pu_size;
+-                int y_tu      = (y0 + i) >> log2_min_tu_size;
+-                MvField *left = &tab_mvf[y_pu * min_pu_width + xp_pu];
+-                MvField *curr = &tab_mvf[y_pu * min_pu_width + xq_pu];
+-                uint8_t left_cbf_luma = s->cbf_luma[y_tu * min_tu_width + xp_tu];
+-                uint8_t curr_cbf_luma = s->cbf_luma[y_tu * min_tu_width + xq_tu];
+-
+-                if (curr->pred_flag == PF_INTRA || left->pred_flag == PF_INTRA)
+-                    bs = 2;
+-                else if (curr_cbf_luma || left_cbf_luma)
+-                    bs = 1;
+-                else
+-                    bs = boundary_strength(s, curr, left, rpl_left);
+-                s->vertical_bs[(x0 + (y0 + i) * s->bs_width) >> 2] = bs;
+-            }
+-    }
++                               rpl;
++        MvField *left = curr - 1;
+ 
+-    if (log2_trafo_size > log2_min_pu_size && !is_intra) {
+-        RefPicList *rpl = s->ref->refPicList;
++        if (is_intra) {
++            for (j = 0; j < (1 << log2_trafo_size); j += 4)
++                bs[j * s->bs_width >> 2] = 2;
+ 
+-        // bs for TU internal horizontal PU boundaries
+-        for (j = 8; j < (1 << log2_trafo_size); j += 8) {
+-            int yp_pu = (y0 + j - 1) >> log2_min_pu_size;
+-            int yq_pu = (y0 + j)     >> log2_min_pu_size;
+-
+-            for (i = 0; i < (1 << log2_trafo_size); i += 4) {
+-                int x_pu = (x0 + i) >> log2_min_pu_size;
+-                MvField *top  = &tab_mvf[yp_pu * min_pu_width + x_pu];
+-                MvField *curr = &tab_mvf[yq_pu * min_pu_width + x_pu];
+-
+-                bs = boundary_strength(s, curr, top, rpl);
+-                s->horizontal_bs[((x0 + i) + (y0 + j) * s->bs_width) >> 2] = bs;
++        } else {
++            int y_tu = y0 >> log2_min_tu_size;
++            int x_tu = x0 >> log2_min_tu_size;
++            uint8_t *curr_cbf_luma = &s->cbf_luma[y_tu * min_tu_width + x_tu];
++            uint8_t *left_cbf_luma = curr_cbf_luma - 1;
++
++            s->hevcdsp.hevc_deblocking_boundary_strengths(trafo_in_min_pus,
++                    min_pu_in_4pix, min_pu_width * sizeof (MvField), 4 * s->bs_width >> 2,
++                    rpl[0].list, rpl[1].list, rpl_left[0].list, rpl_left[1].list,
++                    curr, left, bs);
++
++            for (j = 0; j < (1 << log2_trafo_size); j += 4) {
++                int j_pu = j >> log2_min_pu_size;
++                int j_tu = j >> log2_min_tu_size;
++
++                if (left[j_pu * min_pu_width].pred_flag == PF_INTRA)
++                    bs[j * s->bs_width >> 2] = 2;
++                else if (curr_cbf_luma[j_tu * min_tu_width] || left_cbf_luma[j_tu * min_tu_width])
++                    bs[j * s->bs_width >> 2] = 1;
+             }
+         }
++    }
+ 
+-        // bs for TU internal vertical PU boundaries
+-        for (j = 0; j < (1 << log2_trafo_size); j += 4) {
+-            int y_pu = (y0 + j) >> log2_min_pu_size;
++    if (!is_intra) {
++        for (i = inc; i < trafo_in_min_pus; i += inc) {
++            MvField *left;
+ 
+-            for (i = 8; i < (1 << log2_trafo_size); i += 8) {
+-                int xp_pu = (x0 + i - 1) >> log2_min_pu_size;
+-                int xq_pu = (x0 + i)     >> log2_min_pu_size;
+-                MvField *left = &tab_mvf[y_pu * min_pu_width + xp_pu];
+-                MvField *curr = &tab_mvf[y_pu * min_pu_width + xq_pu];
++            curr += inc;
++            left = curr - 1;
++            bs += inc << log2_min_pu_size >> 2;
+ 
+-                bs = boundary_strength(s, curr, left, rpl);
+-                s->vertical_bs[((x0 + i) + (y0 + j) * s->bs_width) >> 2] = bs;
+-            }
++            s->hevcdsp.hevc_deblocking_boundary_strengths(trafo_in_min_pus,
++                    min_pu_in_4pix, min_pu_width * sizeof (MvField), 4 * s->bs_width >> 2,
++                    rpl[0].list, rpl[1].list, rpl[0].list, rpl[1].list,
++                    curr, left, bs);
+         }
+     }
+ }
+diff --git a/libavcodec/hevcdsp.c b/libavcodec/hevcdsp.c
+index 9d773d9..a6534a9 100644
+--- a/libavcodec/hevcdsp.c
++++ b/libavcodec/hevcdsp.c
+@@ -123,6 +123,120 @@ DECLARE_ALIGNED(16, const int8_t, ff_hevc_qpel_filters[3][16]) = {
+ #include "hevcdsp_template.c"
+ #undef BIT_DEPTH
+ 
++static void hevc_deblocking_boundary_strengths(int pus, int dup, int in_inc, int out_inc,
++                                               int *curr_rpl0, int *curr_rpl1, int *neigh_rpl0, int *neigh_rpl1,
++                                               MvField *curr, MvField *neigh, uint8_t *bs)
++{
++    for (; pus > 0; pus--) {
++        int strength, out;
++        int curr_refL0 = curr_rpl0[curr->ref_idx[0]];
++        int curr_refL1 = curr_rpl1[curr->ref_idx[1]];
++        int neigh_refL0 = neigh_rpl0[neigh->ref_idx[0]];
++        int neigh_refL1 = neigh_rpl1[neigh->ref_idx[1]];
++
++#if 1 // This more directly matches the original implementation
++        if (curr->pred_flag == PF_BI &&  neigh->pred_flag == PF_BI) {
++            // same L0 and L1
++            if (curr_refL0 == neigh_refL0 &&
++                curr_refL0 == curr_refL1 &&
++                neigh_refL0 == neigh_refL1) {
++                if ((FFABS(neigh->mv[0].x - curr->mv[0].x) >= 4 || FFABS(neigh->mv[0].y - curr->mv[0].y) >= 4 ||
++                     FFABS(neigh->mv[1].x - curr->mv[1].x) >= 4 || FFABS(neigh->mv[1].y - curr->mv[1].y) >= 4) &&
++                    (FFABS(neigh->mv[1].x - curr->mv[0].x) >= 4 || FFABS(neigh->mv[1].y - curr->mv[0].y) >= 4 ||
++                     FFABS(neigh->mv[0].x - curr->mv[1].x) >= 4 || FFABS(neigh->mv[0].y - curr->mv[1].y) >= 4))
++                    strength = 1;
++                else
++                    strength = 0;
++            } else if (neigh_refL0 == curr_refL0 &&
++                       neigh_refL1 == curr_refL1) {
++                if (FFABS(neigh->mv[0].x - curr->mv[0].x) >= 4 || FFABS(neigh->mv[0].y - curr->mv[0].y) >= 4 ||
++                    FFABS(neigh->mv[1].x - curr->mv[1].x) >= 4 || FFABS(neigh->mv[1].y - curr->mv[1].y) >= 4)
++                    strength = 1;
++                else
++                    strength = 0;
++            } else if (neigh_refL1 == curr_refL0 &&
++                       neigh_refL0 == curr_refL1) {
++                if (FFABS(neigh->mv[1].x - curr->mv[0].x) >= 4 || FFABS(neigh->mv[1].y - curr->mv[0].y) >= 4 ||
++                    FFABS(neigh->mv[0].x - curr->mv[1].x) >= 4 || FFABS(neigh->mv[0].y - curr->mv[1].y) >= 4)
++                    strength = 1;
++                else
++                    strength = 0;
++            } else {
++                strength = 1;
++            }
++        } else if ((curr->pred_flag != PF_BI) && (neigh->pred_flag != PF_BI)){ // 1 MV
++            Mv curr_mv0, neigh_mv0;
++
++            if (curr->pred_flag & 1) {
++                curr_mv0   = curr->mv[0];
++            } else {
++                curr_mv0   = curr->mv[1];
++                curr_refL0 = curr_refL1;
++            }
++
++            if (neigh->pred_flag & 1) {
++                neigh_mv0   = neigh->mv[0];
++            } else {
++                neigh_mv0   = neigh->mv[1];
++                neigh_refL0 = neigh_refL1;
++            }
++
++            if (curr_refL0 == neigh_refL0) {
++                if (FFABS(curr_mv0.x - neigh_mv0.x) >= 4 || FFABS(curr_mv0.y - neigh_mv0.y) >= 4)
++                    strength = 1;
++                else
++                    strength = 0;
++            } else
++                strength = 1;
++        } else
++            strength = 1;
++#else // This has exactly the same effect, but is more suitable for vectorisation
++        Mv curr_mv[2];
++        Mv neigh_mv[2];
++        memcpy(curr_mv, curr->mv, sizeof curr_mv);
++        memcpy(neigh_mv, neigh->mv, sizeof neigh_mv);
++
++        if (!(curr->pred_flag & 2)) {
++            curr_mv[1] = curr_mv[0];
++            curr_refL1 = curr_refL0;
++        }
++        if (!(neigh->pred_flag & 2)) {
++            neigh_mv[1] = neigh_mv[0];
++            neigh_refL1 = neigh_refL0;
++        }
++        if (!(curr->pred_flag & 1)) {
++            curr_mv[0] = curr_mv[1];
++            curr_refL0 = curr_refL1;
++        }
++        if (!(neigh->pred_flag & 1)) {
++            neigh_mv[0] = neigh_mv[1];
++            neigh_refL0 = neigh_refL1;
++        }
++
++        strength = 1;
++
++        strength &= (neigh_refL0 != curr_refL0) | (neigh_refL1 != curr_refL1) |
++                (FFABS(neigh_mv[0].x - curr_mv[0].x) >= 4) | (FFABS(neigh_mv[0].y - curr_mv[0].y) >= 4) |
++                (FFABS(neigh_mv[1].x - curr_mv[1].x) >= 4) | (FFABS(neigh_mv[1].y - curr_mv[1].y) >= 4);
++
++        strength &= (neigh_refL1 != curr_refL0) | (neigh_refL0 != curr_refL1) |
++                (FFABS(neigh_mv[1].x - curr_mv[0].x) >= 4) | (FFABS(neigh_mv[1].y - curr_mv[0].y) >= 4) |
++                (FFABS(neigh_mv[0].x - curr_mv[1].x) >= 4) | (FFABS(neigh_mv[0].y - curr_mv[1].y) >= 4);
++
++        strength |= (((curr->pred_flag + 1) ^ (neigh->pred_flag + 1)) >> 2);
++#endif
++
++        curr += in_inc / sizeof (MvField);
++        neigh += in_inc / sizeof (MvField);
++
++        for (out = dup; out > 0; out--)
++        {
++            *bs = strength;
++            bs += out_inc;
++        }
++    }
++}
++
+ void ff_hevc_dsp_init(HEVCDSPContext *hevcdsp, int bit_depth)
+ {
+ #undef FUNC
+@@ -257,6 +371,8 @@ int i = 0;
+         break;
+     }
+ 
++    hevcdsp->hevc_deblocking_boundary_strengths = hevc_deblocking_boundary_strengths;
++
+     if (ARCH_X86)
+         ff_hevc_dsp_init_x86(hevcdsp, bit_depth);
+     if (ARCH_ARM)
+diff --git a/libavcodec/hevcdsp.h b/libavcodec/hevcdsp.h
+index 9f1f6dd..e221e54 100644
+--- a/libavcodec/hevcdsp.h
++++ b/libavcodec/hevcdsp.h
+@@ -42,6 +42,17 @@ typedef struct SAOParams {
+     uint8_t type_idx[3];    ///< sao_type_idx
+ } SAOParams;
+ 
++typedef struct Mv {
++    int16_t x;  ///< horizontal component of motion vector
++    int16_t y;  ///< vertical component of motion vector
++} Mv;
++
++typedef struct MvField {
++    DECLARE_ALIGNED(4, Mv, mv)[2];
++    int8_t ref_idx[2];
++    int8_t pred_flag;
++} MvField;
++
+ typedef struct HEVCDSPContext {
+     void (*put_pcm)(uint8_t *_dst, ptrdiff_t _stride, int width, int height,
+                     struct GetBitContext *gb, int pcm_bit_depth);
+@@ -120,6 +131,9 @@ typedef struct HEVCDSPContext {
+     void (*hevc_v_loop_filter_chroma_c)(uint8_t *pix, ptrdiff_t stride,
+                                         int32_t *tc, uint8_t *no_p,
+                                         uint8_t *no_q);
++    void (*hevc_deblocking_boundary_strengths)(int pus, int dup, int in_inc, int out_inc,
++                                               int *curr_rpl0, int *curr_rpl1, int *neigh_rpl0, int *neigh_rpl1,
++                                               MvField *curr, MvField *neigh, uint8_t *bs);
+ } HEVCDSPContext;
+ 
+ void ff_hevc_dsp_init(HEVCDSPContext *hpc, int bit_depth);
+-- 
+2.7.4
+
+
+From 619366d6acfd5f040a3116fda97b1146c8e40250 Mon Sep 17 00:00:00 2001
+From: Peter de Rivaz <peter.derivaz@gmail.com>
+Date: Wed, 15 Jul 2015 09:09:11 +0100
+Subject: [PATCH 68/68] Only enable qpu when needed
+
+---
+ libavcodec/hevc.h    |  2 +-
+ libavcodec/rpi_qpu.c | 21 ++++++++++++++++-----
+ 2 files changed, 17 insertions(+), 6 deletions(-)
+
+diff --git a/libavcodec/hevc.h b/libavcodec/hevc.h
+index 496c0e1..ce14975 100644
+--- a/libavcodec/hevc.h
++++ b/libavcodec/hevc.h
+@@ -57,7 +57,7 @@
+   // Define RPI_WORKER to launch a worker thread for pixel processing tasks
+   #define RPI_WORKER
+   // Define RPI_DEBLOCK_VPU to perform deblocking on the VPUs
+-  #define RPI_DEBLOCK_VPU
++  //#define RPI_DEBLOCK_VPU
+ 
+ #endif
+ 
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index 5aa0432..ffd13ca 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -9,7 +9,7 @@
+ // define RPI_ASYNC to run the VPU in a separate thread, need to make a separate call to check for completion
+ #define RPI_ASYNC
+ // Define RPI_COMBINE_JOBS to find jobs that can be executed in parallel
+-#define RPI_COMBINE_JOBS
++//#define RPI_COMBINE_JOBS
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+@@ -143,9 +143,9 @@ static int gpu_init(volatile struct GPU **gpu) {
+   volatile struct GPU* ptr;
+ 	if (mb < 0)
+ 		return -1;
+-
++#ifndef RPI_ASYNC
+ 	if (qpu_enable(mb, 1)) return -2;
+-
++#endif
+   vcsm_init();
+   gpu_malloc_uncached_internal(sizeof(struct GPU), &gpu_mem_ptr, mb);
+   ptr = (volatile struct GPU*)gpu_mem_ptr.arm;
+@@ -336,9 +336,9 @@ static void gpu_term(void)
+     vpu_post_code(0, 0, 0, 0, 0, 0, -1, NULL);
+     pthread_join(vpu_thread, &res);
+   }
+-#endif
+-
++#else
+   qpu_enable(mb, 0);
++#endif
+   gpu_free_internal(&gpu_mem_ptr);
+ 
+   vcsm_exit();
+@@ -400,6 +400,7 @@ static void *vpu_start(void *arg) {
+   int count_deblock=0;
+   int count_qpu=0;
+ #endif
++  int qpu_started = 0;
+   while(1) {
+     int i;
+     int *p; // Pointer for a QPU/VPU job
+@@ -427,6 +428,12 @@ static void *vpu_start(void *arg) {
+     if (p[7] == 0 && p[0] == 0 && p[16]==0)
+       goto job_done_early;
+ 
++    if (!qpu_started) {
++      int result = qpu_enable(gpu->mb, 1);
++      av_assert0(result==0);
++      qpu_started = 1;
++    }
++
+ #ifdef RPI_COMBINE_JOBS
+     // First scan for a qpu job
+     for (int x=0;x<num_jobs;x++) {
+@@ -556,6 +563,10 @@ job_done_early:
+     pthread_mutex_unlock(&post_mutex);
+   }
+ 
++  if (qpu_started) {
++    qpu_enable(gpu->mb, 0);
++  }
++
+   return NULL;
+ }
+ 
+-- 
+2.7.4
+
+From a0d0946951b53e64ce103dd61b455f8d1f72caf9 Mon Sep 17 00:00:00 2001
+From: John Cox <jc@kynesim.co.uk>
+Date: Tue, 9 Feb 2016 11:57:40 +0000
+Subject: [PATCH 1/2] Zero copy code v6
+
+This version has GPU buffer pooling code
+---
+ ffmpeg.c                 | 123 +++++++++-----
+ libavcodec/Makefile      |   2 +
+ libavcodec/avcodec.h     |   6 +
+ libavcodec/hevc.c        |  92 ++++++-----
+ libavcodec/hevc_filter.c |  83 +++++-----
+ libavcodec/rpi_qpu.c     |   2 +-
+ libavcodec/rpi_qpu.h     | 109 ++++++++++++-
+ libavcodec/rpi_zc.c      | 406 +++++++++++++++++++++++++++++++++++++++++++++++
+ libavcodec/rpi_zc.h      |  83 ++++++++++
+ 9 files changed, 779 insertions(+), 127 deletions(-)
+ create mode 100644 libavcodec/rpi_zc.c
+ create mode 100644 libavcodec/rpi_zc.h
+
+diff --git a/ffmpeg.c b/ffmpeg.c
+index 50c6e86..953e5b8 100644
+--- a/ffmpeg.c
++++ b/ffmpeg.c
+@@ -25,7 +25,7 @@
+ 
+ #ifdef RPI
+ #define RPI_DISPLAY
+-//#define RPI_ZERO_COPY
++#define RPI_ZERO_COPY
+ #endif
+ 
+ #include "config.h"
+@@ -80,9 +80,7 @@
+ #include <interface/mmal/util/mmal_default_components.h>
+ #include <interface/mmal/util/mmal_connection.h>
+ #include <interface/mmal/util/mmal_util_params.h>
+-#ifdef RPI_ZERO_COPY
+-#include "libavcodec/rpi_qpu.h"
+-#endif
++#include "libavcodec/rpi_zc.h"
+ #endif
+ 
+ #if HAVE_SYS_RESOURCE_H
+@@ -183,13 +181,7 @@ static void free_input_threads(void);
+ 
+ static MMAL_COMPONENT_T* rpi_display = NULL;
+ static MMAL_POOL_T *rpi_pool = NULL;
+-
+-#ifdef RPI_ZERO_COPY
+-static uint8_t *get_vc_handle(AVBufferRef *bref) {
+-  GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+-  return (uint8_t *)p->vc_handle;
+-}
+-#endif
++static volatile int rpi_display_count = 0;
+ 
+ static MMAL_POOL_T* display_alloc_pool(MMAL_PORT_T* port, size_t w, size_t h)
+ {
+@@ -206,7 +198,7 @@ static MMAL_POOL_T* display_alloc_pool(MMAL_PORT_T* port, size_t w, size_t h)
+     for (i = 0; i < NUM_BUFFERS; ++i)
+     {
+        MMAL_BUFFER_HEADER_T* buffer = pool->header[i];
+-       void* bufPtr = buffer->data;
++       char * bufPtr = buffer->data;
+        memset(bufPtr, i*30, w*h);
+        memset(bufPtr+w*h, 128, (w*h)/2);
+     }
+@@ -215,23 +207,31 @@ static MMAL_POOL_T* display_alloc_pool(MMAL_PORT_T* port, size_t w, size_t h)
+     return pool;
+ }
+ 
+-static void display_cb_input(MMAL_PORT_T *port,MMAL_BUFFER_HEADER_T *buffer) {
++static void display_cb_input(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer) {
++#ifdef RPI_ZERO_COPY
++    av_rpi_zc_unref(buffer->user_data);
++    --rpi_display_count;
++#endif
++    mmal_buffer_header_release(buffer);
++}
++
++static void display_cb_control(MMAL_PORT_T *port,MMAL_BUFFER_HEADER_T *buffer) {
+   mmal_buffer_header_release(buffer);
+ }
+ 
+ static MMAL_COMPONENT_T* display_init(size_t x, size_t y, size_t w, size_t h)
+ {
+     MMAL_COMPONENT_T* display;
+-    int w2 = (w+31)&~31;
+-    int h2 = (h+15)&~15;
+     MMAL_DISPLAYREGION_T region =
+     {
+-        {MMAL_PARAMETER_DISPLAYREGION, sizeof(region)},
++        .hdr = {MMAL_PARAMETER_DISPLAYREGION, sizeof(region)},
+         .set = MMAL_DISPLAY_SET_LAYER | MMAL_DISPLAY_SET_FULLSCREEN | MMAL_DISPLAY_SET_DEST_RECT,
+         .layer = 2,
+         .fullscreen = 0,
+         .dest_rect = {x, y, w, h}
+     };
++    const AVRpiZcFrameGeometry geo = av_rpi_zc_frame_geometry(w, h);
++
+     bcm_host_init();  // TODO is this needed?
+     mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER, &display);
+     assert(display);
+@@ -240,8 +240,8 @@ static MMAL_COMPONENT_T* display_init(size_t x, size_t y, size_t w, size_t h)
+ 
+     MMAL_ES_FORMAT_T* format = display->input[0]->format;
+     format->encoding = MMAL_ENCODING_I420;
+-    format->es->video.width = w2;
+-    format->es->video.height = h2;
++    format->es->video.width = geo.stride_y;
++    format->es->video.height = geo.height_y;
+     format->es->video.crop.x = 0;
+     format->es->video.crop.y = 0;
+     format->es->video.crop.width = w;
+@@ -250,46 +250,75 @@ static MMAL_COMPONENT_T* display_init(size_t x, size_t y, size_t w, size_t h)
+ 
+     mmal_component_enable(display);
+ 
+-    rpi_pool = display_alloc_pool(display->input[0], w2, h2);
++    rpi_pool = display_alloc_pool(display->input[0], geo.stride_y, geo.height_y);
+ 
+     mmal_port_enable(display->input[0],display_cb_input);
+-    mmal_port_enable(display->control,display_cb_input);
++    mmal_port_enable(display->control,display_cb_control);
+ 
+-    printf("Allocated display %d %d\n",w,h);
++    printf("Allocated display %dx%d in %dx%d\n", w, h, geo.stride_y, geo.height_y);
+ 
+     return display;
+ }
+ 
+-static void display_frame(MMAL_COMPONENT_T* display,AVFrame* fr)
++static void display_frame(struct AVCodecContext * const s, MMAL_COMPONENT_T* const display, const AVFrame* const fr)
+ {
+-    int w = fr->width;
+-    int h = fr->height;
+-    int w2 = (w+31)&~31;
+-    int h2 = (h+15)&~15;
+     if (!display || !rpi_pool)
+         return;
++
++    if (rpi_display_count >= 3) {
++        av_log(s, AV_LOG_VERBOSE, "Frame dropped\n");
++        return;
++    }
++
+     MMAL_BUFFER_HEADER_T* buf = mmal_queue_get(rpi_pool->queue);
+     if (!buf) {
+-      // Running too fast so drop the frame
+-      return;
++        // Running too fast so drop the frame
++        printf("Q alloc failure\n");
++        return;
+     }
+     assert(buf);
+     buf->cmd = 0;
+-    buf->length = (w2 * h2 * 3)/2;
+     buf->offset = 0; // Offset to valid data
+     buf->flags = 0;
+ #ifdef RPI_ZERO_COPY
+-    buf->data = get_vc_handle(fr->buf[0]);
+-    buf->alloc_size = (w2*h2*3)/2;
++{
++    const AVRpiZcRefPtr fr_buf = av_rpi_zc_ref(s, fr, 1);
++
++    buf->user_data = fr_buf;
++    buf->data = av_rpi_zc_vc_handle(fr_buf);
++    buf->alloc_size =
++        buf->length = av_rpi_zc_numbytes(fr_buf);
++
++    ++rpi_display_count;
++}
+ #else
++{
++#error YYY
++    int w = fr->width;
++    int h = fr->height;
++    int w2 = (w+31)&~31;
++    int h2 = (h+15)&~15;
++
++    buf->length = (w2 * h2 * 3)/2;
++    buf->user_data = NULL;
++
+     //mmal_buffer_header_mem_lock(buf);
+     memcpy(buf->data, fr->data[0], w2 * h);
+     memcpy(buf->data+w2*h2, fr->data[1], w2 * h / 4);
+     memcpy(buf->data+w2*h2*5/4, fr->data[2], w2 * h / 4);
+     //mmal_buffer_header_mem_unlock(buf);
++}
+ #endif
+ 
+-    mmal_port_send_buffer(display->input[0], buf);  // I assume this will automatically get released
++    while (rpi_display_count >= 3) {
++        usleep(5000);
++    }
++
++    if (mmal_port_send_buffer(display->input[0], buf) != MMAL_SUCCESS)
++    {
++        printf("** send failed: depth=%d\n", rpi_display_count);
++        display_cb_input(NULL, buf);
++    }
+ }
+ 
+ static void display_exit(MMAL_COMPONENT_T* display)
+@@ -687,6 +716,11 @@ static void ffmpeg_cleanup(int ret)
+         avformat_close_input(&input_files[i]->ctx);
+         av_freep(&input_files[i]);
+     }
++
++#ifdef RPI_DISPLAY
++    display_exit(rpi_display);
++#endif
++
+     for (i = 0; i < nb_input_streams; i++) {
+         InputStream *ist = input_streams[i];
+ 
+@@ -698,6 +732,9 @@ static void ffmpeg_cleanup(int ret)
+         av_freep(&ist->filters);
+         av_freep(&ist->hwaccel_device);
+ 
++#ifdef RPI_ZERO_COPY
++        av_rpi_zc_uninit(ist->dec_ctx);
++#endif
+         avcodec_free_context(&ist->dec_ctx);
+ 
+         av_freep(&input_streams[i]);
+@@ -729,9 +766,6 @@ static void ffmpeg_cleanup(int ret)
+     term_exit();
+     ffmpeg_exited = 1;
+ 
+-#ifdef RPI_DISPLAY
+-    display_exit(rpi_display);
+-#endif
+ }
+ 
+ void remove_avoptions(AVDictionary **a, AVDictionary *b)
+@@ -1091,18 +1125,19 @@ static void do_video_out(AVFormatContext *s,
+     int frame_size = 0;
+     InputStream *ist = NULL;
+     AVFilterContext *filter = ost->filter->filter;
++
++    if (ost->source_index >= 0)
++        ist = input_streams[ost->source_index];
++
+ #ifdef RPI_DISPLAY
+-    if (next_picture)
++    if (next_picture && ist != NULL)
+     {
+-	if (!rpi_display)
++        if (!rpi_display)
+            rpi_display = display_init(0,0,next_picture->width,next_picture->height);
+-        display_frame(rpi_display,next_picture);
++        display_frame(ist->dec_ctx, rpi_display, next_picture);
+     }
+ #endif
+ 
+-    if (ost->source_index >= 0)
+-        ist = input_streams[ost->source_index];
+-
+     if (filter->inputs[0]->frame_rate.num > 0 &&
+         filter->inputs[0]->frame_rate.den > 0)
+         duration = 1/(av_q2d(filter->inputs[0]->frame_rate) * av_q2d(enc->time_base));
+@@ -2708,6 +2743,12 @@ static int init_input_stream(int ist_index, char *error, int error_len)
+         ist->dec_ctx->opaque                = ist;
+         ist->dec_ctx->get_format            = get_format;
+         ist->dec_ctx->get_buffer2           = get_buffer;
++
++#ifdef RPI_ZERO_COPY
++        // Overrides the above get_buffer2
++        av_rpi_zc_init(ist->dec_ctx);
++#endif
++
+         ist->dec_ctx->thread_safe_callbacks = 1;
+ 
+         av_opt_set_int(ist->dec_ctx, "refcounted_frames", 1, 0);
+diff --git a/libavcodec/Makefile b/libavcodec/Makefile
+index 03065cd..21e4514 100644
+--- a/libavcodec/Makefile
++++ b/libavcodec/Makefile
+@@ -9,6 +9,7 @@ HEADERS = avcodec.h                                                     \
+           rpi_shader.h                                                  \
+           rpi_mailbox.h                                                 \
+           rpi_hevc_transform.h                                          \
++          rpi_zc.h                                                      \
+           d3d11va.h                                                     \
+           dirac.h                                                       \
+           dv_profile.h                                                  \
+@@ -50,6 +51,7 @@ OBJS = allcodecs.o                                                      \
+        rpi_qpu.o                                                        \
+        rpi_shader.o                                                     \
+        rpi_mailbox.o                                                    \
++       rpi_zc.o                                                         \
+        vorbis_parser.o                                                  \
+        xiph.o                                                           \
+ 
+diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
+index 39713ed..a1ba217 100644
+--- a/libavcodec/avcodec.h
++++ b/libavcodec/avcodec.h
+@@ -3505,6 +3505,12 @@ typedef struct AVCodecContext {
+ #define FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS 1
+ #endif
+ 
++    /**
++     * Opaque pointer for use by replacement get_buffer2 code
++     *
++     * @author jc (08/02/2016)
++     */
++    void * get_buffer_context;
+ } AVCodecContext;
+ 
+ AVRational av_codec_get_pkt_timebase         (const AVCodecContext *avctx);
+diff --git a/libavcodec/hevc.c b/libavcodec/hevc.c
+index 8437e10..51736c7 100644
+--- a/libavcodec/hevc.c
++++ b/libavcodec/hevc.c
+@@ -114,10 +114,6 @@ static uint32_t rpi_filter_coefs[8][1] = {
+         { ENCODE_COEFFS(  -2,  10,  58,  -2) }
+ };
+ 
+-static uint32_t get_vc_address(AVBufferRef *bref) {
+-  GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+-  return p->vc;
+-}
+ #endif
+ 
+ 
+@@ -2197,9 +2193,9 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   int bw = nPbW-start_x;
+                   int bh = nPbH-start_y;
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
+-                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address_y(ref0->frame);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
+-                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address_y(ref0->frame);
+                   *y++ = ( (bw<16 ? bw : 16) << 16 ) + (bh<16 ? bh : 16);
+                   *y++ = my2_mx2_my_mx;
+                   if (weight_flag) {
+@@ -2207,7 +2203,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   } else {
+                       *y++ = 1; // Weight of 1 and offset of 0
+                   }
+-                  *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
++                  *y++ = (get_vc_address_y(s->frame) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
+                 }
+             }
+@@ -2246,8 +2242,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address_u(ref0->frame);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address_v(ref0->frame);
+                       *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
+                       *u++ = rpi_filter_coefs[_mx][0];
+                       *u++ = rpi_filter_coefs[_my][0];
+@@ -2258,8 +2254,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                           *u++ = 1; // Weight of 1 and offset of 0
+                           *u++ = 1;
+                       }
+-                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+-                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
++                      *u++ = (get_vc_address_u(s->frame) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
++                      *u++ = (get_vc_address_v(s->frame) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+                 }
+                 s->curr_u_mvs = u;
+@@ -2297,9 +2293,9 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   int bw = nPbW-start_x;
+                   int bh = nPbH-start_y;
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
+-                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address_y(ref1->frame);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + 8 + start_x) & 0xffff);
+-                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address_y(ref1->frame);
+                   *y++ = ( (bw<16 ? bw : 16) << 16 ) + (bh<16 ? bh : 16);
+                   *y++ = my2_mx2_my_mx;
+                   if (weight_flag) {
+@@ -2307,7 +2303,7 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   } else {
+                       *y++ = 1; // Weight of 1 and offset of 0
+                   }
+-                  *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
++                  *y++ = (get_vc_address_y(s->frame) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter;
+                 }
+             }
+@@ -2347,8 +2343,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address_u(ref1->frame);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address_v(ref1->frame);
+                       *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
+                       // TODO chroma weight and offset... s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]
+                       *u++ = rpi_filter_coefs[_mx][0];
+@@ -2360,8 +2356,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                           *u++ = 1; // Weight of 1 and offset of 0
+                           *u++ = 1;
+                       }
+-                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+-                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
++                      *u++ = (get_vc_address_u(s->frame) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
++                      *u++ = (get_vc_address_v(s->frame) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+                 }
+                 s->curr_u_mvs = u;
+@@ -2403,13 +2399,13 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                   int bw = nPbW-start_x;
+                   int bh = nPbH-start_y;
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y1 - 3 + start_y) << 16) + ( (x1 - 3 + start_x) & 0xffff);
+-                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address_y(ref0->frame);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = ((y2 - 3 + start_y) << 16) + ( (x2 - 3 + start_x) & 0xffff); // Second fetch is for ref1
+-                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[0]);
++                  y++[-RPI_LUMA_COMMAND_WORDS] = get_vc_address_y(ref1->frame);
+                   *y++ = ( (bw<8 ? bw : 8) << 16 ) + (bh<16 ? bh : 16);
+                   *y++ = my2_mx2_my_mx;
+                   *y++ = 1; // B frame weighted prediction not supported
+-                  *y++ = (get_vc_address(s->frame->buf[0]) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
++                  *y++ = (get_vc_address_y(s->frame) + x0 + start_x + (start_y + y0) * s->frame->linesize[0]);
+                   y++[-RPI_LUMA_COMMAND_WORDS] = s->mc_filter_b;
+                 }
+             }
+@@ -2453,8 +2449,8 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b0;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = x1_c - 1 + start_x;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = y1_c - 1 + start_y;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[1]);
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref0->frame->buf[2]);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address_u(ref0->frame);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address_v(ref0->frame);
+                       *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
+                       *u++ = rpi_filter_coefs[_mx][0];
+                       *u++ = rpi_filter_coefs[_my][0];
+@@ -2464,14 +2460,14 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = s->mc_filter_uv_b;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = x2_c - 1 + start_x;
+                       u++[-RPI_CHROMA_COMMAND_WORDS] = y2_c - 1 + start_y;
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[1]);
+-                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address(ref1->frame->buf[2]);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address_u(ref1->frame);
++                      u++[-RPI_CHROMA_COMMAND_WORDS] = get_vc_address_v(ref1->frame);
+                       *u++ = ( (bw<RPI_CHROMA_BLOCK_WIDTH ? bw : RPI_CHROMA_BLOCK_WIDTH) << 16 ) + (bh<16 ? bh : 16);
+                       *u++ = rpi_filter_coefs[_mx2][0];
+                       *u++ = rpi_filter_coefs[_my2][0];
+                       u+=2; // Weights not supported in B slices
+-                      *u++ = (get_vc_address(s->frame->buf[1]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
+-                      *u++ = (get_vc_address(s->frame->buf[2]) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
++                      *u++ = (get_vc_address_u(s->frame) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[1]);
++                      *u++ = (get_vc_address_v(s->frame) + x0_c + start_x + (start_y + y0_c) * s->frame->linesize[2]);
+                     }
+                 }
+                 s->curr_u_mvs = u;
+@@ -3270,12 +3266,13 @@ static int32_t filter8_luma(uint8_t *data, int x0, int y0, int pitch, int my_mx,
+    return vsum;
+ }
+ 
+-static uint8_t *test_frame(HEVCContext *s,uint32_t p, AVFrame *frame, int cIdx)
++static uint8_t *test_frame(HEVCContext *s,uint32_t p, AVFrame *frame, const int cIdx)
+ {
+   //int pic_width        = s->ps.sps->width >> s->ps.sps->hshift[cIdx];
+   int pic_height       = s->ps.sps->height >> s->ps.sps->vshift[cIdx];
+   int pitch = frame->linesize[cIdx];
+-  uint32_t base = get_vc_address(frame->buf[cIdx]);
++  uint32_t base = c_idx == 0 ? get_vc_address_y(frame);
++    c_idx == 1 ? get_vc_address_u(frame) : get_vc_address_v(frame);
+   if (p>=base && p<base+pitch*pic_height) {
+     return frame->data[cIdx] + (p-base);
+   }
+@@ -3562,6 +3559,7 @@ static void rpi_launch_vpu_qpu(HEVCContext *s)
+ #ifdef RPI
+ 
+ #ifndef RPI_FAST_CACHEFLUSH
++#error RPI_FAST_CACHEFLUSH is broken
+ static void flush_buffer(AVBufferRef *bref) {
+     GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+     gpu_cache_flush(p);
+@@ -3572,7 +3570,7 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
+ {
+ #ifdef RPI_FAST_CACHEFLUSH
+     struct vcsm_user_clean_invalid_s iocache = {};
+-    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
++    GPU_MEM_PTR_T p = get_gpu_mem_ptr_u(s->frame);
+     int n = s->ps.sps->height;
+     int curr_y = 0;
+     int curr_uv = 0;
+@@ -3580,21 +3578,21 @@ static void flush_frame(HEVCContext *s,AVFrame *frame)
+     int sz,base;
+     sz = s->frame->linesize[1] * (n_uv-curr_uv);
+     base = s->frame->linesize[1] * curr_uv;
+-    iocache.s[0].handle = p->vcsm_handle;
++    iocache.s[0].handle = p.vcsm_handle;
+     iocache.s[0].cmd = 3; // clean+invalidate
+-    iocache.s[0].addr = (int)(p->arm) + base;
++    iocache.s[0].addr = (int)(p.arm) + base;
+     iocache.s[0].size  = sz;
+-    p = av_buffer_pool_opaque(frame->buf[2]);
+-    iocache.s[1].handle = p->vcsm_handle;
++    p = get_gpu_mem_ptr_v(s->frame);
++    iocache.s[1].handle = p.vcsm_handle;
+     iocache.s[1].cmd = 3; // clean+invalidate
+-    iocache.s[1].addr = (int)(p->arm) + base;
++    iocache.s[1].addr = (int)(p.arm) + base;
+     iocache.s[1].size  = sz;
+-    p = av_buffer_pool_opaque(frame->buf[0]);
++    p = get_gpu_mem_ptr_y(s->frame);
+     sz = s->frame->linesize[0] * (n-curr_y);
+     base = s->frame->linesize[0] * curr_y;
+-    iocache.s[2].handle = p->vcsm_handle;
++    iocache.s[2].handle = p.vcsm_handle;
+     iocache.s[2].cmd = 3; // clean+invalidate
+-    iocache.s[2].addr = (int)(p->arm) + base;
++    iocache.s[2].addr = (int)(p.arm) + base;
+     iocache.s[2].size  = sz;
+     vcsm_clean_invalid( &iocache );
+ #else
+@@ -3612,7 +3610,7 @@ static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM
+     int curr_y;
+     int curr_uv;
+     int n_uv;
+-    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
++    GPU_MEM_PTR_T p = get_gpu_mem_ptr_u(s->frame);
+     int sz,base;
+     int (*d)[2] = s->dblk_cmds[job];
+     int low=(*d)[1];
+@@ -3629,21 +3627,21 @@ static void flush_frame3(HEVCContext *s,AVFrame *frame,GPU_MEM_PTR_T *p0,GPU_MEM
+ 
+     sz = s->frame->linesize[1] * (n_uv-curr_uv);
+     base = s->frame->linesize[1] * curr_uv;
+-    iocache.s[0].handle = p->vcsm_handle;
++    iocache.s[0].handle = p.vcsm_handle;
+     iocache.s[0].cmd = 3; // clean+invalidate
+-    iocache.s[0].addr = (int)(p->arm) + base;
++    iocache.s[0].addr = (int)(p.arm) + base;
+     iocache.s[0].size  = sz;
+-    p = av_buffer_pool_opaque(frame->buf[2]);
+-    iocache.s[1].handle = p->vcsm_handle;
++    p = get_gpu_mem_ptr_v(s->frame);
++    iocache.s[1].handle = p.vcsm_handle;
+     iocache.s[1].cmd = 3; // clean+invalidate
+-    iocache.s[1].addr = (int)(p->arm) + base;
++    iocache.s[1].addr = (int)(p.arm) + base;
+     iocache.s[1].size  = sz;
+-    p = av_buffer_pool_opaque(frame->buf[0]);
++    p = get_gpu_mem_ptr_y(s->frame);
+     sz = s->frame->linesize[0] * (n-curr_y);
+     base = s->frame->linesize[0] * curr_y;
+-    iocache.s[2].handle = p->vcsm_handle;
++    iocache.s[2].handle = p.vcsm_handle;
+     iocache.s[2].cmd = 3; // clean+invalidate
+-    iocache.s[2].addr = (int)(p->arm) + base;
++    iocache.s[2].addr = (int)(p.arm) + base;
+     iocache.s[2].size  = sz;
+ 
+     iocache.s[3].handle = p0->vcsm_handle;
+diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
+index 826a82f..c4fa305 100644
+--- a/libavcodec/hevc_filter.c
++++ b/libavcodec/hevc_filter.c
+@@ -879,17 +879,25 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
+ #undef CR
+ 
+ #ifdef RPI_INTER_QPU
+-static void flush_buffer(AVBufferRef *bref) {
+-    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+-    gpu_cache_flush(p);
++static void flush_buffer_y(const AVFrame * const frame) {
++    GPU_MEM_PTR_T p = get_gpu_mem_ptr_y(frame);
++    gpu_cache_flush(&p);
+ }
+ 
+-// Return Physical address for this image
+-static uint32_t get_vc_address(AVBufferRef *bref) {
+-  GPU_MEM_PTR_T *p = av_buffer_pool_opaque(bref);
+-  return p->vc;
++static void flush_buffer_u(const AVFrame * const frame) {
++    GPU_MEM_PTR_T p = get_gpu_mem_ptr_u(frame);
++    gpu_cache_flush(&p);
+ }
+ 
++static void flush_buffer_v(const AVFrame * const frame) {
++    GPU_MEM_PTR_T p = get_gpu_mem_ptr_v(frame);
++    gpu_cache_flush(&p);
++}
++
++
++#ifdef RPI_DEBLOCK_VPU
++#error Not fixed yet
++
+ // ff_hevc_flush_buffer_lines
+ // flushes and invalidates all pixel rows in [start,end-1]
+ static void ff_hevc_flush_buffer_lines(HEVCContext *s, int start, int end, int flush_luma, int flush_chroma)
+@@ -901,44 +909,44 @@ static void ff_hevc_flush_buffer_lines(HEVCContext *s, int start, int end, int f
+         int curr_uv = curr_y >> s->ps.sps->vshift[1];
+         int n_uv = n >> s->ps.sps->vshift[1];
+         int sz,base;
+-        GPU_MEM_PTR_T *p;
++        GPU_MEM_PTR_T p;
+         if (curr_uv < 0) curr_uv = 0;
+         if (n_uv<=curr_uv) { return; }
+         sz = s->frame->linesize[1] * (n_uv-curr_uv);
+         base = s->frame->linesize[1] * curr_uv;
+         if (flush_chroma) {
+-          p = av_buffer_pool_opaque(s->frame->buf[1]);
+-          iocache.s[0].handle = p->vcsm_handle;
++          p = get_gpu_mem_ptr_u(s->frame);
++          iocache.s[0].handle = p.vcsm_handle;
+           iocache.s[0].cmd = 3; // clean+invalidate
+-          iocache.s[0].addr = (int)p->arm + base;
++          iocache.s[0].addr = (int)p.arm + base;
+           iocache.s[0].size  = sz;
+-          p = av_buffer_pool_opaque(s->frame->buf[2]);
+-          iocache.s[1].handle = p->vcsm_handle;
++          p = get_gpu_mem_ptr_v(s->frame);
++          iocache.s[1].handle = p.vcsm_handle;
+           iocache.s[1].cmd = 3; // clean+invalidate
+-          iocache.s[1].addr = (int)p->arm + base;
++          iocache.s[1].addr = (int)p.arm + base;
+           iocache.s[1].size  = sz;
+         }
+         if (flush_luma) {
+-          p = av_buffer_pool_opaque(s->frame->buf[0]);
++          p = get_gpu_mem_ptr_y(s->frame);
+           sz = s->frame->linesize[0] * (n-curr_y);
+           base = s->frame->linesize[0] * curr_y;
+-          iocache.s[2].handle = p->vcsm_handle;
++          iocache.s[2].handle = p.vcsm_handle;
+           iocache.s[2].cmd = 3; // clean+invalidate
+-          iocache.s[2].addr = (int)p->arm + base;
++          iocache.s[2].addr = (int)p.arm + base;
+           iocache.s[2].size  = sz;
+         }
+         vcsm_clean_invalid( &iocache );
+ #else
+         if (flush_chroma) {
+-          flush_buffer(s->frame->buf[1]);
+-          flush_buffer(s->frame->buf[2]);
++          flush_buffer_u(s->frame);
++          flush_buffer_v(s->frame);
+         }
+         if (flush_luma) {
+-          flush_buffer(s->frame->buf[0]);
++          flush_buffer_y(s->frame);
+         }
+ #endif
+ }
+-
++#endif
+ 
+ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+ {
+@@ -950,37 +958,37 @@ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+         int curr_uv = curr_y >> s->ps.sps->vshift[1];
+         int n_uv = n >> s->ps.sps->vshift[1];
+         int sz,base;
+-        GPU_MEM_PTR_T *p;
++        GPU_MEM_PTR_T p;
+         if (curr_uv < 0) curr_uv = 0;
+         if (n_uv<=curr_uv) { return; }
+         sz = s->frame->linesize[1] * (n_uv-curr_uv);
+         base = s->frame->linesize[1] * curr_uv;
+-        p = av_buffer_pool_opaque(s->frame->buf[1]);
+-        iocache.s[0].handle = p->vcsm_handle;
++        p = get_gpu_mem_ptr_u(s->frame);
++        iocache.s[0].handle = p.vcsm_handle;
+         iocache.s[0].cmd = 3; // clean+invalidate
+-        iocache.s[0].addr = (int)p->arm + base;
++        iocache.s[0].addr = (int)p.arm + base;
+         iocache.s[0].size  = sz;
+-        p = av_buffer_pool_opaque(s->frame->buf[2]);
+-        iocache.s[1].handle = p->vcsm_handle;
++        p = get_gpu_mem_ptr_v(s->frame);
++        iocache.s[1].handle = p.vcsm_handle;
+         iocache.s[1].cmd = 3; // clean+invalidate
+-        iocache.s[1].addr = (int)p->arm + base;
++        iocache.s[1].addr = (int)p.arm + base;
+         iocache.s[1].size  = sz;
+ 
+ #ifdef RPI_LUMA_QPU
+-        p = av_buffer_pool_opaque(s->frame->buf[0]);
++        p = get_gpu_mem_ptr_y(s->frame);
+         sz = s->frame->linesize[0] * (n-curr_y);
+         base = s->frame->linesize[0] * curr_y;
+-        iocache.s[2].handle = p->vcsm_handle;
++        iocache.s[2].handle = p.vcsm_handle;
+         iocache.s[2].cmd = 3; // clean+invalidate
+-        iocache.s[2].addr = (int)p->arm + base;
++        iocache.s[2].addr = (int)p.arm + base;
+         iocache.s[2].size  = sz;
+ #endif
+         vcsm_clean_invalid( &iocache );
+ #else
+-        flush_buffer(s->frame->buf[1]);
+-        flush_buffer(s->frame->buf[2]);
++        flush_buffer_u(s->frame);
++        flush_buffer_v(s->frame);
+ #ifdef RPI_LUMA_QPU
+-        flush_buffer(s->frame->buf[0]);
++        flush_buffer_y(s->frame);
+ #endif
+ 
+ #endif
+@@ -992,6 +1000,7 @@ void ff_hevc_flush_buffer(HEVCContext *s, ThreadFrame *f, int n)
+ #endif
+ 
+ #ifdef RPI_DEBLOCK_VPU
++#error XXX
+ /* rpi_deblock deblocks an entire row of ctbs using the VPU */
+ static void rpi_deblock(HEVCContext *s, int y, int ctb_size)
+ {
+@@ -1000,21 +1009,21 @@ static void rpi_deblock(HEVCContext *s, int y, int ctb_size)
+   // TODO flush buffer of beta/tc setup when it becomes cached
+ 
+   // Prepare three commands at once to avoid calling overhead
+-  s->vpu_cmds_arm[0][0] = get_vc_address(s->frame->buf[0]) + s->frame->linesize[0] * y;
++  s->vpu_cmds_arm[0][0] = get_vc_address_y(s->frame) + s->frame->linesize[0] * y;
+   s->vpu_cmds_arm[0][1] = s->frame->linesize[0];
+   s->vpu_cmds_arm[0][2] = s->setup_width;
+   s->vpu_cmds_arm[0][3] = (int) ( s->y_setup_vc + s->setup_width * (y>>4) );
+   s->vpu_cmds_arm[0][4] = ctb_size>>4;
+   s->vpu_cmds_arm[0][5] = 2;
+ 
+-  s->vpu_cmds_arm[1][0] = get_vc_address(s->frame->buf[1]) + s->frame->linesize[1] * (y>> s->ps.sps->vshift[1]);
++  s->vpu_cmds_arm[1][0] = get_vc_address_u(s->frame) + s->frame->linesize[1] * (y>> s->ps.sps->vshift[1]);
+   s->vpu_cmds_arm[1][1] = s->frame->linesize[1];
+   s->vpu_cmds_arm[1][2] = s->uv_setup_width;
+   s->vpu_cmds_arm[1][3] = (int) ( s->uv_setup_vc + s->uv_setup_width * ((y>>4)>> s->ps.sps->vshift[1]) );
+   s->vpu_cmds_arm[1][4] = (ctb_size>>4)>> s->ps.sps->vshift[1];
+   s->vpu_cmds_arm[1][5] = 3;
+ 
+-  s->vpu_cmds_arm[2][0] = get_vc_address(s->frame->buf[2]) + s->frame->linesize[2] * (y>> s->ps.sps->vshift[2]);
++  s->vpu_cmds_arm[2][0] = get_vc_address_v(s->frame) + s->frame->linesize[2] * (y>> s->ps.sps->vshift[2]);
+   s->vpu_cmds_arm[2][1] = s->frame->linesize[2];
+   s->vpu_cmds_arm[2][2] = s->uv_setup_width;
+   s->vpu_cmds_arm[2][3] = (int) ( s->uv_setup_vc + s->uv_setup_width * ((y>>4)>> s->ps.sps->vshift[1]) );
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index ffd13ca..b0c9bc5 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -250,7 +250,7 @@ int gpu_get_mailbox(void)
+ }
+ 
+ // Call this to clean and invalidate a region of memory
+-void gpu_cache_flush(GPU_MEM_PTR_T *p)
++void gpu_cache_flush(const GPU_MEM_PTR_T * const p)
+ {
+ #ifdef RPI_FAST_CACHEFLUSH
+     struct vcsm_user_clean_invalid_s iocache = {};
+diff --git a/libavcodec/rpi_qpu.h b/libavcodec/rpi_qpu.h
+index 81c2bb1..b913f79 100644
+--- a/libavcodec/rpi_qpu.h
++++ b/libavcodec/rpi_qpu.h
+@@ -2,8 +2,11 @@
+ #define RPI_QPU_H
+ 
+ // Define RPI_FAST_CACHEFLUSH to use the VCSM cache flush code
++// *** N.B. Code has rotted & crashes if this is unset (before this set of changes)
+ #define RPI_FAST_CACHEFLUSH
+ 
++#define RPI_ONE_BUF 1
++
+ typedef struct gpu_mem_ptr_s {
+   unsigned char *arm; // Pointer to memory mapped on ARM side
+   int vc_handle;   // Videocore handle of relocatable memory
+@@ -16,9 +19,113 @@ typedef struct gpu_mem_ptr_s {
+ extern int gpu_malloc_cached(int numbytes, GPU_MEM_PTR_T *p);
+ extern int gpu_malloc_uncached(int numbytes, GPU_MEM_PTR_T *p);
+ extern void gpu_free(GPU_MEM_PTR_T *p);
+-extern void gpu_cache_flush(GPU_MEM_PTR_T *p);
++extern void gpu_cache_flush(const GPU_MEM_PTR_T * const p);
+ extern void gpu_cache_flush3(GPU_MEM_PTR_T *p0,GPU_MEM_PTR_T *p1,GPU_MEM_PTR_T *p2);
+ 
++#include "libavutil/frame.h"
++#if !RPI_ONE_BUF
++static inline uint32_t get_vc_address_y(const AVFrame * const frame) {
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[0]);
++    return p->vc;
++}
++
++static inline uint32_t get_vc_address_u(const AVFrame * const frame) {
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[1]);
++    return p->vc;
++}
++
++static inline uint32_t get_vc_address_v(const AVFrame * const frame) {
++    GPU_MEM_PTR_T *p = av_buffer_pool_opaque(frame->buf[2]);
++    return p->vc;
++}
++
++static inline GPU_MEM_PTR_T get_gpu_mem_ptr_y(const AVFrame * const frame) {
++    return *(GPU_MEM_PTR_T *)av_buffer_pool_opaque(frame->buf[0]);
++}
++
++static inline GPU_MEM_PTR_T get_gpu_mem_ptr_u(const AVFrame * const frame) {
++    return *(GPU_MEM_PTR_T *)av_buffer_pool_opaque(frame->buf[1]);
++}
++
++static inline GPU_MEM_PTR_T get_gpu_mem_ptr_v(const AVFrame * const frame) {
++    return *(GPU_MEM_PTR_T *)av_buffer_pool_opaque(frame->buf[2]);
++}
++
++#else
++
++static inline int gpu_is_buf1(const AVFrame * const frame)
++{
++    return frame->buf[1] == NULL;
++}
++
++static inline GPU_MEM_PTR_T * gpu_buf1_gmem(const AVFrame * const frame)
++{
++    return av_buffer_get_opaque(frame->buf[0]);
++}
++
++static inline GPU_MEM_PTR_T * gpu_buf3_gmem(const AVFrame * const frame, const int n)
++{
++    return av_buffer_pool_opaque(frame->buf[n]);
++}
++
++
++static inline uint32_t get_vc_address_y(const AVFrame * const frame) {
++    return gpu_is_buf1(frame) ? gpu_buf1_gmem(frame)->vc : gpu_buf3_gmem(frame, 0)->vc;
++}
++
++static inline uint32_t get_vc_address_u(const AVFrame * const frame) {
++    return gpu_is_buf1(frame) ?
++        gpu_buf1_gmem(frame)->vc + frame->data[1] - frame->data[0] :
++        gpu_buf3_gmem(frame, 1)->vc;
++}
++
++static inline uint32_t get_vc_address_v(const AVFrame * const frame) {
++    return gpu_is_buf1(frame) ?
++        gpu_buf1_gmem(frame)->vc + frame->data[2] - frame->data[0] :
++        gpu_buf3_gmem(frame, 2)->vc;
++}
++
++
++static inline GPU_MEM_PTR_T get_gpu_mem_ptr_y(const AVFrame * const frame) {
++    if (gpu_is_buf1(frame))
++    {
++        GPU_MEM_PTR_T g = *gpu_buf1_gmem(frame);
++        g.numbytes = frame->data[1] - frame->data[0];
++        return g;
++    }
++    else
++        return *gpu_buf3_gmem(frame, 0);
++}
++
++static inline GPU_MEM_PTR_T get_gpu_mem_ptr_u(const AVFrame * const frame) {
++    if (gpu_is_buf1(frame))
++    {
++        GPU_MEM_PTR_T g = *gpu_buf1_gmem(frame);
++        g.arm += frame->data[1] - frame->data[0];
++        g.vc += frame->data[1] - frame->data[0];
++        g.numbytes = frame->data[2] - frame->data[1];  // chroma size
++        return g;
++    }
++    else
++        return *gpu_buf3_gmem(frame, 1);
++}
++
++static inline GPU_MEM_PTR_T get_gpu_mem_ptr_v(const AVFrame * const frame) {
++    if (gpu_is_buf1(frame))
++    {
++        GPU_MEM_PTR_T g = *gpu_buf1_gmem(frame);
++        g.arm += frame->data[2] - frame->data[0];
++        g.vc += frame->data[2] - frame->data[0];
++        g.numbytes = frame->data[2] - frame->data[1];  // chroma size
++        return g;
++    }
++    else
++        return *gpu_buf3_gmem(frame, 2);
++}
++
++#endif
++
++
+ // QPU specific functions
+ extern void qpu_run_shader8(int code, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8);
+ extern void qpu_run_shader12(int code, int num, int code2, int num2, int unifs1, int unifs2, int unifs3, int unifs4, int unifs5, int unifs6, int unifs7, int unifs8, int unifs9, int unifs10, int unifs11, int unifs12);
+diff --git a/libavcodec/rpi_zc.c b/libavcodec/rpi_zc.c
+new file mode 100644
+index 0000000..9580165
+--- /dev/null
++++ b/libavcodec/rpi_zc.c
+@@ -0,0 +1,406 @@
++#include "config.h"
++#ifdef RPI
++#include "rpi_qpu.h"
++#include "rpi_zc.h"
++
++#include "libavutil/buffer_internal.h"
++
++struct ZcPoolEnt;
++
++typedef struct ZcPool
++{
++    int numbytes;
++    struct ZcPoolEnt * head;
++    pthread_mutex_t lock;
++} ZcPool;
++
++typedef struct ZcPoolEnt
++{
++    // It is important that we start with gmem as other bits of code will expect to see that
++    GPU_MEM_PTR_T gmem;
++    struct ZcPoolEnt * next;
++    struct ZcPool * pool;
++} ZcPoolEnt;
++
++static ZcPoolEnt * zc_pool_ent_alloc(ZcPool * const pool, const int size)
++{
++    ZcPoolEnt * const zp = av_malloc(sizeof(ZcPoolEnt));
++
++    if (zp == NULL) {
++        av_log(NULL, AV_LOG_ERROR, "av_malloc(ZcPoolEnt) failed\n");
++        goto fail0;
++    }
++
++    if (gpu_malloc_cached(size, &zp->gmem) != 0)
++    {
++        av_log(NULL, AV_LOG_ERROR, "av_gpu_malloc_cached(%d) failed\n", size);
++        goto fail1;
++    }
++
++    zp->next = NULL;
++    zp->pool = pool;
++    return zp;
++
++fail1:
++    av_free(zp);
++fail0:
++    return NULL;
++}
++
++static void zc_pool_ent_free(ZcPoolEnt * const zp)
++{
++    gpu_free(&zp->gmem);
++    av_free(zp);
++}
++
++static void zc_pool_flush(ZcPool * const pool)
++{
++    ZcPoolEnt * p = pool->head;
++    pool->head = NULL;
++    while (p != NULL)
++    {
++        ZcPoolEnt * const zp = p;
++        p = p->next;
++        zc_pool_ent_free(zp);
++    }
++}
++
++static ZcPoolEnt * zc_pool_alloc(ZcPool * const pool, const int numbytes)
++{
++    ZcPoolEnt * zp;
++    pthread_mutex_lock(&pool->lock);
++
++    if (numbytes != pool->numbytes)
++    {
++        zc_pool_flush(pool);
++        pool->numbytes = numbytes;
++    }
++
++    if (pool->head != NULL)
++    {
++        zp = pool->head;
++        pool->head = zp->next;
++    }
++    else
++    {
++        zp = zc_pool_ent_alloc(pool, numbytes);
++    }
++
++    pthread_mutex_unlock(&pool->lock);
++    return zp;
++}
++
++static void zc_pool_free(ZcPoolEnt * const zp)
++{
++    ZcPool * const pool = zp == NULL ? NULL : zp->pool;
++    if (zp != NULL)
++    {
++        pthread_mutex_lock(&pool->lock);
++        if (pool->numbytes == zp->gmem.numbytes)
++        {
++            zp->next = pool->head;
++            pool->head = zp;
++            pthread_mutex_unlock(&pool->lock);
++        }
++        else
++        {
++            pthread_mutex_unlock(&pool->lock);
++            zc_pool_ent_free(zp);
++        }
++    }
++}
++
++static void
++zc_pool_init(ZcPool * const pool)
++{
++    pool->numbytes = -1;
++    pool->head = NULL;
++    pthread_mutex_init(&pool->lock, NULL);
++}
++
++static void
++zc_pool_destroy(ZcPool * const pool)
++{
++    pool->numbytes = -1;
++    zc_pool_flush(pool);
++    pthread_mutex_destroy(&pool->lock);
++}
++
++
++typedef struct AVZcEnv
++{
++    ZcPool pool;
++} ZcEnv;
++
++// Callback when buffer unrefed to zero
++static void rpi_free_display_buffer(void *opaque, uint8_t *data)
++{
++    ZcPoolEnt *const zp = opaque;
++//    printf("%s: data=%p\n", __func__, data);
++    zc_pool_free(zp);
++}
++
++static inline GPU_MEM_PTR_T * pic_gm_ptr(AVBufferRef * const buf)
++{
++    // Kludge where we check the free fn to check this is really
++    // one of our buffers - can't think of a better way
++    return buf == NULL || buf->buffer->free != rpi_free_display_buffer ? NULL :
++        av_buffer_get_opaque(buf);
++}
++
++AVRpiZcFrameGeometry av_rpi_zc_frame_geometry(
++    const unsigned int video_width, const unsigned int video_height)
++{
++    AVRpiZcFrameGeometry geo;
++    geo.stride_y = (video_width + 32 + 31) & ~31;
++    geo.stride_c = geo.stride_y / 2;
++//    geo.height_y = (video_height + 15) & ~15;
++    geo.height_y = (video_height + 32 + 31) & ~31;
++    geo.height_c = geo.height_y / 2;
++    return geo;
++}
++
++static AVBufferRef * rpi_buf_pool_alloc(ZcPool * const pool, int size)
++{
++    ZcPoolEnt *const zp = zc_pool_alloc(pool, size);
++    AVBufferRef * buf;
++
++    if (zp == NULL) {
++        av_log(NULL, AV_LOG_ERROR, "zc_pool_alloc(%d) failed\n", size);
++        goto fail0;
++    }
++
++    if ((buf = av_buffer_create(zp->gmem.arm, size, rpi_free_display_buffer, zp, AV_BUFFER_FLAG_READONLY)) == NULL)
++    {
++        av_log(NULL, AV_LOG_ERROR, "av_buffer_create() failed\n");
++        goto fail2;
++    }
++
++    return buf;
++
++fail2:
++    zc_pool_free(zp);
++fail0:
++    return NULL;
++}
++
++static int rpi_get_display_buffer(struct AVCodecContext * const s, AVFrame * const frame)
++{
++    ZcEnv *const zc = s->get_buffer_context;
++    const AVRpiZcFrameGeometry geo = av_rpi_zc_frame_geometry(frame->width, frame->height);
++    const unsigned int size_y = geo.stride_y * geo.height_y;
++    const unsigned int size_c = geo.stride_c * geo.height_c;
++    const unsigned int size_pic = size_y + size_c * 2;
++    AVBufferRef * buf;
++    unsigned int i;
++
++//    printf("Do local alloc: format=%#x, %dx%d: %u\n", frame->format, frame->width, frame->height, size_pic);
++
++    if ((buf = rpi_buf_pool_alloc(&zc->pool, size_pic)) == NULL)
++    {
++        av_log(s, AV_LOG_ERROR, "rpi_get_display_buffer: Failed to get buffer from pool\n");
++        return AVERROR(ENOMEM);
++    }
++
++    for (i = 0; i < AV_NUM_DATA_POINTERS; i++) {
++        frame->buf[i] = NULL;
++        frame->data[i] = NULL;
++        frame->linesize[i] = 0;
++    }
++
++    frame->buf[0] = buf;
++    frame->linesize[0] = geo.stride_y;
++    frame->linesize[1] = geo.stride_c;
++    frame->linesize[2] = geo.stride_c;
++    frame->data[0] = buf->data;
++    frame->data[1] = frame->data[0] + size_y;
++    frame->data[2] = frame->data[1] + size_c;
++    frame->extended_data = frame->data;
++    // Leave extended buf alone
++
++    return 0;
++}
++
++
++#define RPI_GET_BUFFER2 1
++
++int av_rpi_zc_get_buffer2(struct AVCodecContext *s, AVFrame *frame, int flags)
++{
++#if !RPI_GET_BUFFER2
++    return avcodec_default_get_buffer2(s, frame, flags);
++#else
++    int rv;
++
++    if ((s->codec->capabilities & AV_CODEC_CAP_DR1) == 0 ||
++        frame->format != AV_PIX_FMT_YUV420P)
++    {
++//        printf("Do default alloc: format=%#x\n", frame->format);
++        rv = avcodec_default_get_buffer2(s, frame, flags);
++    }
++    else
++    {
++        rv = rpi_get_display_buffer(s, frame);
++    }
++
++#if 0
++    printf("%s: %dx%d lsize=%d/%d/%d data=%p/%p/%p bref=%p/%p/%p opaque[0]=%p\n", __func__,
++        frame->width, frame->height,
++        frame->linesize[0], frame->linesize[1], frame->linesize[2],
++        frame->data[0], frame->data[1], frame->data[2],
++        frame->buf[0], frame->buf[1], frame->buf[2],
++        av_buffer_get_opaque(frame->buf[0]));
++#endif
++    return rv;
++#endif
++}
++
++
++static AVBufferRef * zc_copy(struct AVCodecContext * const s,
++    const AVFrame * const src)
++{
++    AVFrame dest_frame;
++    AVFrame * const dest = &dest_frame;
++    unsigned int i;
++    uint8_t * psrc, * pdest;
++
++    dest->width = src->width;
++    dest->height = src->height;
++
++    if (rpi_get_display_buffer(s, dest) != 0)
++    {
++        return NULL;
++    }
++
++    for (i = 0, psrc = src->data[0], pdest = dest->data[0];
++         i != dest->height;
++         ++i, psrc += src->linesize[0], pdest += dest->linesize[0])
++    {
++        memcpy(pdest, psrc, dest->width);
++    }
++    for (i = 0, psrc = src->data[1], pdest = dest->data[1];
++         i != dest->height / 2;
++         ++i, psrc += src->linesize[1], pdest += dest->linesize[1])
++    {
++        memcpy(pdest, psrc, dest->width / 2);
++    }
++    for (i = 0, psrc = src->data[2], pdest = dest->data[2];
++         i != dest->height / 2;
++         ++i, psrc += src->linesize[2], pdest += dest->linesize[2])
++    {
++        memcpy(pdest, psrc, dest->width / 2);
++    }
++
++    return dest->buf[0];
++}
++
++
++AVRpiZcRefPtr av_rpi_zc_ref(struct AVCodecContext * const s,
++    const AVFrame * const frame, const int maycopy)
++{
++    assert(s != NULL);
++
++    if (frame->format != AV_PIX_FMT_YUV420P)
++    {
++        av_log(s, AV_LOG_WARNING, "%s: *** Format not YUV420P: %d\n", __func__, frame->format);
++        return NULL;
++    }
++
++    if (frame->buf[1] != NULL)
++    {
++        if (maycopy)
++        {
++            av_log(s, AV_LOG_INFO, "%s: *** Not a single buf frame: copying\n", __func__);
++            return zc_copy(s, frame);
++        }
++        else
++        {
++            av_log(s, AV_LOG_WARNING, "%s: *** Not a single buf frame: NULL\n", __func__);
++            return NULL;
++        }
++    }
++
++    if (pic_gm_ptr(frame->buf[0]) == NULL)
++    {
++        if (maycopy)
++        {
++            av_log(s, AV_LOG_INFO, "%s: *** Not one of our buffers: copying\n", __func__);
++            return zc_copy(s, frame);
++        }
++        else
++        {
++            av_log(s, AV_LOG_WARNING, "%s: *** Not one of our buffers: NULL\n", __func__);
++            return NULL;
++        }
++    }
++
++    return av_buffer_ref(frame->buf[0]);
++}
++
++int av_rpi_zc_vc_handle(const AVRpiZcRefPtr fr_ref)
++{
++    const GPU_MEM_PTR_T * const p = pic_gm_ptr(fr_ref);
++    return p == NULL ? -1 : p->vc_handle;
++}
++
++int av_rpi_zc_numbytes(const AVRpiZcRefPtr fr_ref)
++{
++    const GPU_MEM_PTR_T * const p = pic_gm_ptr(fr_ref);
++    return p == NULL ? 0 : p->numbytes;
++}
++
++void av_rpi_zc_unref(AVRpiZcRefPtr fr_ref)
++{
++    if (fr_ref != NULL)
++    {
++        av_buffer_unref(&fr_ref);
++    }
++}
++
++AVZcEnvPtr av_rpi_zc_env_alloc(void)
++{
++    ZcEnv * const zc = av_mallocz(sizeof(ZcEnv));
++    if (zc == NULL)
++    {
++        av_log(NULL, AV_LOG_ERROR, "av_rpi_zc_env_alloc: Context allocation failed\n");
++        return NULL;
++    }
++
++    zc_pool_init(&zc->pool);
++    return zc;
++}
++
++void av_rpi_zc_env_free(AVZcEnvPtr zc)
++{
++    if (zc != NULL)
++    {
++        zc_pool_destroy(&zc->pool); ;
++        av_free(zc);
++    }
++}
++
++int av_rpi_zc_init(struct AVCodecContext * const s)
++{
++    ZcEnv * const zc = av_rpi_zc_env_alloc();
++    if (zc == NULL)
++    {
++        return AVERROR(ENOMEM);
++    }
++
++    s->get_buffer_context = zc;
++    s->get_buffer2 = av_rpi_zc_get_buffer2;
++    return 0;
++}
++
++void av_rpi_zc_uninit(struct AVCodecContext * const s)
++{
++    if (s->get_buffer2 == av_rpi_zc_get_buffer2)
++    {
++        ZcEnv * const zc = s->get_buffer_context;
++        s->get_buffer2 = avcodec_default_get_buffer2;
++        s->get_buffer_context = NULL;
++        av_rpi_zc_env_free(zc);
++    }
++}
++
++#endif  // RPI
++
+diff --git a/libavcodec/rpi_zc.h b/libavcodec/rpi_zc.h
+new file mode 100644
+index 0000000..f0109f4
+--- /dev/null
++++ b/libavcodec/rpi_zc.h
+@@ -0,0 +1,83 @@
++#ifndef LIBAVCODEC_RPI_ZC_H
++#define LIBAVCODEC_RPI_ZC_H
++
++// Zero-Copy frame code for RPi
++// RPi needs Y/U/V planes to be contiguous for display.  By default
++// ffmpeg will allocate separated planes so a memcpy is needed before
++// display.  This code prodes a method a making ffmpeg allocate a single
++// bit of memory for the frame when can then be refrence counted until
++// display ahs finsihed with it.
++
++#include "libavutil/frame.h"
++#include "libavcodec/avcodec.h"
++
++// "Opaque" pointer to whatever we are using as a buffer reference
++typedef AVBufferRef * AVRpiZcRefPtr;
++
++struct AVZcEnv;
++typedef struct AVZcEnv * AVZcEnvPtr;
++
++typedef struct AVRpiZcFrameGeometry
++{
++    unsigned int stride_y;
++    unsigned int height_y;
++    unsigned int stride_c;
++    unsigned int height_c;
++} AVRpiZcFrameGeometry;
++
++
++AVRpiZcFrameGeometry av_rpi_zc_frame_geometry(
++    const unsigned int video_width, const unsigned int video_height);
++
++// Replacement fn for avctx->get_buffer2
++// Should be set before calling avcodec_decode_open2
++//
++// N.B. in addition to to setting avctx->get_buffer2, avctx->refcounted_frames
++// must be set to 1 as otherwise the buffer info is killed before being returned
++// by avcodec_decode_video2.  Note also that this means that the AVFrame that is
++// return must be manually derefed with av_frame_unref.  This should be done
++// after av_rpi_zc_ref has been called.
++int av_rpi_zc_get_buffer2(struct AVCodecContext *s, AVFrame *frame, int flags);
++
++// Generate a ZC reference to the buffer(s) in this frame
++// If the buffer doesn't appear to be one allocated by _get_buffer_2
++// then the behaviour depends on maycopy:
++//   If maycopy=0 then return NULL
++//   If maycopy=1 && the src frame is in a form where we can easily copy
++//     the data, then allocate a new buffer and copy the data into it
++//   Otherwise return NULL
++AVRpiZcRefPtr av_rpi_zc_ref(struct AVCodecContext * const s,
++    const AVFrame * const frame, const int maycopy);
++
++// Get the vc_handle from the frame ref
++// Returns -1 if ref doesn't look valid
++int av_rpi_zc_vc_handle(const AVRpiZcRefPtr fr_ref);
++// Get the number of bytes allocated from the frame ref
++// Returns 0 if ref doesn't look valid
++int av_rpi_zc_numbytes(const AVRpiZcRefPtr fr_ref);
++
++// Unreference the buffer refed/allocated by _zc_ref
++// If fr_ref is NULL then this will NOP
++void av_rpi_zc_unref(AVRpiZcRefPtr fr_ref);
++
++// Allocate an environment for the buffer pool used by the ZC code
++// This should be put in avctx->get_buffer_context so it can be found by
++// av_rpi_zc_get_buffer2 when it is called from ffmpeg
++AVZcEnvPtr av_rpi_zc_env_alloc(void);
++
++// Allocate the environment used by the ZC code
++void av_rpi_zc_env_free(AVZcEnvPtr);
++
++
++// Init ZC into a context
++// There is nothing magic in this fn - it just packages setting
++// get_buffer2 & get_buffer_context
++int av_rpi_zc_init(struct AVCodecContext * const s);
++
++// Free ZC from a context
++// There is nothing magic in this fn - it just packages unsetting
++// get_buffer2 & get_buffer_context
++void av_rpi_zc_uninit(struct AVCodecContext * const s);
++
++#endif
++
+-- 
+2.7.4
+
+
+From a6da64e1ca42f0394ccfa55dca782a456841da94 Mon Sep 17 00:00:00 2001
+From: John Cox <jc@kynesim.co.uk>
+Date: Tue, 1 Mar 2016 14:21:25 +0000
+Subject: [PATCH 2/2] Set VPU scheduling thread to high priority after creation
+
+---
+ libavcodec/rpi_qpu.c | 48 +++++++++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 47 insertions(+), 1 deletion(-)
+
+diff --git a/libavcodec/rpi_qpu.c b/libavcodec/rpi_qpu.c
+index b0c9bc5..ee19231 100644
+--- a/libavcodec/rpi_qpu.c
++++ b/libavcodec/rpi_qpu.c
+@@ -182,9 +182,55 @@ static int gpu_init(volatile struct GPU **gpu) {
+     err = pthread_create(&vpu_thread, NULL, vpu_start, NULL);
+     //printf("Created thread\n");
+     if (err) {
+-        printf("Failed to create vpu thread\n");
++        av_log(NULL, AV_LOG_FATAL, "Failed to create vpu thread\n");
+         return -4;
+     }
++
++    {
++      struct sched_param param = {0};
++      int policy = 0;
++
++      if (pthread_getschedparam(vpu_thread, &policy, &param) != 0)
++      {
++        av_log(NULL, AV_LOG_ERROR, "Unable to get VPU thread scheduling parameters\n");
++      }
++      else
++      {
++        av_log(NULL, AV_LOG_INFO, "VPU thread: policy=%d (%s), pri=%d\n",
++            policy,
++            policy == SCHED_RR ? "RR" : policy == SCHED_FIFO ? "FIFO" : "???" ,
++            param.sched_priority);
++
++        policy = SCHED_FIFO;
++        param.sched_priority = sched_get_priority_max(SCHED_FIFO);
++
++        av_log(NULL, AV_LOG_INFO, "Attempt to set: policy=%d (%s), pri=%d\n",
++            policy,
++            policy == SCHED_RR ? "RR" : policy == SCHED_FIFO ? "FIFO" : "???" ,
++            param.sched_priority);
++
++        if (pthread_setschedparam(vpu_thread, policy, &param) != 0)
++        {
++          av_log(NULL, AV_LOG_ERROR, "Unable to set VPU thread scheduling parameters\n");
++        }
++        else
++        {
++          if (pthread_getschedparam(vpu_thread, &policy, &param) != 0)
++          {
++            av_log(NULL, AV_LOG_ERROR, "Unable to get VPU thread scheduling parameters\n");
++          }
++          else
++          {
++            av_log(NULL, AV_LOG_INFO, "VPU thread (after): policy=%d (%s), pri=%d\n",
++                policy,
++                policy == SCHED_RR ? "RR" : policy == SCHED_FIFO ? "FIFO" : "???" ,
++                param.sched_priority);
++          }
++        }
++      }
++
++    }
++
+   }
+ #endif
+ 
+-- 
+2.7.4
+
-- 
2.7.4


From 19fa54026bf0d7bd0fd8d2533dab6e442fb3ca83 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 22 Aug 2015 23:06:56 +0100
Subject: [PATCH 129/175] Increase timeout on CDVDMsgGeneralSynchronize

---
 xbmc/cores/VideoPlayer/DVDMessage.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/DVDMessage.cpp b/xbmc/cores/VideoPlayer/DVDMessage.cpp
index c7df4a6..4114ecb 100644
--- a/xbmc/cores/VideoPlayer/DVDMessage.cpp
+++ b/xbmc/cores/VideoPlayer/DVDMessage.cpp
@@ -89,7 +89,7 @@ bool CDVDMsgGeneralSynchronize::Wait(unsigned int milliseconds, unsigned int sou
 
 void CDVDMsgGeneralSynchronize::Wait(std::atomic<bool>& abort, unsigned int source)
 {
-  while(!Wait(100, source) && !abort);
+  while(!Wait(200, source) && !abort);
 }
 
 long CDVDMsgGeneralSynchronize::Release()
-- 
2.7.4


From bd65c09983a8685f3c62dbfca45f4f44501c9277 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 16 Sep 2015 19:05:12 +0100
Subject: [PATCH 130/175] Make MVC a valid 3D filename tag

---
 xbmc/guilib/StereoscopicsManager.cpp | 9 +++++++++
 xbmc/settings/AdvancedSettings.cpp   | 2 ++
 xbmc/settings/AdvancedSettings.h     | 1 +
 3 files changed, 12 insertions(+)

diff --git a/xbmc/guilib/StereoscopicsManager.cpp b/xbmc/guilib/StereoscopicsManager.cpp
index b34873c..1443aca 100644
--- a/xbmc/guilib/StereoscopicsManager.cpp
+++ b/xbmc/guilib/StereoscopicsManager.cpp
@@ -197,6 +197,15 @@ std::string CStereoscopicsManager::DetectStereoModeByString(const std::string &n
   if (re.RegFind(searchString) > -1)
     stereoMode = "top_bottom";
 
+  if (!re.RegComp(g_advancedSettings.m_stereoscopicregex_mvc.c_str()))
+  {
+    CLog::Log(LOGERROR, "%s: Invalid RegExp for matching 3d MVC content:'%s'", __FUNCTION__, g_advancedSettings.m_stereoscopicregex_mvc.c_str());
+    return stereoMode;
+  }
+
+  if (re.RegFind(searchString) > -1)
+    stereoMode = "left_right";
+
   return stereoMode;
 }
 
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 6272960..2784850 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -402,6 +402,7 @@ void CAdvancedSettings::Initialize()
   m_stereoscopicregex_3d = "[-. _]3d[-. _]";
   m_stereoscopicregex_sbs = "[-. _]h?sbs[-. _]";
   m_stereoscopicregex_tab = "[-. _]h?tab[-. _]";
+  m_stereoscopicregex_mvc = "[-. _]h?mvc[-. _]";
 
   m_useDisplayControlHWStereo = false;
 
@@ -516,6 +517,7 @@ void CAdvancedSettings::ParseSettingsFile(const std::string &file)
     XMLUtils::GetString(pElement, "stereoscopicregex3d", m_stereoscopicregex_3d);
     XMLUtils::GetString(pElement, "stereoscopicregexsbs", m_stereoscopicregex_sbs);
     XMLUtils::GetString(pElement, "stereoscopicregextab", m_stereoscopicregex_tab);
+    XMLUtils::GetString(pElement, "stereoscopicregexmvc", m_stereoscopicregex_mvc);
     XMLUtils::GetFloat(pElement, "subsdelayrange", m_videoSubsDelayRange, 10, 600);
     XMLUtils::GetFloat(pElement, "audiodelayrange", m_videoAudioDelayRange, 10, 600);
     XMLUtils::GetString(pElement, "defaultplayer", m_videoDefaultPlayer);
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index fc526d1..6b0e3b8 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -372,6 +372,7 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     std::string m_stereoscopicregex_3d;
     std::string m_stereoscopicregex_sbs;
     std::string m_stereoscopicregex_tab;
+    std::string m_stereoscopicregex_mvc;
 
     bool m_useDisplayControlHWStereo;
 
-- 
2.7.4


From fc36f265399b20e09fb4cbf834f1d11a076e69bf Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 5 Oct 2015 14:58:05 +0100
Subject: [PATCH 131/175] Swap top/bottom sides of GUI

---
 xbmc/guilib/GraphicContext.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 3706e4d..e170b3f 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -266,7 +266,7 @@ CPoint CGraphicContext::StereoCorrection(const CPoint &point) const
   {
     const RESOLUTION_INFO info = GetResInfo();
 
-    if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+    if(m_stereoView == RENDER_STEREO_VIEW_LEFT)
       res.y += info.iHeight + info.iBlanking;
   }
   if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-- 
2.7.4


From d5fb610d6d914ce1263699cb20c5f4f20072ec52 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 11 Oct 2015 20:51:37 +0100
Subject: [PATCH 132/175] Revert "Revert "Disable extra logging by default""

This reverts commit a880554325be187b877cd8f0e2b338e7267da636.
---
 system/settings/settings.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index a254e70..472d79f 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -2820,12 +2820,12 @@
         </setting>
         <setting id="debug.extralogging" type="boolean" label="666" help="36394">
           <level>1</level>
-          <default>true</default>
+          <default>false</default>
           <control type="toggle" />
         </setting>
         <setting id="debug.setextraloglevel" type="list[integer]" parent="debug.extralogging" label="668" help="36534">
           <level>1</level>
-          <default>32768</default>
+          <default></default>
           <constraints>
             <options>loggingcomponents</options>
             <delimiter>,</delimiter>
-- 
2.7.4


From 2e3d42343d62eb4aa535af13cb2996296d3aa18f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 26 Nov 2015 17:14:49 +0000
Subject: [PATCH 133/175] Add debug logging showing resamplerate

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index aac31a0..8fd85f9 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -2450,6 +2450,7 @@ CSampleBuffer* CActiveAE::SyncStream(CActiveAEStream *stream)
     if (stream->m_processingBuffers)
     {
       stream->m_processingBuffers->SetRR(stream->CalcResampleRatio(error), m_settings.atempoThreshold);
+      CLog::Log(LOGDEBUG, "CDVDPlayerAudio::%s rr:%.5f threshold:%.3f error:%.6f", __FUNCTION__, stream->m_processingBuffers->GetRR(), m_settings.atempoThreshold, error);
     }
   }
   else if (stream->m_processingBuffers)
-- 
2.7.4


From 5bf2c73b13a51c43742c8d606e8fe42442b11d88 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 21 Dec 2015 22:17:25 +0000
Subject: [PATCH 134/175] Fall back to arm jpeg encode/decode when gpu is busy

---
 xbmc/cores/omxplayer/OMXImage.cpp | 50 ++++++++++++++++++++++++++++++++-------
 xbmc/cores/omxplayer/OMXImage.h   |  7 ++++++
 2 files changed, 48 insertions(+), 9 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index d2560aa..e16dbf0 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -57,12 +57,17 @@ static XbmcThreads::ConditionVariable g_count_cond;
 static CCriticalSection               g_count_lock;
 static int g_count_val;
 
-static void limit_calls_enter()
+static bool limit_calls_enter()
 {
   CSingleLock lock(g_count_lock);
+  // on Pi2 fall back to arm decode if the queue is getting big
+  if (g_RBP.RasberryPiVersion() > 1 && g_count_val >= 2)
+    return false;
+
   while (g_count_val >= 3)
     g_count_cond.wait(lock);
   g_count_val++;
+  return true;
 }
 
 static void limit_calls_leave()
@@ -112,6 +117,9 @@ bool COMXImage::CreateThumbnailFromSurface(unsigned char* buffer, unsigned int w
       unsigned int format, unsigned int pitch, const std::string& destFile)
 {
   COMXImageEnc omxImageEnc;
+  if (!omxImageEnc.Gpu())
+    return false;
+
   bool ret = omxImageEnc.CreateThumbnailFromSurface(buffer, width, height, format, pitch, destFile);
   if (!ret)
     CLog::Log(LOGNOTICE, "%s: unable to create thumbnail %s %dx%d", __func__, destFile.c_str(), width, height);
@@ -205,6 +213,8 @@ bool COMXImage::CreateThumb(const std::string& srcFile, unsigned int maxHeight,
   bool okay = false;
   COMXImageFile file;
   COMXImageReEnc reenc;
+  if (!reenc.Gpu())
+    return false;
   void *pDestBuffer;
   unsigned int nDestSize;
   int orientation = additional_info == "flipped" ? 1:0;
@@ -310,6 +320,9 @@ bool COMXImage::DecodeJpegToTexture(COMXImageFile *file, unsigned int width, uns
   bool ret = false;
   COMXTexture omx_image;
 
+  if (!omx_image.Gpu())
+    return false;
+
   struct textureinfo *tex = new struct textureinfo;
   if (!tex)
     return NULL;
@@ -924,7 +937,7 @@ bool COMXImageFile::ReadFile(const std::string& inputFile, int orientation)
 
 COMXImageDec::COMXImageDec()
 {
-  limit_calls_enter();
+  m_gpu = limit_calls_enter();
   m_decoded_buffer = NULL;
   OMX_INIT_STRUCTURE(m_decoded_format);
   m_success = false;
@@ -936,7 +949,8 @@ COMXImageDec::~COMXImageDec()
 
   OMX_INIT_STRUCTURE(m_decoded_format);
   m_decoded_buffer = NULL;
-  limit_calls_leave();
+  if (m_gpu)
+    limit_calls_leave();
 }
 
 void COMXImageDec::Close()
@@ -1086,6 +1100,9 @@ bool COMXImageDec::HandlePortSettingChange(unsigned int resize_width, unsigned i
 
 bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes, unsigned width, unsigned height, unsigned stride, void *pixels)
 {
+  if (!m_gpu)
+    return false;
+
   CSingleLock lock(m_OMXSection);
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
@@ -1223,7 +1240,7 @@ bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes
 
 COMXImageEnc::COMXImageEnc()
 {
-  limit_calls_enter();
+  m_gpu = limit_calls_enter();
   CSingleLock lock(m_OMXSection);
   OMX_INIT_STRUCTURE(m_encoded_format);
   m_encoded_buffer = NULL;
@@ -1247,11 +1264,15 @@ COMXImageEnc::~COMXImageEnc()
       m_omx_encoder.Deinitialize();
     }
   }
-  limit_calls_leave();
+  if (m_gpu)
+    limit_calls_leave();
 }
 
 bool COMXImageEnc::Encode(unsigned char *buffer, int size, unsigned width, unsigned height, unsigned int pitch)
 {
+  if (!m_gpu)
+    return false;
+
   CSingleLock lock(m_OMXSection);
 
   unsigned int demuxer_bytes = 0;
@@ -1432,6 +1453,9 @@ bool COMXImageEnc::Encode(unsigned char *buffer, int size, unsigned width, unsig
 bool COMXImageEnc::CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
     unsigned int format, unsigned int pitch, const std::string& destFile)
 {
+  if (!m_gpu)
+    return false;
+
   if(format != XB_FMT_A8R8G8B8 || !buffer)
   {
     CLog::Log(LOGDEBUG, "%s::%s : %s failed format=0x%x\n", CLASSNAME, __func__, destFile.c_str(), format);
@@ -1465,7 +1489,7 @@ bool COMXImageEnc::CreateThumbnailFromSurface(unsigned char* buffer, unsigned in
 
 COMXImageReEnc::COMXImageReEnc()
 {
-  limit_calls_enter();
+  m_gpu = limit_calls_enter();
   m_encoded_buffer = NULL;
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
@@ -1479,7 +1503,8 @@ COMXImageReEnc::~COMXImageReEnc()
     free (m_pDestBuffer);
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
-  limit_calls_leave();
+  if (m_gpu)
+    limit_calls_leave();
 }
 
 void COMXImageReEnc::Close()
@@ -1771,6 +1796,9 @@ bool COMXImageReEnc::HandlePortSettingChange(unsigned int resize_width, unsigned
 
 bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, unsigned int maxHeight, void * &pDestBuffer, unsigned int &nDestSize)
 {
+  if (!m_gpu)
+    return false;
+
   CSingleLock lock(m_OMXSection);
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
@@ -1943,14 +1971,15 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
 
 COMXTexture::COMXTexture()
 {
-  limit_calls_enter();
+  m_gpu = limit_calls_enter();
   m_success = false;
 }
 
 COMXTexture::~COMXTexture()
 {
   Close();
-  limit_calls_leave();
+  if (m_gpu)
+    limit_calls_leave();
 }
 
 void COMXTexture::Close()
@@ -2134,6 +2163,9 @@ bool COMXTexture::HandlePortSettingChange(unsigned int resize_width, unsigned in
 
 bool COMXTexture::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes, unsigned int width, unsigned int height, void *egl_image)
 {
+  if (!m_gpu)
+    return false;
+
   CSingleLock lock(m_OMXSection);
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
diff --git a/xbmc/cores/omxplayer/OMXImage.h b/xbmc/cores/omxplayer/OMXImage.h
index a93aa82..6f38dbc 100644
--- a/xbmc/cores/omxplayer/OMXImage.h
+++ b/xbmc/cores/omxplayer/OMXImage.h
@@ -133,6 +133,7 @@ protected:
   OMX_PARAM_PORTDEFINITIONTYPE  m_decoded_format;
   CCriticalSection              m_OMXSection;
   bool                          m_success;
+  bool                          m_gpu;
 };
 
 class COMXImageEnc
@@ -144,6 +145,7 @@ public:
   // Required overrides
   bool CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
       unsigned int format, unsigned int pitch, const std::string& destFile);
+  bool Gpu() { return m_gpu; }
 protected:
   bool Encode(unsigned char *buffer, int size, unsigned int width, unsigned int height, unsigned int pitch);
   // Components
@@ -152,6 +154,7 @@ protected:
   OMX_PARAM_PORTDEFINITIONTYPE  m_encoded_format;
   CCriticalSection              m_OMXSection;
   bool                          m_success;
+  bool                          m_gpu;
 };
 
 class COMXImageReEnc
@@ -163,6 +166,7 @@ public:
   // Required overrides
   void Close();
   bool ReEncode(COMXImageFile &srcFile, unsigned int width, unsigned int height, void * &pDestBuffer, unsigned int &nDestSize);
+  bool Gpu() { return m_gpu; }
 protected:
   bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, int orientation, bool port_settings_changed);
   // Components
@@ -176,6 +180,7 @@ protected:
   void                          *m_pDestBuffer;
   unsigned int                  m_nDestAllocSize;
   bool                          m_success;
+  bool                          m_gpu;
 };
 
 class COMXTexture
@@ -187,6 +192,7 @@ public:
   // Required overrides
   void Close(void);
   bool Decode(const uint8_t *data, unsigned size, unsigned int width, unsigned int height, void *egl_image);
+  bool Gpu() { return m_gpu; }
 protected:
   bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, void *egl_image, bool port_settings_changed);
 
@@ -201,6 +207,7 @@ protected:
   OMX_BUFFERHEADERTYPE *m_egl_buffer;
   CCriticalSection              m_OMXSection;
   bool              m_success;
+  bool              m_gpu;
 };
 
 extern COMXImage g_OMXImage;
-- 
2.7.4


From 0d7c81a8a120ddb8400addfc915713455215eb02 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 9 Dec 2015 13:31:14 +0000
Subject: [PATCH 135/175] Fail to open when width is invalid. Can happen with
 mpegts files

---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
index aa20f18..cead68b 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
@@ -368,6 +368,9 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s usemmal:%d software:%d %dx%d renderer:%p", CLASSNAME, __func__, CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_USEMMAL), hints.software, hints.width, hints.height, options.m_opaque_pointer);
 
+  // This occurs at start of m2ts files before streams have been fully identified - just ignore
+  if (!hints.width)
+    return false;
   // we always qualify even if DVDFactoryCodec does this too.
   if (!CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_USEMMAL) || hints.software)
     return false;
-- 
2.7.4


From 8dbba22de7473a5a6c73f1c36436fcb13dbbdf51 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 12 Jan 2016 16:29:57 +0000
Subject: [PATCH 136/175] ffmpeg: Add cabac opimisations for hevc

---
 .../0001-Squashed-commit-of-the-following.patch    | 2179 ++++++++++++++++++++
 tools/depends/target/ffmpeg/Makefile               |    5 +-
 tools/depends/target/ffmpeg/autobuild.sh           |    1 +
 3 files changed, 2184 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/0001-Squashed-commit-of-the-following.patch

diff --git a/tools/depends/target/ffmpeg/0001-Squashed-commit-of-the-following.patch b/tools/depends/target/ffmpeg/0001-Squashed-commit-of-the-following.patch
new file mode 100644
index 0000000..38554af
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0001-Squashed-commit-of-the-following.patch
@@ -0,0 +1,2179 @@
+From d08594462136274636c1f2f476a6410ff92a9e16 Mon Sep 17 00:00:00 2001
+From: John Cox <jc@kynesim.co.uk>
+Date: Wed, 13 Jan 2016 16:13:33 +0000
+Subject: [PATCH] H.265 residual decode rework (v2)
+
+Rework the cabac decode functions
+Simplify the code flow and variable usage where possible
+
+(Remove profiling and other spurious deltas that were in v1)
+---
+ libavcodec/arm/cabac.h                |  155 ++++-
+ libavcodec/arm/hevc_cabac.h           |  491 +++++++++++++++
+ libavcodec/arm/hevcdsp_deblock_neon.S |   13 +-
+ libavcodec/arm/hevcdsp_epel_neon.S    |    9 +-
+ libavcodec/cabac.h                    |    9 +-
+ libavcodec/hevc_cabac.c               | 1096 +++++++++++++++++++++++++--------
+ 6 files changed, 1509 insertions(+), 264 deletions(-)
+ create mode 100644 libavcodec/arm/hevc_cabac.h
+
+diff --git a/libavcodec/arm/cabac.h b/libavcodec/arm/cabac.h
+index fdbf86b..0a3980a 100644
+--- a/libavcodec/arm/cabac.h
++++ b/libavcodec/arm/cabac.h
+@@ -26,13 +26,34 @@
+ #include "libavutil/internal.h"
+ #include "libavcodec/cabac.h"
+ 
++
++#if UNCHECKED_BITSTREAM_READER
++#define LOAD_16BITS_BEHI\
++        "ldrh       %[tmp]        , [%[ptr]]    , #2            \n\t"\
++        "rev        %[tmp]        , %[tmp]                      \n\t"
++#elif CONFIG_THUMB
++#define LOAD_16BITS_BEHI\
++        "ldr        %[tmp]        , [%[c], %[end]]              \n\t"\
++        "cmp        %[tmp]        , %[ptr]                      \n\t"\
++        "it         cs                                          \n\t"\
++        "ldrhcs     %[tmp]        , [%[ptr]]    , #2            \n\t"\
++        "rev        %[tmp]        , %[tmp]                      \n\t"
++#else
++#define LOAD_16BITS_BEHI\
++        "ldr        %[tmp]        , [%[c], %[end]]              \n\t"\
++        "cmp        %[tmp]        , %[ptr]                      \n\t"\
++        "ldrcsh     %[tmp]        , [%[ptr]]    , #2            \n\t"\
++        "rev        %[tmp]        , %[tmp]                      \n\t"
++#endif
++
++
+ #define get_cabac_inline get_cabac_inline_arm
+ static av_always_inline int get_cabac_inline_arm(CABACContext *c,
+                                                  uint8_t *const state)
+ {
+     int bit;
++#if 0
+     void *reg_b, *reg_c, *tmp;
+-
+     __asm__ volatile(
+         "ldrb       %[bit]        , [%[state]]                  \n\t"
+         "add        %[r_b]        , %[tables]   , %[lps_off]    \n\t"
+@@ -100,9 +121,141 @@ static av_always_inline int get_cabac_inline_arm(CABACContext *c,
+           [mlps_off]"I"(H264_MLPS_STATE_OFFSET + 128)
+         : "memory", "cc"
+         );
++#else
++   // *** Not thumb compatible yet
++   unsigned int reg_b, tmp;
++    __asm__ (
++        "ldrb       %[bit]        , [%[state]]                  \n\t"
++        "sub        %[r_b]        , %[mlps_tables], %[lps_off]  \n\t"
++        "and        %[tmp]        , %[range]    , #0xC0         \n\t"
++        "add        %[r_b]        , %[r_b]      , %[bit]        \n\t"
++        "ldrb       %[tmp]        , [%[r_b]     , %[tmp], lsl #1] \n\t"
++// %bit = *state
++// %range = range
++// %tmp = RangeLPS
++        "sub        %[range]      , %[range]    , %[tmp]        \n\t"
++
++        "cmp        %[low]        , %[range]    , lsl #17       \n\t"
++        "ittt       ge                                          \n\t"
++        "subge      %[low]        , %[low]      , %[range], lsl #17 \n\t"
++        "mvnge      %[bit]        , %[bit]                      \n\t"
++        "movge      %[range]      , %[tmp]                      \n\t"
++
++        "clz        %[tmp]        , %[range]                    \n\t"
++        "sub        %[tmp]        , #23                         \n\t"
++
++        "ldrb       %[r_b]        , [%[mlps_tables], %[bit]]    \n\t"
++        "lsl        %[low]        , %[low]      , %[tmp]        \n\t"
++        "lsl        %[range]      , %[range]    , %[tmp]        \n\t"
++
++        "strb       %[r_b]        , [%[state]]                  \n\t"
++        "lsls       %[tmp]        , %[low]      , #16           \n\t"
++
++        "bne        2f                                          \n\t"
++        LOAD_16BITS_BEHI
++        "lsr        %[tmp]        , %[tmp]      , #15           \n\t"
++        "movw       %[r_b]        , #0xFFFF                     \n\t"
++        "sub        %[tmp]        , %[tmp]      , %[r_b]        \n\t"
++
++        "rbit       %[r_b]        , %[low]                      \n\t"
++        "clz        %[r_b]        , %[r_b]                      \n\t"
++        "sub        %[r_b]        , %[r_b]      , #16           \n\t"
++#if CONFIG_THUMB
++        "lsl        %[tmp]        , %[tmp]      , %[r_b]        \n\t"
++        "add        %[low]        , %[low]      , %[tmp]        \n\t"
++#else
++        "add        %[low]        , %[low]      , %[tmp], lsl %[r_b] \n\t"
++#endif
++        "2:                                                     \n\t"
++        :    [bit]"=&r"(bit),
++             [low]"+&r"(c->low),
++           [range]"+&r"(c->range),
++             [r_b]"=&r"(reg_b),
++             [ptr]"+&r"(c->bytestream),
++             [tmp]"=&r"(tmp)
++          :  [state]"r"(state),
++            [mlps_tables]"r"(ff_h264_cabac_tables + H264_MLPS_STATE_OFFSET + 128),
++              [byte]"M"(offsetof(CABACContext, bytestream)),
++#if !UNCHECKED_BITSTREAM_READER
++                 [c]"r"(c),
++               [end]"M"(offsetof(CABACContext, bytestream_end)),
++#endif
++           [lps_off]"I"((H264_MLPS_STATE_OFFSET + 128) - H264_LPS_RANGE_OFFSET)
++        : "memory", "cc"
++        );
++#endif
+ 
+     return bit & 1;
+ }
++
++#define get_cabac_bypass get_cabac_bypass_arm
++static inline int get_cabac_bypass_arm(CABACContext * const c)
++{
++    int rv = 0;
++    unsigned int tmp;
++    __asm (
++        "lsl        %[low]        , #1                          \n\t"
++        "cmp        %[low]        , %[range]    , lsl #17       \n\t"
++        "adc        %[rv]         , %[rv]       , #0            \n\t"
++        "it         cs                                          \n\t"
++        "subcs      %[low]        , %[low]      , %[range], lsl #17 \n\t"
++        "lsls       %[tmp]        , %[low]      , #16           \n\t"
++        "bne        1f                                          \n\t"
++        LOAD_16BITS_BEHI
++        "add        %[low]        , %[low]      , %[tmp], lsr #15 \n\t"
++        "movw       %[tmp]        , #0xFFFF                     \n\t"
++        "sub        %[low]        , %[low]      , %[tmp]        \n\t"
++        "1:                                                     \n\t"
++        : // Outputs
++              [rv]"+&r"(rv),
++             [low]"+&r"(c->low),
++             [tmp]"=&r"(tmp),
++             [ptr]"+&r"(c->bytestream)
++        : // Inputs
++#if !UNCHECKED_BITSTREAM_READER
++                 [c]"r"(c),
++               [end]"M"(offsetof(CABACContext, bytestream_end)),
++#endif
++             [range]"r"(c->range)
++        : "cc"
++    );
++    return rv;
++}
++
++
++#define get_cabac_bypass_sign get_cabac_bypass_sign_arm
++static inline int get_cabac_bypass_sign_arm(CABACContext * const c, int rv)
++{
++    unsigned int tmp;
++    __asm (
++        "lsl        %[low]        , #1                          \n\t"
++        "cmp        %[low]        , %[range]    , lsl #17       \n\t"
++        "ite        cc                                          \n\t"
++        "rsbcc      %[rv]         , %[rv]       , #0            \n\t"
++        "subcs      %[low]        , %[low]      , %[range], lsl #17 \n\t"
++        "lsls       %[tmp]        , %[low]      , #16           \n\t"
++        "bne        1f                                          \n\t"
++        LOAD_16BITS_BEHI
++        "add        %[low]        , %[low]      , %[tmp], lsr #15 \n\t"
++        "movw       %[tmp]        , #0xFFFF                     \n\t"
++        "sub        %[low]        , %[low]      , %[tmp]        \n\t"
++        "1:                                                     \n\t"
++        : // Outputs
++              [rv]"+&r"(rv),
++             [low]"+&r"(c->low),
++             [tmp]"=&r"(tmp),
++             [ptr]"+&r"(c->bytestream)
++        : // Inputs
++#if !UNCHECKED_BITSTREAM_READER
++                 [c]"r"(c),
++               [end]"M"(offsetof(CABACContext, bytestream_end)),
++#endif
++             [range]"r"(c->range)
++        : "cc"
++    );
++    return rv;
++}
++
+ #endif /* HAVE_ARMV6T2_INLINE */
+ 
+ #endif /* AVCODEC_ARM_CABAC_H */
+diff --git a/libavcodec/arm/hevc_cabac.h b/libavcodec/arm/hevc_cabac.h
+new file mode 100644
+index 0000000..31d3c59
+--- /dev/null
++++ b/libavcodec/arm/hevc_cabac.h
+@@ -0,0 +1,491 @@
++/*
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++#ifndef AVCODEC_ARM_HEVC_CABAC_H
++#define AVCODEC_ARM_HEVC_CABAC_H
++
++#include "config.h"
++#if HAVE_ARMV6T2_INLINE
++
++#define hevc_mem_bits32 hevc_mem_bits32_arm
++static inline uint32_t hevc_mem_bits32_arm(const void * p, const unsigned int bits)
++{
++    unsigned int n;
++    __asm__ (
++        "rev        %[n], %[x]                     \n\t"
++        : [n]"=r"(n)
++        : [x]"r"(*(const uint32_t *)((const uint8_t *)p + (bits >> 3)))
++        :
++        );
++    return n << (bits & 7);
++}
++
++
++// ---------------------------------------------------------------------------
++//
++// Helper fns - little bits of code where ARM has an instraction that the
++// compiler doesn't know about / use
++
++#define trans_scale_sat trans_scale_sat_arm
++static inline int trans_scale_sat_arm(const int level, const unsigned int scale, const unsigned int scale_m, const unsigned int shift)
++{
++    int rv;
++    int t = ((level * (int)(scale * scale_m)) >> shift) + 1;
++
++    __asm__ (
++    "ssat %[rv], #16, %[t], ASR #1 \n\t"
++    : [rv]"=r"(rv)
++    : [t]"r"(t)
++    :
++    );
++    return rv;
++}
++
++#define update_rice update_rice_arm
++static inline void update_rice_arm(uint8_t * const stat_coeff,
++    const unsigned int last_coeff_abs_level_remaining,
++    const unsigned int c_rice_param)
++{
++    int t;
++    __asm__ (
++    "lsl   %[t], %[coeff], #1               \n\t"
++    "lsrs  %[t], %[t], %[shift]             \n\t"
++    "it    eq                               \n\t"
++    "subeq %[stat], %[stat], #1             \n\t"
++    "cmp   %[t], #6                         \n\t"
++    "adc   %[stat], %[stat], #0             \n\t"
++    "usat  %[stat], #8, %[stat]             \n\t"
++    : [stat]"+&r"(*stat_coeff),
++         [t]"=&r"(t)
++    :  [coeff]"r"(last_coeff_abs_level_remaining),
++       [shift]"r"(c_rice_param)
++    : "cc"
++    );
++}
++
++// ---------------------------------------------------------------------------
++//
++// CABAC get loops
++//
++// Where the loop is simple enough we can normally do 10-30% better than the
++// compiler
++
++// Get the residual greater than 1 bits
++
++#define get_cabac_greater1_bits get_cabac_greater1_bits_arm
++static inline unsigned int get_cabac_greater1_bits_arm(CABACContext * const c, const unsigned int n,
++    uint8_t * const state0)
++{
++    unsigned int i, reg_b, st, tmp, bit, rv;
++     __asm__ (
++         "mov        %[i]          , #0                          \n\t"
++         "mov        %[rv]         , #0                          \n\t"
++         "1:                                                     \n\t"
++         "add        %[i]          , %[i]        , #1            \n\t"
++         "cmp        %[rv]         , #0                          \n\t"
++         "ite        eq                                          \n\t"
++         "usateq     %[st]         , #2          , %[i]          \n\t"
++         "movne      %[st]         , #0                          \n\t"
++
++         "ldrb       %[bit]        , [%[state0], %[st]]          \n\t"
++         "sub        %[r_b]        , %[mlps_tables], %[lps_off]  \n\t"
++         "and        %[tmp]        , %[range]    , #0xC0         \n\t"
++         "add        %[r_b]        , %[r_b]      , %[bit]        \n\t"
++         "ldrb       %[tmp]        , [%[r_b], %[tmp], lsl #1]    \n\t"
++         "sub        %[range]      , %[range]    , %[tmp]        \n\t"
++
++         "cmp        %[low]        , %[range], lsl #17           \n\t"
++         "ittt       ge                                          \n\t"
++         "subge      %[low]        , %[low]      , %[range], lsl #17 \n\t"
++         "mvnge      %[bit]        , %[bit]                      \n\t"
++         "movge      %[range]      , %[tmp]                      \n\t"
++
++         "ldrb       %[r_b]        , [%[mlps_tables], %[bit]]    \n\t"
++         "and        %[bit]        , %[bit]      , #1            \n\t"
++         "orr        %[rv]         , %[bit]      , %[rv], lsl #1 \n\t"
++
++         "clz        %[tmp]        , %[range]                    \n\t"
++         "sub        %[tmp]        , #23                         \n\t"
++
++         "lsl        %[low]        , %[low]      , %[tmp]        \n\t"
++         "lsl        %[range]      , %[range]    , %[tmp]        \n\t"
++
++         "strb       %[r_b]        , [%[state0], %[st]]          \n\t"
++// There is a small speed gain from combining both conditions, using a single
++// branch and then working out what that meant later
++         "lsls       %[tmp]        , %[low]      , #16           \n\t"
++         "it         ne                                          \n\t"
++         "cmpne      %[n]          , %[i]                        \n\t"
++         "bne        1b                                          \n\t"
++
++// If reload is not required then we must have run out of flags to decode
++         "tst        %[tmp]        , %[tmp]                      \n\t"
++         "bne        2f                                          \n\t"
++
++// Do reload
++         "ldrh       %[tmp]        , [%[bptr]]   , #2            \n\t"
++         "movw       %[r_b]        , #0xFFFF                     \n\t"
++         "rev        %[tmp]        , %[tmp]                      \n\t"
++         "rsb        %[tmp]        , %[r_b]      , %[tmp], lsr #15 \n\t"
++
++         "rbit       %[r_b]        , %[low]                      \n\t"
++         "clz        %[r_b]        , %[r_b]                      \n\t"
++         "sub        %[r_b]        , %[r_b]      , #16           \n\t"
++
++#if CONFIG_THUMB
++         "lsl        %[tmp]        , %[tmp]      , %[r_b]        \n\t"
++         "add        %[low]        , %[low]      , %[tmp]        \n\t"
++#else
++         "add        %[low]        , %[low]      , %[tmp], lsl %[r_b] \n\t"
++#endif
++
++         "cmp        %[n]          , %[i]                        \n\t"
++         "bne        1b                                          \n\t"
++         "2:                                                     \n\t"
++         :    [bit]"=&r"(bit),
++              [low]"+&r"(c->low),
++            [range]"+&r"(c->range),
++              [r_b]"=&r"(reg_b),
++             [bptr]"+&r"(c->bytestream),
++                [i]"=&r"(i),
++              [tmp]"=&r"(tmp),
++               [st]"=&r"(st),
++               [rv]"=&r"(rv)
++          :  [state0]"r"(state0),
++                  [n]"r"(n),
++        [mlps_tables]"r"(ff_h264_cabac_tables + H264_MLPS_STATE_OFFSET + 128),
++               [byte]"M"(offsetof(CABACContext, bytestream)),
++            [lps_off]"I"((H264_MLPS_STATE_OFFSET + 128) - H264_LPS_RANGE_OFFSET)
++         : "memory", "cc"
++    );
++    return rv;
++}
++
++
++// n must be > 0 on entry
++#define get_cabac_sig_coeff_flag_idxs get_cabac_sig_coeff_flag_idxs_arm
++static inline uint8_t * get_cabac_sig_coeff_flag_idxs_arm(CABACContext * const c, uint8_t * const state0,
++    unsigned int n,
++    const uint8_t const * ctx_map,
++    uint8_t * p)
++{
++    unsigned int reg_b, tmp, st, bit;
++     __asm__ (
++         "1:                                                     \n\t"
++// Get bin from map
++         "ldrb       %[st]         , [%[ctx_map], %[n]]          \n\t"
++
++// Load state & ranges
++         "sub        %[r_b]        , %[mlps_tables], %[lps_off]  \n\t"
++         "ldrb       %[bit]        , [%[state0], %[st]]          \n\t"
++         "and        %[tmp]        , %[range]    , #0xC0         \n\t"
++         "add        %[r_b]        , %[r_b]      , %[tmp], lsl #1 \n\t"
++         "ldrb       %[tmp]        , [%[r_b], %[bit]]            \n\t"
++         "sub        %[range]      , %[range]    , %[tmp]        \n\t"
++
++         "cmp        %[low]        , %[range], lsl #17           \n\t"
++         "ittt       ge                                          \n\t"
++         "subge      %[low]        , %[low]      , %[range], lsl #17 \n\t"
++         "mvnge      %[bit]        , %[bit]                      \n\t"
++         "movge      %[range]      , %[tmp]                      \n\t"
++
++         "ldrb       %[r_b]        , [%[mlps_tables], %[bit]]    \n\t"
++         "tst        %[bit]        , #1                          \n\t"
++// GCC asm seems to need strbne written differently for thumb and arm
++#if CONFIG_THUMB
++         "it         ne                                          \n\t"
++         "strbne     %[n]          , [%[idx]]    , #1            \n\t"
++#else
++         "strneb     %[n]          , [%[idx]]    , #1            \n\t"
++#endif
++
++// Renorm
++         "clz        %[tmp]        , %[range]                    \n\t"
++         "sub        %[tmp]        , #23                         \n\t"
++         "lsl        %[low]        , %[low]      , %[tmp]        \n\t"
++         "lsl        %[range]      , %[range]    , %[tmp]        \n\t"
++
++         "strb       %[r_b]        , [%[state0], %[st]]          \n\t"
++// There is a small speed gain from combining both conditions, using a single
++// branch and then working out what that meant later
++         "subs       %[n]          , %[n]        , #1            \n\t"
++#if CONFIG_THUMB
++         "itt        ne                                          \n\t"
++         "lslsne     %[tmp]        , %[low]      , #16           \n\t"
++         "bne        1b                                          \n\t"
++#else
++         "lslnes     %[tmp]        , %[low]      , #16           \n\t"
++         "bne        1b                                          \n\t"
++#endif
++
++// If we have bits left then n must be 0 so give up now
++         "lsls       %[tmp]        , %[low]      , #16           \n\t"
++         "bne        2f                                          \n\t"
++
++// Do reload
++         "ldrh       %[tmp]        , [%[bptr]]   , #2            \n\t"
++         "movw       %[r_b]        , #0xFFFF                     \n\t"
++         "rev        %[tmp]        , %[tmp]                      \n\t"
++         "rsb        %[tmp]        , %[r_b]      , %[tmp], lsr #15 \n\t"
++
++         "rbit       %[r_b]        , %[low]                      \n\t"
++         "clz        %[r_b]        , %[r_b]                      \n\t"
++         "sub        %[r_b]        , %[r_b]      , #16           \n\t"
++
++#if CONFIG_THUMB
++         "lsl        %[tmp]        , %[tmp]      , %[r_b]        \n\t"
++         "add        %[low]        , %[low]      , %[tmp]        \n\t"
++#else
++         "add        %[low]        , %[low]      , %[tmp], lsl %[r_b] \n\t"
++#endif
++
++// Check to see if we still have more to do
++         "cmp        %[n]          , #0                          \n\t"
++         "bne        1b                                          \n\t"
++         "2:                                                     \n\t"
++         :    [bit]"=&r"(bit),
++              [low]"+&r"(c->low),
++            [range]"+&r"(c->range),
++              [r_b]"=&r"(reg_b),
++             [bptr]"+&r"(c->bytestream),
++              [idx]"+&r"(p),
++                [n]"+&r"(n),
++              [tmp]"=&r"(tmp),
++               [st]"=&r"(st)
++          :  [state0]"r"(state0),
++            [ctx_map]"r"(ctx_map),
++        [mlps_tables]"r"(ff_h264_cabac_tables + H264_MLPS_STATE_OFFSET + 128),
++               [byte]"M"(offsetof(CABACContext, bytestream)),
++            [lps_off]"I"((H264_MLPS_STATE_OFFSET + 128) - H264_LPS_RANGE_OFFSET)
++         : "memory", "cc"
++    );
++
++    return p;
++}
++
++// ---------------------------------------------------------------------------
++//
++// CABAC_BY22 functions
++//
++// By and large these are (at best) no faster than their C equivalents - the
++// only one worth having is _peek where we do a slightly better job than the
++// compiler
++//
++// The others have been stashed here for reference in case larger scale asm
++// is attempted in which case they might be a useful base
++
++
++#define get_cabac_by22_peek get_cabac_by22_peek_arm
++static inline uint32_t get_cabac_by22_peek_arm(const CABACContext *const c)
++{
++    uint32_t rv, tmp;
++    __asm__ (
++        "bic      %[rv]  , %[low], #1            \n\t"
++        "cmp      %[inv] , #0                    \n\t"
++        "it       ne                             \n\t"
++        "umullne  %[tmp] , %[rv] , %[inv], %[rv] \n\t"
++        :  // Outputs
++             [rv]"=&r"(rv),
++             [tmp]"=r"(tmp)
++        :  // Inputs
++             [low]"r"(c->low),
++             [inv]"r"(c->range)
++        :  // Clobbers
++                "cc"
++    );
++    return rv << 1;
++}
++
++#if 0
++
++// ***** Slower than the C  :-(
++#define get_cabac_by22_flush get_cabac_by22_flush_arm
++static inline void get_cabac_by22_flush_arm(CABACContext *const c, const unsigned int n, const uint32_t val)
++{
++    uint32_t m, tmp;
++    __asm__ (
++    "add    %[bits], %[bits], %[n]   \n\t"
++    "ldr    %[m], [%[ptr], %[bits], lsr #3]  \n\t"
++
++    "rsb    %[tmp], %[n], #32        \n\t"
++    "lsr    %[tmp], %[val], %[tmp]   \n\t"
++    "mul    %[tmp], %[range], %[tmp] \n\t"
++
++    "rev    %[m], %[m]               \n\t"
++
++    "lsl    %[tmp], %[tmp], #23      \n\t"
++    "rsb    %[low], %[tmp], %[low], lsl %[n] \n\t"
++
++    "and    %[tmp], %[bits], #7         \n\t"
++    "lsl    %[m], %[m], %[tmp]          \n\t"
++
++    "orr    %[low], %[low], %[m], lsr #9      \n\t"
++        :  // Outputs
++             [m]"=&r"(m),
++           [tmp]"=&r"(tmp),
++          [bits]"+&r"(c->by22.bits),
++           [low]"+&r"(c->low)
++        :  // Inputs
++               [n]"r"(n),
++             [val]"r"(val),
++             [inv]"r"(c->range),
++           [range]"r"(c->by22.range),
++             [ptr]"r"(c->bytestream)
++        :  // Clobbers
++    );
++}
++
++
++// Works but slower than C
++#define coeff_abs_level_remaining_decode_by22(c,r) coeff_abs_level_remaining_decode_by22_arm(c, r)
++static int coeff_abs_level_remaining_decode_by22_arm(CABACContext * const c, const unsigned int c_rice_param)
++{
++    uint32_t n, val, tmp, level;
++
++//    PROFILE_START();
++
++    __asm__ (
++            // Peek
++            "bic    %[val],  %[low],   #1  \n\t"
++            "cmp    %[inv], #0          \n\t"
++            "umullne  %[tmp], %[val], %[inv], %[val] \n\t"
++            "lsl    %[val], %[val], #1  \n\t"
++
++            // Count bits (n = prefix)
++            "mvn    %[n], %[val] \n\t"
++            "clz    %[n], %[n]   \n\t"
++
++            "lsl    %[level], %[val], %[n] \n\t"
++            "subs   %[tmp], %[n], #3 \n\t"
++            "blo    2f \n\t"
++
++            // prefix >= 3
++            // < tmp = prefix - 3
++            // > tmp = prefix + rice - 3
++            "add    %[tmp], %[tmp], %[rice] \n\t"
++            // > n = prefix * 2 + rice - 3
++            "add    %[n], %[tmp], %[n] \n\t"
++            "cmp    %[n], #21 \n\t"
++            "bhi    3f \n\t"
++
++            "orr    %[level], %[level], #0x80000000 \n\t"
++            "rsb    %[tmp], %[tmp], #31 \n\t"
++            "lsr    %[level], %[level], %[tmp] \n\t"
++
++            "mov    %[tmp], #2 \n\t"
++            "add    %[level], %[level], %[tmp], lsl %[rice] \n\t"
++            "b      1f \n\t"
++
++            // > 22 bits used in total - need reload
++            "3:  \n\t"
++
++            // Stash prefix + rice - 3 in level (only spare reg)
++            "mov    %[level], %[tmp] \n\t"
++            // Restore n to flush value (prefix)
++            "sub    %[n], %[n], %[tmp] \n\t"
++
++            // Flush + reload
++
++//          "rsb    %[tmp], %[n], #32        \n\t"
++//          "lsr    %[tmp], %[val], %[tmp]   \n\t"
++//          "mul    %[tmp], %[range], %[tmp] \n\t"
++
++            // As it happens we know that all the bits we are flushing are 1
++            // so we can cheat slightly
++            "rsb    %[tmp], %[range], %[range], lsl %[n] \n\t"
++            "lsl    %[tmp], %[tmp], #23      \n\t"
++            "rsb    %[low], %[tmp], %[low], lsl %[n] \n\t"
++
++            "add    %[bits], %[bits], %[n]   \n\t"
++            "ldr    %[n], [%[ptr], %[bits], lsr #3]  \n\t"
++            "rev    %[n], %[n]               \n\t"
++            "and    %[tmp], %[bits], #7         \n\t"
++            "lsl    %[n], %[n], %[tmp]          \n\t"
++
++            "orr    %[low], %[low], %[n], lsr #9      \n\t"
++
++            // (reload)
++
++            "bic    %[val],  %[low],   #1  \n\t"
++            "cmp    %[inv], #0          \n\t"
++            "umullne  %[tmp], %[val], %[inv], %[val] \n\t"
++            "lsl    %[val], %[val], #1  \n\t"
++
++            // Build value
++
++            "mov    %[n], %[level] \n\t"
++
++            "orr     %[tmp], %[val], #0x80000000 \n\t"
++            "rsb     %[level], %[level], #31 \n\t"
++            "lsr     %[level], %[tmp], %[level] \n\t"
++
++            "mov    %[tmp], #2 \n\t"
++            "add    %[level], %[level], %[tmp], lsl %[rice] \n\t"
++            "b      1f \n\t"
++
++            // prefix < 3
++            "2:  \n\t"
++            "rsb    %[tmp], %[rice], #31 \n\t"
++            "lsr    %[level], %[level], %[tmp] \n\t"
++            "orr    %[level], %[level], %[n], lsl %[rice] \n\t"
++            "add    %[n], %[n], %[rice] \n\t"
++
++            "1:  \n\t"
++            // Flush
++            "add    %[n], %[n], #1 \n\t"
++
++            "rsb    %[tmp], %[n], #32        \n\t"
++            "lsr    %[tmp], %[val], %[tmp]   \n\t"
++
++            "add    %[bits], %[bits], %[n]   \n\t"
++            "ldr    %[val], [%[ptr], %[bits], lsr #3]  \n\t"
++
++            "mul    %[tmp], %[range], %[tmp] \n\t"
++            "lsl    %[tmp], %[tmp], #23      \n\t"
++            "rsb    %[low], %[tmp], %[low], lsl %[n] \n\t"
++
++            "rev    %[val], %[val]               \n\t"
++            "and    %[tmp], %[bits], #7         \n\t"
++            "lsl    %[val], %[val], %[tmp]          \n\t"
++
++            "orr    %[low], %[low], %[val], lsr #9      \n\t"
++        :  // Outputs
++         [level]"=&r"(level),
++             [n]"=&r"(n),
++           [val]"=&r"(val),
++           [tmp]"=&r"(tmp),
++          [bits]"+&r"(c->by22.bits),
++           [low]"+&r"(c->low)
++        :  // Inputs
++            [rice]"r"(c_rice_param),
++             [inv]"r"(c->range),
++           [range]"r"(c->by22.range),
++             [ptr]"r"(c->bytestream)
++        :  // Clobbers
++                "cc"
++    );
++
++//    PROFILE_ACC(residual_abs);
++
++    return level;
++}
++#endif
++
++#endif /* HAVE_ARMV6T2_INLINE */
++
++#endif /* AVCODEC_ARM_HEVC_CABAC_H */
+diff --git a/libavcodec/arm/hevcdsp_deblock_neon.S b/libavcodec/arm/hevcdsp_deblock_neon.S
+index bad4589..a088cc3 100644
+--- a/libavcodec/arm/hevcdsp_deblock_neon.S
++++ b/libavcodec/arm/hevcdsp_deblock_neon.S
+@@ -409,10 +409,12 @@ function ff_hevc_deblocking_boundary_strengths_neon, export=1
+         beq         90f
+ 
+         tst         a3, #1
++        itee        ne
+         ldrne       a3, [v5, #0]    @ curr->mv[0]
+         ldreq       a3, [v5, #4]    @ curr->mv[1]
+         moveq       v1, v2
+         tst         v8, #1
++        itee        ne
+         ldrne       v8, [v6, #0]    @ neigh->mv[0]
+         ldreq       v8, [v6, #4]    @ neigh->mv[1]
+         moveq       v3, v4
+@@ -424,9 +426,14 @@ function ff_hevc_deblocking_boundary_strengths_neon, export=1
+         sel         a3, a3, ip
+         ands        a3, a3, lr
+         @ drop through
+-10:     movne       a3, #1
++10:     it          ne
++        movne       a3, #1
+ 11:     subs        a2, a2, #1
+-12:     strbhs      a3, [v7], a4
++12:
++A       strbhs      a3, [v7], a4
++T       itt         hs
++T       strbhs      a3, [v7]
++T       addhs       v7, v7, a4
+         subs        a2, a2, #1
+         bhs         12b
+ 
+@@ -442,6 +449,7 @@ function ff_hevc_deblocking_boundary_strengths_neon, export=1
+         bne         10b
+ 
+         teq         v1, v3
++        it          eq
+         teqeq       v2, v4
+         bne         40f
+         teq         v1, v2
+@@ -487,6 +495,7 @@ function ff_hevc_deblocking_boundary_strengths_neon, export=1
+         b           10b
+ 
+ 40:     teq         v1, v4
++        ite         eq
+         teqeq       v2, v3
+         bne         10b
+ 
+diff --git a/libavcodec/arm/hevcdsp_epel_neon.S b/libavcodec/arm/hevcdsp_epel_neon.S
+index 516ae5b..00eab9e 100644
+--- a/libavcodec/arm/hevcdsp_epel_neon.S
++++ b/libavcodec/arm/hevcdsp_epel_neon.S
+@@ -110,7 +110,9 @@ function ff_hevc_put_epel_h_neon_8, export=1
+         sub    r7, #1
+         lsl    r7, #2
+         vpush {d8-d15}
+-        adrl   r12, epel_coeffs
++@ adr reaches if we are in thumb mode but not in arm
++T       adr    r12, epel_coeffs
++A       adrl   r12, epel_coeffs
+         add    r7, r12
+         sub       r1, #1
+         lsl       r4, #1
+@@ -170,7 +172,8 @@ function ff_hevc_put_epel_v_neon_8, export=1
+         sub    r7, #1
+         lsl    r7, #2
+         vpush {d8-d15}
+-        adrl   r12, epel_coeffs
++T       adr    r12, epel_coeffs
++A       adrl   r12, epel_coeffs
+         add    r7, r12
+         load_coeffs_16b r7
+         sub       r1, r2
+@@ -246,7 +249,7 @@ function ff_hevc_put_epel_hv_neon_8, export=1
+         sub    r7, #1
+         lsl    r7, #2
+         vpush {d8-d15}
+-        adrl   r12, epel_coeffs
++        adr    r12, epel_coeffs
+         sub    r6, #1
+         lsl    r6, #2
+         add    r6, r12 // mx epel coeff offset
+diff --git a/libavcodec/cabac.h b/libavcodec/cabac.h
+index 1bf1c62..ccfa991 100644
+--- a/libavcodec/cabac.h
++++ b/libavcodec/cabac.h
+@@ -43,7 +43,14 @@ extern const uint8_t ff_h264_cabac_tables[512 + 4*2*64 + 4*64 + 63];
+ typedef struct CABACContext{
+     int low;
+     int range;
+-    int outstanding_count;
++    union
++    {
++        int outstanding_count;
++        struct {
++            uint16_t bits;
++            uint16_t range;
++        } by22;
++    };
+     const uint8_t *bytestream_start;
+     const uint8_t *bytestream;
+     const uint8_t *bytestream_end;
+diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
+index 8656917..4caf720 100644
+--- a/libavcodec/hevc_cabac.c
++++ b/libavcodec/hevc_cabac.c
+@@ -21,14 +21,72 @@
+  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+  */
+ 
++#define UNCHECKED_BITSTREAM_READER 1
++
+ #include "libavutil/attributes.h"
+ #include "libavutil/common.h"
+ 
+-#include "cabac_functions.h"
+ #include "hevc.h"
++#include "cabac_functions.h"
++
++// BY22 is probably faster than simple bypass if the processor has
++// either a fast 32-bit divide or a fast 32x32->64[63:32] instruction
++// x86 has fast int divide
++// Arm doesn't have divide or general fast 64 bit, but does have the multiply
++// * Beware: ARCH_xxx isn't set if configure --disable-asm is used
++#define USE_BY22 (HAVE_FAST_64BIT || ARCH_ARM || ARCH_X86)
++// Use native divide if we have a fast one - otherwise use mpy 1/x
++// x86 has a fast integer divide - arm doesn't - unsure about other
++// architectures
++#define USE_BY22_DIV  ARCH_X86
++
++// Special case blocks with a single significant ceoff
++// Decreases the complexity of the code for a common case but increases the
++// code size.
++#define USE_N_END_1 1
++
++#if ARCH_ARM
++#include "arm/hevc_cabac.h"
++#endif
+ 
+ #define CABAC_MAX_BIN 31
+ 
++
++#if USE_BY22 && !USE_BY22_DIV
++#define I(x) (uint32_t)((0x10000000000ULL / (uint64_t)(x)) + 1ULL)
++
++static const uint32_t cabac_by22_inv_range[256] = {
++                                                    0,      I(257), I(258), I(259),
++    I(260), I(261), I(262), I(263), I(264), I(265), I(266), I(267), I(268), I(269),
++    I(270), I(271), I(272), I(273), I(274), I(275), I(276), I(277), I(278), I(279),
++    I(280), I(281), I(282), I(283), I(284), I(285), I(286), I(287), I(288), I(289),
++    I(290), I(291), I(292), I(293), I(294), I(295), I(296), I(297), I(298), I(299),
++    I(300), I(301), I(302), I(303), I(304), I(305), I(306), I(307), I(308), I(309),
++    I(310), I(311), I(312), I(313), I(314), I(315), I(316), I(317), I(318), I(319),
++    I(320), I(321), I(322), I(323), I(324), I(325), I(326), I(327), I(328), I(329),
++    I(330), I(331), I(332), I(333), I(334), I(335), I(336), I(337), I(338), I(339),
++    I(340), I(341), I(342), I(343), I(344), I(345), I(346), I(347), I(348), I(349),
++    I(350), I(351), I(352), I(353), I(354), I(355), I(356), I(357), I(358), I(359),
++    I(360), I(361), I(362), I(363), I(364), I(365), I(366), I(367), I(368), I(369),
++    I(370), I(371), I(372), I(373), I(374), I(375), I(376), I(377), I(378), I(379),
++    I(380), I(381), I(382), I(383), I(384), I(385), I(386), I(387), I(388), I(389),
++    I(390), I(391), I(392), I(393), I(394), I(395), I(396), I(397), I(398), I(399),
++    I(400), I(401), I(402), I(403), I(404), I(405), I(406), I(407), I(408), I(409),
++    I(410), I(411), I(412), I(413), I(414), I(415), I(416), I(417), I(418), I(419),
++    I(420), I(421), I(422), I(423), I(424), I(425), I(426), I(427), I(428), I(429),
++    I(430), I(431), I(432), I(433), I(434), I(435), I(436), I(437), I(438), I(439),
++    I(440), I(441), I(442), I(443), I(444), I(445), I(446), I(447), I(448), I(449),
++    I(450), I(451), I(452), I(453), I(454), I(455), I(456), I(457), I(458), I(459),
++    I(460), I(461), I(462), I(463), I(464), I(465), I(466), I(467), I(468), I(469),
++    I(470), I(471), I(472), I(473), I(474), I(475), I(476), I(477), I(478), I(479),
++    I(480), I(481), I(482), I(483), I(484), I(485), I(486), I(487), I(488), I(489),
++    I(490), I(491), I(492), I(493), I(494), I(495), I(496), I(497), I(498), I(499),
++    I(500), I(501), I(502), I(503), I(504), I(505), I(506), I(507), I(508), I(509),
++    I(510), I(511)
++};
++#undef I
++#endif  // USE_BY22
++
+ /**
+  * number of bin by SyntaxElement.
+  */
+@@ -445,6 +503,211 @@ static const uint8_t diag_scan8x8_inv[8][8] = {
+     { 28, 36, 43, 49, 54, 58, 61, 63, },
+ };
+ 
++
++typedef struct
++{
++    uint16_t coeff;
++    uint16_t scale;
++} xy_off_t;
++
++#define XYT_C(x,y,t) ((x) + ((y) << (t)))
++#define SCALE_TRAFO(t) ((t) > 3 ? 3 : (t))
++#define SCALE_SHR(t) ((t) - SCALE_TRAFO(t))
++#define XYT_S(x,y,t) (((x) >> SCALE_SHR(t)) + (((y) >> SCALE_SHR(t)) << SCALE_TRAFO(t)))
++
++#define XYT(x,y,t) {XYT_C(x,y,t), XYT_S(x,y,t)}
++
++#define OFF_DIAG(t) {\
++    XYT(0,0,t), XYT(0,1,t), XYT(1,0,t), XYT(0,2,t),\
++    XYT(1,1,t), XYT(2,0,t), XYT(0,3,t), XYT(1,2,t),\
++    XYT(2,1,t), XYT(3,0,t), XYT(1,3,t), XYT(2,2,t),\
++    XYT(3,1,t), XYT(2,3,t), XYT(3,2,t), XYT(3,3,t)\
++}
++
++#define OFF_HORIZ(t) {\
++    XYT(0,0,t), XYT(1,0,t), XYT(2,0,t), XYT(3,0,t),\
++    XYT(0,1,t), XYT(1,1,t), XYT(2,1,t), XYT(3,1,t),\
++    XYT(0,2,t), XYT(1,2,t), XYT(2,2,t), XYT(3,2,t),\
++    XYT(0,3,t), XYT(1,3,t), XYT(2,3,t), XYT(3,3,t)\
++}
++
++#define OFF_VERT(t) {\
++    XYT(0,0,t), XYT(0,1,t), XYT(0,2,t), XYT(0,3,t),\
++    XYT(1,0,t), XYT(1,1,t), XYT(1,2,t), XYT(1,3,t),\
++    XYT(2,0,t), XYT(2,1,t), XYT(2,2,t), XYT(2,3,t),\
++    XYT(3,0,t), XYT(3,1,t), XYT(3,2,t), XYT(3,3,t)\
++}
++
++static const xy_off_t off_xys[3][4][16] =
++{
++    {OFF_DIAG(2), OFF_DIAG(3), OFF_DIAG(4), OFF_DIAG(5)},
++    {OFF_HORIZ(2), OFF_HORIZ(3), OFF_HORIZ(4), OFF_HORIZ(5)},
++    {OFF_VERT(2), OFF_VERT(3), OFF_VERT(4), OFF_VERT(5)}
++};
++
++
++// Helper fns
++#ifndef hevc_mem_bits32
++static av_always_inline uint32_t hevc_mem_bits32(const void * buf, const unsigned int offset)
++{
++    return AV_RB32((const uint8_t *)buf + (offset >> 3)) << (offset & 7);
++}
++#endif
++
++#if AV_GCC_VERSION_AT_LEAST(3,4) && !defined(hevc_clz32)
++#define hevc_clz32 hevc_clz32_builtin
++static av_always_inline unsigned int hevc_clz32_builtin(const uint32_t x)
++{
++    // __builtin_clz says it works on ints - so adjust if int is >32 bits long
++    return __builtin_clz(x) - (sizeof(int) * 8 - 32);
++}
++#endif
++
++// It is unlikely that we will ever need this but include for completeness
++#ifndef hevc_clz32
++static inline unsigned int hevc_clz32(unsigned int x)
++{
++    unsigned int n = 1;
++    if ((x & 0xffff0000) == 0) {
++        n += 16;
++        x <<= 16;
++    }
++    if ((x & 0xff000000) == 0) {
++        n += 8;
++        x <<= 8;
++    }
++    if ((x & 0xf0000000) == 0) {
++        n += 4;
++        x <<= 4;
++    }
++    if ((x & 0xc0000000) == 0) {
++        n += 2;
++        x <<= 2;
++    }
++    return n - ((x >> 31) & 1);
++}
++#endif
++
++
++#if !USE_BY22
++// If no by22 then _by22 functions will revert to normal and so _peek/_flush
++// will no longer be called but the setup calls will still exist and we want
++// to null them out
++#define bypass_start(s)
++#define bypass_finish(s)
++#else
++// Use BY22 for residual bypass block
++
++#define bypass_start(s) get_cabac_by22_start(&s->HEVClc->cc)
++#define bypass_finish(s) get_cabac_by22_finish(&s->HEVClc->cc)
++
++// BY22 notes that bypass is simply a divide into the bitstream and so we
++// can peek out large quantities of bits at one and treat the result as if
++// it was VLC.  In many cases this will lead to O(1) processing rather than
++// O(n) though the setup and teardown is sufficiently expensive that it is
++// only worth using if we expect to be dealing with more than a few bits
++// The definition of "a few bits" will vary from platform to platform but
++// tests on ARM show that it probably isn't worth it for a single coded
++// residual, but is for >1 - this is probaly reinforced that if there are
++// more residuals then they are likely to be bigger and this will make the
++// O(1) nature of the code more worthwhile.
++
++
++#if !USE_BY22_DIV
++// * 1/x @ 32 bits gets us 22 bits of accuracy
++#define CABAC_BY22_PEEK_BITS  22
++#else
++// A real 32-bit divide gets us another bit
++// If we have a 64 bit int & a unit time divider then we should get a lot
++// of bits (55)  but that is untested and it is unclear if it would give
++// us a large advantage
++#define CABAC_BY22_PEEK_BITS  23
++#endif
++
++// Bypass block start
++// Must be called before _by22_peek is used as it sets the CABAC environment
++// into the correct state.  _by22_finish must be called to return to 'normal'
++// (i.e. non-bypass) cabac decoding
++static inline void get_cabac_by22_start(CABACContext * const c)
++{
++    const unsigned int bits = __builtin_ctz(c->low);
++    const uint32_t m = hevc_mem_bits32(c->bytestream, 0);
++    uint32_t x = (c->low << (22 - CABAC_BITS)) ^ ((m ^ 0x80000000U) >> (9 + CABAC_BITS - bits));
++#if !USE_BY22_DIV
++    const uint32_t inv = cabac_by22_inv_range[c->range & 0xff];
++#endif
++
++    c->bytestream -= (CABAC_BITS / 8);
++    c->by22.bits = bits;
++#if !USE_BY22_DIV
++    c->by22.range = c->range;
++    c->range = inv;
++#endif
++    c->low = x;
++}
++
++// Bypass block finish
++// Must be called at the end of the bypass block to return to normal operation
++static inline void get_cabac_by22_finish(CABACContext * const c)
++{
++    unsigned int used = c->by22.bits;
++    unsigned int bytes_used = (used / CABAC_BITS) * (CABAC_BITS / 8);
++    unsigned int bits_used = used & (CABAC_BITS == 16 ? 15 : 7);
++
++    c->bytestream += bytes_used + (CABAC_BITS / 8);
++    c->low = (((uint32_t)c->low >> (22 - CABAC_BITS + bits_used)) | 1) << bits_used;
++#if !USE_BY22_DIV
++    c->range = c->by22.range;
++#endif
++}
++
++// Peek bypass bits
++// _by22_start must be called before _by22_peek is called and _by22_flush
++// must be called afterwards to flush any used bits
++// The actual number of valid bits returned is
++// min(<coded bypass block length>, CABAC_BY22_PEEK_BITS). CABAC_BY22_PEEK_BITS
++// will be at least 22 which should be long enough for any prefix or suffix
++// though probably not long enough for the worst case combination
++#ifndef get_cabac_by22_peek
++static inline uint32_t get_cabac_by22_peek(const CABACContext * const c)
++{
++#if USE_BY22_DIV
++    return ((unsigned int)c->low / (unsigned int)c->range) << 9;
++#else
++    uint32_t x = c->low & ~1U;
++    const uint32_t inv = c->range;
++
++    if (inv != 0)
++        x = (uint32_t)(((uint64_t)x * (uint64_t)inv) >> 32);
++
++    return x << 1;
++#endif
++}
++#endif
++
++// Flush bypass bits peeked by _by22_peek
++// Flush n bypass bits. n must be >= 1 to guarantee correct operation
++// val is an unmodified copy of whatever _by22_peek returned
++#ifndef get_cabac_by22_flush
++static inline void get_cabac_by22_flush(CABACContext * c, const unsigned int n, const uint32_t val)
++{
++    // Subtract the bits used & reshift up to the top of the word
++#if USE_BY22_DIV
++    const uint32_t low = (((unsigned int)c->low << n) - (((val >> (32 - n)) * (unsigned int)c->range) << 23));
++#else
++    const uint32_t low = (((uint32_t)c->low << n) - (((val >> (32 - n)) * c->by22.range) << 23));
++#endif
++
++    // and refill lower bits
++    // We will probably OR over some existing bits but that doesn't matter
++    c->by22.bits += n;
++    c->low = low | (hevc_mem_bits32(c->bytestream, c->by22.bits) >> 9);
++}
++#endif
++
++#endif  // USE_BY22
++
++
+ void ff_hevc_save_states(HEVCContext *s, int ctb_addr_ts)
+ {
+     if (s->ps.pps->entropy_coding_sync_enabled_flag &&
+@@ -863,19 +1126,19 @@ int ff_hevc_cbf_luma_decode(HEVCContext *s, int trafo_depth)
+     return GET_CABAC(elem_offset[CBF_LUMA] + !trafo_depth);
+ }
+ 
+-static int hevc_transform_skip_flag_decode(HEVCContext *s, int c_idx)
++static int hevc_transform_skip_flag_decode(HEVCContext *s, int c_idx_nz)
+ {
+-    return GET_CABAC(elem_offset[TRANSFORM_SKIP_FLAG] + !!c_idx);
++    return GET_CABAC(elem_offset[TRANSFORM_SKIP_FLAG] + c_idx_nz);
+ }
+ 
+-static int explicit_rdpcm_flag_decode(HEVCContext *s, int c_idx)
++static int explicit_rdpcm_flag_decode(HEVCContext *s, int c_idx_nz)
+ {
+-    return GET_CABAC(elem_offset[EXPLICIT_RDPCM_FLAG] + !!c_idx);
++    return GET_CABAC(elem_offset[EXPLICIT_RDPCM_FLAG] + c_idx_nz);
+ }
+ 
+-static int explicit_rdpcm_dir_flag_decode(HEVCContext *s, int c_idx)
++static int explicit_rdpcm_dir_flag_decode(HEVCContext *s, int c_idx_nz)
+ {
+-    return GET_CABAC(elem_offset[EXPLICIT_RDPCM_DIR_FLAG] + !!c_idx);
++    return GET_CABAC(elem_offset[EXPLICIT_RDPCM_DIR_FLAG] + c_idx_nz);
+ }
+ 
+ int ff_hevc_log2_res_scale_abs(HEVCContext *s, int idx) {
+@@ -891,14 +1154,14 @@ int ff_hevc_res_scale_sign_flag(HEVCContext *s, int idx) {
+     return GET_CABAC(elem_offset[RES_SCALE_SIGN_FLAG] + idx);
+ }
+ 
+-static av_always_inline void last_significant_coeff_xy_prefix_decode(HEVCContext *s, int c_idx,
++static av_always_inline void last_significant_coeff_xy_prefix_decode(HEVCContext *s, int c_idx_nz,
+                                                    int log2_size, int *last_scx_prefix, int *last_scy_prefix)
+ {
+     int i = 0;
+     int max = (log2_size << 1) - 1;
+     int ctx_offset, ctx_shift;
+ 
+-    if (!c_idx) {
++    if (!c_idx_nz) {
+         ctx_offset = 3 * (log2_size - 2)  + ((log2_size - 1) >> 2);
+         ctx_shift = (log2_size + 1) >> 2;
+     } else {
+@@ -929,22 +1192,16 @@ static av_always_inline int last_significant_coeff_suffix_decode(HEVCContext *s,
+     return value;
+ }
+ 
+-static av_always_inline int significant_coeff_group_flag_decode(HEVCContext *s, int c_idx, int ctx_cg)
++static av_always_inline int significant_coeff_group_flag_decode(HEVCContext *s, int c_idx_nz, int ctx_cg)
+ {
+     int inc;
+ 
+-    inc = FFMIN(ctx_cg, 1) + (c_idx>0 ? 2 : 0);
++    inc = (ctx_cg != 0) + (c_idx_nz << 1);
+ 
+     return GET_CABAC(elem_offset[SIGNIFICANT_COEFF_GROUP_FLAG] + inc);
+ }
+-static av_always_inline int significant_coeff_flag_decode(HEVCContext *s, int x_c, int y_c,
+-                                           int offset, const uint8_t *ctx_idx_map)
+-{
+-    int inc = ctx_idx_map[(y_c << 2) + x_c] + offset;
+-    return GET_CABAC(elem_offset[SIGNIFICANT_COEFF_FLAG] + inc);
+-}
+ 
+-static av_always_inline int significant_coeff_flag_decode_0(HEVCContext *s, int c_idx, int offset)
++static av_always_inline int significant_coeff_flag_decode_0(HEVCContext *s, int offset)
+ {
+     return GET_CABAC(elem_offset[SIGNIFICANT_COEFF_FLAG] + offset);
+ }
+@@ -966,65 +1223,305 @@ static av_always_inline int coeff_abs_level_greater2_flag_decode(HEVCContext *s,
+     return GET_CABAC(elem_offset[COEFF_ABS_LEVEL_GREATER2_FLAG] + inc);
+ }
+ 
+-static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)
++
++#if !USE_BY22
++#define coeff_abs_level_remaining_decode_bypass(s,r) coeff_abs_level_remaining_decode(s, r)
++#endif
++
++
++#ifndef coeff_abs_level_remaining_decode_bypass
++static int coeff_abs_level_remaining_decode_bypass(HEVCContext * const s, const unsigned int rice_param)
++{
++    CABACContext * const c = &s->HEVClc->cc;
++    uint32_t y;
++    unsigned int prefix;
++    unsigned int last_coeff_abs_level_remaining;
++    unsigned int n;
++
++    y = get_cabac_by22_peek(c);
++    prefix = hevc_clz32(~y);
++    // y << prefix will always have top bit 0
++
++    if (prefix < 3) {
++        const unsigned int suffix = (y << prefix) >> (31 - rice_param);
++        last_coeff_abs_level_remaining = (prefix << rice_param) + suffix;
++        n = prefix + 1 + rice_param;
++    }
++    else if (prefix * 2 + rice_param <= CABAC_BY22_PEEK_BITS + 2)
++    {
++        const uint32_t suffix = ((y << prefix) | 0x80000000) >> (34 - (prefix + rice_param));
++
++        last_coeff_abs_level_remaining = (2 << rice_param) + suffix;
++        n = prefix * 2 + rice_param - 2;
++    }
++    else {
++        unsigned int suffix;
++
++        get_cabac_by22_flush(c, prefix, y);
++        y = get_cabac_by22_peek(c);
++
++        suffix = (y | 0x80000000) >> (34 - (prefix + rice_param));
++        last_coeff_abs_level_remaining = (2 << rice_param) + suffix;
++        n = prefix + rice_param - 2;
++    }
++
++    get_cabac_by22_flush(c, n, y);
++
++    return last_coeff_abs_level_remaining;
++}
++#endif
++
++static int coeff_abs_level_remaining_decode(HEVCContext * const s, int rc_rice_param)
+ {
++    CABACContext * const c = &s->HEVClc->cc;
+     int prefix = 0;
+     int suffix = 0;
+     int last_coeff_abs_level_remaining;
+     int i;
+ 
+-    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))
++    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(c))
+         prefix++;
+     if (prefix == CABAC_MAX_BIN) {
+         av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", prefix);
+         return 0;
+     }
++
+     if (prefix < 3) {
+         for (i = 0; i < rc_rice_param; i++)
+-            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);
++            suffix = (suffix << 1) | get_cabac_bypass(c);
+         last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;
+     } else {
+         int prefix_minus3 = prefix - 3;
+         for (i = 0; i < prefix_minus3 + rc_rice_param; i++)
+-            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);
++            suffix = (suffix << 1) | get_cabac_bypass(c);
+         last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)
+                                               << rc_rice_param) + suffix;
+     }
++
+     return last_coeff_abs_level_remaining;
+ }
+ 
+-static av_always_inline int coeff_sign_flag_decode(HEVCContext *s, uint8_t nb)
++#if !USE_BY22
++#define coeff_sign_flag_decode_bypass coeff_sign_flag_decode
++static inline uint32_t coeff_sign_flag_decode(HEVCContext * const s, const unsigned int nb)
+ {
+-    int i;
+-    int ret = 0;
++    CABACContext * const c = &s->HEVClc->cc;
++    unsigned int i;
++    uint32_t ret = 0;
+ 
+     for (i = 0; i < nb; i++)
+-        ret = (ret << 1) | get_cabac_bypass(&s->HEVClc->cc);
+-    return ret;
++        ret = (ret << 1) | get_cabac_bypass(c);
++
++    return ret << (32 - nb);
+ }
++#endif
++
++#ifndef coeff_sign_flag_decode_bypass
++static inline uint32_t coeff_sign_flag_decode_bypass(HEVCContext * const s, const unsigned int nb)
++{
++    CABACContext * const c = &s->HEVClc->cc;
++    uint32_t y;
++    y = get_cabac_by22_peek(c);
++    get_cabac_by22_flush(c, nb, y);
++    return y & ~(0xffffffffU >> nb);
++}
++#endif
++
++
++#ifndef get_cabac_greater1_bits
++static inline unsigned int get_cabac_greater1_bits(CABACContext * const c, const unsigned int n,
++    uint8_t * const state0)
++{
++    unsigned int i;
++    unsigned int rv = 0;
++    for (i = 0; i != n; ++i) {
++        const unsigned int idx = rv != 0 ? 0 : i < 3 ? i + 1 : 3;
++        const unsigned int b = get_cabac(c, state0 + idx);
++        rv = (rv << 1) | b;
++    }
++    return rv;
++}
++#endif
++
++
++// N.B. levels returned are the values assuming coeff_abs_level_remaining
++// is uncoded, so 1 must be added if it is coded.  sum_abs also reflects
++// this version of events.
++static inline uint32_t get_greaterx_bits(HEVCContext * const s, const unsigned int n_end, int * const levels,
++    int * const pprev_subset_coded, int * const psum,
++    const unsigned int idx0_gt1, const unsigned int idx_gt2)
++{
++    CABACContext * const c = &s->HEVClc->cc;
++    uint8_t * const state0 = s->HEVClc->cabac_state + idx0_gt1;
++    uint8_t * const state_gt2 = s->HEVClc->cabac_state + idx_gt2;
++    unsigned int rv;
++    unsigned int i;
++    const unsigned int n = FFMIN(n_end, 8);
++
++    // Really this is i != n but the simple unconditional loop is cheaper
++    // and faster
++    for (i = 0; i != 8; ++i)
++        levels[i] = 1;
++
++    rv = get_cabac_greater1_bits(c, n, state0);
++
++    *pprev_subset_coded = 0;
++    *psum = n;
++
++    rv <<= (32 - n);
++    if (rv != 0)
++    {
++        *pprev_subset_coded = 1;
++        *psum = n + 1;
++        i = hevc_clz32(rv);
++        levels[i] = 2;
++        if (get_cabac(c, state_gt2) == 0)
++        {
++            // Unset first coded bit
++            rv &= ~(0x80000000U >> i);
++        }
++    }
++
++    if (n_end > 8) {
++        const unsigned int g8 = n_end - 8;
++        rv |= ((1 << g8) - 1) << (24 - g8);
++        for (i = 0; i != g8; ++i) {
++            levels[i + 8] = 0;
++        }
++    }
++
++    return rv;
++}
++
++// extended_precision_processing_flag must be false given we are
++// putting the result into a 16-bit array
++// So trans_coeff_level must fit in 16 bits too (7.4.9.1 definition of coeff_abs_level_remaining)
++// scale_m is uint8_t
++//
++// scale is [40 - 72] << [0..12] based on qp- worst case is (45 << 12)
++//   or it can be 2 (if we have transquant_bypass)
++// shift is set to one less than we really want but would normally be
++//   s->ps.sps->bit_depth (max 16, min 8) + log2_trafo_size (max 5, min 2?) - 5 = max 16 min 5?
++// however the scale shift is substracted from shift to a min 0 so scale_m worst = 45 << 6
++// This can still theoretically lead to overflow but the coding would have to be very odd (& inefficient)
++// to achieve it
++
++#ifndef trans_scale_sat
++static inline int trans_scale_sat(const int level, const unsigned int scale, const unsigned int scale_m, const unsigned int shift)
++{
++    return av_clip_int16((((level * (int)(scale * scale_m)) >> shift) + 1) >> 1);
++}
++#endif
++
++
++#ifndef update_rice
++static inline void update_rice(uint8_t * const stat_coeff,
++    const unsigned int last_coeff_abs_level_remaining,
++    const unsigned int c_rice_param)
++{
++    const unsigned int x = (last_coeff_abs_level_remaining << 1) >> c_rice_param;
++    if (x >= 6)
++        (*stat_coeff)++;
++    else if (x == 0 && *stat_coeff > 0)
++        (*stat_coeff)--;
++}
++#endif
++
++
++// n must be > 0 on entry
++#ifndef get_cabac_sig_coeff_flag_idxs
++static inline uint8_t * get_cabac_sig_coeff_flag_idxs(CABACContext * const c, uint8_t * const state0,
++    unsigned int n,
++    const uint8_t const * ctx_map,
++    uint8_t * p)
++{
++    do {
++        if (get_cabac(c, state0 + ctx_map[n]))
++            *p++ = n;
++    } while (--n != 0);
++    return p;
++}
++#endif
++
++
++static int get_sig_coeff_flag_idxs(CABACContext * const c, uint8_t * const state0,
++    unsigned int n,
++    const uint8_t const * ctx_map,
++    uint8_t * const flag_idx)
++{
++    int rv;
++
++    rv = get_cabac_sig_coeff_flag_idxs(c, state0, n, ctx_map, flag_idx) - flag_idx;
++
++    return rv;
++}
++
++#define H4x4(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15) {\
++     x0,  x1,  x2,  x3,\
++     x4,  x5,  x6,  x7,\
++     x8,  x9, x10, x11,\
++    x12, x13, x14, x15}
++
++#define V4x4(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15) {\
++     x0,  x4,  x8, x12,\
++     x1,  x5,  x9, x13,\
++     x2,  x6, x10, x14,\
++     x3,  x7, x11, x15}
++
++#define D4x4(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15) {\
++     x0,  x4,  x1,  x8,\
++     x5,  x2, x12,  x9,\
++     x6,  x3, x13, x10,\
++     x7, x14, x11, x15}
++
++
++static inline int next_subset(HEVCContext * const s, int i, const int c_idx_nz,
++    uint8_t * const significant_coeff_group_flag,
++    const uint8_t * const scan_x_cg, const uint8_t * const scan_y_cg,
++    int * const pPrev_sig)
++{
++    while (--i >= 0) {
++        unsigned int x_cg = scan_x_cg[i];
++        unsigned int y_cg = scan_y_cg[i];
++
++        // For the flag decode we only care about Z/NZ but
++        // we use the full Right + Down * 2 when calculating
++        // significant coeff flags so we obtain it here
++        //.
++        // The group flag array is one longer than it needs to
++        // be so we don't need to check for y_cg limits
++        unsigned int prev_sig = ((significant_coeff_group_flag[y_cg] >> (x_cg + 1)) & 1) |
++            (((significant_coeff_group_flag[y_cg + 1] >> x_cg) & 1) << 1);
++
++        if (i == 0 ||
++            significant_coeff_group_flag_decode(s, c_idx_nz, prev_sig))
++        {
++            significant_coeff_group_flag[y_cg] |= (1 << x_cg);
++            *pPrev_sig = prev_sig;
++            break;
++        }
++    }
++
++    return i;
++}
++
+ 
+ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+                                 int log2_trafo_size, enum ScanType scan_idx,
+                                 int c_idx)
+ {
+-#define GET_COORD(offset, n)                                    \
+-    do {                                                        \
+-        x_c = (x_cg << 2) + scan_x_off[n];                      \
+-        y_c = (y_cg << 2) + scan_y_off[n];                      \
+-    } while (0)
+-    HEVCLocalContext *lc = s->HEVClc;
+-    int transform_skip_flag = 0;
++    HEVCLocalContext * const lc = s->HEVClc;
++    int trans_skip_or_bypass = lc->cu.cu_transquant_bypass_flag;
+ 
+     int last_significant_coeff_x, last_significant_coeff_y;
+-    int last_scan_pos;
+-    int n_end;
+     int num_coeff = 0;
+-    int greater1_ctx = 1;
++    int prev_subset_coded = 0;
+ 
+     int num_last_subset;
+     int x_cg_last_sig, y_cg_last_sig;
+ 
+-    const uint8_t *scan_x_cg, *scan_y_cg, *scan_x_off, *scan_y_off;
++    const uint8_t *scan_x_cg, *scan_y_cg;
++    const xy_off_t * scan_xy_off;
+ 
+     ptrdiff_t stride = s->frame->linesize[c_idx];
+     int hshift = s->ps.sps->hshift[c_idx];
+@@ -1032,21 +1529,28 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+     uint8_t *dst = &s->frame->data[c_idx][(y0 >> vshift) * stride +
+                                           ((x0 >> hshift) << s->ps.sps->pixel_shift)];
+ #ifdef RPI
+-    int use_vpu = s->enable_rpi && !lc->cu.cu_transquant_bypass_flag && !transform_skip_flag && !lc->tu.cross_pf && log2_trafo_size>=4;
++    //***** transform_skip_flag decoded later!
++    int use_vpu = s->enable_rpi && !lc->cu.cu_transquant_bypass_flag /* && !transform_skip_flag*/ && !lc->tu.cross_pf && log2_trafo_size>=4;
+ #endif
+     int16_t *coeffs = (int16_t*)(c_idx ? lc->edge_emu_buffer2 : lc->edge_emu_buffer);
+-    uint8_t significant_coeff_group_flag[8][8] = {{0}};
++    uint8_t significant_coeff_group_flag[9] = {0};  // Allow 1 final byte that is always zero
+     int explicit_rdpcm_flag = 0;
+     int explicit_rdpcm_dir_flag;
+ 
+     int trafo_size = 1 << log2_trafo_size;
+     int i;
+-    int qp,shift,add,scale,scale_m;
++    int qp,shift,scale;
+     static const uint8_t level_scale[] = { 40, 45, 51, 57, 64, 72 };
+     const uint8_t *scale_matrix = NULL;
+     uint8_t dc_scale;
+     int pred_mode_intra = (c_idx == 0) ? lc->tu.intra_pred_mode :
+                                          lc->tu.intra_pred_mode_c;
++
++    int prev_sig = 0;
++    const int c_idx_nz = (c_idx != 0);
++
++    int may_hide_sign;
++
+ #ifdef RPI
+     if (s->enable_rpi) {
+         int n = trafo_size * trafo_size;
+@@ -1078,7 +1582,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+ 
+     // Derive QP for dequant
+     if (!lc->cu.cu_transquant_bypass_flag) {
+-        static const int qp_c[] = { 29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37 };
++        static const uint8_t qp_c[] = { 29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37 };
+         static const uint8_t rem6[51 + 4 * 6 + 1] = {
+             0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
+             3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
+@@ -1094,9 +1598,19 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+         };
+         int qp_y = lc->qp_y;
+ 
++        may_hide_sign = s->ps.pps->sign_data_hiding_flag;
++
+         if (s->ps.pps->transform_skip_enabled_flag &&
+             log2_trafo_size <= s->ps.pps->log2_max_transform_skip_block_size) {
+-            transform_skip_flag = hevc_transform_skip_flag_decode(s, c_idx);
++            int transform_skip_flag = hevc_transform_skip_flag_decode(s, c_idx_nz);
++            if (transform_skip_flag) {
++                trans_skip_or_bypass = 1;
++                if (lc->cu.pred_mode ==  MODE_INTRA  &&
++                    s->ps.sps->implicit_rdpcm_enabled_flag &&
++                    (pred_mode_intra == 10 || pred_mode_intra == 26)) {
++                    may_hide_sign = 0;
++                }
++            }
+         }
+ 
+         if (c_idx == 0) {
+@@ -1129,39 +1643,73 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+             qp += s->ps.sps->qp_bd_offset;
+         }
+ 
+-        shift    = s->ps.sps->bit_depth + log2_trafo_size - 5;
+-        add      = 1 << (shift-1);
+-        scale    = level_scale[rem6[qp]] << (div6[qp]);
+-        scale_m  = 16; // default when no custom scaling lists.
+-        dc_scale = 16;
++        // Shift is set to one less than will actually occur as the scale
++        // and saturate step adds 1 and then shifts right again
++        shift = s->ps.sps->bit_depth + log2_trafo_size - 6;
++        scale = level_scale[rem6[qp]];
++        if (div6[qp] >= shift) {
++            scale <<= (div6[qp] - shift);
++            shift = 0;
++        } else {
++            shift -= div6[qp];
++        }
+ 
+-        if (s->ps.sps->scaling_list_enable_flag && !(transform_skip_flag && log2_trafo_size > 2)) {
++        if (s->ps.sps->scaling_list_enable_flag && !(trans_skip_or_bypass && log2_trafo_size > 2)) {
+             const ScalingList *sl = s->ps.pps->scaling_list_data_present_flag ?
+-            &s->ps.pps->scaling_list : &s->ps.sps->scaling_list;
++                &s->ps.pps->scaling_list : &s->ps.sps->scaling_list;
+             int matrix_id = lc->cu.pred_mode != MODE_INTRA;
+ 
+             matrix_id = 3 * matrix_id + c_idx;
+ 
+             scale_matrix = sl->sl[log2_trafo_size - 2][matrix_id];
++            dc_scale = scale_matrix[0];
+             if (log2_trafo_size >= 4)
+                 dc_scale = sl->sl_dc[log2_trafo_size - 4][matrix_id];
+         }
++        else
++        {
++            static const uint8_t sixteen_scale[64] = {
++                16, 16, 16, 16, 16, 16, 16, 16,
++                16, 16, 16, 16, 16, 16, 16, 16,
++                16, 16, 16, 16, 16, 16, 16, 16,
++                16, 16, 16, 16, 16, 16, 16, 16,
++                16, 16, 16, 16, 16, 16, 16, 16,
++                16, 16, 16, 16, 16, 16, 16, 16,
++                16, 16, 16, 16, 16, 16, 16, 16,
++                16, 16, 16, 16, 16, 16, 16, 16
++            };
++            scale_matrix = sixteen_scale;
++            dc_scale = 16;
++        }
+     } else {
++        static const uint8_t unit_scale[64] = {
++            1, 1, 1, 1, 1, 1, 1, 1,
++            1, 1, 1, 1, 1, 1, 1, 1,
++            1, 1, 1, 1, 1, 1, 1, 1,
++            1, 1, 1, 1, 1, 1, 1, 1,
++            1, 1, 1, 1, 1, 1, 1, 1,
++            1, 1, 1, 1, 1, 1, 1, 1,
++            1, 1, 1, 1, 1, 1, 1, 1,
++            1, 1, 1, 1, 1, 1, 1, 1,
++        };
++        scale_matrix = unit_scale;
+         shift        = 0;
+-        add          = 0;
+-        scale        = 0;
+-        dc_scale     = 0;
++        scale        = 2;  // We will shift right to kill this
++        dc_scale     = 1;
++
++        may_hide_sign = 0;
+     }
+ 
+     if (lc->cu.pred_mode == MODE_INTER && s->ps.sps->explicit_rdpcm_enabled_flag &&
+-        (transform_skip_flag || lc->cu.cu_transquant_bypass_flag)) {
+-        explicit_rdpcm_flag = explicit_rdpcm_flag_decode(s, c_idx);
++        trans_skip_or_bypass) {
++        explicit_rdpcm_flag = explicit_rdpcm_flag_decode(s, c_idx_nz);
+         if (explicit_rdpcm_flag) {
+-            explicit_rdpcm_dir_flag = explicit_rdpcm_dir_flag_decode(s, c_idx);
++            may_hide_sign = 0;
++            explicit_rdpcm_dir_flag = explicit_rdpcm_dir_flag_decode(s, c_idx_nz);
+         }
+     }
+ 
+-    last_significant_coeff_xy_prefix_decode(s, c_idx, log2_trafo_size,
++    last_significant_coeff_xy_prefix_decode(s, c_idx_nz, log2_trafo_size,
+                                            &last_significant_coeff_x, &last_significant_coeff_y);
+ 
+     if (last_significant_coeff_x > 3) {
+@@ -1189,119 +1737,113 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+         int last_x_c = last_significant_coeff_x & 3;
+         int last_y_c = last_significant_coeff_y & 3;
+ 
+-        scan_x_off = ff_hevc_diag_scan4x4_x;
+-        scan_y_off = ff_hevc_diag_scan4x4_y;
+         num_coeff = diag_scan4x4_inv[last_y_c][last_x_c];
+-        if (trafo_size == 4) {
++
++        switch (log2_trafo_size) {
++        case 2:
+             scan_x_cg = scan_1x1;
+             scan_y_cg = scan_1x1;
+-        } else if (trafo_size == 8) {
++            break;
++        case 3:
+             num_coeff += diag_scan2x2_inv[y_cg_last_sig][x_cg_last_sig] << 4;
+             scan_x_cg = diag_scan2x2_x;
+             scan_y_cg = diag_scan2x2_y;
+-        } else if (trafo_size == 16) {
++            break;
++        case 4:
+             num_coeff += diag_scan4x4_inv[y_cg_last_sig][x_cg_last_sig] << 4;
+             scan_x_cg = ff_hevc_diag_scan4x4_x;
+             scan_y_cg = ff_hevc_diag_scan4x4_y;
+-        } else { // trafo_size == 32
++            break;
++        case 5:
++        default:
+             num_coeff += diag_scan8x8_inv[y_cg_last_sig][x_cg_last_sig] << 4;
+             scan_x_cg = ff_hevc_diag_scan8x8_x;
+             scan_y_cg = ff_hevc_diag_scan8x8_y;
++            break;
+         }
+         break;
+     }
+     case SCAN_HORIZ:
+         scan_x_cg = horiz_scan2x2_x;
+         scan_y_cg = horiz_scan2x2_y;
+-        scan_x_off = horiz_scan4x4_x;
+-        scan_y_off = horiz_scan4x4_y;
+         num_coeff = horiz_scan8x8_inv[last_significant_coeff_y][last_significant_coeff_x];
+         break;
+     default: //SCAN_VERT
+         scan_x_cg = horiz_scan2x2_y;
+         scan_y_cg = horiz_scan2x2_x;
+-        scan_x_off = horiz_scan4x4_y;
+-        scan_y_off = horiz_scan4x4_x;
+         num_coeff = horiz_scan8x8_inv[last_significant_coeff_x][last_significant_coeff_y];
+         break;
+     }
+     num_coeff++;
+     num_last_subset = (num_coeff - 1) >> 4;
+ 
+-    for (i = num_last_subset; i >= 0; i--) {
+-        int n, m;
+-        int x_cg, y_cg, x_c, y_c, pos;
+-        int implicit_non_zero_coeff = 0;
+-        int64_t trans_coeff_level;
+-        int prev_sig = 0;
+-        int offset = i << 4;
+-        int rice_init = 0;
+-
+-        uint8_t significant_coeff_flag_idx[16];
+-        uint8_t nb_significant_coeff_flag = 0;
++    significant_coeff_group_flag[y_cg_last_sig] = 1 << x_cg_last_sig; // 1st subset always significant
+ 
+-        x_cg = scan_x_cg[i];
+-        y_cg = scan_y_cg[i];
++    scan_xy_off = off_xys[scan_idx][log2_trafo_size - 2];
+ 
+-        if ((i < num_last_subset) && (i > 0)) {
+-            int ctx_cg = 0;
+-            if (x_cg < (1 << (log2_trafo_size - 2)) - 1)
+-                ctx_cg += significant_coeff_group_flag[x_cg + 1][y_cg];
+-            if (y_cg < (1 << (log2_trafo_size - 2)) - 1)
+-                ctx_cg += significant_coeff_group_flag[x_cg][y_cg + 1];
+-
+-            significant_coeff_group_flag[x_cg][y_cg] =
+-                significant_coeff_group_flag_decode(s, c_idx, ctx_cg);
+-            implicit_non_zero_coeff = 1;
+-        } else {
+-            significant_coeff_group_flag[x_cg][y_cg] =
+-            ((x_cg == x_cg_last_sig && y_cg == y_cg_last_sig) ||
+-             (x_cg == 0 && y_cg == 0));
+-        }
++    i = num_last_subset;
++    do {
++        int implicit_non_zero_coeff = 0;
++        int n_end;
+ 
+-        last_scan_pos = num_coeff - offset - 1;
++        uint8_t significant_coeff_flag_idx[16];
++        unsigned int nb_significant_coeff_flag = 0;
+ 
+         if (i == num_last_subset) {
++            // First time through
++            int last_scan_pos = num_coeff - (i << 4) - 1;
+             n_end = last_scan_pos - 1;
+             significant_coeff_flag_idx[0] = last_scan_pos;
+             nb_significant_coeff_flag = 1;
+         } else {
+             n_end = 15;
++            implicit_non_zero_coeff = (i != 0);
+         }
+ 
+-        if (x_cg < ((1 << log2_trafo_size) - 1) >> 2)
+-            prev_sig = !!significant_coeff_group_flag[x_cg + 1][y_cg];
+-        if (y_cg < ((1 << log2_trafo_size) - 1) >> 2)
+-            prev_sig += (!!significant_coeff_group_flag[x_cg][y_cg + 1] << 1);
+-
+-        if (significant_coeff_group_flag[x_cg][y_cg] && n_end >= 0) {
+-            static const uint8_t ctx_idx_map[] = {
+-                0, 1, 4, 5, 2, 3, 4, 5, 6, 6, 8, 8, 7, 7, 8, 8, // log2_trafo_size == 2
+-                1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, // prev_sig == 0
+-                2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, // prev_sig == 1
+-                2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0, // prev_sig == 2
+-                2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2  // default
++        if (n_end >= 0) {
++            static const uint8_t ctx_idx_maps_ts2[3][16] = {
++                D4x4(0, 1, 4, 5, 2, 3, 4, 5, 6, 6, 8, 8, 7, 7, 8, 8), // log2_trafo_size == 2
++                H4x4(0, 1, 4, 5, 2, 3, 4, 5, 6, 6, 8, 8, 7, 7, 8, 8), // log2_trafo_size == 2
++                V4x4(0, 1, 4, 5, 2, 3, 4, 5, 6, 6, 8, 8, 7, 7, 8, 8)  // log2_trafo_size == 2
++            };
++            static const uint8_t ctx_idx_maps[3][4][16] = {
++                {
++                    D4x4(1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0), // prev_sig == 0
++                    D4x4(2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0), // prev_sig == 1
++                    D4x4(2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0), // prev_sig == 2
++                    D4x4(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)  // prev_sig == 3, default
++                },
++                {
++                    H4x4(1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0), // prev_sig == 0
++                    H4x4(2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0), // prev_sig == 1
++                    H4x4(2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0), // prev_sig == 2
++                    H4x4(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)  // prev_sig == 3, default
++                },
++                {
++                    V4x4(1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0), // prev_sig == 0
++                    V4x4(2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0), // prev_sig == 1
++                    V4x4(2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0, 2, 1, 0, 0), // prev_sig == 2
++                    V4x4(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)  // prev_sig == 3, default
++                }
+             };
+             const uint8_t *ctx_idx_map_p;
+             int scf_offset = 0;
+-            if (s->ps.sps->transform_skip_context_enabled_flag &&
+-                (transform_skip_flag || lc->cu.cu_transquant_bypass_flag)) {
+-                ctx_idx_map_p = (uint8_t*) &ctx_idx_map[4 * 16];
+-                if (c_idx == 0) {
+-                    scf_offset = 40;
+-                } else {
+-                    scf_offset = 14 + 27;
+-                }
++
++            if (s->ps.sps->transform_skip_context_enabled_flag && trans_skip_or_bypass) {
++                ctx_idx_map_p = ctx_idx_maps[0][3];
++                scf_offset = 40 + c_idx_nz;
+             } else {
+-                if (c_idx != 0)
++                if (c_idx_nz != 0)
+                     scf_offset = 27;
++
+                 if (log2_trafo_size == 2) {
+-                    ctx_idx_map_p = (uint8_t*) &ctx_idx_map[0];
++                    ctx_idx_map_p = ctx_idx_maps_ts2[scan_idx];
+                 } else {
+-                    ctx_idx_map_p = (uint8_t*) &ctx_idx_map[(prev_sig + 1) << 4];
+-                    if (c_idx == 0) {
+-                        if ((x_cg > 0 || y_cg > 0))
++                    ctx_idx_map_p = ctx_idx_maps[scan_idx][prev_sig];
++                    if (!c_idx_nz) {
++                        if (i != 0)
+                             scf_offset += 3;
++
+                         if (log2_trafo_size == 3) {
+                             scf_offset += (scan_idx == SCAN_DIAG) ? 9 : 15;
+                         } else {
+@@ -1315,34 +1857,30 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+                     }
+                 }
+             }
+-            for (n = n_end; n > 0; n--) {
+-                x_c = scan_x_off[n];
+-                y_c = scan_y_off[n];
+-                if (significant_coeff_flag_decode(s, x_c, y_c, scf_offset, ctx_idx_map_p)) {
+-                    significant_coeff_flag_idx[nb_significant_coeff_flag] = n;
+-                    nb_significant_coeff_flag++;
++
++            if (n_end > 0) {
++                int cnt = get_sig_coeff_flag_idxs(&s->HEVClc->cc,
++                    s->HEVClc->cabac_state + elem_offset[SIGNIFICANT_COEFF_FLAG] + scf_offset,
++                    n_end, ctx_idx_map_p,
++                    significant_coeff_flag_idx + nb_significant_coeff_flag);
++
++                nb_significant_coeff_flag += cnt;
++                if (cnt != 0) {
+                     implicit_non_zero_coeff = 0;
+                 }
+             }
++
+             if (implicit_non_zero_coeff == 0) {
+-                if (s->ps.sps->transform_skip_context_enabled_flag &&
+-                    (transform_skip_flag || lc->cu.cu_transquant_bypass_flag)) {
+-                    if (c_idx == 0) {
+-                        scf_offset = 42;
+-                    } else {
+-                        scf_offset = 16 + 27;
+-                    }
++                if (s->ps.sps->transform_skip_context_enabled_flag && trans_skip_or_bypass) {
++                    scf_offset = 42 + c_idx_nz;
+                 } else {
+                     if (i == 0) {
+-                        if (c_idx == 0)
+-                            scf_offset = 0;
+-                        else
+-                            scf_offset = 27;
++                        scf_offset = c_idx_nz ? 27 : 0;
+                     } else {
+                         scf_offset = 2 + scf_offset;
+                     }
+                 }
+-                if (significant_coeff_flag_decode_0(s, c_idx, scf_offset) == 1) {
++                if (significant_coeff_flag_decode_0(s, scf_offset) == 1) {
+                     significant_coeff_flag_idx[nb_significant_coeff_flag] = 0;
+                     nb_significant_coeff_flag++;
+                 }
+@@ -1352,141 +1890,185 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+             }
+         }
+ 
+-        n_end = nb_significant_coeff_flag;
+-
++        if (nb_significant_coeff_flag != 0) {
++            const unsigned int gt1_idx_delta = (c_idx_nz << 2) |
++                ((i != 0 && !c_idx_nz) ? 2 : 0) |
++                prev_subset_coded;
++            const unsigned int idx0_gt1 = elem_offset[COEFF_ABS_LEVEL_GREATER1_FLAG] +
++                (gt1_idx_delta << 2);
++            const unsigned int idx_gt2 = elem_offset[COEFF_ABS_LEVEL_GREATER2_FLAG] +
++                gt1_idx_delta;
++
++            const unsigned int x_cg = scan_x_cg[i];
++            const unsigned int y_cg = scan_y_cg[i];
++            int16_t * const blk_coeffs = coeffs +
++                ((x_cg + (y_cg << log2_trafo_size)) << 2);
++            // This calculation is 'wrong' for log2_traffo_size == 2
++            // but that doesn't mattor as in this case x_cg & y_cg
++            // are always 0 so result is correct (0) anyway
++            const uint8_t * const blk_scale = scale_matrix +
++                (((x_cg + (y_cg << 3)) << (5 - log2_trafo_size)));
++
++            // * THe following code block doesn't deal with these flags:
++            //   (nor did the one it replaces)
++            //
++            // cabac_bypass_alignment_enabled_flag
++            //    This should be easy but I can't find a test case
++            // extended_precision_processing_flag
++            //    This can extend the required precision past 16bits
++            //    so is probably tricky - also no example found yet
++
++#if USE_N_END_1
++            if (nb_significant_coeff_flag == 1) {
++                // There is a small gain to be had from special casing the single
++                // transform coefficient case.  The reduction in complexity
++                // makes up for the code duplicatioon.
++
++                int trans_coeff_level = 1;
++                int coeff_sign_flag;
++                int coded_val = 0;
++
++                // initialize first elem of coeff_bas_level_greater1_flag
++                prev_subset_coded = 0;
++
++                if (get_cabac(&s->HEVClc->cc, s->HEVClc->cabac_state + idx0_gt1 + 1)) {
++                    trans_coeff_level = 2;
++                    prev_subset_coded = 1;
++                    coded_val = get_cabac(&s->HEVClc->cc, s->HEVClc->cabac_state + idx_gt2);
++                }
+ 
+-        if (n_end) {
+-            int first_nz_pos_in_cg;
+-            int last_nz_pos_in_cg;
+-            int c_rice_param = 0;
+-            int first_greater1_coeff_idx = -1;
+-            uint8_t coeff_abs_level_greater1_flag[8];
+-            uint16_t coeff_sign_flag;
+-            int sum_abs = 0;
+-            int sign_hidden;
+-            int sb_type;
++                // Probably not worth the overhead of starting by22 for just one value
++                coeff_sign_flag = get_cabac_bypass(&s->HEVClc->cc);
+ 
++                if (coded_val)
++                {
++                    if (!s->ps.sps->persistent_rice_adaptation_enabled_flag) {
++                        trans_coeff_level = 3 + coeff_abs_level_remaining_decode(s, 0);
++                    } else {
++                        uint8_t * const stat_coeff =
++                            lc->stat_coeff + trans_skip_or_bypass + 2 - ((c_idx_nz) << 1);
++                        const unsigned int c_rice_param = *stat_coeff >> 2;
++                        const int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode(s, c_rice_param);
+ 
+-            // initialize first elem of coeff_bas_level_greater1_flag
+-            int ctx_set = (i > 0 && c_idx == 0) ? 2 : 0;
++                        trans_coeff_level = 3 + last_coeff_abs_level_remaining;
++                        update_rice(stat_coeff, last_coeff_abs_level_remaining, c_rice_param);
++                    }
++                }
+ 
+-            if (s->ps.sps->persistent_rice_adaptation_enabled_flag) {
+-                if (!transform_skip_flag && !lc->cu.cu_transquant_bypass_flag)
+-                    sb_type = 2 * (c_idx == 0 ? 1 : 0);
+-                else
+-                    sb_type = 2 * (c_idx == 0 ? 1 : 0) + 1;
+-                c_rice_param = lc->stat_coeff[sb_type] / 4;
+-            }
++                {
++                    const xy_off_t * const xy_off = scan_xy_off + significant_coeff_flag_idx[0];
++                    const int k = (int32_t)(coeff_sign_flag << 31) >> 31;
++                    const unsigned int scale_m = blk_scale[xy_off->scale];
+ 
+-            if (!(i == num_last_subset) && greater1_ctx == 0)
+-                ctx_set++;
+-            greater1_ctx = 1;
+-            last_nz_pos_in_cg = significant_coeff_flag_idx[0];
+-
+-            for (m = 0; m < (n_end > 8 ? 8 : n_end); m++) {
+-                int inc = (ctx_set << 2) + greater1_ctx;
+-                coeff_abs_level_greater1_flag[m] =
+-                    coeff_abs_level_greater1_flag_decode(s, c_idx, inc);
+-                if (coeff_abs_level_greater1_flag[m]) {
+-                    greater1_ctx = 0;
+-                    if (first_greater1_coeff_idx == -1)
+-                        first_greater1_coeff_idx = m;
+-                } else if (greater1_ctx > 0 && greater1_ctx < 3) {
+-                    greater1_ctx++;
++                    blk_coeffs[xy_off->coeff] = trans_scale_sat(
++                        (trans_coeff_level ^ k) - k,  // Apply sign
++                        scale,
++                        i == 0 && xy_off->coeff == 0 ? dc_scale : scale_m,
++                        shift);
+                 }
+             }
+-            first_nz_pos_in_cg = significant_coeff_flag_idx[n_end - 1];
+-
+-            if (lc->cu.cu_transquant_bypass_flag ||
+-                (lc->cu.pred_mode ==  MODE_INTRA  &&
+-                 s->ps.sps->implicit_rdpcm_enabled_flag  &&  transform_skip_flag  &&
+-                 (pred_mode_intra == 10 || pred_mode_intra  ==  26 )) ||
+-                 explicit_rdpcm_flag)
+-                sign_hidden = 0;
+             else
+-                sign_hidden = (last_nz_pos_in_cg - first_nz_pos_in_cg >= 4);
++#endif
++            {
++                int sign_hidden = may_hide_sign;
++                int levels[16]; // Should be able to get away with int16_t but that fails some tests
++                uint32_t coeff_sign_flags;
++                uint32_t coded_vals = 0;
++                // Sum(abs(level[]))
++                // In fact we only need the bottom bit and in some future
++                // version that may be all we calculate
++                unsigned int sum_abs;
++
++                coded_vals = get_greaterx_bits(s, nb_significant_coeff_flag, levels,
++                    &prev_subset_coded, &sum_abs, idx0_gt1, idx_gt2);
++
++                if (significant_coeff_flag_idx[0] - significant_coeff_flag_idx[nb_significant_coeff_flag - 1] <= 3)
++                    sign_hidden = 0;
++
++                // -- Start bypass block
++
++                bypass_start(s);
++
++                coeff_sign_flags = coeff_sign_flag_decode_bypass(s, nb_significant_coeff_flag - sign_hidden);
++
++                if (coded_vals != 0)
++                {
++                    const int rice_adaptation_enabled = s->ps.sps->persistent_rice_adaptation_enabled_flag;
++                    uint8_t * stat_coeff = !rice_adaptation_enabled ? NULL :
++                        lc->stat_coeff + trans_skip_or_bypass + 2 - ((c_idx_nz) << 1);
++                    int c_rice_param = !rice_adaptation_enabled ? 0 : *stat_coeff >> 2;
++                    int * level = levels - 1;
++
++                    do {
++                        {
++                            const unsigned int z = hevc_clz32(coded_vals) + 1;
++                            level += z;
++                            coded_vals <<= z;
++                        }
+ 
+-            if (first_greater1_coeff_idx != -1) {
+-                coeff_abs_level_greater1_flag[first_greater1_coeff_idx] += coeff_abs_level_greater2_flag_decode(s, c_idx, ctx_set);
+-            }
+-            if (!s->ps.pps->sign_data_hiding_flag || !sign_hidden ) {
+-                coeff_sign_flag = coeff_sign_flag_decode(s, nb_significant_coeff_flag) << (16 - nb_significant_coeff_flag);
+-            } else {
+-                coeff_sign_flag = coeff_sign_flag_decode(s, nb_significant_coeff_flag - 1) << (16 - (nb_significant_coeff_flag - 1));
+-            }
++                        {
++                            const int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode_bypass(s, c_rice_param);
++                            const int trans_coeff_level = *level + last_coeff_abs_level_remaining + 1;
++
++                            sum_abs += last_coeff_abs_level_remaining + 1;
++                            *level = trans_coeff_level;
+ 
+-            for (m = 0; m < n_end; m++) {
+-                n = significant_coeff_flag_idx[m];
+-                GET_COORD(offset, n);
+-                if (m < 8) {
+-                    trans_coeff_level = 1 + coeff_abs_level_greater1_flag[m];
+-                    if (trans_coeff_level == ((m == first_greater1_coeff_idx) ? 3 : 2)) {
+-                        int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode(s, c_rice_param);
+-
+-                        trans_coeff_level += last_coeff_abs_level_remaining;
+-                        if (trans_coeff_level > (3 << c_rice_param))
+-                            c_rice_param = s->ps.sps->persistent_rice_adaptation_enabled_flag ? c_rice_param + 1 : FFMIN(c_rice_param + 1, 4);
+-                        if (s->ps.sps->persistent_rice_adaptation_enabled_flag && !rice_init) {
+-                            int c_rice_p_init = lc->stat_coeff[sb_type] / 4;
+-                            if (last_coeff_abs_level_remaining >= (3 << c_rice_p_init))
+-                                lc->stat_coeff[sb_type]++;
+-                            else if (2 * last_coeff_abs_level_remaining < (1 << c_rice_p_init))
+-                                if (lc->stat_coeff[sb_type] > 0)
+-                                    lc->stat_coeff[sb_type]--;
+-                            rice_init = 1;
++                            if (stat_coeff != NULL)
++                                update_rice(stat_coeff, last_coeff_abs_level_remaining, c_rice_param);
++                            stat_coeff = NULL;
++
++                            if (trans_coeff_level > (3 << c_rice_param) &&
++                                (c_rice_param < 4 || rice_adaptation_enabled))
++                                ++c_rice_param;
+                         }
+-                    }
+-                } else {
+-                    int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode(s, c_rice_param);
+-
+-                    trans_coeff_level = 1 + last_coeff_abs_level_remaining;
+-                    if (trans_coeff_level > (3 << c_rice_param))
+-                        c_rice_param = s->ps.sps->persistent_rice_adaptation_enabled_flag ? c_rice_param + 1 : FFMIN(c_rice_param + 1, 4);
+-                    if (s->ps.sps->persistent_rice_adaptation_enabled_flag && !rice_init) {
+-                        int c_rice_p_init = lc->stat_coeff[sb_type] / 4;
+-                        if (last_coeff_abs_level_remaining >= (3 << c_rice_p_init))
+-                            lc->stat_coeff[sb_type]++;
+-                        else if (2 * last_coeff_abs_level_remaining < (1 << c_rice_p_init))
+-                            if (lc->stat_coeff[sb_type] > 0)
+-                                lc->stat_coeff[sb_type]--;
+-                        rice_init = 1;
+-                    }
++                    } while (coded_vals != 0);
+                 }
+-                if (s->ps.pps->sign_data_hiding_flag && sign_hidden) {
+-                    sum_abs += trans_coeff_level;
+-                    if (n == first_nz_pos_in_cg && (sum_abs&1))
+-                        trans_coeff_level = -trans_coeff_level;
++
++                // sign_hidden = 0 or 1 so we can combine the tests
++                if ((sign_hidden & sum_abs) != 0) {
++                    levels[nb_significant_coeff_flag - 1] = -levels[nb_significant_coeff_flag - 1];
+                 }
+-                if (coeff_sign_flag >> 15)
+-                    trans_coeff_level = -trans_coeff_level;
+-                coeff_sign_flag <<= 1;
+-                if(!lc->cu.cu_transquant_bypass_flag) {
+-                    if (s->ps.sps->scaling_list_enable_flag && !(transform_skip_flag && log2_trafo_size > 2)) {
+-                        if(y_c || x_c || log2_trafo_size < 4) {
+-                            switch(log2_trafo_size) {
+-                                case 3: pos = (y_c << 3) + x_c; break;
+-                                case 4: pos = ((y_c >> 1) << 3) + (x_c >> 1); break;
+-                                case 5: pos = ((y_c >> 2) << 3) + (x_c >> 2); break;
+-                                default: pos = (y_c << 2) + x_c; break;
+-                            }
+-                            scale_m = scale_matrix[pos];
+-                        } else {
+-                            scale_m = dc_scale;
+-                        }
++
++                bypass_finish(s);
++
++                // -- Finish bypass block
++
++                // Scale loop
++                {
++                    int m = nb_significant_coeff_flag - 1;
++
++                    // Deal with DC component (if any) first
++                    if (i == 0 && significant_coeff_flag_idx[m] == 0)
++                    {
++                        const int k = (int32_t)(coeff_sign_flags << m) >> 31;
++                        blk_coeffs[0] = trans_scale_sat(
++                            (levels[m] ^ k) - k, scale, dc_scale, shift);
++                        --m;
+                     }
+-                    trans_coeff_level = (trans_coeff_level * (int64_t)scale * (int64_t)scale_m + add) >> shift;
+-                    if(trans_coeff_level < 0) {
+-                        if((~trans_coeff_level) & 0xFffffffffff8000)
+-                            trans_coeff_level = -32768;
+-                    } else {
+-                        if(trans_coeff_level & 0xffffffffffff8000)
+-                            trans_coeff_level = 32767;
++
++#if !USE_N_END_1
++                    // If N_END_! set then m was at least 1 initially
++                    if (m >= 0)
++#endif
++                    {
++                        do {
++                            const xy_off_t * const xy_off = scan_xy_off +
++                                significant_coeff_flag_idx[m];
++                            const int k = (int32_t)(coeff_sign_flags << m) >> 31;
++
++                            blk_coeffs[xy_off->coeff] = trans_scale_sat(
++                                (levels[m] ^ k) - k,
++                                scale,
++                                blk_scale[xy_off->scale],
++                                shift);
++                        } while (--m >= 0);
+                     }
+                 }
+-                coeffs[y_c * trafo_size + x_c] = trans_coeff_level;
++
+             }
+         }
+-    }
++    } while ((i = next_subset(s, i, c_idx_nz,
++        significant_coeff_group_flag, scan_x_cg, scan_y_cg, &prev_sig)) >= 0);
+ 
+     if (lc->cu.cu_transquant_bypass_flag) {
+         if (explicit_rdpcm_flag || (s->ps.sps->implicit_rdpcm_enabled_flag &&
+@@ -1496,7 +2078,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+             s->hevcdsp.transform_rdpcm(coeffs, log2_trafo_size, mode);
+         }
+     } else {
+-        if (transform_skip_flag) {
++        if (trans_skip_or_bypass) { // Must be trans_skip as we've already dealt with bypass
+             int rot = s->ps.sps->transform_skip_rotation_enabled_flag &&
+                       log2_trafo_size == 2 &&
+                       lc->cu.pred_mode == MODE_INTRA;
+-- 
+2.7.4
+
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 48f8d56..337dbaa 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -3,7 +3,8 @@ include FFMPEG-VERSION
 DEPS= ../../Makefile.include FFMPEG-VERSION Makefile \
   0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch \
   hevcdsp_ARM_NEON_optimized_epel_functions.patch added_ARM_NEON_optimized_SAO_patches.patch \
-  pfcd_hevc_optimisations.patch
+  pfcd_hevc_optimisations.patch \
+  0001-Squashed-commit-of-the-following.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -71,6 +72,7 @@ ifeq ($(Configuration), Release)
   ffmpg_config += --disable-debug
 endif
 
+ffmpg_config += --extra-cflags="-DRPI=1"
 
 CLEAN_FILES=$(ARCHIVE) $(PLATFORM)
 
@@ -87,6 +89,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); patch -p1 < ../hevcdsp_ARM_NEON_optimized_epel_functions.patch
 	cd $(PLATFORM); patch -p1 < ../added_ARM_NEON_optimized_SAO_patches.patch
 	cd $(PLATFORM); patch -p1 < ../pfcd_hevc_optimisations.patch
+	cd $(PLATFORM); patch -p1 < ../0001-Squashed-commit-of-the-following.patch
 
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
diff --git a/tools/depends/target/ffmpeg/autobuild.sh b/tools/depends/target/ffmpeg/autobuild.sh
index e264109..7022b5f 100755
--- a/tools/depends/target/ffmpeg/autobuild.sh
+++ b/tools/depends/target/ffmpeg/autobuild.sh
@@ -131,6 +131,7 @@ patch -p1 < ../0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
 patch -p1 < ../hevcdsp_ARM_NEON_optimized_epel_functions.patch
 patch -p1 < ../added_ARM_NEON_optimized_SAO_patches.patch
 patch -p1 < ../pfcd_hevc_optimisations.patch
+patch -p1 < ../0001-Squashed-commit-of-the-following.patch
 
 CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
 ./configure --prefix=$FFMPEG_PREFIX \
-- 
2.7.4


From 1e7d128c9f3af4395875cf8ba2347b96a25938b7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 19 Sep 2014 11:54:49 +0100
Subject: [PATCH 137/175] Add pi specific option to maintain vsync with pll
 adjustment

New A/V sync option in settings/video/playback to do "Adjust PLL".
This uses video clock (so perfect video syncing) but avoids having to resample
or drop/dupe audio packets which is normally required.
---
 .../resource.language.en_gb/resources/strings.po   | 32 ++++++++++++++++++++++
 system/settings/rbp.xml                            | 14 ++++++++++
 .../AudioEngine/Engines/ActiveAE/ActiveAE.cpp      | 31 +++++++++++++++------
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h |  9 +++++-
 .../Engines/ActiveAE/ActiveAEStream.cpp            |  7 +++--
 .../AudioEngine/Engines/ActiveAE/ActiveAEStream.h  |  4 ++-
 xbmc/cores/AudioEngine/Interfaces/AEStream.h       | 10 ++++++-
 xbmc/cores/VideoPlayer/DVDAudio.cpp                |  4 +--
 xbmc/cores/VideoPlayer/DVDAudio.h                  |  2 +-
 xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp        | 12 ++++++--
 xbmc/linux/RBP.cpp                                 | 13 +++++++++
 xbmc/linux/RBP.h                                   |  3 ++
 12 files changed, 122 insertions(+), 19 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index a260fdf..a6f7763 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -19673,3 +19673,35 @@ msgstr ""
 msgctxt "#38190"
 msgid "Extract thumbnails from video files"
 msgstr ""
+
+#. Description of setting "System -> Audio Ouput -> A/V sync method" with label #38200
+#: system/settings/settings.xml
+msgctxt "#38200"
+msgid "PLL adjustment to maintain audio/video sync"
+msgstr ""
+
+#. Description of setting "Videos -> Playback -> A/V sync method" with label #38201
+#: system/settings/settings.xml
+msgctxt "#38201"
+msgid "Allows sync adjustment without resampling. Lower the settings if you get audio/video dropouts."
+msgstr ""
+
+msgctxt "#38202"
+msgid "Off"
+msgstr ""
+
+msgctxt "#38203"
+msgid "Low"
+msgstr ""
+
+msgctxt "#38204"
+msgid "Medium"
+msgstr ""
+
+msgctxt "#38205"
+msgid "High"
+msgstr ""
+
+msgctxt "#38206"
+msgid "Max"
+msgstr ""
diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 289dc55..2572e25 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -101,6 +101,20 @@
         <setting id="audiooutput.atempothreshold">
           <default>100</default> <!-- disabled -->
         </setting>
+        <setting id="audiooutput.plladjust" type="integer" label="38200" help="38201">
+          <level>3</level>
+          <default>0</default>
+          <constraints>
+            <options>
+              <option label="38202">0</option> <!-- off -->
+              <option label="38203">1</option> <!-- low -->
+              <option label="38204">2</option> <!-- medium -->
+              <option label="38205">3</option> <!-- high -->
+              <option label="38206">4</option> <!-- max -->
+            </options>
+          </constraints>
+          <control type="spinner" format="string" />
+        </setting>
       </group>
       <group id="3">
         <setting id="audiooutput.ac3transcode" help="37024">
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 8fd85f9..b89a82e 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -34,6 +34,10 @@ using namespace ActiveAE;
 #include "windowing/WindowingFactory.h"
 #include "utils/log.h"
 
+#if defined(TARGET_RASPBERRY_PI)
+#include "linux/RBP.h"
+#endif
+
 #define MAX_CACHE_LEVEL 0.4   // total cache time of stream in seconds
 #define MAX_WATER_LEVEL 0.2   // buffered time after stream stages in seconds
 #define MAX_BUFFER_TIME 0.1   // max time of a buffer in seconds
@@ -363,11 +367,12 @@ void CActiveAE::StateMachine(int signal, Protocol *port, Message *msg)
           m_sink.m_controlPort.SendOutMessage(CSinkControlProtocol::APPFOCUSED, msg->data, sizeof(bool));
           return;
         case CActiveAEControlProtocol::STREAMRESAMPLEMODE:
-          MsgStreamParameter *par;
-          par = (MsgStreamParameter*)msg->data;
+          MsgStreamResample *par;
+          par = (MsgStreamResample*)msg->data;
           if (par->stream)
           {
-            par->stream->m_resampleMode = par->parameter.int_par;
+            par->stream->m_resampleMode = par->mode;
+            par->stream->m_pllAdjust = par->plladjust;
             par->stream->m_resampleIntegral = 0.0;
           }
           return;
@@ -2445,7 +2450,16 @@ CSampleBuffer* CActiveAE::SyncStream(CActiveAEStream *stream)
   if (!newerror || stream->m_syncState != CAESyncInfo::AESyncState::SYNC_INSYNC)
     return ret;
 
-  if (stream->m_resampleMode)
+  if (stream->m_pllAdjust > 0)  // pll adjust
+  {
+#if defined(TARGET_RASPBERRY_PI)
+    double e = std::max(std::min(error / 50.0, 1.0), -1.0);
+    double m_plladjust = 1.0 + e * stream->m_pllAdjust;
+    double m_last_plladjust = g_RBP.AdjustHDMIClock(m_plladjust);
+    CLog::Log(LOGDEBUG, "CDVDPlayerAudio::%s pll:%.5f (%.5f) error:%.6f e:%.6f a:%f", __FUNCTION__, m_plladjust, m_last_plladjust, error, e * stream->m_pllAdjust, stream->m_pllAdjust );
+#endif
+  }
+  else if (stream->m_resampleMode)
   {
     if (stream->m_processingBuffers)
     {
@@ -3313,13 +3327,14 @@ void CActiveAE::SetStreamResampleRatio(CActiveAEStream *stream, double ratio)
                                      &msg, sizeof(MsgStreamParameter));
 }
 
-void CActiveAE::SetStreamResampleMode(CActiveAEStream *stream, int mode)
+void CActiveAE::SetStreamResampleMode(CActiveAEStream *stream, int mode, float plladjust)
 {
-  MsgStreamParameter msg;
+  MsgStreamResample msg;
   msg.stream = stream;
-  msg.parameter.int_par = mode;
+  msg.mode = mode;
+  msg.plladjust = plladjust;
   m_controlPort.SendOutMessage(CActiveAEControlProtocol::STREAMRESAMPLEMODE,
-                               &msg, sizeof(MsgStreamParameter));
+                               &msg, sizeof(MsgStreamResample));
 }
 
 void CActiveAE::SetStreamFFmpegInfo(CActiveAEStream *stream, int profile, enum AVMatrixEncoding matrix_encoding, enum AVAudioServiceType audio_service_type)
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
index 502ee4e..14249e1 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
@@ -175,6 +175,13 @@ struct MsgStreamFFmpegInfo
   enum AVAudioServiceType audio_service_type;
 };
 
+struct MsgStreamResample
+{
+  CActiveAEStream *stream;
+  int mode;
+  float plladjust;
+};
+
 class CEngineStats
 {
 public:
@@ -291,7 +298,7 @@ protected:
   void SetStreamReplaygain(CActiveAEStream *stream, float rgain);
   void SetStreamVolume(CActiveAEStream *stream, float volume);
   void SetStreamResampleRatio(CActiveAEStream *stream, double ratio);
-  void SetStreamResampleMode(CActiveAEStream *stream, int mode);
+  void SetStreamResampleMode(CActiveAEStream *stream, int mode, float plladjust);
   void SetStreamFFmpegInfo(CActiveAEStream *stream, int profile, enum AVMatrixEncoding matrix_encoding, enum AVAudioServiceType audio_service_type);
   void SetStreamFade(CActiveAEStream *stream, float from, float target, unsigned int millis);
 
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
index 246d7e6..394459a 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
@@ -509,11 +509,12 @@ void CActiveAEStream::SetResampleRatio(double ratio)
   m_streamResampleRatio = ratio;
 }
 
-void CActiveAEStream::SetResampleMode(int mode)
+void CActiveAEStream::SetResampleMode(int mode, float plladjust)
 {
-  if (mode != m_streamResampleMode)
-    AE.SetStreamResampleMode(this, mode);
+  if (mode != m_streamResampleMode || plladjust != m_streamPllAdjust)
+    AE.SetStreamResampleMode(this, mode, plladjust);
   m_streamResampleMode = mode;
+  m_streamPllAdjust = plladjust;
 }
 
 void CActiveAEStream::SetFFmpegInfo(int profile, enum AVMatrixEncoding matrix_encoding, enum AVAudioServiceType audio_service_type)
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
index 531dedc..927f93e 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
@@ -169,7 +169,7 @@ public:
   
   virtual double GetResampleRatio();
   virtual void SetResampleRatio(double ratio);
-  virtual void SetResampleMode(int mode);
+  virtual void SetResampleMode(int mode, float plladjust);
   virtual void RegisterAudioCallback(IAudioCallback* pCallback);
   virtual void UnRegisterAudioCallback();
   virtual void FadeVolume(float from, float to, unsigned int time);
@@ -186,6 +186,7 @@ protected:
   float m_streamAmplify;
   double m_streamResampleRatio;
   int m_streamResampleMode;
+  float m_streamPllAdjust;
   unsigned int m_streamSpace;
   bool m_streamDraining;
   bool m_streamDrained;
@@ -226,6 +227,7 @@ protected:
   int m_fadingTime;
   int m_profile;
   int m_resampleMode;
+  float m_pllAdjust;
   double m_resampleIntegral;
   double m_clockSpeed;
   enum AVMatrixEncoding m_matrixEncoding;
diff --git a/xbmc/cores/AudioEngine/Interfaces/AEStream.h b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
index 533f671..9e33493 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AEStream.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
@@ -41,6 +41,14 @@ public:
 class CAESyncInfo
 {
 public:
+  CAESyncInfo()
+  {
+    delay = 0.0;
+    error = 0.0;
+    rr = 1.0;
+    errortime = 0;
+    state = SYNC_OFF;
+  }
   double delay;
   double error;
   double rr;
@@ -231,7 +239,7 @@ public:
   /**
    * Sets the resamplling on/ff
    */
-  virtual void SetResampleMode(int mode) = 0;
+  virtual void SetResampleMode(int mode, float plladjust) = 0;
 
   /**
    * Registers the audio callback to call with each block of data, this is used by Audio Visualizations
diff --git a/xbmc/cores/VideoPlayer/DVDAudio.cpp b/xbmc/cores/VideoPlayer/DVDAudio.cpp
index 2dd9b36..8a7c2a7 100644
--- a/xbmc/cores/VideoPlayer/DVDAudio.cpp
+++ b/xbmc/cores/VideoPlayer/DVDAudio.cpp
@@ -313,12 +313,12 @@ double CDVDAudio::GetResampleRatio()
   return m_resampleRatio;
 }
 
-void CDVDAudio::SetResampleMode(int mode)
+void CDVDAudio::SetResampleMode(int mode, float plladjust)
 {
   CSingleLock lock (m_critSection);
   if(m_pAudioStream)
   {
-    m_pAudioStream->SetResampleMode(mode);
+    m_pAudioStream->SetResampleMode(mode, plladjust);
   }
 }
 
diff --git a/xbmc/cores/VideoPlayer/DVDAudio.h b/xbmc/cores/VideoPlayer/DVDAudio.h
index 81882a1..ed6974b 100644
--- a/xbmc/cores/VideoPlayer/DVDAudio.h
+++ b/xbmc/cores/VideoPlayer/DVDAudio.h
@@ -61,7 +61,7 @@ public:
   double GetSyncError();
   void SetSyncErrorCorrection(double correction);
   double GetResampleRatio();
-  void SetResampleMode(int mode);
+  void SetResampleMode(int mode, float plladjust);
   void Flush();
   void Drain();
   void AbortAddPackets();
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
index 9db3a9c..56170f4 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
@@ -96,6 +96,7 @@ bool CVideoPlayerAudio::OpenStream(CDVDStreamInfo &hints)
   bool allowpassthrough = !CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_USEDISPLAYASCLOCK);
   if (hints.realtime)
     allowpassthrough = false;
+  allowpassthrough |= CSettings::GetInstance().GetInt("audiooutput.plladjust") > 0;
   CDVDAudioCodec* codec = CDVDFactoryCodec::CreateAudioCodec(hints, m_processInfo, allowpassthrough, m_processInfo.AllowDTSHDDecode());
   if(!codec)
   {
@@ -217,8 +218,12 @@ void CVideoPlayerAudio::UpdatePlayerInfo()
 
   //print the inverse of the resample ratio, since that makes more sense
   //if the resample ratio is 0.5, then we're playing twice as fast
+#ifdef TARGET_RASPBERRY_PI
+  s << ", rr:" << std::fixed << std::setprecision(5) << 1.0 / m_dvdAudio.GetResampleRatio() << ", pll:" << std::fixed << std::setprecision(5) << g_RBP.GetAdjustHDMIClock() << ", err:" << std::fixed << std::setprecision(1) << m_dvdAudio.GetSyncError() * 1e-3 << "ms";
+#else
   if (m_synctype == SYNC_RESAMPLE)
     s << ", rr:" << std::fixed << std::setprecision(5) << 1.0 / m_dvdAudio.GetResampleRatio();
+#endif
 
   s << ", att:" << std::fixed << std::setprecision(1) << log(GetCurrentAttenuation()) * 20.0f << " dB";
 
@@ -541,10 +546,12 @@ void CVideoPlayerAudio::SetSyncType(bool passthrough)
     int synctype = (m_synctype >= 0 && m_synctype <= 1) ? m_synctype : 2;
     CLog::Log(LOGDEBUG, "CVideoPlayerAudio:: synctype set to %i: %s", m_synctype, synctypes[synctype]);
     m_prevsynctype = m_synctype;
+    const float plladjusts[] = { 0.0f, 0.00001f, 0.0001f, 0.001f, 0.01f };
+    float plladjust = plladjusts[CSettings::GetInstance().GetInt("audiooutput.plladjust")];
     if (m_synctype == SYNC_RESAMPLE)
-      m_dvdAudio.SetResampleMode(1);
+      m_dvdAudio.SetResampleMode(1, plladjust);
     else
-      m_dvdAudio.SetResampleMode(0);
+      m_dvdAudio.SetResampleMode(0, plladjust);
   }
 }
 
@@ -602,6 +609,7 @@ bool CVideoPlayerAudio::SwitchCodecIfNeeded()
   bool allowpassthrough = !CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_USEDISPLAYASCLOCK);
   if (m_streaminfo.realtime)
     allowpassthrough = false;
+  allowpassthrough |= CSettings::GetInstance().GetInt("audiooutput.plladjust") > 0;
   CDVDAudioCodec *codec = CDVDFactoryCodec::CreateAudioCodec(m_streaminfo, m_processInfo, allowpassthrough, m_processInfo.AllowDTSHDDecode());
   if (!codec || codec->NeedPassthrough() == m_pAudioCodec->NeedPassthrough()) {
     // passthrough state has not changed
diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 92f20e5..3618a68 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -49,6 +49,7 @@ CRBP::CRBP()
   m_DllBcmHost      = new DllBcmHost();
   m_OMX             = new COMXCore();
   m_display = DISPMANX_NO_HANDLE;
+  m_last_pll_adjust = 1.0;
   m_p = NULL;
   m_x = 0;
   m_y = 0;
@@ -162,6 +163,7 @@ void CRBP::CloseDisplay(DISPMANX_DISPLAY_HANDLE_T display)
   assert(s == 0);
   vc_dispmanx_display_close(m_display);
   m_display = DISPMANX_NO_HANDLE;
+  m_last_pll_adjust = 1.0;
 }
 
 void CRBP::GetDisplaySize(int &width, int &height)
@@ -504,4 +506,15 @@ void CRBP::uninit_cursor()
   mailbox_set_cursor_position(m_mb, 0, 0, 0);
 }
 
+double CRBP::AdjustHDMIClock(double adjust)
+{
+  char response[80];
+  vc_gencmd(response, sizeof response, "hdmi_adjust_clock %f", adjust);
+  char *p = strchr(response, '=');
+  if (p)
+    m_last_pll_adjust = atof(p+1);
+  CLog::Log(LOGDEBUG, "CRBP::%s(%.4f) = %.4f", __func__, adjust, m_last_pll_adjust);
+  return m_last_pll_adjust;
+}
+
 #endif
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index 90b04db..084fba8 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -82,6 +82,8 @@ public:
   uint32_t WaitVsync(uint32_t target = ~0U);
   void VSyncCallback();
   int GetMBox() { return m_mb; }
+  double AdjustHDMIClock(double adjust);
+  double GetAdjustHDMIClock() { return m_last_pll_adjust; }
 
 private:
   DllBcmHost *m_DllBcmHost;
@@ -107,6 +109,7 @@ private:
   int m_x;
   int m_y;
   bool m_enabled;
+  double m_last_pll_adjust;
   public:
   void init_cursor();
   void set_cursor(const void *pixels, int width, int height, int hotspot_x, int hotspot_y);
-- 
2.7.4


From 943d785bd8cd5bb22494495abb98656d3be0772f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 7 May 2015 15:35:43 +0100
Subject: [PATCH 138/175] rbp: Support zero copy interface with hevc
 acceleration

---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp | 9 +++++++++
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp          | 5 +++--
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index bd9d08f..63df727 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -369,6 +369,15 @@ bool CDVDVideoCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
     if (tryhw && m_decoderState == STATE_NONE)
     {
       m_decoderState = STATE_HW_SINGLE;
+#ifdef TARGET_RASPBERRY_PI
+      int num_threads = g_cpuInfo.getCPUCount() * 3 / 2;
+      num_threads = std::max(1, std::min(num_threads, 16));
+      if (pCodec->id == AV_CODEC_ID_HEVC)
+        num_threads = 8;
+      m_pCodecContext->thread_count = num_threads;
+      m_pCodecContext->thread_safe_callbacks = 0;
+      CLog::Log(LOGDEBUG, "CDVDVideoCodecFFmpeg - open frame threaded with %d threads", num_threads);
+#endif
     }
     else
     {
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
index 29c4e6d..864650d 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
@@ -290,8 +290,9 @@ bool CDecoder::GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture
   picture->MMALBuffer->mmal_buffer->data = (uint8_t *)gmem->m_vc_handle;
   picture->MMALBuffer->mmal_buffer->alloc_size = picture->MMALBuffer->mmal_buffer->length = gmem->m_numbytes;
 
-  // need to flush ARM cache so GPU can see it
-  gmem->Flush();
+  // need to flush ARM cache so GPU can see it (HEVC will have already done this)
+  if (avctx->codec_id != AV_CODEC_ID_HEVC)
+    gmem->Flush();
 
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s - mmal:%p dts:%.3f pts:%.3f buf:%p gpu:%p", CLASSNAME, __FUNCTION__, picture->MMALBuffer->mmal_buffer, 1e-6*picture->dts, 1e-6*picture->pts, picture->MMALBuffer, gmem);
-- 
2.7.4


From d981d06c32278eba8e6d4de4be3aaad8772a3b0f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 16 May 2015 18:26:04 +0100
Subject: [PATCH 139/175] ffmpeg: use upstream mvc patches

---
 ...vcodec-add-h264_mvc-codec-id-and-profiles.patch |  68 ++++++++++++
 ...er-add-support-for-parsing-h264-mvc-NALUs.patch | 116 +++++++++++++++++++++
 tools/depends/target/ffmpeg/Makefile               |   7 +-
 tools/depends/target/ffmpeg/autobuild.sh           |   3 +
 ...arsing_of_mvc_slices_in_some_corner_cases.patch |  55 ++++++++++
 5 files changed, 248 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/0001-avcodec-add-h264_mvc-codec-id-and-profiles.patch
 create mode 100644 tools/depends/target/ffmpeg/0001-h264_parser-add-support-for-parsing-h264-mvc-NALUs.patch
 create mode 100644 tools/depends/target/ffmpeg/h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch

diff --git a/tools/depends/target/ffmpeg/0001-avcodec-add-h264_mvc-codec-id-and-profiles.patch b/tools/depends/target/ffmpeg/0001-avcodec-add-h264_mvc-codec-id-and-profiles.patch
new file mode 100644
index 0000000..2e7381f
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0001-avcodec-add-h264_mvc-codec-id-and-profiles.patch
@@ -0,0 +1,68 @@
+From 4060f15e2d29e268110032d4366382e370e088d0 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Sun, 26 Jun 2016 20:09:18 +0100
+Subject: [PATCH] avcodec: add h264_mvc codec id and profiles
+
+---
+ libavcodec/avcodec.h    | 5 +++++
+ libavcodec/codec_desc.c | 7 +++++++
+ libavformat/mpegts.c    | 2 +-
+ 3 files changed, 13 insertions(+), 1 deletion(-)
+
+diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
+index a1ba217..abd2e91 100644
+--- a/libavcodec/avcodec.h
++++ b/libavcodec/avcodec.h
+@@ -410,6 +410,8 @@ enum AVCodecID {
+     AV_CODEC_ID_SHEERVIDEO,
+     AV_CODEC_ID_YLC,
+ 
++    AV_CODEC_ID_H264_MVC,
++
+     /* various PCM "codecs" */
+     AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
+     AV_CODEC_ID_PCM_S16LE = 0x10000,
+@@ -3195,6 +3197,9 @@ typedef struct AVCodecContext {
+ #define FF_PROFILE_H264_HIGH_444_PREDICTIVE  244
+ #define FF_PROFILE_H264_HIGH_444_INTRA       (244|FF_PROFILE_H264_INTRA)
+ #define FF_PROFILE_H264_CAVLC_444            44
++#define FF_PROFILE_H264_MULTIVIEW_HIGH       118
++#define FF_PROFILE_H264_STEREO_HIGH          128
++#define FF_PROFILE_H264_MULTIVIEW_HIGH_DEPTH 138
+ 
+ #define FF_PROFILE_VC1_SIMPLE   0
+ #define FF_PROFILE_VC1_MAIN     1
+diff --git a/libavcodec/codec_desc.c b/libavcodec/codec_desc.c
+index 9d94b72..535ebf0 100644
+--- a/libavcodec/codec_desc.c
++++ b/libavcodec/codec_desc.c
+@@ -1563,6 +1563,13 @@ static const AVCodecDescriptor codec_descriptors[] = {
+         .long_name = NULL_IF_CONFIG_SMALL("YUY2 Lossless Codec"),
+         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+     },
++    {
++        .id        = AV_CODEC_ID_H264_MVC,
++        .type      = AVMEDIA_TYPE_VIDEO,
++        .name      = "h264_mvc",
++        .long_name = NULL_IF_CONFIG_SMALL("H264 MVC"),
++        .props     = AV_CODEC_PROP_LOSSY,
++    },
+ 
+     /* various PCM "codecs" */
+     {
+diff --git a/libavformat/mpegts.c b/libavformat/mpegts.c
+index b31d233..2767306 100644
+--- a/libavformat/mpegts.c
++++ b/libavformat/mpegts.c
+@@ -701,7 +701,7 @@ static const StreamType ISO_types[] = {
+ #endif
+     { 0x1b, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_H264       },
+     { 0x1c, AVMEDIA_TYPE_AUDIO, AV_CODEC_ID_AAC        },
+-    { 0x20, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_H264       },
++    { 0x20, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_H264_MVC   },
+     { 0x21, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_JPEG2000   },
+     { 0x24, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_HEVC       },
+     { 0x42, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_CAVS       },
+-- 
+2.7.4
+
diff --git a/tools/depends/target/ffmpeg/0001-h264_parser-add-support-for-parsing-h264-mvc-NALUs.patch b/tools/depends/target/ffmpeg/0001-h264_parser-add-support-for-parsing-h264-mvc-NALUs.patch
new file mode 100644
index 0000000..399e8a9
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0001-h264_parser-add-support-for-parsing-h264-mvc-NALUs.patch
@@ -0,0 +1,116 @@
+From 23dd20678a05e1764e5d8d30481cb354a51b6c8b Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Sun, 26 Jun 2016 20:16:03 +0100
+Subject: [PATCH] h264_parser: add support for parsing h264 mvc NALUs
+
+---
+ libavcodec/allcodecs.c   |  1 +
+ libavcodec/h264.h        |  2 ++
+ libavcodec/h264_parser.c | 34 ++++++++++++++++++++++++++++++----
+ 3 files changed, 33 insertions(+), 4 deletions(-)
+
+diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
+index 54efaad..02a89c3 100644
+--- a/libavcodec/allcodecs.c
++++ b/libavcodec/allcodecs.c
+@@ -667,6 +667,7 @@ void avcodec_register_all(void)
+     REGISTER_PARSER(H261,               h261);
+     REGISTER_PARSER(H263,               h263);
+     REGISTER_PARSER(H264,               h264);
++    REGISTER_PARSER(H264_MVC,           h264_mvc);
+     REGISTER_PARSER(HEVC,               hevc);
+     REGISTER_PARSER(MJPEG,              mjpeg);
+     REGISTER_PARSER(MLP,                mlp);
+diff --git a/libavcodec/h264.h b/libavcodec/h264.h
+index efe3555..16358aa 100644
+--- a/libavcodec/h264.h
++++ b/libavcodec/h264.h
+@@ -126,7 +126,9 @@ enum {
+     NAL_END_STREAM      = 11,
+     NAL_FILLER_DATA     = 12,
+     NAL_SPS_EXT         = 13,
++    NAL_SPS_SUBSET      = 15,
+     NAL_AUXILIARY_SLICE = 19,
++    NAL_SLICE_EXT       = 20,
+     NAL_FF_IGNORE       = 0xff0f001,
+ };
+ 
+diff --git a/libavcodec/h264_parser.c b/libavcodec/h264_parser.c
+index ce4bab2..082ac17 100644
+--- a/libavcodec/h264_parser.c
++++ b/libavcodec/h264_parser.c
+@@ -58,6 +58,7 @@ typedef struct H264ParseContext {
+     uint8_t parse_history[6];
+     int parse_history_count;
+     int parse_last_mb;
++    int is_mvc;
+ } H264ParseContext;
+ 
+ 
+@@ -105,14 +106,18 @@ static int h264_find_frame_end(H264ParseContext *p, const uint8_t *buf,
+         } else if (state <= 5) {
+             int nalu_type = buf[i] & 0x1F;
+             if (nalu_type == NAL_SEI || nalu_type == NAL_SPS ||
+-                nalu_type == NAL_PPS || nalu_type == NAL_AUD) {
++                nalu_type == NAL_PPS || nalu_type == NAL_AUD ||
++                nalu_type == NAL_SPS_SUBSET) {
+                 if (pc->frame_start_found) {
+                     i++;
+                     goto found;
+                 }
+             } else if (nalu_type == NAL_SLICE || nalu_type == NAL_DPA ||
+-                       nalu_type == NAL_IDR_SLICE) {
++                       nalu_type == NAL_IDR_SLICE || (p->is_mvc && nalu_type == NAL_SLICE_EXT)) {
+                 state += 8;
++
++                if (nalu_type == NAL_SLICE_EXT)
++                    i += 3; // skip mvc extension
+                 continue;
+             }
+             state = 7;
+@@ -585,7 +590,8 @@ static int h264_parse(AVCodecParserContext *s,
+         }
+     }
+ 
+-    parse_nal_units(s, avctx, buf, buf_size);
++    if (!p->is_mvc)
++        parse_nal_units(s, avctx, buf, buf_size);
+ 
+     if (avctx->framerate.num)
+         avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));
+@@ -622,7 +628,7 @@ static int h264_split(AVCodecContext *avctx,
+         if ((state & 0xFFFFFF00) != 0x100)
+             break;
+         nalu_type = state & 0x1F;
+-        if (nalu_type == NAL_SPS) {
++        if (nalu_type == NAL_SPS || nalu_type == NAL_SPS_SUBSET) {
+             has_sps = 1;
+         } else if (nalu_type == NAL_PPS)
+             has_pps = 1;
+@@ -672,3 +678,23 @@ AVCodecParser ff_h264_parser = {
+     .parser_close   = h264_close,
+     .split          = h264_split,
+ };
++
++static av_cold int init_mvc(AVCodecParserContext *s)
++{
++    H264ParseContext *p = s->priv_data;
++    int ret = init(s);
++    if (ret < 0)
++        return ret;
++
++    p->is_mvc = 1;
++    return 0;
++}
++
++AVCodecParser ff_h264_mvc_parser = {
++    .codec_ids      = { AV_CODEC_ID_H264_MVC },
++    .priv_data_size = sizeof(H264ParseContext),
++    .parser_init    = init_mvc,
++    .parser_parse   = h264_parse,
++    .parser_close   = h264_close,
++    .split          = h264_split,
++};
+-- 
+2.7.4
+
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 337dbaa..7e97e4d 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -4,7 +4,9 @@ DEPS= ../../Makefile.include FFMPEG-VERSION Makefile \
   0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch \
   hevcdsp_ARM_NEON_optimized_epel_functions.patch added_ARM_NEON_optimized_SAO_patches.patch \
   pfcd_hevc_optimisations.patch \
-  0001-Squashed-commit-of-the-following.patch
+  0001-Squashed-commit-of-the-following.patch \
+  0001-avcodec-add-h264_mvc-codec-id-and-profiles.patch 0001-h264_parser-add-support-for-parsing-h264-mvc-NALUs.patch \
+  h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -90,6 +92,9 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); patch -p1 < ../added_ARM_NEON_optimized_SAO_patches.patch
 	cd $(PLATFORM); patch -p1 < ../pfcd_hevc_optimisations.patch
 	cd $(PLATFORM); patch -p1 < ../0001-Squashed-commit-of-the-following.patch
+	cd $(PLATFORM); patch -p1 < ../0001-avcodec-add-h264_mvc-codec-id-and-profiles.patch
+	cd $(PLATFORM); patch -p1 < ../0001-h264_parser-add-support-for-parsing-h264-mvc-NALUs.patch
+	cd $(PLATFORM); patch -p1 < ../h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch
 
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
diff --git a/tools/depends/target/ffmpeg/autobuild.sh b/tools/depends/target/ffmpeg/autobuild.sh
index 7022b5f..0c323ac 100755
--- a/tools/depends/target/ffmpeg/autobuild.sh
+++ b/tools/depends/target/ffmpeg/autobuild.sh
@@ -132,6 +132,9 @@ patch -p1 < ../hevcdsp_ARM_NEON_optimized_epel_functions.patch
 patch -p1 < ../added_ARM_NEON_optimized_SAO_patches.patch
 patch -p1 < ../pfcd_hevc_optimisations.patch
 patch -p1 < ../0001-Squashed-commit-of-the-following.patch
+patch -p1 < ../0001-avcodec-add-h264_mvc-codec-id-and-profiles.patch
+patch -p1 < ../0001-h264_parser-add-support-for-parsing-h264-mvc-NALUs.patch
+patch -p1 < ../h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch
 
 CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
 ./configure --prefix=$FFMPEG_PREFIX \
diff --git a/tools/depends/target/ffmpeg/h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch b/tools/depends/target/ffmpeg/h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch
new file mode 100644
index 0000000..b39480a
--- /dev/null
+++ b/tools/depends/target/ffmpeg/h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch
@@ -0,0 +1,55 @@
+From 12d99a92469e5916de3bc787dce4c13abfdd5e09 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Sun, 26 Jun 2016 20:20:04 +0100
+Subject: [PATCH] h264_parser: fix parsing of mvc slices in some corner cases
+
+---
+ libavcodec/h264_parser.c | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/libavcodec/h264_parser.c b/libavcodec/h264_parser.c
+index 082ac17..b9b0c78 100644
+--- a/libavcodec/h264_parser.c
++++ b/libavcodec/h264_parser.c
+@@ -59,6 +59,7 @@ typedef struct H264ParseContext {
+     int parse_history_count;
+     int parse_last_mb;
+     int is_mvc;
++    int slice_ext;
+ } H264ParseContext;
+ 
+ 
+@@ -116,18 +117,17 @@ static int h264_find_frame_end(H264ParseContext *p, const uint8_t *buf,
+                        nalu_type == NAL_IDR_SLICE || (p->is_mvc && nalu_type == NAL_SLICE_EXT)) {
+                 state += 8;
+ 
+-                if (nalu_type == NAL_SLICE_EXT)
+-                    i += 3; // skip mvc extension
++                p->slice_ext = (nalu_type == NAL_SLICE_EXT);
+                 continue;
+             }
+             state = 7;
+         } else {
+             p->parse_history[p->parse_history_count++] = buf[i];
+-            if (p->parse_history_count > 5) {
++            if (p->parse_history_count > 8) {
+                 unsigned int mb, last_mb = p->parse_last_mb;
+                 GetBitContext gb;
+ 
+-                init_get_bits(&gb, p->parse_history, 8*p->parse_history_count);
++                init_get_bits8(&gb, p->parse_history + 3*p->slice_ext, p->parse_history_count - 3*p->slice_ext);
+                 p->parse_history_count = 0;
+                 mb= get_ue_golomb_long(&gb);
+                 p->parse_last_mb = mb;
+@@ -150,7 +150,7 @@ found:
+     pc->frame_start_found = 0;
+     if (p->is_avc)
+         return next_avc;
+-    return i - (state & 5) - 5 * (state > 7);
++    return i - (state & 5) - 8 * (state > 7);
+ }
+ 
+ static int scan_mmco_reset(AVCodecParserContext *s, GetBitContext *gb,
+-- 
+2.7.4
+
-- 
2.7.4


From a4c5fb1c260afd98bc638fac82f05bc888ba12db Mon Sep 17 00:00:00 2001
From: Anton Fedchin <afedchin@ruswizards.com>
Date: Wed, 20 Jan 2016 17:02:16 +0300
Subject: [PATCH 140/175] DemuxFFmpeg: Properly demuxing h264_mvc streams.

---
 .../VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp     | 23 +++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index b2f2268..d648bb3 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -25,6 +25,7 @@
 
 #include "commons/Exception.h"
 #include "cores/FFmpeg.h"
+#include "DVDCodecs/DVDCodecUtils.h"
 #include "DVDClock.h" // for DVD_TIME_BASE
 #include "DVDDemuxUtils.h"
 #include "DVDInputStreams/DVDInputStream.h"
@@ -1306,6 +1307,15 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
       }
     case AVMEDIA_TYPE_VIDEO:
       {
+        if (pStream->codec->codec_id == AV_CODEC_ID_H264_MVC)
+        {
+          // ignore MVC extension streams, they are handled specially
+          stream = new CDemuxStream();
+          stream->type = STREAM_DATA;
+          stream->disabled = true;
+          pStream->need_parsing = AVSTREAM_PARSE_NONE;
+          break;
+        }
         CDemuxStreamVideoFFmpeg* st = new CDemuxStreamVideoFFmpeg(this, pStream);
         stream = st;
         if(strcmp(m_pFormatContext->iformat->name, "flv") == 0)
@@ -1314,7 +1324,7 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
           st->bVFR = false;
 
         // never trust pts in avi files with h264.
-        if (m_bAVI && pStream->codec->codec_id == AV_CODEC_ID_H264)
+        if (m_bAVI && (pStream->codec->codec_id == AV_CODEC_ID_H264 || pStream->codec->codec_id == AV_CODEC_ID_H264_MVC))
           st->bPTSInvalid = true;
 
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
@@ -1385,6 +1395,17 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
         if (av_dict_get(pStream->metadata, "title", NULL, 0))
           st->m_description = av_dict_get(pStream->metadata, "title", NULL, 0)->value;
 
+        if (pStream->codec->codec_id == AV_CODEC_ID_H264)
+        {
+          if (CDVDCodecUtils::IsH264AnnexB(m_pFormatContext->iformat->name, pStream))
+          {
+            // TODO
+          }
+          else if (CDVDCodecUtils::ProcessH264MVCExtradata(pStream->codec->extradata, pStream->codec->extradata_size))
+          {
+            pStream->codec->codec_tag = MKTAG('M', 'V', 'C', '1');
+          }
+        }
         break;
       }
     case AVMEDIA_TYPE_DATA:
-- 
2.7.4


From f93da302fc86036ebcf93bdaec791e16d855d537 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <anightik@gmail.com>
Date: Thu, 25 Feb 2016 11:21:25 +0300
Subject: [PATCH 141/175] Added mvc modes.

---
 xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp | 4 ++++
 xbmc/guilib/StereoscopicsManager.cpp                  | 6 +++++-
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp
index 809766a..04ceed1 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp
@@ -104,6 +104,8 @@ namespace RenderManager {
       convert["anaglyph_yellow_blue"]   = 0u;
       convert["block_lr"]               = 0u;
       convert["block_rl"]               = 0u;
+      convert["mvc_lr"]                 = 0u;
+      convert["mvc_rl"]                 = 0u;
     }
     return convert[mode];
   }
@@ -125,6 +127,8 @@ namespace RenderManager {
       convert["col_interleaved_lr"]     = "col_interleaved_rl";
       convert["block_lr"]               = "block_lr";
       convert["block_rl"]               = "block_rl";
+      convert["mvc_lr"]                 = "mvc_rl";
+      convert["mvc_rl"]                 = "mvc_lr";
     }
     std::string res = convert[mode];
     if(res.empty())
diff --git a/xbmc/guilib/StereoscopicsManager.cpp b/xbmc/guilib/StereoscopicsManager.cpp
index 1443aca..6eb0752 100644
--- a/xbmc/guilib/StereoscopicsManager.cpp
+++ b/xbmc/guilib/StereoscopicsManager.cpp
@@ -72,6 +72,10 @@ static const struct StereoModeMap VideoModeToGuiModeMap[] =
   { "anaglyph_yellow_blue",     RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE },
   { "block_lr",                 RENDER_STEREO_MODE_OFF }, // unsupported
   { "block_rl",                 RENDER_STEREO_MODE_OFF }, // unsupported
+  { "mvc_lr",                   RENDER_STEREO_MODE_HARDWAREBASED }, 
+  { "mvc_rl",                   RENDER_STEREO_MODE_HARDWAREBASED },
+  { "mvc_lr",                   RENDER_STEREO_MODE_SPLIT_HORIZONTAL }, // fallback
+  { "mvc_rl",                   RENDER_STEREO_MODE_SPLIT_HORIZONTAL }, // fallback
   {}
 };
 
@@ -310,7 +314,7 @@ int CStereoscopicsManager::ConvertVideoToGuiStereoMode(const std::string &mode)
   size_t i = 0;
   while (VideoModeToGuiModeMap[i].name)
   {
-    if (mode == VideoModeToGuiModeMap[i].name)
+    if (mode == VideoModeToGuiModeMap[i].name && g_Windowing.SupportsStereo(VideoModeToGuiModeMap[i].mode))
       return VideoModeToGuiModeMap[i].mode;
     i++;
   }
-- 
2.7.4


From 3806ad731acb2628ac8ee3354b793faeedcad61f Mon Sep 17 00:00:00 2001
From: Anton Fedchin <afedchin@ruswizards.com>
Date: Sat, 23 Jan 2016 10:21:32 +0300
Subject: [PATCH 142/175] Fix possible wrong aspect.

---
 xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
index 9ff13f6..c395359 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
@@ -182,7 +182,7 @@ void CVideoPlayerVideo::OpenStream(CDVDStreamInfo &hint, CDVDVideoCodec* codec)
   }
 
   // use aspect in stream if available
-  if(hint.forced_aspect)
+  if (hint.forced_aspect && !std::isnan(hint.aspect))
     m_fForcedAspectRatio = hint.aspect;
   else
     m_fForcedAspectRatio = 0.0;
-- 
2.7.4


From 24038e5237d29a6ad2dbfb18fcdc959053a2a142 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <afedchin@ruswizards.com>
Date: Fri, 22 Jan 2016 18:18:33 +0300
Subject: [PATCH 143/175] DemuxFFmpeg: ssif remux

---
 xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt  |   2 +
 .../VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp     |  47 ++++++-
 .../cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h |   2 +
 .../VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp | 156 +++++++++++++++++++++
 .../VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h   |  49 +++++++
 xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in     |   1 +
 xbmc/settings/AdvancedSettings.cpp                 |   2 +-
 7 files changed, 251 insertions(+), 8 deletions(-)
 create mode 100644 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp
 create mode 100644 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h

diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt b/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt
index 63776b1..0da129f 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt
@@ -5,6 +5,7 @@ set(SOURCES DemuxMultiSource.cpp
             DVDDemuxCDDA.cpp
             DVDDemuxClient.cpp
             DVDDemuxFFmpeg.cpp
+            DVDDemuxStreamSSIF.cpp
             DVDDemuxUtils.cpp
             DVDDemuxVobsub.cpp
             DVDFactoryDemuxer.cpp)
@@ -16,6 +17,7 @@ set(HEADERS DemuxMultiSource.h
             DVDDemuxCDDA.h
             DVDDemuxClient.h
             DVDDemuxFFmpeg.h
+            DVDDemuxStreamSSIF.h
             DVDDemuxPacket.h
             DVDDemuxUtils.h
             DVDDemuxVobsub.h
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index d648bb3..ac2c912 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -164,6 +164,7 @@ CDVDDemuxFFmpeg::CDVDDemuxFFmpeg() : CDVDDemux()
   m_currentPts = DVD_NOPTS_VALUE;
   m_bMatroska = false;
   m_bAVI = false;
+  m_pSSIF = nullptr;
   m_speed = DVD_PLAYSPEED_NORMAL;
   m_program = UINT_MAX;
   m_pkt.result = -1;
@@ -535,6 +536,8 @@ void CDVDDemuxFFmpeg::Dispose()
   m_pkt.result = -1;
   av_packet_unref(&m_pkt.pkt);
 
+  SAFE_DELETE(m_pSSIF);
+
   if (m_pFormatContext)
   {
     for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
@@ -585,6 +588,9 @@ void CDVDDemuxFFmpeg::Flush()
 
   m_displayTime = 0;
   m_dtsAtDisplayTime = DVD_NOPTS_VALUE;
+
+  if (m_pSSIF)
+    m_pSSIF->Flush();
 }
 
 void CDVDDemuxFFmpeg::Abort()
@@ -852,7 +858,9 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
     {
       Flush();
     }
-    else if (IsProgramChange())
+    // libavformat is confused by the interleaved SSIF.
+    // Disable program management for those
+    else if (!m_pSSIF && IsProgramChange())
     {
       // update streams
       CreateStreams(m_program);
@@ -880,6 +888,9 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
 
       m_pkt.result = -1;
       av_packet_unref(&m_pkt.pkt);
+
+      if (m_pSSIF)
+        m_pSSIF->Flush();
     }
     else
     {
@@ -889,7 +900,9 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
 
       if (IsVideoReady())
       {
-        if (m_program != UINT_MAX)
+        // libavformat is confused by the interleaved SSIF.
+        // Disable program management for those
+        if (!m_pSSIF && m_program != UINT_MAX )
         {
           /* check so packet belongs to selected program */
           for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
@@ -1038,6 +1051,15 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
         stream = AddStream(pPacket->iStreamId);
       }
     }
+    if (stream && m_pSSIF)
+    {
+      if (stream->type == STREAM_VIDEO || 
+          stream->type == STREAM_DATA)
+        pPacket = m_pSSIF->AddPacket(pPacket);
+
+      if (stream->type == STREAM_DATA && stream->codec == AV_CODEC_ID_H264_MVC && pPacket->iSize)
+        stream = GetStream(pPacket->iStreamId);
+    }
     if (!stream)
     {
       CLog::Log(LOGERROR, "CDVDDemuxFFmpeg::AddStream - internal error, stream is null");
@@ -1067,6 +1089,9 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
   m_pkt.result = -1;
   av_packet_unref(&m_pkt.pkt);
 
+  if (m_pSSIF)
+    m_pSSIF->Flush();
+
   CDVDInputStream::IPosTime* ist = m_pInput->GetIPosTime();
   if (ist)
   {
@@ -1142,6 +1167,9 @@ bool CDVDDemuxFFmpeg::SeekByte(int64_t pos)
   m_pkt.result = -1;
   av_packet_unref(&m_pkt.pkt);
 
+  if (m_pSSIF)
+    m_pSSIF->Flush();
+
   return (ret >= 0);
 }
 
@@ -1309,11 +1337,12 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
       {
         if (pStream->codec->codec_id == AV_CODEC_ID_H264_MVC)
         {
-          // ignore MVC extension streams, they are handled specially
+          m_pSSIF = new CDVDDemuxStreamSSIF();
+          m_pSSIF->SetMVCStreamId(streamIdx);
+
           stream = new CDemuxStream();
           stream->type = STREAM_DATA;
-          stream->disabled = true;
-          pStream->need_parsing = AVSTREAM_PARSE_NONE;
+          pStream->codec->codec_type = AVMEDIA_TYPE_DATA;
           break;
         }
         CDemuxStreamVideoFFmpeg* st = new CDemuxStreamVideoFFmpeg(this, pStream);
@@ -1399,7 +1428,11 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
         {
           if (CDVDCodecUtils::IsH264AnnexB(m_pFormatContext->iformat->name, pStream))
           {
-            // TODO
+            if (m_pSSIF)
+            {
+              m_pSSIF->SetH264StreamId(streamIdx);
+              pStream->codec->codec_tag = MKTAG('A', 'M', 'V', 'C');
+            }
           }
           else if (CDVDCodecUtils::ProcessH264MVCExtradata(pStream->codec->extradata, pStream->codec->extradata_size))
           {
@@ -1492,7 +1525,7 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
     if (langTag)
       strncpy(stream->language, langTag->value, 3);
 
-    if( stream->type != STREAM_NONE && pStream->codec->extradata && pStream->codec->extradata_size > 0 )
+    if (stream->type != STREAM_NONE && pStream->codec->extradata && pStream->codec->extradata_size > 0)
     {
       stream->ExtraSize = pStream->codec->extradata_size;
       stream->ExtraData = new uint8_t[pStream->codec->extradata_size];
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h
index 26cb1b9..49128bf 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -21,6 +21,7 @@
  */
 
 #include "DVDDemux.h"
+#include "DVDDemuxStreamSSIF.h"
 #include "threads/CriticalSection.h"
 #include "threads/SystemClock.h"
 #include <map>
@@ -152,6 +153,7 @@ protected:
   double   m_currentPts; // used for stream length estimation
   bool     m_bMatroska;
   bool     m_bAVI;
+  CDVDDemuxStreamSSIF* m_pSSIF;
   int      m_speed;
   unsigned m_program;
   XbmcThreads::EndTime  m_timeout;
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp
new file mode 100644
index 0000000..e99352a
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp
@@ -0,0 +1,156 @@
+/*
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include "DVDDemuxStreamSSIF.h"
+#include "DVDClock.h"
+#include "DVDDemuxUtils.h"
+#include "utils/log.h"
+
+//#define DEBUG_VERBOSE
+
+DemuxPacket* CDVDDemuxStreamSSIF::AddPacket(DemuxPacket* &srcPkt)
+{
+  if (srcPkt->iStreamId != m_h264StreamId && 
+      srcPkt->iStreamId != m_mvcStreamId)
+    return srcPkt;
+
+  if (srcPkt->iStreamId == m_h264StreamId)
+  {
+    m_H264queue.push(srcPkt);
+  }
+  else if (srcPkt->iStreamId == m_mvcStreamId)
+  {
+    m_MVCqueue.push(srcPkt);
+  }
+
+  return GetMVCPacket();
+}
+
+void CDVDDemuxStreamSSIF::Flush()
+{
+  while (!m_H264queue.empty())
+  {
+    CDVDDemuxUtils::FreeDemuxPacket(m_H264queue.front());
+    m_H264queue.pop();
+  }
+  while (!m_MVCqueue.empty())
+  {
+    CDVDDemuxUtils::FreeDemuxPacket(m_MVCqueue.front());
+    m_MVCqueue.pop();
+  }
+}
+
+DemuxPacket* CDVDDemuxStreamSSIF::MergePacket(DemuxPacket* &srcPkt, DemuxPacket* &appendPkt)
+{
+  DemuxPacket* newpkt = NULL;
+  newpkt = CDVDDemuxUtils::AllocateDemuxPacket(srcPkt->iSize + appendPkt->iSize);
+  newpkt->iSize = srcPkt->iSize + appendPkt->iSize;
+
+  newpkt->pts = srcPkt->pts;
+  newpkt->dts = srcPkt->dts;
+  newpkt->duration = srcPkt->duration;
+  newpkt->iGroupId = srcPkt->iGroupId;
+  newpkt->iStreamId = srcPkt->iStreamId;
+  memcpy(newpkt->pData, srcPkt->pData, srcPkt->iSize);
+  memcpy(newpkt->pData + srcPkt->iSize, appendPkt->pData, appendPkt->iSize);
+
+  CDVDDemuxUtils::FreeDemuxPacket(srcPkt);
+  srcPkt = NULL;
+  CDVDDemuxUtils::FreeDemuxPacket(appendPkt);
+  appendPkt = NULL;
+
+  return newpkt;
+}
+
+DemuxPacket* CDVDDemuxStreamSSIF::GetMVCPacket()
+{
+  // Here, we recreate a h264 MVC packet from the base one + buffered MVC NALU's
+  while (!m_H264queue.empty() && !m_MVCqueue.empty())
+  {
+    DemuxPacket* h264pkt = m_H264queue.front();
+    double tsH264 = (h264pkt->dts != DVD_NOPTS_VALUE ? h264pkt->dts : h264pkt->pts);
+    DemuxPacket* mvcpkt = m_MVCqueue.front();
+    double tsMVC = (mvcpkt->dts != DVD_NOPTS_VALUE ? mvcpkt->dts : mvcpkt->pts);
+
+    if (tsH264 == tsMVC)
+    {
+      m_H264queue.pop();
+      m_MVCqueue.pop();
+
+      while (!m_H264queue.empty())
+      {
+        DemuxPacket* pkt = m_H264queue.front();
+        double ts = (pkt->dts != DVD_NOPTS_VALUE ? pkt->dts : pkt->pts);
+        if (ts == DVD_NOPTS_VALUE)
+        {
+#if defined(DEBUG_VERBOSE)
+          CLog::Log(LOGDEBUG, ">>> MVC merge h264 fragment: %6d+%6d, pts(%.3f/%.3f) dts(%.3f/%.3f)", h264pkt->iSize, pkt->iSize, h264pkt->pts*1e-6, pkt->pts*1e-6, h264pkt->dts*1e-6, pkt->dts*1e-6);
+#endif
+          h264pkt = MergePacket(h264pkt, pkt);
+          m_H264queue.pop();
+        }
+        else
+          break;
+      }
+      while (!m_MVCqueue.empty())
+      {
+        DemuxPacket* pkt = m_MVCqueue.front();
+        double ts = (pkt->dts != DVD_NOPTS_VALUE ? pkt->dts : pkt->pts);
+        if (ts == DVD_NOPTS_VALUE)
+        {
+#if defined(DEBUG_VERBOSE)
+          CLog::Log(LOGDEBUG, ">>> MVC merge mvc fragment: %6d+%6d, pts(%.3f/%.3f) dts(%.3f/%.3f)", mvcpkt->iSize, pkt->iSize, mvcpkt->pts*1e-6, pkt->pts*1e-6, mvcpkt->dts*1e-6, pkt->dts*1e-6);
+#endif
+          mvcpkt = MergePacket(mvcpkt, pkt);
+          m_MVCqueue.pop();
+        }
+        else
+          break;
+      }
+
+#if defined(DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, ">>> MVC merge packet: %6d+%6d, pts(%.3f/%.3f) dts(%.3f/%.3f)", h264pkt->iSize, mvcpkt->iSize, h264pkt->pts*1e-6, mvcpkt->pts*1e-6, h264pkt->dts*1e-6, mvcpkt->dts*1e-6);
+#endif
+      return MergePacket(h264pkt, mvcpkt);
+    }
+    else if (tsH264 > tsMVC)
+    {
+#if defined(DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, ">>> MVC discard  mvc: %6d, pts(%.3f) dts(%.3f)", mvcpkt->iSize, mvcpkt->pts*1e-6, mvcpkt->dts*1e-6);
+#endif
+      CDVDDemuxUtils::FreeDemuxPacket(mvcpkt);
+      m_MVCqueue.pop();
+    }
+    else
+    {
+#if defined(DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, ">>> MVC discard h264: %6d, pts(%.3f) dts(%.3f)", h264pkt->iSize, h264pkt->pts*1e-6, h264pkt->dts*1e-6);
+#endif
+      CDVDDemuxUtils::FreeDemuxPacket(h264pkt);
+      m_H264queue.pop();
+    }
+  }
+
+#if defined(DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, ">>> MVC waiting. MVC(%d) H264(%d)", m_MVCqueue.size(), m_H264queue.size());
+#endif
+
+  return CDVDDemuxUtils::AllocateDemuxPacket(0);
+}
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h
new file mode 100644
index 0000000..8412627
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h
@@ -0,0 +1,49 @@
+#pragma once
+
+/*
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include "DVDDemuxPacket.h"
+#include <queue>
+
+extern "C" {
+#include "libavformat/avformat.h"
+}
+
+class CDVDDemuxStreamSSIF
+{
+public:
+  CDVDDemuxStreamSSIF() {};
+  ~CDVDDemuxStreamSSIF() { Flush(); }
+
+  DemuxPacket* AddPacket(DemuxPacket* &scrPkt);
+  void Flush();
+  void SetH264StreamId(int id) { m_h264StreamId = id; };
+  void SetMVCStreamId(int id) { m_mvcStreamId = id; };
+
+private:
+  DemuxPacket* GetMVCPacket();
+  DemuxPacket* MergePacket(DemuxPacket* &srcPkt, DemuxPacket* &appendPkt);
+
+  std::queue<DemuxPacket*> m_H264queue;
+  std::queue<DemuxPacket*> m_MVCqueue;
+  int m_h264StreamId = 0;
+  int m_mvcStreamId = 0;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in b/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in
index e4f8aed..f3b717d 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in
@@ -10,6 +10,7 @@ SRCS += DVDDemuxUtils.cpp
 SRCS += DVDDemuxVobsub.cpp
 SRCS += DVDDemuxCC.cpp
 SRCS += DVDFactoryDemuxer.cpp
+SRCS += DVDDemuxStreamSSIF.cpp
 
 LIB = DVDDemuxers.a
 
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 2784850..a75687f 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -391,7 +391,7 @@ void CAdvancedSettings::Initialize()
 
   m_pictureExtensions = ".png|.jpg|.jpeg|.bmp|.gif|.ico|.tif|.tiff|.tga|.pcx|.cbz|.zip|.cbr|.rar|.rss|.webp|.jp2|.apng";
   m_musicExtensions = ".nsv|.m4a|.flac|.aac|.strm|.pls|.rm|.rma|.mpa|.wav|.wma|.ogg|.mp3|.mp2|.m3u|.gdm|.imf|.m15|.sfx|.uni|.ac3|.dts|.cue|.aif|.aiff|.wpl|.ape|.mac|.mpc|.mp+|.mpp|.shn|.zip|.rar|.wv|.dsp|.xsp|.xwav|.waa|.wvs|.wam|.gcm|.idsp|.mpdsp|.mss|.spt|.rsd|.sap|.cmc|.cmr|.dmc|.mpt|.mpd|.rmt|.tmc|.tm8|.tm2|.oga|.url|.pxml|.tta|.rss|.wtv|.mka|.tak|.opus|.dff|.dsf";
-  m_videoExtensions = ".m4v|.3g2|.3gp|.nsv|.tp|.ts|.ty|.strm|.pls|.rm|.rmvb|.mpd|.m3u|.m3u8|.ifo|.mov|.qt|.divx|.xvid|.bivx|.vob|.nrg|.img|.iso|.pva|.wmv|.asf|.asx|.ogm|.m2v|.avi|.bin|.dat|.mpg|.mpeg|.mp4|.mkv|.mk3d|.avc|.vp3|.svq3|.nuv|.viv|.dv|.fli|.flv|.rar|.001|.wpl|.zip|.vdr|.dvr-ms|.xsp|.mts|.m2t|.m2ts|.evo|.ogv|.sdp|.avs|.rec|.url|.pxml|.vc1|.h264|.rcv|.rss|.mpls|.webm|.bdmv|.wtv";
+  m_videoExtensions = ".m4v|.3g2|.3gp|.nsv|.tp|.ts|.ty|.strm|.pls|.rm|.rmvb|.mpd|.m3u|.m3u8|.ifo|.mov|.qt|.divx|.xvid|.bivx|.vob|.nrg|.img|.iso|.pva|.wmv|.asf|.asx|.ogm|.m2v|.avi|.bin|.dat|.mpg|.mpeg|.mp4|.mkv|.mk3d|.avc|.vp3|.svq3|.nuv|.viv|.dv|.fli|.flv|.rar|.001|.wpl|.zip|.vdr|.dvr-ms|.xsp|.mts|.m2t|.m2ts|.evo|.ogv|.sdp|.avs|.rec|.url|.pxml|.vc1|.h264|.rcv|.rss|.mpls|.webm|.bdmv|.wtv|.ssif";
   m_subtitlesExtensions = ".utf|.utf8|.utf-8|.sub|.srt|.smi|.rt|.txt|.ssa|.text|.ssa|.aqt|.jss|.ass|.idx|.ifo|.rar|.zip";
   m_discStubExtensions = ".disc";
   // internal music extensions
-- 
2.7.4


From 0bf3369d9b43e0d601e89a008be8b19c17b736e3 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <afedchin@ruswizards.com>
Date: Tue, 23 Feb 2016 16:01:08 +0300
Subject: [PATCH 144/175] bump libbluray to 0.9.2-mvc.

---
 project/BuildDependencies/scripts/0_package.list | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/project/BuildDependencies/scripts/0_package.list b/project/BuildDependencies/scripts/0_package.list
index 4d1be9c..bc4913a 100644
--- a/project/BuildDependencies/scripts/0_package.list
+++ b/project/BuildDependencies/scripts/0_package.list
@@ -17,7 +17,7 @@ freetype-2.6.3-win32-vc140.7z
 giflib-5.1.4-win32-vc140.7z
 jsonschemabuilder-1.0.0-win32-3.7z
 libass-0.13.2-win32-vc140.7z
-libbluray-0.9.3-win32-vc140.7z
+libbluray-0.9.2-mvc-win32-vc120.7z
 libcdio-0.9.3-win32-vc140.7z
 libcec-3.1.0-win32-vc140.7z
 libfribidi-0.19.2-win32.7z
-- 
2.7.4


From 37ae07535afbaf206648d5e26763cd2637e716dd Mon Sep 17 00:00:00 2001
From: Anton Fedchin <afedchin@ruswizards.com>
Date: Tue, 23 Feb 2016 16:02:46 +0300
Subject: [PATCH 145/175] Added support of 3D-BluRay playback.

---
 lib/DllLibbluray.h                                 |   8 +
 xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt  |   2 +
 .../VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp     |  57 ++++-
 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.cpp | 262 +++++++++++++++++++++
 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.h   |  57 +++++
 .../VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp |  40 +++-
 .../VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h   |  12 +-
 xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in     |   1 +
 .../DVDInputStreams/DVDInputStreamBluray.cpp       | 159 +++++++++++--
 .../DVDInputStreams/DVDInputStreamBluray.h         |  20 ++
 10 files changed, 583 insertions(+), 35 deletions(-)
 create mode 100644 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.cpp
 create mode 100644 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.h

diff --git a/lib/DllLibbluray.h b/lib/DllLibbluray.h
index f5a337f..03f9339 100644
--- a/lib/DllLibbluray.h
+++ b/lib/DllLibbluray.h
@@ -31,6 +31,8 @@ extern "C"
 #include <libbluray/log_control.h>
 #include <libbluray/keys.h>
 #include <libbluray/overlay.h>
+#include <libbluray/clpi_parse.h>
+#include <libbluray/mpls_parse.h>
 }
 
 class DllLibblurayInterface
@@ -80,6 +82,8 @@ public:
 #endif
   virtual int      bd_menu_call                 (BLURAY *bd, int64_t pts)=0;
   virtual int      bd_mouse_select              (BLURAY *bd, int64_t pts, uint16_t x, uint16_t y)=0;
+  virtual MPLS_PL* bd_get_title_mpls            (BLURAY *bd) = 0;
+  virtual int      bd_get_clip_infos            (BLURAY *bd, unsigned clip, uint64_t *clip_start_time, uint64_t *stream_start_time, uint64_t *pos, uint64_t *duration) = 0;
 };
 
 class DllLibbluray : public DllDynamic, DllLibblurayInterface
@@ -128,6 +132,8 @@ class DllLibbluray : public DllDynamic, DllLibblurayInterface
 #endif
   DEFINE_METHOD2(int,                 bd_menu_call,              (BLURAY *p1, int64_t p2))
   DEFINE_METHOD4(int,                 bd_mouse_select,           (BLURAY *p1, int64_t p2, uint16_t p3, uint16_t p4))
+  DEFINE_METHOD1(MPLS_PL*,            bd_get_title_mpls,         (BLURAY *p1))
+  DEFINE_METHOD6(int,                 bd_get_clip_infos,         (BLURAY *p1, unsigned p2, uint64_t *p3, uint64_t *p4, uint64_t *p5, uint64_t *p6))
 
   BEGIN_METHOD_RESOLVE()
     RESOLVE_METHOD(bd_get_titles)
@@ -172,6 +178,8 @@ class DllLibbluray : public DllDynamic, DllLibblurayInterface
 #endif
     RESOLVE_METHOD(bd_menu_call)
     RESOLVE_METHOD(bd_mouse_select)
+    RESOLVE_METHOD(bd_get_title_mpls)
+    RESOLVE_METHOD(bd_get_clip_infos)
   END_METHOD_RESOLVE()
 
 public:
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt b/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt
index 0da129f..82d4b49 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt
@@ -5,6 +5,7 @@ set(SOURCES DemuxMultiSource.cpp
             DVDDemuxCDDA.cpp
             DVDDemuxClient.cpp
             DVDDemuxFFmpeg.cpp
+            DVDDemuxMVC.cpp
             DVDDemuxStreamSSIF.cpp
             DVDDemuxUtils.cpp
             DVDDemuxVobsub.cpp
@@ -17,6 +18,7 @@ set(HEADERS DemuxMultiSource.h
             DVDDemuxCDDA.h
             DVDDemuxClient.h
             DVDDemuxFFmpeg.h
+            DVDDemuxMVC.h
             DVDDemuxStreamSSIF.h
             DVDDemuxPacket.h
             DVDDemuxUtils.h
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index ac2c912..511b44b 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -27,6 +27,7 @@
 #include "cores/FFmpeg.h"
 #include "DVDCodecs/DVDCodecUtils.h"
 #include "DVDClock.h" // for DVD_TIME_BASE
+#include "DVDDemuxMVC.h"
 #include "DVDDemuxUtils.h"
 #include "DVDInputStreams/DVDInputStream.h"
 #include "DVDInputStreams/DVDInputStreamFFmpeg.h"
@@ -495,6 +496,16 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo, bool filein
 
   UpdateCurrentPTS();
 
+  if (!fileinfo && m_pInput->IsStreamType(DVDSTREAM_TYPE_BLURAY))
+  {
+    CDVDInputStreamBluray *bluRay = static_cast<CDVDInputStreamBluray*>(m_pInput);
+    if (bluRay->HasMVC())
+    {
+      SAFE_DELETE(m_pSSIF);
+      m_pSSIF = new CDVDDemuxStreamSSIF();
+      m_pSSIF->SetBluRay(bluRay);
+    }
+  }
   // in case of mpegts and we have not seen pat/pmt, defer creation of streams
   if (!skipCreateStreams || m_pFormatContext->nb_programs > 0)
   {
@@ -858,9 +869,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
     {
       Flush();
     }
-    // libavformat is confused by the interleaved SSIF.
-    // Disable program management for those
-    else if (!m_pSSIF && IsProgramChange())
+    else if (IsProgramChange())
     {
       // update streams
       CreateStreams(m_program);
@@ -901,8 +910,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
       if (IsVideoReady())
       {
         // libavformat is confused by the interleaved SSIF.
-        // Disable program management for those
-        if (!m_pSSIF && m_program != UINT_MAX )
+        if ((!m_pSSIF || m_pSSIF->IsBluRay()) && m_program != UINT_MAX)
         {
           /* check so packet belongs to selected program */
           for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
@@ -1053,10 +1061,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
     }
     if (stream && m_pSSIF)
     {
-      if (stream->type == STREAM_VIDEO || 
-          stream->type == STREAM_DATA)
-        pPacket = m_pSSIF->AddPacket(pPacket);
-
+      pPacket = m_pSSIF->AddPacket(pPacket);
       if (stream->type == STREAM_DATA && stream->codec == AV_CODEC_ID_H264_MVC && pPacket->iSize)
         stream = GetStream(pPacket->iStreamId);
     }
@@ -1432,6 +1437,29 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
             {
               m_pSSIF->SetH264StreamId(streamIdx);
               pStream->codec->codec_tag = MKTAG('A', 'M', 'V', 'C');
+
+              AVStream* mvcStream = nullptr;
+              if (m_pInput->IsStreamType(DVDSTREAM_TYPE_BLURAY))
+              {
+                CDVDInputStreamBluray *bluRay = static_cast<CDVDInputStreamBluray*>(m_pInput);
+                if (bluRay->HasMVC())
+                {
+                  st->stereo_mode = bluRay->AreEyesFlipped() ? "mvc_rl" : "mvc_lr";
+                  mvcStream = static_cast<CDVDDemuxMVC*>(bluRay->GetDemuxMVC())->GetAVStream();
+                }
+              }
+              else
+                mvcStream = m_pFormatContext->streams[m_pSSIF->GetMVCStreamId()];
+
+              if (mvcStream && pStream->codec->extradata_size > 0 && mvcStream->codec->extradata_size > 0)
+              {
+                uint8_t* extr = pStream->codec->extradata;
+                pStream->codec->extradata = (uint8_t*)av_mallocz(pStream->codec->extradata_size + mvcStream->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                memcpy(pStream->codec->extradata, extr, pStream->codec->extradata_size);
+                memcpy(pStream->codec->extradata + pStream->codec->extradata_size, mvcStream->codec->extradata, mvcStream->codec->extradata_size);
+                pStream->codec->extradata_size += mvcStream->codec->extradata_size;
+                av_free(extr);
+              }
             }
           }
           else if (CDVDCodecUtils::ProcessH264MVCExtradata(pStream->codec->extradata, pStream->codec->extradata_size))
@@ -1692,6 +1720,12 @@ bool CDVDDemuxFFmpeg::SeekChapter(int chapter, double* startpts)
     }
 
     Flush();
+    if (m_pInput->IsStreamType(DVDSTREAM_TYPE_BLURAY) 
+      && static_cast<CDVDInputStreamBluray*>(m_pInput)->HasMVC())
+    {
+      // also empty the internal ffmpeg buffer otherwise it may cause MVC buffers hang
+      m_ioContext->buf_ptr = m_ioContext->buf_end;
+    }
     return true;
   }
 
@@ -1736,6 +1770,11 @@ std::string CDVDDemuxFFmpeg::GetStreamCodecName(int iStreamId)
 
 bool CDVDDemuxFFmpeg::IsProgramChange()
 {
+  // libavformat is confused by the interleaved SSIF.
+  // disable program management for those
+  if (m_pSSIF && !m_pSSIF->IsBluRay())
+    return false;
+
   if (m_program == UINT_MAX)
     return false;
 
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.cpp
new file mode 100644
index 0000000..4ed7c43
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.cpp
@@ -0,0 +1,262 @@
+/*
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include "DVDDemuxMVC.h"
+#include "DVDDemuxUtils.h"
+#include "DVDInputStreams/DVDInputStream.h"
+#include "DVDClock.h"
+#include "cores/FFmpeg.h"
+#include "utils/log.h"
+
+extern "C" {
+#include "libavutil/opt.h"
+};
+
+#define MVC_SEEK_TIME_WINDOW 75000 // experimental value depends on seeking accurate
+
+static int mvc_file_read(void *h, uint8_t* buf, int size)
+{
+  CDVDInputStream* pInputStream = static_cast<CDVDDemuxMVC*>(h)->m_pInput;
+  return pInputStream->Read(buf, size);
+}
+
+static int64_t mvc_file_seek(void *h, int64_t pos, int whence)
+{
+  CDVDInputStream* pInputStream = static_cast<CDVDDemuxMVC*>(h)->m_pInput;
+  if (whence == AVSEEK_SIZE)
+    return pInputStream->GetLength();
+  else
+    return pInputStream->Seek(pos, whence & ~AVSEEK_FORCE);
+}
+
+CDVDDemuxMVC::CDVDDemuxMVC()
+{
+  m_ioContext = nullptr;
+  m_pFormatContext = nullptr;
+  m_pInput = nullptr;
+  m_nStreamIndex = -1;
+}
+
+CDVDDemuxMVC::~CDVDDemuxMVC()
+{
+  Dispose();
+}
+
+bool CDVDDemuxMVC::Open(CDVDInputStream* pInput)
+{
+  int ret;
+
+  if (!pInput)
+    return false;
+  m_pInput = pInput;
+
+  unsigned char* buffer = (unsigned char*)av_malloc(FFMPEG_FILE_BUFFER_SIZE);
+  m_ioContext = avio_alloc_context(buffer, FFMPEG_FILE_BUFFER_SIZE, 0, this, mvc_file_read, NULL, mvc_file_seek);
+  m_ioContext->max_packet_size = m_pInput->GetBlockSize();
+  if (m_ioContext->max_packet_size)
+    m_ioContext->max_packet_size *= FFMPEG_FILE_BUFFER_SIZE / m_ioContext->max_packet_size;
+
+  m_pFormatContext = avformat_alloc_context();
+  m_pFormatContext->pb = m_ioContext;
+
+  AVInputFormat *format = av_find_input_format("mpegts");
+  ret = avformat_open_input(&m_pFormatContext, m_pInput->GetFileName().c_str(), format, nullptr);
+  if (ret < 0)
+  {
+    CLog::Log(LOGDEBUG, "%s: Opening MVC demuxing context failed (%d)", __FUNCTION__, ret);
+    Dispose();
+    return false;
+  }
+
+  av_opt_set_int(m_pFormatContext, "analyzeduration", 500000, 0);
+  av_opt_set_int(m_pFormatContext, "correct_ts_overflow", 0, 0);
+  m_pFormatContext->flags |= AVFMT_FLAG_KEEP_SIDE_DATA;
+
+  // Find the streams
+  ret = avformat_find_stream_info(m_pFormatContext, nullptr);
+  //it always returns -1 so just ignore it
+  //if (ret < 0) 
+  //{
+  //  CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::OpenMVCDemuxer(): avformat_find_stream_info failed (%d)", ret);
+  //  Dispose();
+  //  return false;
+  //}
+
+  // print some extra information
+  av_dump_format(m_pFormatContext, 0, m_pInput->GetFileName().c_str(), 0);
+
+  // Find and select our MVC stream
+  CLog::Log(LOGDEBUG, "%s: MVC m2ts has %d streams", __FUNCTION__, m_pFormatContext->nb_streams);
+  for (unsigned i = 0; i < m_pFormatContext->nb_streams; i++)
+  {
+    if (m_pFormatContext->streams[i]->codec->codec_id == AV_CODEC_ID_H264_MVC
+      && m_pFormatContext->streams[i]->codec->extradata_size > 0)
+    {
+      m_nStreamIndex = i;
+      break;
+    }
+    else
+      m_pFormatContext->streams[i]->discard = AVDISCARD_ALL;
+  }
+
+  if (m_nStreamIndex < 0)
+  {
+    CLog::Log(LOGDEBUG, "%s: MVC Stream not found", __FUNCTION__);
+    Dispose();
+    return false;
+  }
+
+  return true;
+}
+
+void CDVDDemuxMVC::Reset()
+{
+  CDVDInputStream* pInput = m_pInput;
+  Dispose();
+  Open(pInput);
+}
+
+void CDVDDemuxMVC::Abort()
+{
+}
+
+void CDVDDemuxMVC::Flush()
+{
+  if (m_pFormatContext)
+    avformat_flush(m_pFormatContext);
+}
+
+DemuxPacket* CDVDDemuxMVC::Read()
+{
+  int ret;
+  AVPacket mvcPacket = { 0 };
+  av_init_packet(&mvcPacket);
+
+  while (true)
+  {
+    ret = av_read_frame(m_pFormatContext, &mvcPacket);
+
+    if (ret == AVERROR(EINTR) || ret == AVERROR(EAGAIN))
+      continue;
+    else if (ret == AVERROR_EOF)
+      break;
+    else if (mvcPacket.size <= 0 || mvcPacket.stream_index != m_nStreamIndex)
+    {
+      av_packet_unref(&mvcPacket);
+      continue;
+    }
+    else
+    {
+      AVStream *stream = m_pFormatContext->streams[mvcPacket.stream_index];
+      double dts = ConvertTimestamp(mvcPacket.dts, stream->time_base.den, stream->time_base.num);
+      double pts = ConvertTimestamp(mvcPacket.pts, stream->time_base.den, stream->time_base.num);
+
+      DemuxPacket* newPkt = CDVDDemuxUtils::AllocateDemuxPacket(mvcPacket.size);
+      if (mvcPacket.data)
+        memcpy(newPkt->pData, mvcPacket.data, mvcPacket.size);
+      newPkt->iSize = mvcPacket.size;
+      newPkt->dts = dts;
+      newPkt->pts = pts;
+      newPkt->iStreamId = stream->id;
+
+      av_packet_unref(&mvcPacket);
+      return newPkt;
+    }
+  }
+
+  return nullptr;
+}
+
+bool CDVDDemuxMVC::SeekTime(int time, bool backwords, double* startpts)
+{
+  if (!m_pInput)
+    return false;
+
+  AVRational time_base = m_pFormatContext->streams[m_nStreamIndex]->time_base;
+  int64_t seek_pts = av_rescale(DVD_MSEC_TO_TIME(time), time_base.den, (int64_t)time_base.num * AV_TIME_BASE);
+  int64_t starttime = 0;
+
+  if (m_pFormatContext->start_time != (int64_t)AV_NOPTS_VALUE)
+    starttime = av_rescale(m_pFormatContext->start_time, time_base.den, (int64_t)time_base.num * AV_TIME_BASE);
+  if (starttime != 0)
+    seek_pts += starttime;
+  if (seek_pts < MVC_SEEK_TIME_WINDOW)
+    seek_pts = 0;
+  else 
+    seek_pts -= MVC_SEEK_TIME_WINDOW;
+
+  av_seek_frame(m_pFormatContext, m_nStreamIndex, seek_pts, AVSEEK_FLAG_BACKWARD);
+  return true;
+}
+
+std::string CDVDDemuxMVC::GetFileName()
+{
+  return m_pInput->GetFileName();
+}
+
+AVStream* CDVDDemuxMVC::GetAVStream()
+{
+  return m_pFormatContext ? m_pFormatContext->streams[m_nStreamIndex] : nullptr;
+}
+
+void CDVDDemuxMVC::Dispose()
+{
+  if (m_pFormatContext)
+    avformat_close_input(&m_pFormatContext);
+
+  if (m_ioContext)
+  {
+    av_free(m_ioContext->buffer);
+    av_free(m_ioContext);
+  }
+
+  m_ioContext = nullptr;
+  m_pFormatContext = nullptr;
+  m_pInput = nullptr;
+  m_nStreamIndex = -1;
+}
+
+double CDVDDemuxMVC::ConvertTimestamp(int64_t pts, int den, int num)
+{
+  if (pts == (int64_t)AV_NOPTS_VALUE)
+    return DVD_NOPTS_VALUE;
+
+  // do calculations in floats as they can easily overflow otherwise
+  // we don't care for having a completly exact timestamp anyway
+  double timestamp = (double)pts * num / den;
+  double starttime = 0.0f;
+
+  /*if (m_MVCFormatContext->start_time != (int64_t)AV_NOPTS_VALUE)
+  starttime = (double)m_MVCFormatContext->start_time / AV_TIME_BASE;*/
+
+  if (timestamp > starttime)
+    timestamp -= starttime;
+  // allow for largest possible difference in pts and dts for a single packet
+  else if (timestamp + 0.5f > starttime)
+    timestamp = 0;
+
+  return timestamp * DVD_TIME_BASE;
+}
+
+std::vector<CDemuxStream*> CDVDDemuxMVC::GetStreams() const
+{
+  std::vector<CDemuxStream*> streams;
+  return streams;
+}
\ No newline at end of file
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.h
new file mode 100644
index 0000000..284358f
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxMVC.h
@@ -0,0 +1,57 @@
+#pragma once
+
+/*
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include "DVDDemux.h"
+
+extern "C" {
+#include "libavformat/avformat.h"
+}
+
+class CDVDDemuxMVC : public CDVDDemux
+{
+public:
+  CDVDDemuxMVC();
+  virtual ~CDVDDemuxMVC();
+  bool Open(CDVDInputStream* pInput);
+  virtual void Reset();
+  virtual void Abort();
+  virtual void Flush();
+  virtual DemuxPacket* Read();
+  virtual bool SeekTime(int time, bool backwords = false, double* startpts = nullptr);
+  virtual void SetSpeed(int iSpeed) { };
+  virtual int GetStreamLength() { return 0; };
+  virtual CDemuxStream* GetStream(int iStreamId) const override { return nullptr; };
+  virtual std::vector<CDemuxStream*> GetStreams() const override;
+  virtual int GetNrOfStreams() const override { return 1; };
+  virtual std::string GetFileName();
+
+  AVStream* GetAVStream();
+  CDVDInputStream*    m_pInput;
+
+private:
+  void Dispose();
+  double ConvertTimestamp(int64_t pts, int den, int num);
+
+  AVIOContext        *m_ioContext = nullptr;
+  AVFormatContext    *m_pFormatContext = nullptr;
+  int                 m_nStreamIndex = -1;
+};
\ No newline at end of file
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp
index e99352a..e390529 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.cpp
@@ -19,11 +19,13 @@
 */
 
 #include "DVDDemuxStreamSSIF.h"
+#include "DVDDemux.h"
 #include "DVDClock.h"
 #include "DVDDemuxUtils.h"
 #include "utils/log.h"
 
 //#define DEBUG_VERBOSE
+#define MVC_QUEUE_SIZE 100
 
 DemuxPacket* CDVDDemuxStreamSSIF::AddPacket(DemuxPacket* &srcPkt)
 {
@@ -37,7 +39,7 @@ DemuxPacket* CDVDDemuxStreamSSIF::AddPacket(DemuxPacket* &srcPkt)
   }
   else if (srcPkt->iStreamId == m_mvcStreamId)
   {
-    m_MVCqueue.push(srcPkt);
+    AddMVCExtPacket(srcPkt);
   }
 
   return GetMVCPacket();
@@ -81,6 +83,10 @@ DemuxPacket* CDVDDemuxStreamSSIF::MergePacket(DemuxPacket* &srcPkt, DemuxPacket*
 
 DemuxPacket* CDVDDemuxStreamSSIF::GetMVCPacket()
 {
+  // if input is a bluray fill mvc queue before processing
+  if (m_bluRay && m_MVCqueue.empty() && !m_H264queue.empty())
+    FillMVCQueue(m_H264queue.front()->dts);
+
   // Here, we recreate a h264 MVC packet from the base one + buffered MVC NALU's
   while (!m_H264queue.empty() && !m_MVCqueue.empty())
   {
@@ -151,6 +157,36 @@ DemuxPacket* CDVDDemuxStreamSSIF::GetMVCPacket()
 #if defined(DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, ">>> MVC waiting. MVC(%d) H264(%d)", m_MVCqueue.size(), m_H264queue.size());
 #endif
-
   return CDVDDemuxUtils::AllocateDemuxPacket(0);
 }
+
+void CDVDDemuxStreamSSIF::AddMVCExtPacket(DemuxPacket* &mvcExtPkt)
+{
+  m_MVCqueue.push(mvcExtPkt);
+}
+
+bool CDVDDemuxStreamSSIF::FillMVCQueue(double dtsBase)
+{
+  if (!m_bluRay)
+    return false;
+
+  CDVDDemux* demux = m_bluRay->GetDemuxMVC();
+  DemuxPacket* mvc;
+  while ((m_MVCqueue.size() < MVC_QUEUE_SIZE) && (mvc = demux->Read()))
+  {
+    if (dtsBase == DVD_NOPTS_VALUE || mvc->dts == DVD_NOPTS_VALUE)
+    {
+      // do nothing, can't compare timestamps when they are not set
+    }
+    else if (mvc->dts < dtsBase)
+    {
+#if defined(DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, ">>> MVC discard mvc: %6d, pts(%.3f) dts(%.3f)", mvc->iSize, mvc->pts*1e-6, mvc->dts*1e-6);
+#endif
+      CDVDDemuxUtils::FreeDemuxPacket(mvc);
+      continue;
+    }
+    AddMVCExtPacket(mvc);
+  };
+  return m_MVCqueue.size() == MVC_QUEUE_SIZE;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h
index 8412627..579c382 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxStreamSSIF.h
@@ -21,6 +21,7 @@
 */
 
 #include "DVDDemuxPacket.h"
+#include "DVDInputStreams/DVDInputStreamBluray.h"
 #include <queue>
 
 extern "C" {
@@ -37,13 +38,20 @@ public:
   void Flush();
   void SetH264StreamId(int id) { m_h264StreamId = id; };
   void SetMVCStreamId(int id) { m_mvcStreamId = id; };
+  int GetH264StreamId() { return m_h264StreamId; };
+  int GetMVCStreamId() { return m_mvcStreamId; };
+  void AddMVCExtPacket(DemuxPacket* &scrPkt);
+  void SetBluRay(CDVDInputStreamBluray* &bluRay) { m_bluRay = bluRay; };
+  bool IsBluRay() { return m_bluRay != nullptr; };
 
 private:
   DemuxPacket* GetMVCPacket();
   DemuxPacket* MergePacket(DemuxPacket* &srcPkt, DemuxPacket* &appendPkt);
+  bool FillMVCQueue(double dtsBase);
 
+  CDVDInputStreamBluray*   m_bluRay = nullptr;
   std::queue<DemuxPacket*> m_H264queue;
   std::queue<DemuxPacket*> m_MVCqueue;
-  int m_h264StreamId = 0;
-  int m_mvcStreamId = 0;
+  int m_h264StreamId = -1;
+  int m_mvcStreamId = -1;
 };
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in b/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in
index f3b717d..80ceeea 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in
@@ -11,6 +11,7 @@ SRCS += DVDDemuxVobsub.cpp
 SRCS += DVDDemuxCC.cpp
 SRCS += DVDFactoryDemuxer.cpp
 SRCS += DVDDemuxStreamSSIF.cpp
+SRCS += DVDDemuxMVC.cpp
 
 LIB = DVDDemuxers.a
 
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp
index 6ccd9a8..5e85db2 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp
@@ -26,6 +26,8 @@
 #include "IVideoPlayer.h"
 #include "DVDCodecs/Overlay/DVDOverlay.h"
 #include "DVDCodecs/Overlay/DVDOverlayImage.h"
+#include "DVDInputStreamFile.h"
+#include "DVDDemuxers/DVDDemuxMVC.h"
 #include "settings/Settings.h"
 #include "LangInfo.h"
 #include "utils/log.h"
@@ -231,10 +233,8 @@ bool CDVDInputStreamBluray::IsEOF()
 
 BLURAY_TITLE_INFO* CDVDInputStreamBluray::GetTitleLongest()
 {
-  int titles = m_dll->bd_get_titles(m_bd, TITLES_RELEVANT, 0);
-
   BLURAY_TITLE_INFO *s = NULL;
-  for(int i=0; i < titles; i++)
+  for(int i=0; i < m_nTitles; i++)
   {
     BLURAY_TITLE_INFO *t = m_dll->bd_get_title_info(m_bd, i, 0);
     if(!t)
@@ -326,6 +326,7 @@ bool CDVDInputStreamBluray::Open()
     return false;
   }
 
+  m_root = root;
   const BLURAY_DISC_INFO *disc_info;
 
   disc_info = m_dll->bd_get_disc_info(m_bd);
@@ -349,6 +350,7 @@ bool CDVDInputStreamBluray::Open()
     CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::Open - BD+ detected        : %d", disc_info->bdplus_detected);
     CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::Open - libbdplus detected  : %d", disc_info->libbdplus_detected);
     CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::Open - BD+ handled         : %d", disc_info->bdplus_handled);
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::Open - 3D content exist    : %d", disc_info->content_exist_3D);
   }
   else
     CLog::Log(LOGERROR, "CDVDInputStreamBluray::Open - BluRay not detected");
@@ -365,6 +367,7 @@ bool CDVDInputStreamBluray::Open()
     return false;
   }
 
+  m_nTitles = m_dll->bd_get_titles(m_bd, TITLES_RELEVANT, 0);
   int mode = CSettings::GetInstance().GetInt(CSettings::SETTING_DISC_PLAYBACK);
 
   if (URIUtils::HasExtension(filename, ".mpls"))
@@ -393,18 +396,17 @@ bool CDVDInputStreamBluray::Open()
       m_title = GetTitleLongest();
   }
 
-  if(m_navmode)
+  SetupPlayerSettings();
+  m_dll->bd_get_event(m_bd, NULL);
+
+  if (m_navmode)
   {
-    SetupPlayerSettings();
 
     m_dll->bd_register_overlay_proc (m_bd, this, bluray_overlay_cb);
 #ifdef HAVE_LIBBLURAY_BDJ
     m_dll->bd_register_argb_overlay_proc (m_bd, this, bluray_overlay_argb_cb, NULL);
 #endif
 
-    m_dll->bd_get_event(m_bd, NULL);
-
-
     if(m_dll->bd_play(m_bd) <= 0)
     {
       CLog::Log(LOGERROR, "CDVDInputStreamBluray::Open - failed play disk %s", strPath.c_str());
@@ -419,21 +421,25 @@ bool CDVDInputStreamBluray::Open()
       CLog::Log(LOGERROR, "CDVDInputStreamBluray::Open - failed to get title info");
       return false;
     }
-
-    if(m_dll->bd_select_playlist(m_bd, m_title->playlist) == 0 )
+    if (m_dll->bd_select_playlist(m_bd, m_title->playlist) == 0)
     {
       CLog::Log(LOGERROR, "CDVDInputStreamBluray::Open - failed to select title %d", m_title->idx);
       return false;
     }
-    m_clip = 0;
   }
 
+  // Process any events that occured during opening
+  while (m_dll->bd_get_event(m_bd, &m_event))
+    ProcessEvent();
+
   return true;
 }
 
 // close file and reset everyting
 void CDVDInputStreamBluray::Close()
 {
+  CloseMVCDemux();
+
   if (!m_dll)
     return;
   if(m_title)
@@ -449,7 +455,7 @@ void CDVDInputStreamBluray::Close()
 
 void CDVDInputStreamBluray::ProcessEvent() {
 
-  int pid = -1;
+  int pid = -1, ret;
   switch (m_event.event) {
 
   case BD_EVENT_ERROR:
@@ -514,15 +520,17 @@ void CDVDInputStreamBluray::ProcessEvent() {
     CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYLIST %d",
         m_event.param);
     m_playlist = m_event.param;
-    if(m_title)
-      m_dll->bd_free_title_info(m_title);
-    m_title = m_dll->bd_get_playlist_info(m_bd, m_playlist, m_angle);
+    ProcessItem(m_playlist);
     break;
 
   case BD_EVENT_PLAYITEM:
     CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYITEM %d",
         m_event.param);
     m_clip    = m_event.param;
+    uint64_t clip_start, clip_in, bytepos;
+    ret = m_dll->bd_get_clip_infos(m_bd, m_clip, &clip_start, &clip_in, &bytepos, nullptr);
+    if (ret) 
+      m_clipStartTime = clip_start / 90;
     break;
 
   case BD_EVENT_CHAPTER:
@@ -601,14 +609,20 @@ void CDVDInputStreamBluray::ProcessEvent() {
 
   /* event has been consumed */
   m_event.event = BD_EVENT_NONE;
+
+  if (m_bMVCPlayback && m_clip >= 0 && m_title && m_clip < m_title->clip_count && m_nMVCClip != m_clip)
+  {
+    CloseMVCDemux();
+    OpenMVCDemux(m_clip);
+  }
 }
 
 int CDVDInputStreamBluray::Read(uint8_t* buf, int buf_size)
 {
+  int result = 0;
   m_dispTimeBeforeRead = (int)(m_dll->bd_tell_time(m_bd) / 90);
   if(m_navmode)
   {
-    int result = 0;
     do {
 
       if(m_hold == HOLD_HELD)
@@ -658,10 +672,14 @@ int CDVDInputStreamBluray::Read(uint8_t* buf, int buf_size)
 
     } while(result == 0);
 
-    return result;
   }
   else
-    return m_dll->bd_read(m_bd, buf, buf_size);
+  {
+    result = m_dll->bd_read(m_bd, buf, buf_size);
+    while (m_dll->bd_get_event(m_bd, &m_event))
+      ProcessEvent();
+  }
+  return result;
 }
 
 static uint8_t  clamp(double v)
@@ -909,8 +927,12 @@ bool CDVDInputStreamBluray::PosTime(int ms)
 {
   if(m_dll->bd_seek_time(m_bd, ms * 90) < 0)
     return false;
-  else
-    return true;
+
+  while (m_dll->bd_get_event(m_bd, &m_event))
+    ProcessEvent();
+
+  SeekMVCDemux(ms - m_clipStartTime);
+  return true;
 }
 
 int CDVDInputStreamBluray::GetChapterCount()
@@ -933,8 +955,12 @@ bool CDVDInputStreamBluray::SeekChapter(int ch)
 {
   if(m_title && m_dll->bd_seek_chapter(m_bd, ch-1) < 0)
     return false;
-  else
-    return true;
+
+  while (m_dll->bd_get_event(m_bd, &m_event))
+    ProcessEvent();
+
+  SeekMVCDemux(GetChapterPos(ch) * 1000 - m_clipStartTime);
+  return true;
 }
 
 int64_t CDVDInputStreamBluray::GetChapterPos(int ch)
@@ -1132,6 +1158,95 @@ bool CDVDInputStreamBluray::HasMenu()
   return m_navmode;
 }
 
+bool CDVDInputStreamBluray::ProcessItem(int playitem)
+{
+  if (m_title)
+    m_dll->bd_free_title_info(m_title);
+  
+  m_title = m_dll->bd_get_playlist_info(m_bd, playitem, m_angle);
+
+  if (CSettings::GetInstance().GetBool("videoplayer.supportmvc"))
+  {
+    MPLS_PL * mpls = m_dll->bd_get_title_mpls(m_bd);
+    if (mpls)
+    {
+      for (int i = 0; i < mpls->ext_sub_count; i++)
+      {
+        if (mpls->ext_sub_path[i].type == 8
+          && mpls->ext_sub_path[i].sub_playitem_count == mpls->list_count)
+        {
+          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - Enabling BD3D MVC demuxing");
+          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - MVC_Base_view_R_flag: %d", m_title->mvc_base_view_r_flag);
+          m_bMVCPlayback = true;
+          m_nMVCSubPathIndex = i;
+          m_bFlipEyes = m_title->mvc_base_view_r_flag != 0;
+          break;
+        }
+      }
+    }
+  }
+  CloseMVCDemux();
+  return true;
+}
+
+bool CDVDInputStreamBluray::OpenMVCDemux(int playItem)
+{
+  MPLS_PL *pl = m_dll->bd_get_title_mpls(m_bd);
+  if (!pl)
+    return false;
+
+  std::string strFileName;
+  strFileName.append(m_root);
+  strFileName.append("/BDMV/STREAM/");
+  strFileName.append(pl->ext_sub_path[m_nMVCSubPathIndex].sub_play_item[playItem].clip->clip_id);
+  strFileName.append(".m2ts");
+
+  CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::OpenMVCDemuxer(): Opening MVC extension stream at %s", strFileName.c_str());
+
+  CFileItem fileitem(CURL(strFileName), false);
+  m_pMVCInput = new CDVDInputStreamFile(fileitem);
+
+  // Try to open the MVC stream
+  if (!m_pMVCInput->Open())
+  {
+    CloseMVCDemux();
+    m_bMVCPlayback = false;
+    return false;
+  }
+
+  if (m_pMVCDemux)
+    SAFE_DELETE(m_pMVCDemux);
+
+  CDVDDemuxMVC* pMVCDemux = new CDVDDemuxMVC;
+  m_pMVCDemux = pMVCDemux;
+
+  if (!pMVCDemux->Open(m_pMVCInput))
+  {
+    CloseMVCDemux();
+    m_bMVCPlayback = false;
+    return false;
+  }
+
+  m_nMVCClip = playItem;
+  return true;
+}
+
+bool CDVDInputStreamBluray::CloseMVCDemux()
+{
+  if (m_pMVCDemux)
+    SAFE_DELETE(m_pMVCDemux);
+
+  SAFE_DELETE(m_pMVCInput);
+  m_nMVCClip = -1;
+  return true;
+}
+
+void CDVDInputStreamBluray::SeekMVCDemux(int64_t time)
+{
+  if (m_bMVCPlayback && m_pMVCDemux)
+    m_pMVCDemux->SeekTime(time);
+}
+
 void CDVDInputStreamBluray::SetupPlayerSettings()
 {
   int region = CSettings::GetInstance().GetInt(CSettings::SETTING_BLURAY_PLAYERREGION);
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h
index b967a85..561fb5c 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h
@@ -38,6 +38,7 @@ extern "C"
 class CDVDOverlayImage;
 class DllLibbluray;
 class IVideoPlayer;
+class CDVDDemux;
 
 class CDVDInputStreamBluray 
   : public CDVDInputStream
@@ -119,6 +120,9 @@ public:
   BLURAY_TITLE_INFO* GetTitleFile(const std::string& name);
 
   void ProcessEvent();
+  CDVDDemux* GetDemuxMVC() { return m_pMVCDemux; };
+  bool HasMVC() { return m_bMVCPlayback; }
+  bool AreEyesFlipped() { return m_bFlipEyes; }
 
 protected:
   struct SPlane;
@@ -127,6 +131,11 @@ protected:
   void OverlayClose();
   static void OverlayClear(SPlane& plane, int x, int y, int w, int h);
   static void OverlayInit (SPlane& plane, int w, int h);
+  bool ProcessItem(int playitem);
+
+  bool OpenMVCDemux(int playItem);
+  bool CloseMVCDemux();
+  void SeekMVCDemux(int64_t time);
 
   IVideoPlayer*         m_player;
   DllLibbluray*       m_dll;
@@ -138,6 +147,17 @@ protected:
   bool                m_menu;
   bool                m_navmode;
   int m_dispTimeBeforeRead;
+  int                 m_nTitles = -1;
+  std::string         m_root;
+
+  // MVC related members
+  CDVDDemux*          m_pMVCDemux = nullptr;
+  CDVDInputStream    *m_pMVCInput = nullptr;
+  bool                m_bMVCPlayback = false;
+  int                 m_nMVCSubPathIndex = 0;
+  int                 m_nMVCClip = -1;
+  bool                m_bFlipEyes = false;
+  uint64_t            m_clipStartTime = 0;
 
   typedef std::shared_ptr<CDVDOverlayImage> SOverlay;
   typedef std::list<SOverlay>                 SOverlays;
-- 
2.7.4


From eabcd43deae389fafaa33b31be842d98afcc3f95 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <afedchin@ruswizards.com>
Date: Wed, 2 Mar 2016 23:31:50 +0300
Subject: [PATCH 146/175] Fix aspect for TAB/SBS (need more testing)

---
 xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp
index f9b3bfb..ab804ab 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp
@@ -35,6 +35,9 @@
 #include "settings/AdvancedSettings.h"
 #include "cores/VideoPlayer/VideoRenderers/RenderFlags.h"
 
+extern "C" {
+#include "libavformat/version.h"
+}
 
 CBaseRenderer::CBaseRenderer()
 {
@@ -369,6 +372,21 @@ void CBaseRenderer::CalculateFrameAspectRatio(unsigned int desired_width, unsign
     if (m_sourceHeight == 576) // PAL
       m_sourceFrameRatio = imageFrameRatio * PALPixelRatio * Non4by3Correction;
   }
+#if (LIBAVFORMAT_VERSION_MAJOR >= 57)
+  bool isAnamorph = m_sourceWidth <= 1920 && m_sourceHeight <= 1080;
+  float factor = isAnamorph ? 2.0f : 4.0f;
+  switch (CONF_FLAGS_STEREO_MODE_MASK(m_iFlags))
+  {
+  case CONF_FLAGS_STEREO_MODE_TAB:
+    m_sourceFrameRatio *= factor;
+    break;
+  case CONF_FLAGS_STEREO_MODE_SBS:
+    m_sourceFrameRatio /= factor;
+    break;
+  default:
+    break;
+  }
+#endif
 }
 
 void CBaseRenderer::ManageRenderArea()
-- 
2.7.4


From 47e004903870f3ec120760296c9176b2bc284302 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 29 Feb 2016 17:00:50 +0000
Subject: [PATCH 147/175] libbluray: Bump to Nevcairie's v0.9.2

This includes 3D support
---
 tools/depends/target/libbluray/Makefile            |    1 +
 .../libbluray/bump_to_Nevcairie_v0.9.2.patch       | 1629 ++++++++++++++++++++
 2 files changed, 1630 insertions(+)
 create mode 100644 tools/depends/target/libbluray/bump_to_Nevcairie_v0.9.2.patch

diff --git a/tools/depends/target/libbluray/Makefile b/tools/depends/target/libbluray/Makefile
index 09d2a8e..741a820 100644
--- a/tools/depends/target/libbluray/Makefile
+++ b/tools/depends/target/libbluray/Makefile
@@ -24,6 +24,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	# libbluray has borked Makefile.am with respect to CFLAGS, remove the offending line
 	sed -i -e "s|CFLAGS=|#CFLAGS=|" $(PLATFORM)/Makefile.am
+	cd $(PLATFORM); patch -p1 < ../bump_to_Nevcairie_v0.9.2.patch
 	cd $(PLATFORM); ./bootstrap
 	cd $(PLATFORM); $(CONFIGURE)
 
diff --git a/tools/depends/target/libbluray/bump_to_Nevcairie_v0.9.2.patch b/tools/depends/target/libbluray/bump_to_Nevcairie_v0.9.2.patch
new file mode 100644
index 0000000..5ef0124
--- /dev/null
+++ b/tools/depends/target/libbluray/bump_to_Nevcairie_v0.9.2.patch
@@ -0,0 +1,1629 @@
+diff --git a/Makefile.am b/Makefile.am
+index 3a54bfc..035553b 100644
+--- a/Makefile.am
++++ b/Makefile.am
+@@ -161,6 +161,15 @@ noinst_HEADERS = \
+ 	jni/win32/jni_md.h \
+ 	jni/darwin/jni_md.h
+ 
++
++bdnavdir=$(pkgincludedir)/bdnav
++bdnav_HEADERS = \
++	src/libbluray/bdnav/clpi_data.h
++
++utildir=$(pkgincludedir)/../util
++util_HEADERS = \
++	src/util/attributes.h
++
+ pkginclude_HEADERS = \
+ 	src/file/filesystem.h \
+ 	src/libbluray/bluray.h \
+@@ -168,6 +177,9 @@ pkginclude_HEADERS = \
+ 	src/libbluray/keys.h \
+ 	src/libbluray/player_settings.h \
+ 	src/libbluray/bdnav/clpi_data.h \
++	src/libbluray/bdnav/clpi_parse.h \
++	src/libbluray/bdnav/mpls_parse.h \
++	src/libbluray/bdnav/uo_mask_table.h \
+ 	src/libbluray/bdnav/meta_data.h \
+ 	src/libbluray/decoders/overlay.h \
+ 	src/util/log_control.h
+diff --git a/config.h b/config.h
+new file mode 100644
+index 0000000..6764704
+--- /dev/null
++++ b/config.h
+@@ -0,0 +1,157 @@
++/* config.h.  Generated from config.h.in by configure.  */
++/* config.h.in.  Generated from configure.ac by autoheader.  */
++
++/* Define to 1 if libudfread is to be used for disc image access */
++/* #undef ENABLE_UDF */
++
++/* Define to 1 if using libbluray J2ME stack */
++/* #undef HAVE_BDJ_J2ME */
++
++/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
++   */
++/* #undef HAVE_DIRENT_H */
++
++/* Define to 1 if you have the <dlfcn.h> header file. */
++/* #undef HAVE_DLFCN_H */
++
++/* Define to 1 if you have the <errno.h> header file. */
++#define HAVE_ERRNO_H 1
++
++/* Define to 1 if you have the <fcntl.h> header file. */
++/* #undef HAVE_FCNTL_H */
++
++/* Define this if you have fontconfig library */
++/* #undef HAVE_FONTCONFIG */
++
++/* Define this if you have FreeType2 library */
++/* #undef HAVE_FT2 */
++
++/* Define to 1 if you have the <inttypes.h> header file. */
++#define HAVE_INTTYPES_H 1
++
++/* Define to 1 if you have the <jni.h> header file. */
++/* #undef HAVE_JNI_H */
++
++/* Define to 1 if you have the <libgen.h> header file. */
++#define HAVE_LIBGEN_H 1
++
++/* Define to 1 if libxml2 is to be used for metadata parsing */
++/* #undef HAVE_LIBXML2 */
++
++/* Define to 1 if you have the <linux/cdrom.h> header file. */
++/* #undef HAVE_LINUX_CDROM_H */
++
++/* Define to 1 if you have the <malloc.h> header file. */
++#define HAVE_MALLOC_H 1
++
++/* Define to 1 if you have the <memory.h> header file. */
++#define HAVE_MEMORY_H 1
++
++/* Define to 1 if you have the <mntent.h> header file. */
++/* #undef HAVE_MNTENT_H */
++
++/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
++/* #undef HAVE_NDIR_H */
++
++/* Define to 1 if you have the <pthread.h> header file. */
++/* #undef HAVE_PTHREAD_H */
++
++/* Define to 1 if you have the <stdarg.h> header file. */
++#define HAVE_STDARG_H 1
++
++/* Define to 1 if you have the <stdint.h> header file. */
++#define HAVE_STDINT_H 1
++
++/* Define to 1 if you have the <stdlib.h> header file. */
++#define HAVE_STDLIB_H 1
++
++/* Define to 1 if you have the <strings.h> header file. */
++/* #undef HAVE_STRINGS_H */
++
++/* Define to 1 if you have the <string.h> header file. */
++#define HAVE_STRING_H 1
++
++/* Define to 1 if `d_type' is a member of `struct dirent'. */
++/* #undef HAVE_STRUCT_DIRENT_D_TYPE */
++
++/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
++   */
++/* #undef HAVE_SYS_DIR_H */
++
++/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
++   */
++/* #undef HAVE_SYS_NDIR_H */
++
++/* Define to 1 if you have the <sys/stat.h> header file. */
++#define HAVE_SYS_STAT_H 1
++
++/* Define to 1 if you have the <sys/time.h> header file. */
++#define HAVE_SYS_TIME_H 1
++
++/* Define to 1 if you have the <sys/types.h> header file. */
++#define HAVE_SYS_TYPES_H 1
++
++/* Define to 1 if you have the <time.h> header file. */
++#define HAVE_TIME_H 1
++
++/* Define to 1 if you have the <unistd.h> header file. */
++/* #undef HAVE_UNISTD_H */
++
++/* "Defines the architecture of the java vm." */
++/* #undef JAVA_ARCH */
++
++/* "" */
++/* #undef JDK_HOME */
++
++/* Define to the sub-directory where libtool stores uninstalled libraries. */
++#define LT_OBJDIR ".libs/"
++
++/* Name of package */
++#define PACKAGE "libbluray"
++
++/* Define to the address where bug reports for this package should be sent. */
++#define PACKAGE_BUGREPORT "http://www.videolan.org/developers/libbluray.html"
++
++/* Define to the full name of this package. */
++#define PACKAGE_NAME "libbluray"
++
++/* Define to the full name and version of this package. */
++#define PACKAGE_STRING "libbluray 0.9.2"
++
++/* Define to the one symbol short name of this package. */
++#define PACKAGE_TARNAME "libbluray"
++
++/* Define to the home page for this package. */
++#define PACKAGE_URL ""
++
++/* Define to the version of this package. */
++#define PACKAGE_VERSION "0.9.2"
++
++/* Define as the return type of signal handlers (`int' or `void'). */
++#define RETSIGTYPE void
++
++/* Define to 1 if you have the ANSI C header files. */
++#define STDC_HEADERS 1
++
++/* "Define to 1 if using BD-Java" */
++/* #undef USING_BDJAVA */
++
++/* Version number of package */
++#define VERSION "0.9.2"
++
++/* Enable large inode numbers on Mac OS X 10.5.  */
++#ifndef _DARWIN_USE_64_BIT_INODE
++# define _DARWIN_USE_64_BIT_INODE 1
++#endif
++
++/* Number of bits in a file offset, on hosts where this is settable. */
++#define _FILE_OFFSET_BITS 64
++
++/* Define for large files, on AIX-style hosts. */
++/* #undef _LARGE_FILES */
++
++/* Define to '0x0501' for IE 5.01. */
++#define _WIN32_IE 0x0501
++
++/* Define to '0x0502' for Windows XP SP2 APIs. */
++#define _WIN32_WINNT 0x0502
+diff --git a/includes/inttypes.h b/includes/inttypes.h
+new file mode 100644
+index 0000000..ead903f
+--- /dev/null
++++ b/includes/inttypes.h
+@@ -0,0 +1,305 @@
++// ISO C9x  compliant inttypes.h for Microsoft Visual Studio
++// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124
++//
++//  Copyright (c) 2006 Alexander Chemeris
++//
++// Redistribution and use in source and binary forms, with or without
++// modification, are permitted provided that the following conditions are met:
++//
++//   1. Redistributions of source code must retain the above copyright notice,
++//      this list of conditions and the following disclaimer.
++//
++//   2. Redistributions in binary form must reproduce the above copyright
++//      notice, this list of conditions and the following disclaimer in the
++//      documentation and/or other materials provided with the distribution.
++//
++//   3. The name of the author may be used to endorse or promote products
++//      derived from this software without specific prior written permission.
++//
++// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
++// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
++// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
++// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
++// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
++// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
++// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
++// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
++// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++//
++///////////////////////////////////////////////////////////////////////////////
++
++#ifndef _MSC_VER // [
++#error "Use this header only with Microsoft Visual C++ compilers!"
++#endif // _MSC_VER ]
++
++#ifndef _MSC_INTTYPES_H_ // [
++#define _MSC_INTTYPES_H_
++
++#if _MSC_VER > 1000
++#pragma once
++#endif
++
++#include "stdint.h"
++
++// 7.8 Format conversion of integer types
++
++typedef struct {
++   intmax_t quot;
++   intmax_t rem;
++} imaxdiv_t;
++
++// 7.8.1 Macros for format specifiers
++
++#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) // [   See footnote 185 at page 198
++
++// The fprintf macros for signed integers are:
++#define PRId8       "d"
++#define PRIi8       "i"
++#define PRIdLEAST8  "d"
++#define PRIiLEAST8  "i"
++#define PRIdFAST8   "d"
++#define PRIiFAST8   "i"
++
++#define PRId16       "hd"
++#define PRIi16       "hi"
++#define PRIdLEAST16  "hd"
++#define PRIiLEAST16  "hi"
++#define PRIdFAST16   "hd"
++#define PRIiFAST16   "hi"
++
++#define PRId32       "I32d"
++#define PRIi32       "I32i"
++#define PRIdLEAST32  "I32d"
++#define PRIiLEAST32  "I32i"
++#define PRIdFAST32   "I32d"
++#define PRIiFAST32   "I32i"
++
++#define PRId64       "I64d"
++#define PRIi64       "I64i"
++#define PRIdLEAST64  "I64d"
++#define PRIiLEAST64  "I64i"
++#define PRIdFAST64   "I64d"
++#define PRIiFAST64   "I64i"
++
++#define PRIdMAX     "I64d"
++#define PRIiMAX     "I64i"
++
++#define PRIdPTR     "Id"
++#define PRIiPTR     "Ii"
++
++// The fprintf macros for unsigned integers are:
++#define PRIo8       "o"
++#define PRIu8       "u"
++#define PRIx8       "x"
++#define PRIX8       "X"
++#define PRIoLEAST8  "o"
++#define PRIuLEAST8  "u"
++#define PRIxLEAST8  "x"
++#define PRIXLEAST8  "X"
++#define PRIoFAST8   "o"
++#define PRIuFAST8   "u"
++#define PRIxFAST8   "x"
++#define PRIXFAST8   "X"
++
++#define PRIo16       "ho"
++#define PRIu16       "hu"
++#define PRIx16       "hx"
++#define PRIX16       "hX"
++#define PRIoLEAST16  "ho"
++#define PRIuLEAST16  "hu"
++#define PRIxLEAST16  "hx"
++#define PRIXLEAST16  "hX"
++#define PRIoFAST16   "ho"
++#define PRIuFAST16   "hu"
++#define PRIxFAST16   "hx"
++#define PRIXFAST16   "hX"
++
++#define PRIo32       "I32o"
++#define PRIu32       "I32u"
++#define PRIx32       "I32x"
++#define PRIX32       "I32X"
++#define PRIoLEAST32  "I32o"
++#define PRIuLEAST32  "I32u"
++#define PRIxLEAST32  "I32x"
++#define PRIXLEAST32  "I32X"
++#define PRIoFAST32   "I32o"
++#define PRIuFAST32   "I32u"
++#define PRIxFAST32   "I32x"
++#define PRIXFAST32   "I32X"
++
++#define PRIo64       "I64o"
++#define PRIu64       "I64u"
++#define PRIx64       "I64x"
++#define PRIX64       "I64X"
++#define PRIoLEAST64  "I64o"
++#define PRIuLEAST64  "I64u"
++#define PRIxLEAST64  "I64x"
++#define PRIXLEAST64  "I64X"
++#define PRIoFAST64   "I64o"
++#define PRIuFAST64   "I64u"
++#define PRIxFAST64   "I64x"
++#define PRIXFAST64   "I64X"
++
++#define PRIoMAX     "I64o"
++#define PRIuMAX     "I64u"
++#define PRIxMAX     "I64x"
++#define PRIXMAX     "I64X"
++
++#define PRIoPTR     "Io"
++#define PRIuPTR     "Iu"
++#define PRIxPTR     "Ix"
++#define PRIXPTR     "IX"
++
++// The fscanf macros for signed integers are:
++#define SCNd8       "d"
++#define SCNi8       "i"
++#define SCNdLEAST8  "d"
++#define SCNiLEAST8  "i"
++#define SCNdFAST8   "d"
++#define SCNiFAST8   "i"
++
++#define SCNd16       "hd"
++#define SCNi16       "hi"
++#define SCNdLEAST16  "hd"
++#define SCNiLEAST16  "hi"
++#define SCNdFAST16   "hd"
++#define SCNiFAST16   "hi"
++
++#define SCNd32       "ld"
++#define SCNi32       "li"
++#define SCNdLEAST32  "ld"
++#define SCNiLEAST32  "li"
++#define SCNdFAST32   "ld"
++#define SCNiFAST32   "li"
++
++#define SCNd64       "I64d"
++#define SCNi64       "I64i"
++#define SCNdLEAST64  "I64d"
++#define SCNiLEAST64  "I64i"
++#define SCNdFAST64   "I64d"
++#define SCNiFAST64   "I64i"
++
++#define SCNdMAX     "I64d"
++#define SCNiMAX     "I64i"
++
++#ifdef _WIN64 // [
++#  define SCNdPTR     "I64d"
++#  define SCNiPTR     "I64i"
++#else  // _WIN64 ][
++#  define SCNdPTR     "ld"
++#  define SCNiPTR     "li"
++#endif  // _WIN64 ]
++
++// The fscanf macros for unsigned integers are:
++#define SCNo8       "o"
++#define SCNu8       "u"
++#define SCNx8       "x"
++#define SCNX8       "X"
++#define SCNoLEAST8  "o"
++#define SCNuLEAST8  "u"
++#define SCNxLEAST8  "x"
++#define SCNXLEAST8  "X"
++#define SCNoFAST8   "o"
++#define SCNuFAST8   "u"
++#define SCNxFAST8   "x"
++#define SCNXFAST8   "X"
++
++#define SCNo16       "ho"
++#define SCNu16       "hu"
++#define SCNx16       "hx"
++#define SCNX16       "hX"
++#define SCNoLEAST16  "ho"
++#define SCNuLEAST16  "hu"
++#define SCNxLEAST16  "hx"
++#define SCNXLEAST16  "hX"
++#define SCNoFAST16   "ho"
++#define SCNuFAST16   "hu"
++#define SCNxFAST16   "hx"
++#define SCNXFAST16   "hX"
++
++#define SCNo32       "lo"
++#define SCNu32       "lu"
++#define SCNx32       "lx"
++#define SCNX32       "lX"
++#define SCNoLEAST32  "lo"
++#define SCNuLEAST32  "lu"
++#define SCNxLEAST32  "lx"
++#define SCNXLEAST32  "lX"
++#define SCNoFAST32   "lo"
++#define SCNuFAST32   "lu"
++#define SCNxFAST32   "lx"
++#define SCNXFAST32   "lX"
++
++#define SCNo64       "I64o"
++#define SCNu64       "I64u"
++#define SCNx64       "I64x"
++#define SCNX64       "I64X"
++#define SCNoLEAST64  "I64o"
++#define SCNuLEAST64  "I64u"
++#define SCNxLEAST64  "I64x"
++#define SCNXLEAST64  "I64X"
++#define SCNoFAST64   "I64o"
++#define SCNuFAST64   "I64u"
++#define SCNxFAST64   "I64x"
++#define SCNXFAST64   "I64X"
++
++#define SCNoMAX     "I64o"
++#define SCNuMAX     "I64u"
++#define SCNxMAX     "I64x"
++#define SCNXMAX     "I64X"
++
++#ifdef _WIN64 // [
++#  define SCNoPTR     "I64o"
++#  define SCNuPTR     "I64u"
++#  define SCNxPTR     "I64x"
++#  define SCNXPTR     "I64X"
++#else  // _WIN64 ][
++#  define SCNoPTR     "lo"
++#  define SCNuPTR     "lu"
++#  define SCNxPTR     "lx"
++#  define SCNXPTR     "lX"
++#endif  // _WIN64 ]
++
++#endif // __STDC_FORMAT_MACROS ]
++
++// 7.8.2 Functions for greatest-width integer types
++
++// 7.8.2.1 The imaxabs function
++#define imaxabs _abs64
++
++// 7.8.2.2 The imaxdiv function
++
++// This is modified version of div() function from Microsoft's div.c found
++// in %MSVC.NET%\crt\src\div.c
++#ifdef STATIC_IMAXDIV // [
++static
++#else // STATIC_IMAXDIV ][
++_inline
++#endif // STATIC_IMAXDIV ]
++imaxdiv_t __cdecl imaxdiv(intmax_t numer, intmax_t denom)
++{
++   imaxdiv_t result;
++
++   result.quot = numer / denom;
++   result.rem = numer % denom;
++
++   if (numer < 0 && result.rem > 0) {
++      // did division wrong; must fix up
++      ++result.quot;
++      result.rem -= denom;
++   }
++
++   return result;
++}
++
++// 7.8.2.3 The strtoimax and strtoumax functions
++#define strtoimax _strtoi64
++#define strtoumax _strtoui64
++
++// 7.8.2.4 The wcstoimax and wcstoumax functions
++#define wcstoimax _wcstoi64
++#define wcstoumax _wcstoui64
++
++
++#endif // _MSC_INTTYPES_H_ ]
+diff --git a/libbluray.def b/libbluray.def
+new file mode 100644
+index 0000000..d4c93cb
+--- /dev/null
++++ b/libbluray.def
+@@ -0,0 +1,63 @@
++; libbluray.def ; declares the exports
++
++LIBRARY         "libbluray.dll"
++
++EXPORTS
++                ; bluray.h
++                bd_get_version
++                bd_get_titles
++                bd_get_title_info
++                bd_get_playlist_info
++                bd_free_title_info
++                bd_open
++                bd_close
++                bd_seek
++                bd_seek_time
++                bd_find_seek_point
++                bd_read
++                bd_read_skip_still
++                bd_seek_chapter
++                bd_chapter_pos
++                bd_get_current_chapter
++                bd_seek_mark
++                bd_seek_playitem
++                bd_select_playlist
++                bd_select_title
++                bd_select_angle
++                bd_seamless_angle_change
++                bd_get_title_size
++                bd_get_current_title
++                bd_get_current_angle
++                bd_tell
++                bd_tell_time
++                bd_get_disc_info
++                bd_set_player_setting
++                bd_set_player_setting_str
++                bd_start_bdj
++                bd_stop_bdj
++                bd_get_event
++                bd_play
++                bd_read_ext
++                bd_play_title
++                bd_menu_call
++                bd_register_overlay_proc
++                bd_register_argb_overlay_proc
++                bd_set_scr
++                bd_user_input
++                bd_mouse_select
++                bd_get_sound_effect
++                bd_get_meta
++                bd_get_clpi
++                bd_read_clpi
++                bd_free_clpi
++                bd_read_mpls
++                bd_free_mpls
++                bd_read_mobj
++                bd_free_mobj
++                bd_get_clip_infos
++                bd_get_title_mpls
++
++                ; additional functions
++                bd_set_debug_handler
++                bd_set_debug_mask
++                bd_get_debug_mask
+diff --git a/libbluray.vcxproj b/libbluray.vcxproj
+new file mode 100644
+index 0000000..c778955
+--- /dev/null
++++ b/libbluray.vcxproj
+@@ -0,0 +1,231 @@
++﻿<?xml version="1.0" encoding="utf-8"?>
++<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
++  <ItemGroup Label="ProjectConfigurations">
++    <ProjectConfiguration Include="DebugRelease|Win32">
++      <Configuration>DebugRelease</Configuration>
++      <Platform>Win32</Platform>
++    </ProjectConfiguration>
++    <ProjectConfiguration Include="DebugRelease|x64">
++      <Configuration>DebugRelease</Configuration>
++      <Platform>x64</Platform>
++    </ProjectConfiguration>
++    <ProjectConfiguration Include="Debug|Win32">
++      <Configuration>Debug</Configuration>
++      <Platform>Win32</Platform>
++    </ProjectConfiguration>
++    <ProjectConfiguration Include="Debug|x64">
++      <Configuration>Debug</Configuration>
++      <Platform>x64</Platform>
++    </ProjectConfiguration>
++    <ProjectConfiguration Include="Release|Win32">
++      <Configuration>Release</Configuration>
++      <Platform>Win32</Platform>
++    </ProjectConfiguration>
++    <ProjectConfiguration Include="Release|x64">
++      <Configuration>Release</Configuration>
++      <Platform>x64</Platform>
++    </ProjectConfiguration>
++  </ItemGroup>
++  <ItemGroup>
++    <ClInclude Include="src\file\dirs.h" />
++    <ClInclude Include="src\file\dl.h" />
++    <ClInclude Include="src\file\file.h" />
++    <ClInclude Include="src\file\filesystem.h" />
++    <ClInclude Include="src\file\mount.h" />
++    <ClInclude Include="src\libbluray\bdnav\bdid_parse.h" />
++    <ClInclude Include="src\libbluray\bdnav\bdparse.h" />
++    <ClInclude Include="src\libbluray\bdnav\clpi_data.h" />
++    <ClInclude Include="src\libbluray\bdnav\clpi_parse.h" />
++    <ClInclude Include="src\libbluray\bdnav\extdata_parse.h" />
++    <ClInclude Include="src\libbluray\bdnav\index_parse.h" />
++    <ClInclude Include="src\libbluray\bdnav\meta_data.h" />
++    <ClInclude Include="src\libbluray\bdnav\meta_parse.h" />
++    <ClInclude Include="src\libbluray\bdnav\mpls_parse.h" />
++    <ClInclude Include="src\libbluray\bdnav\navigation.h" />
++    <ClInclude Include="src\libbluray\bdnav\sound_parse.h" />
++    <ClInclude Include="src\libbluray\bdnav\uo_mask_table.h" />
++    <ClInclude Include="src\libbluray\bluray-version.h" />
++    <ClInclude Include="src\libbluray\bluray.h" />
++    <ClInclude Include="src\libbluray\bluray_internal.h" />
++    <ClInclude Include="src\libbluray\decoders\graphics_controller.h" />
++    <ClInclude Include="src\libbluray\decoders\graphics_processor.h" />
++    <ClInclude Include="src\libbluray\decoders\ig.h" />
++    <ClInclude Include="src\libbluray\decoders\ig_decode.h" />
++    <ClInclude Include="src\libbluray\decoders\m2ts_demux.h" />
++    <ClInclude Include="src\libbluray\decoders\m2ts_filter.h" />
++    <ClInclude Include="src\libbluray\decoders\overlay.h" />
++    <ClInclude Include="src\libbluray\decoders\pes_buffer.h" />
++    <ClInclude Include="src\libbluray\decoders\pg.h" />
++    <ClInclude Include="src\libbluray\decoders\pg_decode.h" />
++    <ClInclude Include="src\libbluray\decoders\rle.h" />
++    <ClInclude Include="src\libbluray\decoders\textst.h" />
++    <ClInclude Include="src\libbluray\decoders\textst_decode.h" />
++    <ClInclude Include="src\libbluray\decoders\textst_render.h" />
++    <ClInclude Include="src\libbluray\disc\aacs.h" />
++    <ClInclude Include="src\libbluray\disc\bdplus.h" />
++    <ClInclude Include="src\libbluray\disc\dec.h" />
++    <ClInclude Include="src\libbluray\disc\disc.h" />
++    <ClInclude Include="src\libbluray\disc\enc_info.h" />
++    <ClInclude Include="src\libbluray\hdmv\hdmv_insn.h" />
++    <ClInclude Include="src\libbluray\hdmv\hdmv_vm.h" />
++    <ClInclude Include="src\libbluray\hdmv\mobj_parse.h" />
++    <ClInclude Include="src\libbluray\keys.h" />
++    <ClInclude Include="src\libbluray\register.h" />
++    <ClInclude Include="src\util\array.h" />
++    <ClInclude Include="src\util\attributes.h" />
++    <ClInclude Include="src\util\bits.h" />
++    <ClInclude Include="src\util\logging.h" />
++    <ClInclude Include="src\util\log_control.h" />
++    <ClInclude Include="src\util\macro.h" />
++    <ClInclude Include="src\util\mutex.h" />
++    <ClInclude Include="src\util\refcnt.h" />
++    <ClInclude Include="src\util\strutl.h" />
++    <ClInclude Include="src\util\time.h" />
++  </ItemGroup>
++  <ItemGroup>
++    <ClCompile Include="src\file\dirs_win32.c" />
++    <ClCompile Include="src\file\dir_win32.c" />
++    <ClCompile Include="src\file\dl_win32.c" />
++    <ClCompile Include="src\file\file.c" />
++    <ClCompile Include="src\file\filesystem.c" />
++    <ClCompile Include="src\file\file_win32.c" />
++    <ClCompile Include="src\file\mount.c" />
++    <ClCompile Include="src\libbluray\bdnav\bdid_parse.c" />
++    <ClCompile Include="src\libbluray\bdnav\clpi_parse.c" />
++    <ClCompile Include="src\libbluray\bdnav\extdata_parse.c" />
++    <ClCompile Include="src\libbluray\bdnav\index_parse.c" />
++    <ClCompile Include="src\libbluray\bdnav\meta_parse.c" />
++    <ClCompile Include="src\libbluray\bdnav\mpls_parse.c" />
++    <ClCompile Include="src\libbluray\bdnav\navigation.c" />
++    <ClCompile Include="src\libbluray\bdnav\sound_parse.c" />
++    <ClCompile Include="src\libbluray\bluray.c" />
++    <ClCompile Include="src\libbluray\decoders\graphics_controller.c" />
++    <ClCompile Include="src\libbluray\decoders\graphics_processor.c" />
++    <ClCompile Include="src\libbluray\decoders\ig_decode.c" />
++    <ClCompile Include="src\libbluray\decoders\m2ts_demux.c" />
++    <ClCompile Include="src\libbluray\decoders\m2ts_filter.c" />
++    <ClCompile Include="src\libbluray\decoders\pes_buffer.c" />
++    <ClCompile Include="src\libbluray\decoders\pg_decode.c" />
++    <ClCompile Include="src\libbluray\decoders\rle.c" />
++    <ClCompile Include="src\libbluray\decoders\textst_decode.c" />
++    <ClCompile Include="src\libbluray\decoders\textst_render.c" />
++    <ClCompile Include="src\libbluray\disc\aacs.c" />
++    <ClCompile Include="src\libbluray\disc\bdplus.c" />
++    <ClCompile Include="src\libbluray\disc\dec.c" />
++    <ClCompile Include="src\libbluray\disc\disc.c" />
++    <ClCompile Include="src\libbluray\hdmv\hdmv_vm.c" />
++    <ClCompile Include="src\libbluray\hdmv\mobj_parse.c" />
++    <ClCompile Include="src\libbluray\hdmv\mobj_print.c" />
++    <ClCompile Include="src\libbluray\register.c" />
++    <ClCompile Include="src\util\array.c" />
++    <ClCompile Include="src\util\bits.c" />
++    <ClCompile Include="src\util\logging.c" />
++    <ClCompile Include="src\util\mutex.c" />
++    <ClCompile Include="src\util\refcnt.c" />
++    <ClCompile Include="src\util\strutl.c" />
++    <ClCompile Include="src\util\time.c" />
++  </ItemGroup>
++  <ItemGroup>
++    <None Include="libbluray.def" />
++  </ItemGroup>
++  <PropertyGroup Label="Globals">
++    <ProjectGuid>{E1DA1B95-71F1-4C21-A271-121176925062}</ProjectGuid>
++    <Keyword>Win32Proj</Keyword>
++    <RootNamespace>libbluray</RootNamespace>
++  </PropertyGroup>
++  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
++  <PropertyGroup Label="Configuration" Condition="'$(VisualStudioVersion)' == '11.0'">
++    <PlatformToolset>v110_xp</PlatformToolset>
++  </PropertyGroup>
++  <PropertyGroup Label="Configuration" Condition="'$(VisualStudioVersion)' == '12.0'">
++    <PlatformToolset>v120_xp</PlatformToolset>
++  </PropertyGroup>
++  <PropertyGroup Label="Configuration" Condition="'$(VisualStudioVersion)' == '14.0'">
++    <PlatformToolset>v140_xp</PlatformToolset>
++  </PropertyGroup>
++  <PropertyGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='DebugRelease'" Label="Configuration">
++    <ConfigurationType>DynamicLibrary</ConfigurationType>
++    <UseDebugLibraries>true</UseDebugLibraries>
++    <CharacterSet>Unicode</CharacterSet>
++  </PropertyGroup>
++  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
++    <ConfigurationType>DynamicLibrary</ConfigurationType>
++    <UseDebugLibraries>false</UseDebugLibraries>
++    <WholeProgramOptimization>true</WholeProgramOptimization>
++    <CharacterSet>Unicode</CharacterSet>
++  </PropertyGroup>
++  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
++  <ImportGroup Label="ExtensionSettings">
++  </ImportGroup>
++  <ImportGroup Label="PropertySheets">
++    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
++  </ImportGroup>
++  <PropertyGroup Label="UserMacros" />
++  <PropertyGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='DebugRelease'">
++    <LinkIncremental>true</LinkIncremental>
++    <OutDir>$(SolutionDir)bin_$(PlatformName)d\</OutDir>
++    <IntDir>$(SolutionDir)bin_$(PlatformName)d\$(ProjectName)\</IntDir>
++  </PropertyGroup>
++  <PropertyGroup Condition="'$(Configuration)'=='Release'">
++    <LinkIncremental>false</LinkIncremental>
++    <OutDir>$(SolutionDir)bin_$(PlatformName)\$(ProjectName)\</OutDir>
++    <IntDir>$(SolutionDir)bin_$(PlatformName)\$(ProjectName)\</IntDir>
++  </PropertyGroup>
++  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='DebugRelease'">
++    <ClCompile>
++      <PrecompiledHeader>
++      </PrecompiledHeader>
++      <WarningLevel>Level3</WarningLevel>
++      <Optimization>Disabled</Optimization>
++      <PreprocessorDefinitions>HAVE_CONFIG_H;WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBBLURAY_EXPORTS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
++      <PreprocessorDefinitions Condition="'$(VisualStudioVersion)' == '12.0'">__STDC_FORMAT_MACROS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
++      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)includes;$(ProjectDir)src;$(ProjectDir)src\libbluray;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
++      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
++      <CompileAs Condition="'$(VisualStudioVersion)' == '12.0'">CompileAsCpp</CompileAs>
++    </ClCompile>
++    <Link>
++      <SubSystem>Windows</SubSystem>
++      <GenerateDebugInformation>true</GenerateDebugInformation>
++      <ModuleDefinitionFile>libbluray.def</ModuleDefinitionFile>
++    </Link>
++    <PostBuildEvent>
++      <Command>xcopy /I /Y "$(OutDir)$(TargetName).lib" "$(OutDir)lib\"</Command>
++      <Message>Copy .lib into library path</Message>
++    </PostBuildEvent>
++  </ItemDefinitionGroup>
++  <ItemDefinitionGroup Condition="'$(Configuration)'=='DebugRelease'">
++    <ClCompile>
++      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
++    </ClCompile>
++  </ItemDefinitionGroup>
++  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
++    <ClCompile>
++      <WarningLevel>Level3</WarningLevel>
++      <Optimization>MaxSpeed</Optimization>
++      <FunctionLevelLinking>true</FunctionLevelLinking>
++      <IntrinsicFunctions>true</IntrinsicFunctions>
++      <PreprocessorDefinitions>HAVE_CONFIG_H;WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBBLURAY_EXPORTS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
++      <PreprocessorDefinitions Condition="'$(VisualStudioVersion)' == '12.0'">__STDC_FORMAT_MACROS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
++      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)includes;$(ProjectDir)src;$(ProjectDir)src\libbluray;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
++      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
++      <EnableEnhancedInstructionSet Condition="'$(Platform)'=='Win32'">StreamingSIMDExtensions</EnableEnhancedInstructionSet>
++      <CompileAs Condition="'$(VisualStudioVersion)' == '12.0'">CompileAsCpp</CompileAs>
++    </ClCompile>
++    <Link>
++      <SubSystem>Windows</SubSystem>
++      <GenerateDebugInformation>true</GenerateDebugInformation>
++      <EnableCOMDATFolding>true</EnableCOMDATFolding>
++      <OptimizeReferences>true</OptimizeReferences>
++      <ModuleDefinitionFile>libbluray.def</ModuleDefinitionFile>
++      <SetChecksum>true</SetChecksum>
++    </Link>
++    <PostBuildEvent>
++      <Command>xcopy /I /Y "$(TargetDir)$(TargetName)$(TargetExt)" "$(OutDir)..\"
++xcopy /I /Y "$(TargetDir)$(TargetName).lib" "$(OutDir)..\lib\"</Command>
++      <Message>Copy .dll/.lib into library path</Message>
++    </PostBuildEvent>
++  </ItemDefinitionGroup>
++  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
++  <ImportGroup Label="ExtensionTargets">
++  </ImportGroup>
++</Project>
+\ No newline at end of file
+diff --git a/libbluray.vcxproj.filters b/libbluray.vcxproj.filters
+new file mode 100644
+index 0000000..57ff16c
+--- /dev/null
++++ b/libbluray.vcxproj.filters
+@@ -0,0 +1,353 @@
++﻿<?xml version="1.0" encoding="utf-8"?>
++<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
++  <ItemGroup>
++    <Filter Include="Source Files">
++      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
++      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
++    </Filter>
++    <Filter Include="Header Files">
++      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
++      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
++    </Filter>
++    <Filter Include="Resource Files">
++      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
++      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
++    </Filter>
++    <Filter Include="Source Files\util">
++      <UniqueIdentifier>{1ab0e905-7c04-4090-b385-6363dd1c961c}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Header Files\util">
++      <UniqueIdentifier>{b8fa3348-a089-461f-9ef5-3d9df997b8e5}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Header Files\file">
++      <UniqueIdentifier>{125333e9-0b5e-45f9-a444-f0aaaf547d9b}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Source Files\file">
++      <UniqueIdentifier>{a743058f-f07a-4d0f-bab6-02dc57defda9}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Source Files\libbluray">
++      <UniqueIdentifier>{7dacc7c4-ef59-452b-9e5b-392c9df07c98}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Header Files\libbluray">
++      <UniqueIdentifier>{c7895c81-c186-4d5e-a8ff-645c6d55a731}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Header Files\libbluray\bdnav">
++      <UniqueIdentifier>{c8619466-211b-4c85-9d30-d1b1a822d32e}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Source Files\libbluray\bdnav">
++      <UniqueIdentifier>{8afb6919-994f-4d1f-9638-ce4a06d0b473}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Source Files\libbluray\decoders">
++      <UniqueIdentifier>{0e9086a7-eebf-4b8e-a4fe-b1724d148877}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Header Files\libbluray\decoders">
++      <UniqueIdentifier>{fc5e776b-0f32-493a-b823-240288288502}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Header Files\libbluray\hdmv">
++      <UniqueIdentifier>{96d2d786-cd45-4856-937d-9e6f85ced241}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Source Files\libbluray\hdmv">
++      <UniqueIdentifier>{9f4ea4ae-217a-4d97-a5f3-e561ce1e49cd}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Source Files\libbluray\disc">
++      <UniqueIdentifier>{09e1b1b8-3aa3-4918-b157-3dfc0554ccbb}</UniqueIdentifier>
++    </Filter>
++    <Filter Include="Header Files\libbluray\disc">
++      <UniqueIdentifier>{1e02e503-752e-4765-9dfb-8cc67a7b79f8}</UniqueIdentifier>
++    </Filter>
++  </ItemGroup>
++  <ItemGroup>
++    <ClInclude Include="src\util\attributes.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\util\strutl.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\util\bits.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\util\log_control.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\util\logging.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\util\macro.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\util\mutex.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\file\dl.h">
++      <Filter>Header Files\file</Filter>
++    </ClInclude>
++    <ClInclude Include="src\file\filesystem.h">
++      <Filter>Header Files\file</Filter>
++    </ClInclude>
++    <ClInclude Include="src\file\file.h">
++      <Filter>Header Files\file</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bluray.h">
++      <Filter>Header Files\libbluray</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\register.h">
++      <Filter>Header Files\libbluray</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\keys.h">
++      <Filter>Header Files\libbluray</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\bdparse.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\uo_mask_table.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\clpi_parse.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\index_parse.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\meta_data.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\meta_parse.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\mpls_parse.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\navigation.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\sound_parse.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\graphics_controller.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\pg_decode.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\graphics_processor.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\ig.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\ig_decode.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\m2ts_demux.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\overlay.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\pes_buffer.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\pg.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\hdmv\hdmv_insn.h">
++      <Filter>Header Files\libbluray\hdmv</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\hdmv\mobj_parse.h">
++      <Filter>Header Files\libbluray\hdmv</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\hdmv\hdmv_vm.h">
++      <Filter>Header Files\libbluray\hdmv</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\bdid_parse.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\clpi_data.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bdnav\extdata_parse.h">
++      <Filter>Header Files\libbluray\bdnav</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\textst.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\textst_render.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\textst_decode.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\rle.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\util\refcnt.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\util\time.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bluray_internal.h">
++      <Filter>Header Files\libbluray</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\decoders\m2ts_filter.h">
++      <Filter>Header Files\libbluray\decoders</Filter>
++    </ClInclude>
++    <ClInclude Include="src\file\dirs.h">
++      <Filter>Header Files\file</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\bluray-version.h">
++      <Filter>Header Files\libbluray</Filter>
++    </ClInclude>
++    <ClInclude Include="src\util\array.h">
++      <Filter>Header Files\util</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\disc\aacs.h">
++      <Filter>Header Files\libbluray\disc</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\disc\bdplus.h">
++      <Filter>Header Files\libbluray\disc</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\disc\dec.h">
++      <Filter>Header Files\libbluray\disc</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\disc\disc.h">
++      <Filter>Header Files\libbluray\disc</Filter>
++    </ClInclude>
++    <ClInclude Include="src\libbluray\disc\enc_info.h">
++      <Filter>Header Files\libbluray\disc</Filter>
++    </ClInclude>
++    <ClInclude Include="src\file\mount.h">
++      <Filter>Header Files\file</Filter>
++    </ClInclude>
++  </ItemGroup>
++  <ItemGroup>
++    <ClCompile Include="src\util\logging.c">
++      <Filter>Source Files\util</Filter>
++    </ClCompile>
++    <ClCompile Include="src\util\strutl.c">
++      <Filter>Source Files\util</Filter>
++    </ClCompile>
++    <ClCompile Include="src\file\filesystem.c">
++      <Filter>Source Files\file</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\bluray.c">
++      <Filter>Source Files\libbluray</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\register.c">
++      <Filter>Source Files\libbluray</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\bdnav\clpi_parse.c">
++      <Filter>Source Files\libbluray\bdnav</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\bdnav\sound_parse.c">
++      <Filter>Source Files\libbluray\bdnav</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\bdnav\index_parse.c">
++      <Filter>Source Files\libbluray\bdnav</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\bdnav\meta_parse.c">
++      <Filter>Source Files\libbluray\bdnav</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\bdnav\mpls_parse.c">
++      <Filter>Source Files\libbluray\bdnav</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\bdnav\navigation.c">
++      <Filter>Source Files\libbluray\bdnav</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\graphics_controller.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\pg_decode.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\graphics_processor.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\ig_decode.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\m2ts_demux.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\pes_buffer.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\hdmv\hdmv_vm.c">
++      <Filter>Source Files\libbluray\hdmv</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\hdmv\mobj_print.c">
++      <Filter>Source Files\libbluray\hdmv</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\hdmv\mobj_parse.c">
++      <Filter>Source Files\libbluray\hdmv</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\bdnav\bdid_parse.c">
++      <Filter>Source Files\libbluray\bdnav</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\bdnav\extdata_parse.c">
++      <Filter>Source Files\libbluray\bdnav</Filter>
++    </ClCompile>
++    <ClCompile Include="src\util\bits.c">
++      <Filter>Source Files\util</Filter>
++    </ClCompile>
++    <ClCompile Include="src\file\dir_win32.c">
++      <Filter>Source Files\file</Filter>
++    </ClCompile>
++    <ClCompile Include="src\file\dirs_win32.c">
++      <Filter>Source Files\file</Filter>
++    </ClCompile>
++    <ClCompile Include="src\file\dl_win32.c">
++      <Filter>Source Files\file</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\textst_decode.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\textst_render.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\util\refcnt.c">
++      <Filter>Source Files\util</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\m2ts_filter.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\decoders\rle.c">
++      <Filter>Source Files\libbluray\decoders</Filter>
++    </ClCompile>
++    <ClCompile Include="src\file\file_win32.c">
++      <Filter>Source Files\file</Filter>
++    </ClCompile>
++    <ClCompile Include="src\file\file.c">
++      <Filter>Source Files\file</Filter>
++    </ClCompile>
++    <ClCompile Include="src\util\array.c">
++      <Filter>Source Files\util</Filter>
++    </ClCompile>
++    <ClCompile Include="src\util\mutex.c">
++      <Filter>Source Files\util</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\disc\aacs.c">
++      <Filter>Source Files\libbluray\disc</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\disc\bdplus.c">
++      <Filter>Source Files\libbluray\disc</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\disc\dec.c">
++      <Filter>Source Files\libbluray\disc</Filter>
++    </ClCompile>
++    <ClCompile Include="src\libbluray\disc\disc.c">
++      <Filter>Source Files\libbluray\disc</Filter>
++    </ClCompile>
++    <ClCompile Include="src\util\time.c">
++      <Filter>Source Files\util</Filter>
++    </ClCompile>
++    <ClCompile Include="src\file\mount.c">
++      <Filter>Source Files\file</Filter>
++    </ClCompile>
++  </ItemGroup>
++  <ItemGroup>
++    <None Include="libbluray.def">
++      <Filter>Source Files</Filter>
++    </None>
++  </ItemGroup>
++</Project>
+\ No newline at end of file
+diff --git a/src/file/dir_win32.c b/src/file/dir_win32.c
+index 2690658..f42114d 100644
+--- a/src/file/dir_win32.c
++++ b/src/file/dir_win32.c
+@@ -86,8 +86,8 @@ static BD_DIR_H *_dir_open_win32(const char* dirname)
+ 
+     dir->internal = priv;
+ 
+-    wchar_t wfilespec[MAX_PATH];
+-    if (MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, filespec, -1, wfilespec, MAX_PATH))
++    wchar_t wfilespec[4096 + 1] = {0};
++    if (MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, filespec, -1, wfilespec, 4096))
+         priv->handle = _wfindfirst(wfilespec, &priv->info);
+     else
+         priv->handle = -1;
+diff --git a/src/file/dirs_win32.c b/src/file/dirs_win32.c
+index e165fea..3d07251 100644
+--- a/src/file/dirs_win32.c
++++ b/src/file/dirs_win32.c
+@@ -36,7 +36,7 @@
+ 
+ char *win32_get_font_dir(const char *font_file)
+ {
+-    wchar_t wdir[MAX_PATH];
++    wchar_t wdir[MAX_PATH+1] = {0};
+     if (S_OK != SHGetFolderPathW(NULL, CSIDL_FONTS, NULL, SHGFP_TYPE_CURRENT, wdir)) {
+         int lenght = GetWindowsDirectoryW(wdir, MAX_PATH);
+         if (lenght == 0 || lenght > (MAX_PATH - 8)) {
+@@ -67,7 +67,7 @@ char *file_get_config_home(void)
+ 
+ char *file_get_data_home(void)
+ {
+-    wchar_t wdir[MAX_PATH];
++    wchar_t wdir[MAX_PATH+1] = {0};
+ 
+     /* Get the "Application Data" folder for the user */
+     if (S_OK == SHGetFolderPathW(NULL, CSIDL_APPDATA | CSIDL_FLAG_CREATE,
+@@ -92,7 +92,7 @@ char *file_get_cache_home(void)
+ const char *file_get_config_system(const char *dir)
+ {
+     static char *appdir = NULL;
+-    wchar_t wdir[MAX_PATH];
++    wchar_t wdir[MAX_PATH+1] = {0};
+ 
+     if (!dir) {
+         // first call
+diff --git a/src/file/dl_win32.c b/src/file/dl_win32.c
+index e4492e1..7f6ae73 100644
+--- a/src/file/dl_win32.c
++++ b/src/file/dl_win32.c
+@@ -57,7 +57,7 @@ void *dl_dlopen(const char *path, const char *version)
+ {
+     (void)version;
+ 
+-    wchar_t wname[MAX_PATH];
++    wchar_t wname[MAX_PATH+1] = {0};
+     char *name;
+     void *result;
+ 
+@@ -109,7 +109,7 @@ const char *dl_get_path(void)
+     if (!initialized) {
+         initialized = 1;
+ 
+-        static char path[MAX_PATH];
++        static char path[MAX_PATH + 1];
+         HMODULE hModule;
+         wchar_t wpath[MAX_PATH];
+ 
+diff --git a/src/file/file_win32.c b/src/file/file_win32.c
+index d9845fb..b4fb7ad 100644
+--- a/src/file/file_win32.c
++++ b/src/file/file_win32.c
+@@ -107,9 +107,9 @@ static BD_FILE_H *_file_open(const char* filename, const char *mode)
+ {
+     BD_FILE_H *file;
+     FILE *fp;
+-    wchar_t wfilename[MAX_PATH], wmode[8];
++    wchar_t wfilename[4096 + 1] = {0}, wmode[8] = {0};
+ 
+-    if (!MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, filename, -1, wfilename, MAX_PATH) ||
++    if (!MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, filename, -1, wfilename, 4096) ||
+         !MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, mode, -1, wmode, 8)) {
+ 
+         BD_DEBUG(DBG_FILE, "Error opening file %s\n", filename);
+@@ -122,6 +122,9 @@ static BD_FILE_H *_file_open(const char* filename, const char *mode)
+         return NULL;
+     }
+ 
++    // Set file buffer
++    setvbuf(fp, NULL, _IOFBF, 6144 * 10);
++
+     file = calloc(1, sizeof(BD_FILE_H));
+     if (!file) {
+         BD_DEBUG(DBG_FILE | DBG_CRIT, "Error opening file %s (out of memory)\n", filename);
+diff --git a/src/libbluray/bdnav/clpi_parse.c b/src/libbluray/bdnav/clpi_parse.c
+index 394347e..39bbcef 100644
+--- a/src/libbluray/bdnav/clpi_parse.c
++++ b/src/libbluray/bdnav/clpi_parse.c
+@@ -39,6 +39,7 @@
+ #define CLPI_SIG1  ('H' << 24 | 'D' << 16 | 'M' << 8 | 'V')
+ #define CLPI_SIG2A ('0' << 24 | '2' << 16 | '0' << 8 | '0')
+ #define CLPI_SIG2B ('0' << 24 | '1' << 16 | '0' << 8 | '0')
++#define CLPI_SIG2C ('0' << 24 | '2' << 16 | '4' << 8 | '0')
+ 
+ static void
+ _human_readable_sig(char *sig, uint32_t s1, uint32_t s2)
+@@ -129,7 +130,8 @@ _parse_header(BITSTREAM *bits, CLPI_CL *cl)
+     cl->type_indicator2 = bs_read(bits, 32);
+     if (cl->type_indicator != CLPI_SIG1 || 
+         (cl->type_indicator2 != CLPI_SIG2A &&
+-         cl->type_indicator2 != CLPI_SIG2B)) {
++         cl->type_indicator2 != CLPI_SIG2B &&
++         cl->type_indicator2 != CLPI_SIG2C)) {
+ 
+         char sig[9];
+         char expect[9];
+diff --git a/src/libbluray/bdnav/mpls_parse.c b/src/libbluray/bdnav/mpls_parse.c
+index e196118..87b240a 100644
+--- a/src/libbluray/bdnav/mpls_parse.c
++++ b/src/libbluray/bdnav/mpls_parse.c
+@@ -39,6 +39,7 @@
+ #define MPLS_SIG1  ('M' << 24 | 'P' << 16 | 'L' << 8 | 'S')
+ #define MPLS_SIG2A ('0' << 24 | '2' << 16 | '0' << 8 | '0')
+ #define MPLS_SIG2B ('0' << 24 | '1' << 16 | '0' << 8 | '0')
++#define MPLS_SIG2C ('0' << 24 | '2' << 16 | '4' << 8 | '0')
+ 
+ static void
+ _human_readable_sig(char *sig, uint32_t s1, uint32_t s2)
+@@ -137,8 +138,9 @@ _parse_appinfo(BITSTREAM *bits, MPLS_AI *ai)
+     ai->random_access_flag = bs_read(bits, 1);
+     ai->audio_mix_flag = bs_read(bits, 1);
+     ai->lossless_bypass_flag = bs_read(bits, 1);
++    ai->mvc_base_view_r_flag = bs_read(bits, 1);
+     // Reserved
+-    bs_skip(bits, 13);
++    bs_skip(bits, 12);
+     bs_seek_byte(bits, pos + len);
+     return 1;
+ }
+@@ -155,7 +157,8 @@ _parse_header(BITSTREAM *bits, MPLS_PL *pl)
+     pl->type_indicator2 = bs_read(bits, 32);
+     if (pl->type_indicator != MPLS_SIG1 || 
+         (pl->type_indicator2 != MPLS_SIG2A && 
+-         pl->type_indicator2 != MPLS_SIG2B)) {
++         pl->type_indicator2 != MPLS_SIG2B &&
++         pl->type_indicator2 != MPLS_SIG2C)) {
+ 
+         char sig[9];
+         char expect[9];
+@@ -259,6 +262,7 @@ _parse_stream(BITSTREAM *bits, MPLS_STREAM *s)
+             break;
+     };
+     s->lang[3] = '\0';
++    s->ss_offset_sequence_id = 0xFF;
+ 
+     bs_seek_byte(bits, pos + len);
+     return 1;
+@@ -882,6 +886,99 @@ _parse_subpath_extension(BITSTREAM *bits, MPLS_PL *pl)
+ }
+ 
+ static int
++_parse_stn_ss_extension(BITSTREAM *bits, MPLS_PL *pl)
++{
++    int ii, s;
++    int64_t pos;
++
++    for (ii = 0; ii < pl->list_count; ii++) {
++        uint32_t len = bs_read(bits, 16);
++        pos = bs_pos(bits) >> 3;
++        int Fixed_offset_during_PopUp_flag = bs_read(bits, 1);
++        bs_skip(bits, 15); // reserved
++
++        for (s = 0; s < pl->play_item[ii].stn.num_video; s++) {
++            // stream_entry
++            uint32_t slen = bs_read(bits, 8);
++            bs_skip(bits, slen * 8);
++
++            // stream_attributes_ss
++            slen = bs_read(bits, 8);
++            bs_skip(bits, slen * 8);
++
++            bs_skip(bits, 10); // reserved
++            bs_skip(bits, 6);  // number_of_offset_sequences
++        }
++
++        for (s = 0; s < pl->play_item[ii].stn.num_pg; s++) {
++            pl->play_item[ii].stn.pg[s].ss_offset_sequence_id = bs_read(bits, 8);
++
++            bs_skip(bits, 4); // reserved
++            bs_skip(bits, 1); // dialog_region_offset_valid_flag
++            int is_SS_PG = bs_read(bits, 1);
++            int is_top_AS_PG_textST = bs_read(bits, 1);
++            int is_bottom_AS_PG_textST = bs_read(bits, 1);
++            if (is_SS_PG) {
++                // stream_entry left eye
++                uint32_t slen = bs_read(bits, 8);
++                bs_skip(bits, slen * 8);
++
++                // stream_entry right eye
++                slen = bs_read(bits, 8);
++                bs_skip(bits, slen * 8);
++
++                bs_skip(bits, 8); // reserved
++                bs_skip(bits, 8); // PG offset
++            }
++            if (is_top_AS_PG_textST) {
++                // stream_entry
++                uint32_t slen = bs_read(bits, 8);
++                bs_skip(bits, slen * 8);
++
++                bs_skip(bits, 8); // reserved
++                bs_skip(bits, 8); // PG offset
++            }
++            if (is_bottom_AS_PG_textST) {
++                // stream_entry
++                uint32_t slen = bs_read(bits, 8);
++                bs_skip(bits, slen * 8);
++
++                bs_skip(bits, 8); // reserved
++                bs_skip(bits, 8); // PG offset
++            }
++        }
++
++        for (s = 0; s < pl->play_item[ii].stn.num_ig; s++) {
++            if (Fixed_offset_during_PopUp_flag)
++              bs_skip(bits, 8);
++            else
++              pl->play_item[ii].stn.ig[s].ss_offset_sequence_id = bs_read(bits, 8);
++
++            bs_skip(bits, 16); // IG_Plane_offset_during_BB_video
++            bs_skip(bits, 7); // reserved
++            int is_SS_IG = bs_read(bits, 1);
++            if (is_SS_IG) {
++                // stream_entry left eye
++                uint32_t slen = bs_read(bits, 8);
++                bs_skip(bits, slen * 8);
++
++                // stream_entry right eye
++                slen = bs_read(bits, 8);
++                bs_skip(bits, slen * 8);
++
++                bs_skip(bits, 8); // reserved
++                bs_skip(bits, 8); // PG offset
++            }
++        }
++
++        // Skip to next play item
++        bs_seek_byte(bits, pos + len);
++    }
++
++    return 0;
++}
++
++static int
+ _parse_mpls_extension(BITSTREAM *bits, int id1, int id2, void *handle)
+ {
+     MPLS_PL *pl = (MPLS_PL*)handle;
+@@ -895,7 +992,7 @@ _parse_mpls_extension(BITSTREAM *bits, int id1, int id2, void *handle)
+ 
+     if (id1 == 2) {
+         if (id2 == 1) {
+-            return 0;
++            return _parse_stn_ss_extension(bits, pl);
+         }
+         if (id2 == 2) {
+             // SubPath entries extension
+diff --git a/src/libbluray/bdnav/mpls_parse.h b/src/libbluray/bdnav/mpls_parse.h
+index 94bfa67..c1b2c31 100644
+--- a/src/libbluray/bdnav/mpls_parse.h
++++ b/src/libbluray/bdnav/mpls_parse.h
+@@ -49,6 +49,7 @@ typedef struct
+     uint8_t         sv_num_pip_pg_ref;
+     uint8_t        *sv_secondary_audio_ref;
+     uint8_t        *sv_pip_pg_ref;
++    uint8_t         ss_offset_sequence_id;
+ } MPLS_STREAM;
+ 
+ typedef struct
+@@ -109,6 +110,7 @@ typedef struct
+     uint8_t         random_access_flag;
+     uint8_t         audio_mix_flag;
+     uint8_t         lossless_bypass_flag;
++    uint8_t         mvc_base_view_r_flag;
+ } MPLS_AI;
+ 
+ typedef struct
+diff --git a/src/libbluray/bluray.c b/src/libbluray/bluray.c
+index 0e60b68..f633d7a 100644
+--- a/src/libbluray/bluray.c
++++ b/src/libbluray/bluray.c
+@@ -1626,6 +1626,25 @@ int64_t bd_seek_time(BLURAY *bd, uint64_t tick)
+     return bd->s_pos;
+ }
+ 
++int64_t bd_find_seek_point(BLURAY *bd, uint64_t tick)
++{
++  uint32_t clip_pkt, out_pkt;
++  NAV_CLIP *clip;
++
++  tick /= 2;
++
++  if (bd->title &&
++    tick < bd->title->duration) {
++
++      // Find the closest access unit to the requested position
++      clip = nav_time_search(bd->title, (uint32_t)tick, &clip_pkt, &out_pkt);
++
++      return (int64_t)out_pkt * 192;
++  }
++
++  return bd->s_pos;
++}
++
+ uint64_t bd_tell_time(BLURAY *bd)
+ {
+     uint32_t clip_pkt = 0, out_pkt = 0, out_time = 0;
+@@ -2602,6 +2621,7 @@ static BLURAY_TITLE_INFO* _fill_title_info(NAV_TITLE* title, uint32_t title_idx,
+         BLURAY_CLIP_INFO *ci = &title_info->clips[ii];
+         NAV_CLIP *nc = &title->clip_list.clip[ii];
+ 
++        ci->idx = nc->clip_id;
+         ci->pkt_count = nc->end_pkt - nc->start_pkt;
+         ci->start_time = (uint64_t)nc->title_time * 2;
+         ci->in_time = (uint64_t)pi->in_time * 2;
+@@ -2628,6 +2648,8 @@ static BLURAY_TITLE_INFO* _fill_title_info(NAV_TITLE* title, uint32_t title_idx,
+         _copy_streams(nc, ci->sec_audio_streams, pi->stn.secondary_audio, ci->sec_audio_stream_count);
+     }
+ 
++    title_info->mvc_base_view_r_flag = title->pl->app_info.mvc_base_view_r_flag;
++
+     return title_info;
+ }
+ 
+@@ -3746,3 +3768,28 @@ void bd_free_bdjo(struct bdjo_data *obj)
+     (void)obj;
+ #endif
+ }
++
++int bd_get_clip_infos(BLURAY *bd, unsigned clip, uint64_t *clip_start_time, uint64_t *stream_start_time, uint64_t *pos, uint64_t *duration)
++{
++    if (bd && bd->title && bd->title->clip_list.count > clip) {
++      if (clip_start_time)
++        *clip_start_time = (uint64_t)bd->title->clip_list.clip[clip].title_time << 1;
++      if (stream_start_time)
++        *stream_start_time = (uint64_t)bd->title->clip_list.clip[clip].in_time << 1;
++      if (pos)
++        *pos = (uint64_t)bd->title->clip_list.clip[clip].title_pkt * 192;
++      if (duration)
++        *duration = (uint64_t)bd->title->clip_list.clip[clip].duration << 1;
++
++      return 1;
++    }
++    return 0;
++}
++
++struct mpls_pl* bd_get_title_mpls(BLURAY * bd)
++{
++  if (bd && bd->title) {
++    return bd->title->pl;
++  }
++  return NULL;
++}
+diff --git a/src/libbluray/bluray.h b/src/libbluray/bluray.h
+index cbf16fc..97dc1a3 100644
+--- a/src/libbluray/bluray.h
++++ b/src/libbluray/bluray.h
+@@ -32,6 +32,7 @@ extern "C" {
+  */
+ 
+ #include <stdint.h>
++#include "bdnav/clpi_data.h"
+ 
+ #define TITLES_ALL              0    /**< all titles. */
+ #define TITLES_FILTER_DUP_TITLE 0x01 /**< remove duplicate titles. */
+@@ -225,6 +226,7 @@ typedef struct bd_stream_info {
+ } BLURAY_STREAM_INFO;
+ 
+ typedef struct bd_clip {
++    uint32_t           idx;
+     uint32_t           pkt_count;
+     uint8_t            still_mode;
+     uint16_t           still_time;  /* seconds */
+@@ -275,6 +277,8 @@ typedef struct bd_title_info {
+ 
+     uint32_t             mark_count;
+     BLURAY_TITLE_MARK    *marks;
++
++    uint8_t              mvc_base_view_r_flag;
+ } BLURAY_TITLE_INFO;
+ 
+ /*
+@@ -483,6 +487,16 @@ uint32_t bd_get_current_title(BLURAY *bd);
+ 
+ /**
+  *
++ * Find the byte position to specific time in 90Khz ticks
++ *
++ * @param bd    BLURAY ojbect
++ * @param tick  tick count
++ * @return byte position
++ */
++int64_t bd_find_seek_point(BLURAY *bd, uint64_t tick);
++
++/**
++ *
+  *  Read from currently selected title file, decrypt if possible
+  *
+  * @param bd  BLURAY object
+@@ -1007,7 +1021,6 @@ int bd_mouse_select(BLURAY *bd, int64_t pts, uint16_t x, uint16_t y);
+ 
+ /* access to internal information */
+ 
+-struct clpi_cl;
+ /**
+  *
+  *  Get copy of clip information for requested playitem.
+@@ -1060,6 +1073,28 @@ void bd_stop_bdj(BLURAY *bd); // shutdown BD-J and clean up resources
+  */
+ int bd_read_file(BLURAY *, const char *path, void **data, int64_t *size);
+ 
++/**
++ *
++ * Get information about the clip
++ *
++ * @param bd  BLURAY object
++ * @param clip clip index
++ * @param clip_start_time start of the clip (in the total title) (in 90khz)
++ * @param stream_start_time first pts in the clip (in 90khz)
++ * @param byte position of the clip (absolute)
++ * @param duration duration of the clip (in 90khz)
++ */
++int bd_get_clip_infos(BLURAY *bd, unsigned clip, uint64_t *clip_start_time, uint64_t *stream_start_time, uint64_t *pos, uint64_t *duration);
++
++/**
++ * Get the MPLS struct of the current title
++ *
++ * @param bd BLURAY object
++ * @return the MPLS struct
++ *
++ * Lifetime of the MPLS pointer is limited to the lifetime of the BD title
++ */
++struct mpls_pl* bd_get_title_mpls(BLURAY * bd);
+ 
+ #ifdef __cplusplus
+ }
+diff --git a/src/libbluray/disc/disc.c b/src/libbluray/disc/disc.c
+index defa084..375e6c3 100644
+--- a/src/libbluray/disc/disc.c
++++ b/src/libbluray/disc/disc.c
+@@ -69,7 +69,7 @@ static BD_FILE_H *_bdrom_open_path(void *p, const char *rel_path)
+         return NULL;
+     }
+ 
+-    fp = file_open(abs_path, "rb");
++    fp = file_open(abs_path, "rbS");
+     X_FREE(abs_path);
+ 
+     return fp;
-- 
2.7.4


From 6d964a1167ce5c4c3e4b178ace5b1f9ffceb941d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 2 Mar 2016 19:40:47 +0000
Subject: [PATCH 148/175] Added new msdk-mvc decoder.

---
 xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.cpp | 61 ++++++++++++++++++++++
 xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h   |  4 ++
 2 files changed, 65 insertions(+)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.cpp
index ac4e063..0d88acf 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.cpp
@@ -24,6 +24,7 @@
 #include "utils/log.h"
 #include "cores/FFmpeg.h"
 #include "Util.h"
+#include <assert.h>
 
 #ifdef TARGET_WINDOWS
 #pragma comment(lib, "avcodec.lib")
@@ -37,6 +38,7 @@
 
 extern "C" {
 #include "libswscale/swscale.h"
+#include "libavutil/intreadwrite.h"
 }
 
 // allocate a new picture (AV_PIX_FMT_YUV420P)
@@ -402,6 +404,65 @@ double CDVDCodecUtils::NormalizeFrameduration(double frameduration, bool *match)
   }
 }
 
+bool CDVDCodecUtils::IsH264AnnexB(std::string format, AVStream *avstream)
+{
+  assert(avstream->codec->codec_id == AV_CODEC_ID_H264 || avstream->codec->codec_id == AV_CODEC_ID_H264_MVC);
+  if (avstream->codec->extradata_size < 4)
+    return true;
+  if (avstream->codec->extradata[0] == 1)
+    return false;
+  if (format == "avi")
+  {
+    BYTE *src = avstream->codec->extradata;
+    unsigned startcode = AV_RB32(src);
+    if (startcode == 0x00000001 || (startcode & 0xffffff00) == 0x00000100)
+      return true;
+    if (avstream->codec->codec_tag == MKTAG('A', 'V', 'C', '1') || avstream->codec->codec_tag == MKTAG('a', 'v', 'c', '1'))
+      return false;
+  }
+  return true;
+}
+
+bool CDVDCodecUtils::ProcessH264MVCExtradata(uint8_t *data, int data_size, uint8_t **mvc_data, int *mvc_data_size)
+{
+  uint8_t* extradata = data;
+  int extradata_size = data_size;
+
+  if (extradata_size > 4 && *(char *)extradata == 1)
+  {
+    // Find "mvcC" atom
+    uint32_t state = -1;
+    int i = 0;
+    for (; i < extradata_size; i++)
+    {
+      state = (state << 8) | extradata[i];
+      if (state == MKBETAG('m', 'v', 'c', 'C'))
+        break;
+    }
+    if (i >= 8 && i < extradata_size)
+    {
+      // Update pointers to the start of the mvcC atom
+      extradata = extradata + i - 7;
+      extradata_size = extradata_size - i + 7;
+      // verify size atom and actual size
+      if (extradata_size >= 14 && (AV_RB32(extradata) + 4) <= extradata_size)
+      {
+        extradata += 8;
+        extradata_size -= 8;
+        if (*(char *)extradata == 1)
+        {
+          if (mvc_data)
+            *mvc_data = extradata;
+          if (mvc_data_size)
+            *mvc_data_size = extradata_size;
+          return true;
+        }
+      }
+    }
+  }
+  return false;
+}
+
 struct EFormatMap {
   AVPixelFormat   pix_fmt;
   ERenderFormat format;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h b/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h
index 361c966..8ec50bb 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h
@@ -28,6 +28,7 @@ extern "C" {
 }
 
 struct YV12Image;
+class AVStream;
 
 class CDVDCodecUtils
 {
@@ -46,6 +47,9 @@ public:
 
   static double NormalizeFrameduration(double frameduration, bool *match = NULL);
 
+  static bool IsH264AnnexB(std::string format, AVStream *avstream);
+  static bool ProcessH264MVCExtradata(uint8_t *extradata, int extradata_size, uint8_t **mvc_extradata = nullptr, int *mvc_extradata_size = nullptr);
+
   static ERenderFormat EFormatFromPixfmt(int fmt);
   static AVPixelFormat PixfmtFromEFormat(ERenderFormat format);
 };
-- 
2.7.4


From 6977dd5a110f6dcd8a1f31281fb54b5cd8452354 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 6 Mar 2016 12:54:59 +0000
Subject: [PATCH 149/175] mvc: Automatically enable stereo mode

---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp | 6 +++++-
 xbmc/cores/omxplayer/OMXVideo.cpp                    | 6 +++++-
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
index cead68b..38e7d44 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
@@ -405,13 +405,17 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
   switch (hints.codec)
   {
     case AV_CODEC_ID_H264:
+    case AV_CODEC_ID_H264_MVC:
       // H.264
       m_codingType = MMAL_ENCODING_H264;
       m_pFormatName = "mmal-h264";
-      if (CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_SUPPORTMVC))
+      if ((hints.codec_tag == MKTAG('M', 'V', 'C', '1') || hints.codec_tag == MKTAG('A', 'M', 'V', 'C')) &&
+        CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_SUPPORTMVC))
       {
         m_codingType = MMAL_ENCODING_MVC;
         m_pFormatName= "mmal-mvc";
+        if (hints.stereo_mode == "mono")
+          hints.stereo_mode = "mvc_lr";
       }
     break;
     case AV_CODEC_ID_H263:
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 311dd66..536332c 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -398,6 +398,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool hdmi_clock_syn
   switch (hints.codec)
   {
     case AV_CODEC_ID_H264:
+    case AV_CODEC_ID_H264_MVC:
     {
       switch(hints.profile)
       {
@@ -434,10 +435,13 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool hdmi_clock_syn
           break;
       }
     }
-    if (CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_SUPPORTMVC))
+    if ((hints.codec_tag == MKTAG('M', 'V', 'C', '1') || hints.codec_tag == MKTAG('A', 'M', 'V', 'C')) &&
+      CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_SUPPORTMVC))
     {
       m_codingType = OMX_VIDEO_CodingMVC;
       m_video_codec_name = "omx-mvc";
+      if (hints.stereo_mode == "mono")
+        hints.stereo_mode = "mvc_lr";
     }
     break;
     case AV_CODEC_ID_MPEG4:
-- 
2.7.4


From 7b56033f354680c3f89497357c729e4ab0033994 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 24 Mar 2016 13:02:58 +0000
Subject: [PATCH 150/175] ffmpeg: mvc: fix for pixelation from packets with no
 pts/dts

---
 .../73fde6f9f3d01f7fc0f3ae4b66f6c725f9fb1105.patch | 24 ++++++++++++++++++++++
 tools/depends/target/ffmpeg/Makefile               |  4 +++-
 2 files changed, 27 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/73fde6f9f3d01f7fc0f3ae4b66f6c725f9fb1105.patch

diff --git a/tools/depends/target/ffmpeg/73fde6f9f3d01f7fc0f3ae4b66f6c725f9fb1105.patch b/tools/depends/target/ffmpeg/73fde6f9f3d01f7fc0f3ae4b66f6c725f9fb1105.patch
new file mode 100644
index 0000000..5240cf5
--- /dev/null
+++ b/tools/depends/target/ffmpeg/73fde6f9f3d01f7fc0f3ae4b66f6c725f9fb1105.patch
@@ -0,0 +1,24 @@
+From 73fde6f9f3d01f7fc0f3ae4b66f6c725f9fb1105 Mon Sep 17 00:00:00 2001
+From: Hendrik Leppkes <h.leppkes@gmail.com>
+Date: Mon, 1 Sep 2014 11:39:09 +0200
+Subject: [PATCH] h264_parser: force grabing a new timestamp until a frame
+ start was found
+
+---
+ libavcodec/h264_parser.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/libavcodec/h264_parser.c b/libavcodec/h264_parser.c
+index 2fd3f2b..7165652 100644
+--- a/libavcodec/h264_parser.c
++++ b/libavcodec/h264_parser.c
+@@ -525,6 +525,9 @@ static int h264_parse(AVCodecParserContext *s,
+     } else {
+         next = h264_find_frame_end(p, buf, buf_size);
+ 
++        if (next == END_NOT_FOUND && pc->frame_start_found == 0)
++            s->fetch_timestamp = 1;
++
+         if (ff_combine_frame(pc, next, &buf, &buf_size) < 0) {
+             *poutbuf      = NULL;
+             *poutbuf_size = 0;
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 7e97e4d..d4f279f 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -6,7 +6,8 @@ DEPS= ../../Makefile.include FFMPEG-VERSION Makefile \
   pfcd_hevc_optimisations.patch \
   0001-Squashed-commit-of-the-following.patch \
   0001-avcodec-add-h264_mvc-codec-id-and-profiles.patch 0001-h264_parser-add-support-for-parsing-h264-mvc-NALUs.patch \
-  h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch
+  h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch \
+  73fde6f9f3d01f7fc0f3ae4b66f6c725f9fb1105.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -95,6 +96,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); patch -p1 < ../0001-avcodec-add-h264_mvc-codec-id-and-profiles.patch
 	cd $(PLATFORM); patch -p1 < ../0001-h264_parser-add-support-for-parsing-h264-mvc-NALUs.patch
 	cd $(PLATFORM); patch -p1 < ../h264_parser_fix_parsing_of_mvc_slices_in_some_corner_cases.patch
+	cd $(PLATFORM); patch -p1 < ../73fde6f9f3d01f7fc0f3ae4b66f6c725f9fb1105.patch
 
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
-- 
2.7.4


From 2f6350150320f89f33a1fa4b490d682a9486ba64 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 9 Mar 2016 13:08:44 +0000
Subject: [PATCH 151/175] stereoscopicmanager: remove hardwarebased for rbp

---
 xbmc/guilib/StereoscopicsManager.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/guilib/StereoscopicsManager.cpp b/xbmc/guilib/StereoscopicsManager.cpp
index 6eb0752..9426604 100644
--- a/xbmc/guilib/StereoscopicsManager.cpp
+++ b/xbmc/guilib/StereoscopicsManager.cpp
@@ -72,8 +72,10 @@ static const struct StereoModeMap VideoModeToGuiModeMap[] =
   { "anaglyph_yellow_blue",     RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE },
   { "block_lr",                 RENDER_STEREO_MODE_OFF }, // unsupported
   { "block_rl",                 RENDER_STEREO_MODE_OFF }, // unsupported
+#ifndef TARGET_RASPBERRY_PI
   { "mvc_lr",                   RENDER_STEREO_MODE_HARDWAREBASED }, 
   { "mvc_rl",                   RENDER_STEREO_MODE_HARDWAREBASED },
+#endif
   { "mvc_lr",                   RENDER_STEREO_MODE_SPLIT_HORIZONTAL }, // fallback
   { "mvc_rl",                   RENDER_STEREO_MODE_SPLIT_HORIZONTAL }, // fallback
   {}
-- 
2.7.4


From 59258ff3d4b91f8283f8f71adfc0e9d01f40a1b7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 17 May 2016 19:24:08 +0100
Subject: [PATCH 152/175] stereoscopics: Switch to using block_lr for mvc to
 match makemkv

See: http://forum.kodi.tv/showthread.php?tid=221407&pid=2339656#pid2339656
---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp  |  2 +-
 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp |  2 +-
 xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp | 12 ++++--------
 xbmc/cores/omxplayer/OMXVideo.cpp                     |  2 +-
 xbmc/guilib/StereoscopicsManager.cpp                  | 11 +++++------
 5 files changed, 12 insertions(+), 17 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
index 38e7d44..654a927 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
@@ -415,7 +415,7 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
         m_codingType = MMAL_ENCODING_MVC;
         m_pFormatName= "mmal-mvc";
         if (hints.stereo_mode == "mono")
-          hints.stereo_mode = "mvc_lr";
+          hints.stereo_mode = "block_lr";
       }
     break;
     case AV_CODEC_ID_H263:
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 511b44b..ba73712 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -1444,7 +1444,7 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
                 CDVDInputStreamBluray *bluRay = static_cast<CDVDInputStreamBluray*>(m_pInput);
                 if (bluRay->HasMVC())
                 {
-                  st->stereo_mode = bluRay->AreEyesFlipped() ? "mvc_rl" : "mvc_lr";
+                  st->stereo_mode = bluRay->AreEyesFlipped() ? "block_rl" : "block_lr";
                   mvcStream = static_cast<CDVDDemuxMVC*>(bluRay->GetDemuxMVC())->GetAVStream();
                 }
               }
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp
index 04ceed1..49f7f7c 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp
@@ -102,10 +102,8 @@ namespace RenderManager {
       convert["right_left"]             = CONF_FLAGS_STEREO_MODE_SBS | CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT;
       convert["anaglyph_green_magenta"] = 0u;
       convert["anaglyph_yellow_blue"]   = 0u;
-      convert["block_lr"]               = 0u;
-      convert["block_rl"]               = 0u;
-      convert["mvc_lr"]                 = 0u;
-      convert["mvc_rl"]                 = 0u;
+      convert["block_lr"]               = CONF_FLAGS_STEREO_CADANCE_LEFT_RIGHT;
+      convert["block_rl"]               = CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT;
     }
     return convert[mode];
   }
@@ -125,10 +123,8 @@ namespace RenderManager {
       convert["row_interleaved_lr"]     = "row_interleaved_rl";
       convert["col_interleaved_rl"]     = "col_interleaved_lr";
       convert["col_interleaved_lr"]     = "col_interleaved_rl";
-      convert["block_lr"]               = "block_lr";
-      convert["block_rl"]               = "block_rl";
-      convert["mvc_lr"]                 = "mvc_rl";
-      convert["mvc_rl"]                 = "mvc_lr";
+      convert["block_lr"]               = "block_rl";
+      convert["block_rl"]               = "block_lr";
     }
     std::string res = convert[mode];
     if(res.empty())
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 536332c..39bc053 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -441,7 +441,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool hdmi_clock_syn
       m_codingType = OMX_VIDEO_CodingMVC;
       m_video_codec_name = "omx-mvc";
       if (hints.stereo_mode == "mono")
-        hints.stereo_mode = "mvc_lr";
+        hints.stereo_mode = "block_lr";
     }
     break;
     case AV_CODEC_ID_MPEG4:
diff --git a/xbmc/guilib/StereoscopicsManager.cpp b/xbmc/guilib/StereoscopicsManager.cpp
index 9426604..cc929b5 100644
--- a/xbmc/guilib/StereoscopicsManager.cpp
+++ b/xbmc/guilib/StereoscopicsManager.cpp
@@ -70,14 +70,13 @@ static const struct StereoModeMap VideoModeToGuiModeMap[] =
   { "anaglyph_cyan_red",        RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN },
   { "anaglyph_green_magenta",   RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA },
   { "anaglyph_yellow_blue",     RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE },
-  { "block_lr",                 RENDER_STEREO_MODE_OFF }, // unsupported
-  { "block_rl",                 RENDER_STEREO_MODE_OFF }, // unsupported
 #ifndef TARGET_RASPBERRY_PI
-  { "mvc_lr",                   RENDER_STEREO_MODE_HARDWAREBASED }, 
-  { "mvc_rl",                   RENDER_STEREO_MODE_HARDWAREBASED },
+  { "block_lr",                 RENDER_STEREO_MODE_HARDWAREBASED },
+  { "block_rl",                 RENDER_STEREO_MODE_HARDWAREBASED },
+#else
+  { "block_lr",                 RENDER_STEREO_MODE_SPLIT_HORIZONTAL }, // fallback
+  { "block_rl",                 RENDER_STEREO_MODE_SPLIT_HORIZONTAL }, // fallback
 #endif
-  { "mvc_lr",                   RENDER_STEREO_MODE_SPLIT_HORIZONTAL }, // fallback
-  { "mvc_rl",                   RENDER_STEREO_MODE_SPLIT_HORIZONTAL }, // fallback
   {}
 };
 
-- 
2.7.4


From cf0fed688fccfd377d77c799042fe86aa255e462 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <anightik@gmail.com>
Date: Thu, 10 Mar 2016 18:11:33 +0300
Subject: [PATCH 153/175] fixup! Revert supporting crappy tab/sbs subtitles.
 this fixes regular subtitles.

---
 .../VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp      | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
index 3a080d0..7c0b707 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
@@ -243,20 +243,20 @@ CDVDOverlay* CDVDOverlayCodecFFmpeg::GetOverlay()
       }
     }
 
-    RENDER_STEREO_MODE render_stereo_mode = g_graphicsContext.GetStereoMode();
+    /*RENDER_STEREO_MODE render_stereo_mode = g_graphicsContext.GetStereoMode();
     if (render_stereo_mode != RENDER_STEREO_MODE_OFF)
     {
-      if (rect.h > m_height / 2)
+      if ((rect.h - rect.y) > m_height / 2)
       {
         m_height /= 2;
         rect.h /= 2;
       }
-      else if (rect.w > m_width / 2)
+      else if ((rect.w - rect.x) > m_width / 2)
       {
         m_width /= 2;
         rect.w /= 2;
       }
-    }
+    }*/
 
     CDVDOverlayImage* overlay = new CDVDOverlayImage();
 
@@ -290,6 +290,7 @@ CDVDOverlay* CDVDOverlayCodecFFmpeg::GetOverlay()
 
     m_SubtitleIndex++;
 
+    CLog::Log(LOGDEBUG, "Overlay: x:%d y:%d w:%d h:%d", overlay->x, overlay->y, overlay->width, overlay->height);
     return overlay;
   }
 
-- 
2.7.4


From 69b4ecdfb7053749c73f9c3f159cb509fd5dfe42 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 10 Feb 2015 15:29:16 +0000
Subject: [PATCH 154/175] Add repeating keypress patch from popcornmix' repo

---
 tools/depends/target/libcec/Makefile         |   1 +
 tools/depends/target/libcec/popcornmix.patch | 859 +++++++++++++++++++++++++++
 2 files changed, 860 insertions(+)
 create mode 100644 tools/depends/target/libcec/popcornmix.patch

diff --git a/tools/depends/target/libcec/Makefile b/tools/depends/target/libcec/Makefile
index f54af9e..ddf9963 100644
--- a/tools/depends/target/libcec/Makefile
+++ b/tools/depends/target/libcec/Makefile
@@ -21,6 +21,7 @@ $(TARBALLS_LOCATION)/$(ARCHIVE):
 $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM); mkdir -p $(PLATFORM)/build
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
+	cd $(PLATFORM); patch -p1 < ../popcornmix.patch
 	cd $(PLATFORM)/build; $(CMAKE) -DBUILD_SHARED_LIBS=1 -DSKIP_PYTHON_WRAPPER:STRING=1 -DCMAKE_INSTALL_LIBDIR=$(PREFIX)/lib ..
 
 $(LIBDYLIB): $(PLATFORM)
diff --git a/tools/depends/target/libcec/popcornmix.patch b/tools/depends/target/libcec/popcornmix.patch
new file mode 100644
index 0000000..8366a69
--- /dev/null
+++ b/tools/depends/target/libcec/popcornmix.patch
@@ -0,0 +1,859 @@
+From ec982e9800ae312972d306b67779215a2add6cde Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Fri, 24 Oct 2014 13:45:21 +0100
+Subject: [PATCH 1/6] Make released key polling wait for exact time until key
+ gets released
+
+---
+ src/libcec/CECClient.cpp    | 16 ++++++++++++++--
+ src/libcec/CECClient.h      |  2 +-
+ src/libcec/CECProcessor.cpp |  8 +++++---
+ src/libcec/LibCEC.cpp       | 10 ++++++++--
+ src/libcec/LibCEC.h         |  4 +++-
+ 5 files changed, 31 insertions(+), 9 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index 35c2d3e..e307c0e 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -1067,7 +1067,7 @@ void CCECClient::SetCurrentButton(const cec_user_control_code iButtonCode)
+   AddKey(key);
+ }
+ 
+-void CCECClient::CheckKeypressTimeout(void)
++uint16_t CCECClient::CheckKeypressTimeout(void)
+ {
+   cec_keypress key;
+ 
+@@ -1091,12 +1091,24 @@ void CCECClient::CheckKeypressTimeout(void)
+     }
+     else
+     {
+-      return;
++      // time when this keypress will be released and we'd like to be called again
++      unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
++      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
++        timeout = iTimeoutMs - (iNow - m_buttontime) + 1;
++      else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey)
++        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_buttontime) + 1;
++      if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
++      {
++        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_buttontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
++        timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
++      }
++      return timeout;
+     }
+   }
+ 
+   LIB_CEC->AddLog(CEC_LOG_DEBUG, "key auto-released: %s (%1x)", ToString(key.keycode), key.keycode);
+   QueueAddKey(key);
++  return CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+ }
+ 
+ bool CCECClient::EnableCallbacks(void *cbParam, ICECCallbacks *callbacks)
+diff --git a/src/libcec/CECClient.h b/src/libcec/CECClient.h
+index 12f8a3b..c9ce5e3 100644
+--- a/src/libcec/CECClient.h
++++ b/src/libcec/CECClient.h
+@@ -272,7 +272,7 @@ namespace CEC
+     virtual void                  AddKey(bool bSendComboKey = false);
+     virtual void                  AddKey(const cec_keypress &key);
+     virtual void                  SetCurrentButton(const cec_user_control_code iButtonCode);
+-    virtual void                  CheckKeypressTimeout(void);
++    virtual uint16_t              CheckKeypressTimeout(void);
+     virtual void                  SourceActivated(const cec_logical_address logicalAddress);
+     virtual void                  SourceDeactivated(const cec_logical_address logicalAddress);
+ 
+diff --git a/src/libcec/CECProcessor.cpp b/src/libcec/CECProcessor.cpp
+index 99f71aa..604b950 100644
+--- a/src/libcec/CECProcessor.cpp
++++ b/src/libcec/CECProcessor.cpp
+@@ -52,7 +52,6 @@
+ using namespace CEC;
+ using namespace PLATFORM;
+ 
+-#define CEC_PROCESSOR_SIGNAL_WAIT_TIME 1000
+ #define ACTIVE_SOURCE_CHECK_INTERVAL   500
+ #define TV_PRESENT_CHECK_INTERVAL      30000
+ 
+@@ -260,6 +259,7 @@ bool CCECProcessor::OnCommandReceived(const cec_command &command)
+ 
+ void *CCECProcessor::Process(void)
+ {
++  uint16_t timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   m_libcec->AddLog(CEC_LOG_DEBUG, "processor thread started");
+ 
+   if (!m_connCheck)
+@@ -274,13 +274,13 @@ void *CCECProcessor::Process(void)
+   while (!IsStopped() && m_communication->IsOpen())
+   {
+     // wait for a new incoming command, and process it
+-    if (m_inBuffer.Pop(command, CEC_PROCESSOR_SIGNAL_WAIT_TIME))
++    if (m_inBuffer.Pop(command, timeout))
+       ProcessCommand(command);
+ 
+     if (CECInitialised() && !IsStopped())
+     {
+       // check clients for keypress timeouts
+-      m_libcec->CheckKeypressTimeout();
++      timeout = m_libcec->CheckKeypressTimeout();
+ 
+       // check if we need to replace handlers
+       ReplaceHandlers();
+@@ -311,6 +311,8 @@ void *CCECProcessor::Process(void)
+         tvPresentCheck.Init(TV_PRESENT_CHECK_INTERVAL);
+       }
+     }
++    else
++      timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   }
+ 
+   return NULL;
+diff --git a/src/libcec/LibCEC.cpp b/src/libcec/LibCEC.cpp
+index af36b79..5ccb8dd 100644
+--- a/src/libcec/LibCEC.cpp
++++ b/src/libcec/LibCEC.cpp
+@@ -361,11 +361,17 @@ bool CLibCEC::IsValidPhysicalAddress(uint16_t iPhysicalAddress)
+          iPhysicalAddress <= CEC_MAX_PHYSICAL_ADDRESS;
+ }
+ 
+-void CLibCEC::CheckKeypressTimeout(void)
++uint16_t CLibCEC::CheckKeypressTimeout(void)
+ {
++  uint16_t timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   // check all clients
+   for (std::vector<CECClientPtr>::iterator it = m_clients.begin(); it != m_clients.end(); it++)
+-    (*it)->CheckKeypressTimeout();
++  {
++    uint16_t t = (*it)->CheckKeypressTimeout();
++    if (t < timeout)
++      timeout = t;
++  }
++  return timeout;
+ }
+ 
+ void CLibCEC::AddLog(const cec_log_level level, const char *strFormat, ...)
+diff --git a/src/libcec/LibCEC.h b/src/libcec/LibCEC.h
+index 6d9a229..d9d1e7b 100644
+--- a/src/libcec/LibCEC.h
++++ b/src/libcec/LibCEC.h
+@@ -39,6 +39,8 @@
+ #include "CECTypeUtils.h"
+ #include <memory>
+ 
++#define CEC_PROCESSOR_SIGNAL_WAIT_TIME 1000
++
+ namespace CEC
+ {
+   class CAdapterCommunication;
+@@ -125,7 +127,7 @@ namespace CEC
+ 
+       void AddLog(const cec_log_level level, const char *strFormat, ...);
+       void AddCommand(const cec_command &command);
+-      void CheckKeypressTimeout(void);
++      uint16_t CheckKeypressTimeout(void);
+       void Alert(const libcec_alert type, const libcec_parameter &param);
+ 
+       static bool IsValidPhysicalAddress(uint16_t iPhysicalAddress);
+-- 
+1.9.1
+
+
+From 41f0f3ec9ac136da3565c96fd5a7075499f3938d Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Fri, 24 Oct 2014 13:51:34 +0100
+Subject: [PATCH 2/6] Keep track of time since initial button press and last
+ button update
+
+---
+ src/libcec/CECClient.cpp | 44 +++++++++++++++++++++++++++-----------------
+ src/libcec/CECClient.h   |  3 ++-
+ 2 files changed, 29 insertions(+), 18 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index e307c0e..e7935b9 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -54,7 +54,8 @@ CCECClient::CCECClient(CCECProcessor *processor, const libcec_configuration &con
+     m_bInitialised(false),
+     m_bRegistered(false),
+     m_iCurrentButton(CEC_USER_CONTROL_CODE_UNKNOWN),
+-    m_buttontime(0),
++    m_initialButtontime(0),
++    m_updateButtontime(0),
+     m_iPreventForwardingPowerOffCommand(0),
+     m_iLastKeypressTime(0)
+ {
+@@ -981,9 +982,10 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */)
+     CLockObject lock(m_mutex);
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN)
+     {
+-      key.duration = (unsigned int) (GetTimeMs() - m_buttontime);
++      unsigned int duration = (unsigned int) (GetTimeMs() - m_updateButtontime);
++      key.duration = (unsigned int) (GetTimeMs() - m_initialButtontime);
+ 
+-      if (key.duration > m_configuration.iComboKeyTimeoutMs ||
++      if (duration > m_configuration.iComboKeyTimeoutMs ||
+           m_configuration.iComboKeyTimeoutMs == 0 ||
+           m_iCurrentButton != m_configuration.comboKey ||
+           bSendComboKey)
+@@ -991,14 +993,15 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */)
+         key.keycode = m_iCurrentButton;
+ 
+         m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
+-        m_buttontime = 0;
++        m_initialButtontime = 0;
++        m_updateButtontime = 0;
+       }
+     }
+   }
+ 
+   if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
+   {
+-    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key released: %s (%1x)", ToString(key.keycode), key.keycode);
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key released: %s (%1x) D:%dms", ToString(key.keycode), key.keycode, key.duration);
+     QueueAddKey(key);
+   }
+ }
+@@ -1012,7 +1015,7 @@ void CCECClient::AddKey(const cec_keypress &key)
+     AddKey();
+     return;
+   }
+-
++  bool isrepeat = false;
+   cec_keypress transmitKey(key);
+   cec_user_control_code comboKey(m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5) ?
+       m_configuration.comboKey : CEC_USER_CONTROL_CODE_STOP);
+@@ -1035,22 +1038,27 @@ void CCECClient::AddKey(const cec_keypress &key)
+         AddKey(true);
+     }
+ 
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x) current(%lx) duration(%d)", ToString(transmitKey.keycode), transmitKey.keycode, m_iCurrentButton, key.duration);
++
+     if (m_iCurrentButton == key.keycode)
+     {
+-      m_buttontime = GetTimeMs();
++      m_updateButtontime = GetTimeMs();
++      isrepeat = true;
+     }
+     else
+     {
+-      AddKey();
++      if (m_iCurrentButton != transmitKey.keycode)
++        AddKey();
+       if (key.duration == 0)
+       {
+         m_iCurrentButton = transmitKey.keycode;
+-        m_buttontime = m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN || key.duration > 0 ? 0 : GetTimeMs();
++        m_initialButtontime = m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN || key.duration > 0 ? 0 : GetTimeMs();
++        m_updateButtontime = m_initialButtontime;
+       }
+     }
+   }
+ 
+-  if (key.keycode != comboKey || key.duration > 0)
++  if (!isrepeat && (key.keycode != comboKey || key.duration > 0))
+   {
+     LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x)", ToString(transmitKey.keycode), transmitKey.keycode);
+     QueueAddKey(transmitKey);
+@@ -1074,32 +1082,34 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+   {
+     CLockObject lock(m_mutex);
+     uint64_t iNow = GetTimeMs();
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s T:%.3f", __FUNCTION__, iNow*1e-3);
+     cec_user_control_code comboKey(m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5) ?
+         m_configuration.comboKey : CEC_USER_CONTROL_CODE_STOP);
+     uint32_t iTimeoutMs(m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5) ?
+         m_configuration.iComboKeyTimeoutMs : CEC_DEFAULT_COMBO_TIMEOUT_MS);
+ 
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_buttontime > iTimeoutMs) ||
+-          (m_iCurrentButton != comboKey && iNow - m_buttontime > CEC_BUTTON_TIMEOUT)))
++          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime > iTimeoutMs) ||
++          (m_iCurrentButton != comboKey && iNow - m_updateButtontime > CEC_BUTTON_TIMEOUT)))
+     {
+-      key.duration = (unsigned int) (iNow - m_buttontime);
++      key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+ 
+       m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
+-      m_buttontime = 0;
++      m_initialButtontime = 0;
++      m_updateButtontime = 0;
+     }
+     else
+     {
+       // time when this keypress will be released and we'd like to be called again
+       unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
+-        timeout = iTimeoutMs - (iNow - m_buttontime) + 1;
++        timeout = iTimeoutMs - (iNow - m_updateButtontime) + 1;
+       else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey)
+-        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_buttontime) + 1;
++        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_updateButtontime) + 1;
+       if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
+       {
+-        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_buttontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
++        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_updateButtontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
+         timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       }
+       return timeout;
+diff --git a/src/libcec/CECClient.h b/src/libcec/CECClient.h
+index c9ce5e3..611c68b 100644
+--- a/src/libcec/CECClient.h
++++ b/src/libcec/CECClient.h
+@@ -404,7 +404,8 @@ namespace CEC
+     PLATFORM::CMutex      m_mutex;                             /**< mutex for changes to this instance */
+     PLATFORM::CMutex      m_cbMutex;                           /**< mutex that is held when doing anything with callbacks */
+     cec_user_control_code m_iCurrentButton;                    /**< the control code of the button that's currently held down (if any) */
+-    int64_t               m_buttontime;                        /**< the timestamp when the button was pressed (in seconds since epoch), or 0 if none was pressed. */
++    int64_t               m_initialButtontime;                 /**< the timestamp when the button was initially pressed (in seconds since epoch), or 0 if none was pressed. */
++    int64_t               m_updateButtontime;                  /**< the timestamp when the button was updated (in seconds since epoch), or 0 if none was pressed. */
+     int64_t               m_iPreventForwardingPowerOffCommand; /**< prevent forwarding standby commands until this time */
+     int64_t               m_iLastKeypressTime;                 /**< last time a key press was sent to the client */
+     cec_keypress          m_lastKeypress;                      /**< the last key press that was sent to the client */
+-- 
+1.9.1
+
+
+From 273ead6980b69eddf98810eb1eb33d94a7d74fce Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Tue, 28 Oct 2014 00:09:18 +0000
+Subject: [PATCH 3/6] Support repeating button presses with configurable repeat
+ rate
+
+---
+ include/cectypes.h                               |   6 ++
+ src/libcec/CECClient.cpp                         | 100 +++++++++++++++++++----
+ src/libcec/CECClient.h                           |   6 +-
+ src/libcec/implementations/CECCommandHandler.cpp |   2 +-
+ 4 files changed, 96 insertions(+), 18 deletions(-)
+
+diff --git a/include/cectypes.h b/include/cectypes.h
+index acff259..8f098ef 100644
+--- a/include/cectypes.h
++++ b/include/cectypes.h
+@@ -1493,6 +1493,8 @@ struct libcec_configuration
+                                                    XXX changed meaning in 2.2.0 to not break binary compatibility. next major (3.0) release will fix it in a nicer way */
+   cec_user_control_code comboKey;             /*!< key code that initiates combo keys. defaults to CEC_USER_CONTROL_CODE_F1_BLUE. CEC_USER_CONTROL_CODE_UNKNOWN to disable. added in 2.0.5 */
+   uint32_t              iComboKeyTimeoutMs;   /*!< timeout until the combo key is sent as normal keypress */
++  uint32_t              iButtonRepeatRateMs;  /*!< rate at which buttons autorepeat. 0 means rely on CEC device */
++  uint32_t              iButtonReleaseDelayMs;/*!< duration after last update until a button is considered released */
+ 
+ #ifdef __cplusplus
+    libcec_configuration(void) { Clear(); }
+@@ -1527,6 +1529,8 @@ struct libcec_configuration
+                  cecVersion                == other.cecVersion &&
+                  adapterType               == other.adapterType &&
+                  iDoubleTapTimeout50Ms     == other.iDoubleTapTimeout50Ms &&
++                 iButtonRepeatRateMs       == other.iButtonRepeatRateMs &&
++                 iButtonReleaseDelayMs     == other.iButtonReleaseDelayMs &&
+                  (other.clientVersion <= LIBCEC_VERSION_TO_UINT(2, 0, 4) || comboKey            == other.comboKey) &&
+                  (other.clientVersion <= LIBCEC_VERSION_TO_UINT(2, 0, 4) || iComboKeyTimeoutMs  == other.iComboKeyTimeoutMs) &&
+                  (other.clientVersion <  LIBCEC_VERSION_TO_UINT(2, 1, 0) || bPowerOnScreensaver == other.bPowerOnScreensaver));
+@@ -1567,6 +1571,8 @@ struct libcec_configuration
+     iDoubleTapTimeout50Ms =           CEC_DOUBLE_TAP_TIMEOUT_50_MS;
+     comboKey =                        CEC_USER_CONTROL_CODE_STOP;
+     iComboKeyTimeoutMs =              CEC_DEFAULT_COMBO_TIMEOUT_MS;
++    iButtonRepeatRateMs =             0;
++    iButtonReleaseDelayMs =           CEC_BUTTON_TIMEOUT;
+ 
+     memset(strDeviceName, 0, 13);
+     deviceTypes.Clear();
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index e7935b9..598628d 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -56,6 +56,10 @@ CCECClient::CCECClient(CCECProcessor *processor, const libcec_configuration &con
+     m_iCurrentButton(CEC_USER_CONTROL_CODE_UNKNOWN),
+     m_initialButtontime(0),
+     m_updateButtontime(0),
++    m_repeatButtontime(0),
++    m_releaseButtontime(0),
++    m_pressedButtoncount(0),
++    m_releasedButtoncount(0),
+     m_iPreventForwardingPowerOffCommand(0),
+     m_iLastKeypressTime(0)
+ {
+@@ -851,6 +855,9 @@ bool CCECClient::GetCurrentConfiguration(libcec_configuration &configuration)
+   configuration.bMonitorOnly              = m_configuration.bMonitorOnly;
+   configuration.cecVersion                = m_configuration.cecVersion;
+   configuration.adapterType               = m_configuration.adapterType;
++  configuration.iDoubleTapTimeout50Ms     = m_configuration.iDoubleTapTimeout50Ms;
++  configuration.iButtonRepeatRateMs       = m_configuration.iButtonRepeatRateMs;
++  configuration.iButtonReleaseDelayMs     = m_configuration.iButtonReleaseDelayMs;
+ 
+   return true;
+ }
+@@ -894,6 +901,9 @@ bool CCECClient::SetConfiguration(const libcec_configuration &configuration)
+     m_configuration.cecVersion                 = configuration.cecVersion;
+     m_configuration.adapterType                = configuration.adapterType;
+     m_configuration.iDoubleTapTimeout50Ms      = configuration.iDoubleTapTimeout50Ms;
++    m_configuration.iButtonRepeatRateMs        = configuration.iButtonRepeatRateMs;
++    m_configuration.iButtonReleaseDelayMs      = configuration.iButtonReleaseDelayMs;
++
+     m_configuration.deviceTypes.Add(configuration.deviceTypes[0]);
+ 
+     if (m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5))
+@@ -950,6 +960,7 @@ bool CCECClient::SetConfiguration(const libcec_configuration &configuration)
+     primary->ActivateSource();
+   }
+ 
++  LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: %d:%d:%d", __FUNCTION__, DoubleTapTimeoutMS(), m_configuration.iButtonRepeatRateMs, m_configuration.iButtonReleaseDelayMs);
+   return true;
+ }
+ 
+@@ -973,11 +984,15 @@ void CCECClient::AddCommand(const cec_command &command)
+   }
+ }
+ 
+-void CCECClient::AddKey(bool bSendComboKey /* = false */)
++void CCECClient::AddKey(bool bSendComboKey /* = false */, bool bButtonRelease /* = false */)
+ {
+   cec_keypress key;
+   key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+ 
++  // we ignore button releases when supporting repeating keys
++  if (bButtonRelease && m_configuration.iButtonRepeatRateMs && m_configuration.iButtonReleaseDelayMs)
++    return;
++
+   {
+     CLockObject lock(m_mutex);
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN)
+@@ -995,6 +1010,10 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */)
+         m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
+         m_initialButtontime = 0;
+         m_updateButtontime = 0;
++        m_repeatButtontime = 0;
++        m_releaseButtontime = 0;
++        m_pressedButtoncount = 0;
++        m_releasedButtoncount = 0;
+       }
+     }
+   }
+@@ -1012,6 +1031,7 @@ void CCECClient::AddKey(const cec_keypress &key)
+       key.keycode < CEC_USER_CONTROL_CODE_SELECT)
+   {
+     // send back the previous key if there is one
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "Unexpected key %s (%1x) D:%dms", ToString(key.keycode), key.keycode, key.duration);
+     AddKey();
+     return;
+   }
+@@ -1035,7 +1055,10 @@ void CCECClient::AddKey(const cec_keypress &key)
+         transmitKey.keycode = CEC_USER_CONTROL_CODE_DOT;
+       // default, send back the previous key
+       else
++      {
++        LIB_CEC->AddLog(CEC_LOG_DEBUG, "Combo key %s (%1x) D%dms:", ToString(key.keycode), key.keycode, key.duration);
+         AddKey(true);
++      }
+     }
+ 
+     LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x) current(%lx) duration(%d)", ToString(transmitKey.keycode), transmitKey.keycode, m_iCurrentButton, key.duration);
+@@ -1043,17 +1066,44 @@ void CCECClient::AddKey(const cec_keypress &key)
+     if (m_iCurrentButton == key.keycode)
+     {
+       m_updateButtontime = GetTimeMs();
+-      isrepeat = true;
++      m_releaseButtontime = m_updateButtontime + (m_configuration.iButtonReleaseDelayMs ? m_configuration.iButtonReleaseDelayMs : CEC_BUTTON_TIMEOUT);
++      // want to have seen some updated before considering a repeat
++      if (m_configuration.iButtonRepeatRateMs)
++      {
++        if (!m_repeatButtontime && m_pressedButtoncount > 1)
++          m_repeatButtontime = m_initialButtontime + DoubleTapTimeoutMS();
++        isrepeat = true;
++      }
++      m_pressedButtoncount++;
+     }
+     else
+     {
+       if (m_iCurrentButton != transmitKey.keycode)
++      {
++        LIB_CEC->AddLog(CEC_LOG_DEBUG, "Changed key %s (%1x) D:%dms cur:%lx", ToString(transmitKey.keycode), transmitKey.keycode, transmitKey.duration, m_iCurrentButton);
+         AddKey();
++      }
+       if (key.duration == 0)
+       {
+         m_iCurrentButton = transmitKey.keycode;
+-        m_initialButtontime = m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN || key.duration > 0 ? 0 : GetTimeMs();
+-        m_updateButtontime = m_initialButtontime;
++        if (m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN)
++        {
++          m_initialButtontime = 0;
++          m_updateButtontime = 0;
++          m_repeatButtontime = 0;
++          m_releaseButtontime = 0;
++          m_pressedButtoncount = 0;
++          m_releasedButtoncount = 0;
++        }
++        else
++        {
++          m_initialButtontime = GetTimeMs();
++          m_updateButtontime = m_initialButtontime;
++          m_repeatButtontime = 0; // set this on next update
++          m_releaseButtontime = m_initialButtontime + (m_configuration.iButtonReleaseDelayMs ? m_configuration.iButtonReleaseDelayMs : CEC_BUTTON_TIMEOUT);
++          m_pressedButtoncount = 1;
++          m_releasedButtoncount = 0;
++        }
+       }
+     }
+   }
+@@ -1072,12 +1122,16 @@ void CCECClient::SetCurrentButton(const cec_user_control_code iButtonCode)
+   key.duration = 0;
+   key.keycode = iButtonCode;
+ 
++  LIB_CEC->AddLog(CEC_LOG_DEBUG, "SetCurrentButton %s (%1x) D:%dms cur:%lx", ToString(key.keycode), key.keycode, key.duration);
+   AddKey(key);
+ }
+ 
+ uint16_t CCECClient::CheckKeypressTimeout(void)
+ {
++  // time when we'd like to be called again
++  unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   cec_keypress key;
++  key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+ 
+   {
+     CLockObject lock(m_mutex);
+@@ -1089,8 +1143,8 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+         m_configuration.iComboKeyTimeoutMs : CEC_DEFAULT_COMBO_TIMEOUT_MS);
+ 
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime > iTimeoutMs) ||
+-          (m_iCurrentButton != comboKey && iNow - m_updateButtontime > CEC_BUTTON_TIMEOUT)))
++          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs) ||
++          (m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)))
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+@@ -1098,27 +1152,41 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+       m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
+       m_initialButtontime = 0;
+       m_updateButtontime = 0;
++      m_repeatButtontime = 0;
++      m_releaseButtontime = 0;
++      m_pressedButtoncount = 0;
++      m_releasedButtoncount = 0;
++    }
++    else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
++          (m_iCurrentButton != comboKey && m_repeatButtontime && iNow >= (uint64_t)m_repeatButtontime))
++    {
++      key.duration = 0;
++      key.keycode = m_iCurrentButton;
++      m_repeatButtontime = iNow + m_configuration.iButtonRepeatRateMs;
++      timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
+     }
+     else
+     {
+-      // time when this keypress will be released and we'd like to be called again
+-      unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
+-        timeout = iTimeoutMs - (iNow - m_updateButtontime) + 1;
+-      else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey)
+-        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_updateButtontime) + 1;
++        timeout = std::min((uint64_t)timeout, m_updateButtontime - iNow + iTimeoutMs);
++      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey && m_releaseButtontime)
++        timeout = std::min((uint64_t)timeout, m_releaseButtontime - iNow);
++      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey && m_repeatButtontime)
++        timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
+       if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
+       {
+-        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_updateButtontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
++        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_updateButtontime*1e-3, m_releaseButtontime*1e-3, m_iCurrentButton);
+         timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       }
+-      return timeout;
+     }
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key %s: %s (%1x) timeout:%dms (rel:%d,rep:%d,prs:%d,rel:%d)", key.keycode == CEC_USER_CONTROL_CODE_UNKNOWN ? "idle" : key.duration ? "released" : "repeated",
++        ToString(m_iCurrentButton), m_iCurrentButton, timeout, (int)(m_releaseButtontime ? m_releaseButtontime - iNow : 0), (int)(m_repeatButtontime ? m_repeatButtontime - iNow : 0), m_pressedButtoncount, m_releasedButtoncount);
+   }
+ 
+-  LIB_CEC->AddLog(CEC_LOG_DEBUG, "key auto-released: %s (%1x)", ToString(key.keycode), key.keycode);
+-  QueueAddKey(key);
+-  return CEC_PROCESSOR_SIGNAL_WAIT_TIME;
++  if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
++    QueueAddKey(key);
++
++  return timeout;
+ }
+ 
+ bool CCECClient::EnableCallbacks(void *cbParam, ICECCallbacks *callbacks)
+diff --git a/src/libcec/CECClient.h b/src/libcec/CECClient.h
+index 611c68b..adeb5af 100644
+--- a/src/libcec/CECClient.h
++++ b/src/libcec/CECClient.h
+@@ -269,7 +269,7 @@ namespace CEC
+     // callbacks
+     virtual void                  Alert(const libcec_alert type, const libcec_parameter &param) { QueueAlert(type, param); }
+     virtual void                  AddLog(const cec_log_message &message) { QueueAddLog(message); }
+-    virtual void                  AddKey(bool bSendComboKey = false);
++    virtual void                  AddKey(bool bSendComboKey = false, bool bButtonRelease = false);
+     virtual void                  AddKey(const cec_keypress &key);
+     virtual void                  SetCurrentButton(const cec_user_control_code iButtonCode);
+     virtual uint16_t              CheckKeypressTimeout(void);
+@@ -406,6 +406,10 @@ namespace CEC
+     cec_user_control_code m_iCurrentButton;                    /**< the control code of the button that's currently held down (if any) */
+     int64_t               m_initialButtontime;                 /**< the timestamp when the button was initially pressed (in seconds since epoch), or 0 if none was pressed. */
+     int64_t               m_updateButtontime;                  /**< the timestamp when the button was updated (in seconds since epoch), or 0 if none was pressed. */
++    int64_t               m_repeatButtontime;                  /**< the timestamp when the button will next repeat (in seconds since epoch), or 0 if repeat is disabled. */
++    int64_t               m_releaseButtontime;                 /**< the timestamp when the button will be released (in seconds since epoch), or 0 if none was pressed. */
++    int32_t               m_pressedButtoncount;                /**< the number of times a button released message has been seen for this press. */
++    int32_t               m_releasedButtoncount;               /**< the number of times a button pressed message has been seen for this press. */
+     int64_t               m_iPreventForwardingPowerOffCommand; /**< prevent forwarding standby commands until this time */
+     int64_t               m_iLastKeypressTime;                 /**< last time a key press was sent to the client */
+     cec_keypress          m_lastKeypress;                      /**< the last key press that was sent to the client */
+diff --git a/src/libcec/implementations/CECCommandHandler.cpp b/src/libcec/implementations/CECCommandHandler.cpp
+index 6d6244e..d64186f 100644
+--- a/src/libcec/implementations/CECCommandHandler.cpp
++++ b/src/libcec/implementations/CECCommandHandler.cpp
+@@ -770,7 +770,7 @@ int CCECCommandHandler::HandleUserControlRelease(const cec_command &command)
+ 
+   CECClientPtr client = m_processor->GetClient(command.destination);
+   if (client)
+-    client->AddKey();
++    client->AddKey(false, true);
+ 
+   return COMMAND_HANDLED;
+ }
+-- 
+1.9.1
+
+
+From 3336d0827f7fd159430f3431642b07090c06c869 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Tue, 28 Oct 2014 01:21:35 +0000
+Subject: [PATCH 4/6] Skip double press removal. It is handled through other
+ means.
+
+---
+ src/libcec/CECClient.cpp | 18 +-----------------
+ src/libcec/CECClient.h   |  2 --
+ 2 files changed, 1 insertion(+), 19 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index 598628d..dccd874 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -60,11 +60,8 @@ CCECClient::CCECClient(CCECProcessor *processor, const libcec_configuration &con
+     m_releaseButtontime(0),
+     m_pressedButtoncount(0),
+     m_releasedButtoncount(0),
+-    m_iPreventForwardingPowerOffCommand(0),
+-    m_iLastKeypressTime(0)
++    m_iPreventForwardingPowerOffCommand(0)
+ {
+-  m_lastKeypress.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+-  m_lastKeypress.duration = 0;
+   m_configuration.Clear();
+   // set the initial configuration
+   SetConfiguration(configuration);
+@@ -1647,20 +1644,7 @@ void CCECClient::CallbackAddKey(const cec_keypress &key)
+ {
+   CLockObject lock(m_cbMutex);
+   if (m_configuration.callbacks && m_configuration.callbacks->CBCecKeyPress)
+-  {
+-    // prevent double taps
+-    int64_t now = GetTimeMs();
+-    if (m_lastKeypress.keycode != key.keycode ||
+-        key.duration > 0 ||
+-        now - m_iLastKeypressTime >= DoubleTapTimeoutMS())
+-    {
+-      // no double tap
+-      if (key.duration == 0)
+-        m_iLastKeypressTime = now;
+-      m_lastKeypress = key;
+       m_configuration.callbacks->CBCecKeyPress(m_configuration.callbackParam, key);
+-    }
+-  }
+ }
+ 
+ void CCECClient::CallbackAddLog(const cec_log_message &message)
+diff --git a/src/libcec/CECClient.h b/src/libcec/CECClient.h
+index adeb5af..43a713b 100644
+--- a/src/libcec/CECClient.h
++++ b/src/libcec/CECClient.h
+@@ -411,8 +411,6 @@ namespace CEC
+     int32_t               m_pressedButtoncount;                /**< the number of times a button released message has been seen for this press. */
+     int32_t               m_releasedButtoncount;               /**< the number of times a button pressed message has been seen for this press. */
+     int64_t               m_iPreventForwardingPowerOffCommand; /**< prevent forwarding standby commands until this time */
+-    int64_t               m_iLastKeypressTime;                 /**< last time a key press was sent to the client */
+-    cec_keypress          m_lastKeypress;                      /**< the last key press that was sent to the client */
+     PLATFORM::SyncedBuffer<CCallbackWrap*> m_callbackCalls;
+   };
+ }
+-- 
+1.9.1
+
+
+From 0dd0234f620a546bfa843172648383f83d88088c Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Mon, 3 Nov 2014 23:28:04 +0000
+Subject: [PATCH 5/6] Pass through duration on all button repeats
+
+---
+ src/libcec/CECClient.cpp | 34 ++++++++++++++++++++++++----------
+ 1 file changed, 24 insertions(+), 10 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index dccd874..1946148 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -986,10 +986,6 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */, bool bButtonRelease /*
+   cec_keypress key;
+   key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+ 
+-  // we ignore button releases when supporting repeating keys
+-  if (bButtonRelease && m_configuration.iButtonRepeatRateMs && m_configuration.iButtonReleaseDelayMs)
+-    return;
+-
+   {
+     CLockObject lock(m_mutex);
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN)
+@@ -1015,6 +1011,10 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */, bool bButtonRelease /*
+     }
+   }
+ 
++  // we don't forward releases when supporting repeating keys
++  if (bButtonRelease && m_configuration.iButtonRepeatRateMs)
++    return;
++
+   if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
+   {
+     LIB_CEC->AddLog(CEC_LOG_DEBUG, "key released: %s (%1x) D:%dms", ToString(key.keycode), key.keycode, key.duration);
+@@ -1107,7 +1107,7 @@ void CCECClient::AddKey(const cec_keypress &key)
+ 
+   if (!isrepeat && (key.keycode != comboKey || key.duration > 0))
+   {
+-    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x)", ToString(transmitKey.keycode), transmitKey.keycode);
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x, %d)", ToString(transmitKey.keycode), transmitKey.keycode, transmitKey.duration);
+     QueueAddKey(transmitKey);
+   }
+ }
+@@ -1129,6 +1129,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+   unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   cec_keypress key;
+   key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
++  key.duration = 0;
+ 
+   {
+     CLockObject lock(m_mutex);
+@@ -1140,8 +1141,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+         m_configuration.iComboKeyTimeoutMs : CEC_DEFAULT_COMBO_TIMEOUT_MS);
+ 
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs) ||
+-          (m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)))
++          m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs)
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+@@ -1155,9 +1155,23 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+       m_releasedButtoncount = 0;
+     }
+     else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
++          m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)
++    {
++      key.duration = (unsigned int) (iNow - m_initialButtontime);
++      key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
++
++      m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
++      m_initialButtontime = 0;
++      m_updateButtontime = 0;
++      m_repeatButtontime = 0;
++      m_releaseButtontime = 0;
++      m_pressedButtoncount = 0;
++      m_releasedButtoncount = 0;
++    }
++    else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+           (m_iCurrentButton != comboKey && m_repeatButtontime && iNow >= (uint64_t)m_repeatButtontime))
+     {
+-      key.duration = 0;
++      key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+       m_repeatButtontime = iNow + m_configuration.iButtonRepeatRateMs;
+       timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
+@@ -1176,8 +1190,8 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+         timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       }
+     }
+-    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key %s: %s (%1x) timeout:%dms (rel:%d,rep:%d,prs:%d,rel:%d)", key.keycode == CEC_USER_CONTROL_CODE_UNKNOWN ? "idle" : key.duration ? "released" : "repeated",
+-        ToString(m_iCurrentButton), m_iCurrentButton, timeout, (int)(m_releaseButtontime ? m_releaseButtontime - iNow : 0), (int)(m_repeatButtontime ? m_repeatButtontime - iNow : 0), m_pressedButtoncount, m_releasedButtoncount);
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "Key %s: %s (duration:%d) (%1x) timeout:%dms (rel:%d,rep:%d,prs:%d,rel:%d)", ToString(m_iCurrentButton), key.keycode == CEC_USER_CONTROL_CODE_UNKNOWN ? "idle" : m_repeatButtontime ? "repeated" : "released", key.duration,
++        m_iCurrentButton, timeout, (int)(m_releaseButtontime ? m_releaseButtontime - iNow : 0), (int)(m_repeatButtontime ? m_repeatButtontime - iNow : 0), m_pressedButtoncount, m_releasedButtoncount);
+   }
+ 
+   if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
+-- 
+1.9.1
+
+
+From 1ea01f59d8186d4d53af41961aaccbbc11651115 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Wed, 5 Nov 2014 21:04:25 +0000
+Subject: [PATCH 6/6] squash: Fix for stop needing to be pressed twice
+
+---
+ src/libcec/CECClient.cpp | 17 ++++++++---------
+ 1 file changed, 8 insertions(+), 9 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index 1946148..f4f114b 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -1131,6 +1131,8 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+   key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+   key.duration = 0;
+ 
++  if (m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN)
++    return timeout;
+   {
+     CLockObject lock(m_mutex);
+     uint64_t iNow = GetTimeMs();
+@@ -1140,8 +1142,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+     uint32_t iTimeoutMs(m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5) ?
+         m_configuration.iComboKeyTimeoutMs : CEC_DEFAULT_COMBO_TIMEOUT_MS);
+ 
+-    if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs)
++    if (m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs)
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+@@ -1154,8 +1155,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+       m_pressedButtoncount = 0;
+       m_releasedButtoncount = 0;
+     }
+-    else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)
++    else if (m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+@@ -1168,8 +1168,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+       m_pressedButtoncount = 0;
+       m_releasedButtoncount = 0;
+     }
+-    else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          (m_iCurrentButton != comboKey && m_repeatButtontime && iNow >= (uint64_t)m_repeatButtontime))
++    else if (m_iCurrentButton != comboKey && m_repeatButtontime && iNow >= (uint64_t)m_repeatButtontime)
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+@@ -1178,11 +1177,11 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+     }
+     else
+     {
+-      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
++      if (m_iCurrentButton == comboKey && iTimeoutMs > 0)
+         timeout = std::min((uint64_t)timeout, m_updateButtontime - iNow + iTimeoutMs);
+-      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey && m_releaseButtontime)
++      if (m_iCurrentButton != comboKey && m_releaseButtontime)
+         timeout = std::min((uint64_t)timeout, m_releaseButtontime - iNow);
+-      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey && m_repeatButtontime)
++      if (m_iCurrentButton != comboKey && m_repeatButtontime)
+         timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
+       if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
+       {
+-- 
+1.9.1
+
-- 
2.7.4


From 3a769ee9068591a4f44ddd3dc7e87ba70867ce9a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 19 Mar 2016 17:15:29 +0000
Subject: [PATCH 155/175] cec: hack: pretend bump to 3.1.0

---
 tools/depends/target/libcec/Makefile   |  1 +
 tools/depends/target/libcec/bump.patch | 21 +++++++++++++++++++++
 2 files changed, 22 insertions(+)
 create mode 100644 tools/depends/target/libcec/bump.patch

diff --git a/tools/depends/target/libcec/Makefile b/tools/depends/target/libcec/Makefile
index ddf9963..39ba882 100644
--- a/tools/depends/target/libcec/Makefile
+++ b/tools/depends/target/libcec/Makefile
@@ -22,6 +22,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM); mkdir -p $(PLATFORM)/build
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); patch -p1 < ../popcornmix.patch
+	cd $(PLATFORM); patch -p1 < ../bump.patch
 	cd $(PLATFORM)/build; $(CMAKE) -DBUILD_SHARED_LIBS=1 -DSKIP_PYTHON_WRAPPER:STRING=1 -DCMAKE_INSTALL_LIBDIR=$(PREFIX)/lib ..
 
 $(LIBDYLIB): $(PLATFORM)
diff --git a/tools/depends/target/libcec/bump.patch b/tools/depends/target/libcec/bump.patch
new file mode 100644
index 0000000..9e55e51
--- /dev/null
+++ b/tools/depends/target/libcec/bump.patch
@@ -0,0 +1,21 @@
+commit 49a1728feabca68b8424a8b22abec9ee87b9aa99
+Author: Lars Op den Kamp <lars@opdenkamp.eu>
+Date:   Wed Jan 20 01:06:50 2016 +0100
+
+    bump to 3.1.0
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 23d71fc..173f625 100644
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -2,8 +2,8 @@ project(libcec)
+ cmake_minimum_required(VERSION 2.8.9)
+ 
+ set(LIBCEC_VERSION_MAJOR 3)
+-set(LIBCEC_VERSION_MINOR 0)
+-set(LIBCEC_VERSION_PATCH 0)
++set(LIBCEC_VERSION_MINOR 1)
++set(LIBCEC_VERSION_PATCH 0)
+ 
+ # cec-client
+ add_subdirectory(src/cec-client)
-- 
2.7.4


From fb86d8ca7f2225c7208d1ee0c79968fa766f5e04 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 28 Oct 2014 00:19:40 +0000
Subject: [PATCH 156/175] Add settings for configuring button repeats

---
 addons/resource.language.en_gb/resources/strings.po | 15 +++++++++++++++
 system/peripherals.xml                              |  4 +++-
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp   | 16 ++++++++++++++++
 3 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index a6f7763..21b7f3f 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -19705,3 +19705,18 @@ msgstr ""
 msgctxt "#38206"
 msgid "Max"
 msgstr ""
+
+#: system/peripherals.xml
+msgctxt "#38050"
+msgid "Remote button press delay before repeating (ms)"
+msgstr ""
+
+#: system/peripherals.xml
+msgctxt "#38051"
+msgid "Remote button press repeat rate (ms)"
+msgstr ""
+
+#: system/peripherals.xml
+msgctxt "#38052"
+msgid "Remote button press release time (ms)"
+msgstr ""
diff --git a/system/peripherals.xml b/system/peripherals.xml
index 3f6221e..924076e 100644
--- a/system/peripherals.xml
+++ b/system/peripherals.xml
@@ -31,7 +31,9 @@
     <setting key="device_type" type="int" value="1" configurable="0" />
     <setting key="wake_devices_advanced" type="string" value="" configurable="0" />
     <setting key="standby_devices_advanced" type="string" value="" configurable="0" />
-    <setting key="double_tap_timeout_ms" type="int" min="0" value="300" configurable="0" />
+    <setting key="double_tap_timeout_ms" type="int" min="50" max="1000" step="50" value="300" label="38050" order="16" />
+    <setting key="button_repeat_rate_ms" type="int" min="0" max="250" step="10" value="0" label="38051" order="17" />
+    <setting key="button_release_delay_ms" type="int" min="0" max="500" step="50" value="0" label="38052" order="18" />
   </peripheral>
 
   <peripheral vendor_product="2548:1001,2548:1002" bus="usb" name="Pulse-Eight CEC Adapter" mapTo="cec">
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 61ec54a..88024b5 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -1284,6 +1284,20 @@ void CPeripheralCecAdapter::SetConfigurationFromLibCEC(const CEC::libcec_configu
   m_configuration.bSendInactiveSource = config.bSendInactiveSource;
   bChanged |= SetSetting("send_inactive_source", m_configuration.bSendInactiveSource == 1);
 
+#if defined(CEC_DOUBLE_TAP_TIMEOUT_MS_OLD)
+  m_configuration.iDoubleTapTimeout50Ms = config.iDoubleTapTimeout50Ms;
+  bChanged |= SetSetting("double_tap_timeout_ms", (int)m_configuration.iDoubleTapTimeout50Ms * 50);
+#else
+  m_configuration.iDoubleTapTimeoutMs = config.iDoubleTapTimeoutMs;
+  bChanged |= SetSetting("double_tap_timeout_ms", (int)m_configuration.iDoubleTapTimeoutMs;
+#endif
+
+  m_configuration.iButtonRepeatRateMs = config.iButtonRepeatRateMs;
+  bChanged |= SetSetting("button_repeat_rate_ms", (int)m_configuration.iButtonRepeatRateMs);
+
+  m_configuration.iButtonReleaseDelayMs = config.iButtonReleaseDelayMs;
+  bChanged |= SetSetting("button_release_delay_ms", (int)m_configuration.iButtonReleaseDelayMs);
+
   m_configuration.iFirmwareVersion = config.iFirmwareVersion;
   m_configuration.bShutdownOnStandby = config.bShutdownOnStandby;
 
@@ -1388,6 +1402,8 @@ void CPeripheralCecAdapter::SetConfigurationFromSettings(void)
   // backwards compatibility. will be removed once the next major release of libCEC is out
   m_configuration.iDoubleTapTimeoutMs = GetSettingInt("double_tap_timeout_ms");
 #endif
+  m_configuration.iButtonRepeatRateMs = GetSettingInt("button_repeat_rate_ms");
+  m_configuration.iButtonReleaseDelayMs = GetSettingInt("button_release_delay_ms");
 
   if (GetSettingBool("pause_playback_on_deactivate"))
   {
-- 
2.7.4


From c06bb70d153cfd8370fff4d6af50a364ce0bdc2d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Nov 2014 23:17:46 +0000
Subject: [PATCH 157/175] Don't discard buttons when repeat mode is enabled

---
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 88024b5..66d64f2 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -775,7 +775,10 @@ void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress &key)
   CLog::Log(LOGDEBUG, "%s - received key %2x duration %d", __FUNCTION__, key.iButton, key.iDuration);
 
   CSingleLock lock(m_critSection);
-  if (key.iDuration > 0)
+  // avoid the queue getting too long
+  if (m_configuration.iButtonRepeatRateMs && m_buttonQueue.size() > 5)
+    return;
+  if (m_configuration.iButtonRepeatRateMs == 0 && key.iDuration > 0)
   {
     if (m_currentButton.iButton == key.iButton && m_currentButton.iDuration == 0)
     {
-- 
2.7.4


From 0c389a8681f2fdcf4ac44795b28623394c794cdd Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 4 Nov 2014 18:50:00 +0000
Subject: [PATCH 158/175] Temp - more logging

---
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 66d64f2..d2bff79 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -772,12 +772,15 @@ void CPeripheralCecAdapter::GetNextKey(void)
 
 void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress &key)
 {
-  CLog::Log(LOGDEBUG, "%s - received key %2x duration %d", __FUNCTION__, key.iButton, key.iDuration);
+  CLog::Log(LOGDEBUG, "%s - received key %2x duration %d (rep:%d size:%d)", __FUNCTION__, key.iButton, key.iDuration, m_configuration.iButtonRepeatRateMs, m_buttonQueue.size());
 
   CSingleLock lock(m_critSection);
   // avoid the queue getting too long
   if (m_configuration.iButtonRepeatRateMs && m_buttonQueue.size() > 5)
+  {
+    CLog::Log(LOGDEBUG, "%s - discarded key %2x", __FUNCTION__, key.iButton);
     return;
+  }
   if (m_configuration.iButtonRepeatRateMs == 0 && key.iDuration > 0)
   {
     if (m_currentButton.iButton == key.iButton && m_currentButton.iDuration == 0)
@@ -786,6 +789,7 @@ void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress &key)
       if (m_bHasButton)
         m_currentButton.iDuration = key.iDuration;
       // ignore this one, since it's already been handled by xbmc
+      CLog::Log(LOGDEBUG, "%s - ignored key %2x", __FUNCTION__, key.iButton);
       return;
     }
     // if we received a keypress with a duration set, try to find the same one without a duration set, and replace it
@@ -796,6 +800,7 @@ void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress &key)
         if ((*it).iDuration == 0)
         {
           // replace this entry
+          CLog::Log(LOGDEBUG, "%s - replaced key %2x", __FUNCTION__, key.iButton);
           (*it).iDuration = key.iDuration;
           return;
         }
@@ -805,6 +810,7 @@ void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress &key)
     }
   }
 
+  CLog::Log(LOGDEBUG, "%s - added key %2x", __FUNCTION__, key.iButton);
   m_buttonQueue.push_back(key);
 }
 
-- 
2.7.4


From aa26f050a37e0cdfdc0d8289ce3d1203488760ed Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 22 Jan 2016 12:29:41 +0000
Subject: [PATCH 159/175] Update for libcec 3.1.0

---
 configure.ac                                      | 4 ++--
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/configure.ac b/configure.ac
index 20ec1a9..ccc5f73 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1447,9 +1447,9 @@ if test "x$use_libcec" != "xno"; then
   # libcec is dyloaded, so we need to check for its headers and link any depends.
   if test "x$use_libcec" != "xno"; then
     if test "x$use_libcec" != "xauto"; then
-      PKG_CHECK_MODULES([CEC],[libcec >= 3.0.0],,[use_libcec="no";AC_MSG_ERROR($libcec_disabled)])
+      PKG_CHECK_MODULES([CEC],[libcec >= 3.1.0],,[use_libcec="no";AC_MSG_ERROR($libcec_disabled)])
     else
-      PKG_CHECK_MODULES([CEC],[libcec >= 3.0.0],,[use_libcec="no";AC_MSG_RESULT($libcec_disabled)])
+      PKG_CHECK_MODULES([CEC],[libcec >= 3.1.0],,[use_libcec="no";AC_MSG_RESULT($libcec_disabled)])
     fi
 
     if test "x$use_libcec" != "xno"; then
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index d2bff79..c5732c7 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -43,7 +43,7 @@ using namespace PERIPHERALS;
 using namespace ANNOUNCEMENT;
 using namespace CEC;
 
-#define CEC_LIB_SUPPORTED_VERSION LIBCEC_VERSION_TO_UINT(3, 0, 0)
+#define CEC_LIB_SUPPORTED_VERSION LIBCEC_VERSION_TO_UINT(3, 1, 0)
 
 /* time in seconds to ignore standby commands from devices after the screensaver has been activated */
 #define SCREENSAVER_TIMEOUT       20
@@ -1326,7 +1326,7 @@ void CPeripheralCecAdapter::SetConfigurationFromLibCEC(const CEC::libcec_configu
 void CPeripheralCecAdapter::SetConfigurationFromSettings(void)
 {
   // client version matches the version of libCEC that we originally used the API from
-  m_configuration.clientVersion = LIBCEC_VERSION_TO_UINT(3, 0, 0);
+  m_configuration.clientVersion = CEC_LIB_SUPPORTED_VERSION;
 
   // device name 'XBMC'
   snprintf(m_configuration.strDeviceName, 13, "%s", GetSettingString("device_name").c_str());
-- 
2.7.4


From bf1f6d0697941805c4509e04f1cf2e14d8a4e429 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 19 Mar 2016 14:46:41 +0000
Subject: [PATCH 160/175] libcec: use system audio mode request instead of
 power on to start AVR reliable

---
 tools/depends/target/libcec/208.patch | 38 +++++++++++++++++++++++++++++++++++
 tools/depends/target/libcec/Makefile  |  1 +
 2 files changed, 39 insertions(+)
 create mode 100644 tools/depends/target/libcec/208.patch

diff --git a/tools/depends/target/libcec/208.patch b/tools/depends/target/libcec/208.patch
new file mode 100644
index 0000000..3dc5adf
--- /dev/null
+++ b/tools/depends/target/libcec/208.patch
@@ -0,0 +1,38 @@
+From f70c4d76e1d9c0219a3927b6b66090b7575e7933 Mon Sep 17 00:00:00 2001
+From: Gerald Dachs <gda@dachsweb.de>
+Date: Thu, 17 Mar 2016 12:12:51 +0100
+Subject: [PATCH] use system audio mode request instead of power on to start
+ AVR reliable
+
+---
+ src/libcec/devices/CECBusDevice.cpp | 13 +++++++++----
+ 1 file changed, 9 insertions(+), 4 deletions(-)
+
+diff --git a/src/libcec/devices/CECBusDevice.cpp b/src/libcec/devices/CECBusDevice.cpp
+index 55939d1..e2d5ea3 100644
+--- a/src/libcec/devices/CECBusDevice.cpp
++++ b/src/libcec/devices/CECBusDevice.cpp
+@@ -1025,14 +1025,19 @@ bool CCECBusDevice::ActivateSource(uint64_t iDelay /* = 0 */)
+   bool bReturn(true);
+   if (iDelay == 0)
+   {
+-    /** some AVRs fail to be powered up by the TV when it powers up. power up the AVR explicitly */
++    /** send system audio mode request if AVR exists */
+     if (m_iLogicalAddress != CECDEVICE_AUDIOSYSTEM)
+     {
+       CCECBusDevice* audioSystem(m_processor->GetDevice(CECDEVICE_AUDIOSYSTEM));
+-      if (audioSystem && audioSystem->IsPresent() && audioSystem->GetPowerStatus(m_iLogicalAddress) != CEC_POWER_STATUS_ON)
++      if (audioSystem && audioSystem->IsPresent())
+       {
+-        LIB_CEC->AddLog(CEC_LOG_DEBUG, "powering up the AVR");
+-        audioSystem->PowerOn(m_iLogicalAddress);
++        cec_command command;
++
++        LIB_CEC->AddLog(CEC_LOG_DEBUG, "sending system audio mode request for '%s'", ToString(m_iLogicalAddress));
++        cec_command::Format(command, m_iLogicalAddress, CECDEVICE_AUDIOSYSTEM, CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST);
++        command.parameters.PushBack((uint8_t) ((m_iPhysicalAddress >> 8) & 0xFF));
++        command.parameters.PushBack((uint8_t) (m_iPhysicalAddress & 0xFF));
++        bReturn = m_handler->Transmit(command, false, false);
+       }
+     }
+ 
diff --git a/tools/depends/target/libcec/Makefile b/tools/depends/target/libcec/Makefile
index 39ba882..4565dc9 100644
--- a/tools/depends/target/libcec/Makefile
+++ b/tools/depends/target/libcec/Makefile
@@ -23,6 +23,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); patch -p1 < ../popcornmix.patch
 	cd $(PLATFORM); patch -p1 < ../bump.patch
+	cd $(PLATFORM); patch -p1 < ../208.patch
 	cd $(PLATFORM)/build; $(CMAKE) -DBUILD_SHARED_LIBS=1 -DSKIP_PYTHON_WRAPPER:STRING=1 -DCMAKE_INSTALL_LIBDIR=$(PREFIX)/lib ..
 
 $(LIBDYLIB): $(PLATFORM)
-- 
2.7.4


From 75d5f3344c728f003f5055d60d946a4c9dce04fd Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 22 Mar 2016 09:51:52 +0100
Subject: [PATCH 161/175] python: use kodi provided cert if available

---
 xbmc/interfaces/python/XBPython.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/xbmc/interfaces/python/XBPython.cpp b/xbmc/interfaces/python/XBPython.cpp
index bc84af9..ff4ed7d 100644
--- a/xbmc/interfaces/python/XBPython.cpp
+++ b/xbmc/interfaces/python/XBPython.cpp
@@ -595,6 +595,12 @@ bool XBPython::OnScriptInitialized(ILanguageInvoker *invoker)
     CEnvironment::putenv(buf);
 #endif
 
+#if !defined(TARGET_WINDOWS)
+    // use Kodi provided cert if available
+    if (XFILE::CFile::Exists("special://xbmc/system/certs/cacert.pem"))
+      setenv("SSL_CERT_FILE", CSpecialProtocol::TranslatePath("special://xbmc/system/certs/cacert.pem").c_str(), 1);
+#endif
+
     if (PyEval_ThreadsInitialized())
       PyEval_AcquireLock();
     else
-- 
2.7.4


From b52e343ee6e0337ed26d61c2f6edf1ac05828736 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 25 May 2016 18:31:17 +0100
Subject: [PATCH 162/175] rbp: Hard code the number of buffers to improve audio
 sync

---
 system/settings/rbp.xml                                 | 6 ++++++
 xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp | 4 ++++
 2 files changed, 10 insertions(+)

diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 2572e25..5d9f716 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -92,6 +92,12 @@
           <control type="toggle" />
         </setting>
       </group>
+      <group id="3">
+        <setting id="videoscreen.noofbuffers">
+          <visible>false</visible>
+          <default>2</default> <!-- double buffered -->
+        </setting>
+      </group>
     </category>
     <category id="audio">
       <group id="1">
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
index 9160a9b..e03af0c 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
@@ -1047,7 +1047,11 @@ void CRenderManager::UpdateDisplayLatency()
     refresh = 0; // No idea about refresh rate when windowed, just get the default latency
   m_displayLatency = (double) g_advancedSettings.GetDisplayLatency(refresh);
 
+#ifdef TARGET_RASPBERRY_PI
+  int buffers = CSettings::GetInstance().GetBool("videoplayer.usedisplayasclock") ? 1:2;
+#else
   int buffers = g_Windowing.NoOfBuffers();
+#endif
   m_displayLatency += (buffers - 1) / fps;
 
 }
-- 
2.7.4


From b86495a7393b47bb1fc905b9ae5513c33df6d2a4 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 4 Jul 2016 18:30:03 +0100
Subject: [PATCH 163/175] rbp: Update the GL libs to new naming scheme

As the opensource mesa GL library is getting more usable, the name collision wih the firmware GL driver is causing issues.
As such we are renaming the firmware GL driver to avoid this.

The new names are libbrcmEGL.so and libbrcmGLESv2.so. Both will be supported for some time, but the original name
will be dropped at some point
---
 configure.ac                             | 2 +-
 project/cmake/modules/FindOpenGLES.cmake | 6 +++---
 tools/depends/configure.ac               | 2 +-
 3 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/configure.ac b/configure.ac
index ccc5f73..040eab2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -943,7 +943,7 @@ if test "$use_gles" = "yes"; then
       AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
       AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
       AC_MSG_RESULT(== WARNING: OpenGLES support is assumed.)
-      LIBS="$LIBS -lEGL -lGLESv2 -lbcm_host -lvcos -lvchiq_arm -lmmal -lmmal_core -lmmal_util -lvcsm"
+      LIBS="$LIBS -lbrcmEGL -lbrcmGLESv2 -lbcm_host -lvcos -lvchiq_arm -lmmal -lmmal_core -lmmal_util -lvcsm"
     else
       AC_CHECK_LIB([EGL],   [main],, AC_MSG_ERROR($missing_library))
       AC_CHECK_LIB([GLESv2],[main],, AC_MSG_ERROR($missing_library))
diff --git a/project/cmake/modules/FindOpenGLES.cmake b/project/cmake/modules/FindOpenGLES.cmake
index ab06f96..87f1faa 100644
--- a/project/cmake/modules/FindOpenGLES.cmake
+++ b/project/cmake/modules/FindOpenGLES.cmake
@@ -13,7 +13,7 @@
 find_package(EMBEDDED)
 
 if(PKG_CONFIG_FOUND AND NOT PLATFORM STREQUAL "raspberry-pi")
-  pkg_check_modules(PC_OPENGLES glesv2 QUIET)
+  pkg_check_modules(PC_OPENGLES brcmglesv2 QUIET)
   if(NOT OPENGLES_FOUND AND EMBEDDED_FOUND)
     set(CMAKE_PREFIX_PATH ${EMBEDDED_FOUND} ${CMAKE_PREFIX_PATH})
   endif()
@@ -22,9 +22,9 @@ endif()
 if(NOT CORE_SYSTEM_NAME STREQUAL ios)
   find_path(OPENGLES_INCLUDE_DIR GLES2/gl2.h
                                  PATHS ${PC_OPENGLES_INCLUDEDIR})
-  find_library(OPENGLES_gl_LIBRARY NAMES GLESv2
+  find_library(OPENGLES_gl_LIBRARY NAMES brcmGLESv2
                                    PATHS ${PC_OPENGLES_LIBDIR})
-  find_library(OPENGLES_egl_LIBRARY NAMES EGL
+  find_library(OPENGLES_egl_LIBRARY NAMES brcmEGL
                                     PATHS ${PC_OPENGLES_LIBDIR})
 else()
   find_library(OPENGLES_gl_LIBRARY NAMES OpenGLES
diff --git a/tools/depends/configure.ac b/tools/depends/configure.ac
index f6f9fc3..e6dc068 100644
--- a/tools/depends/configure.ac
+++ b/tools/depends/configure.ac
@@ -420,7 +420,7 @@ if test "$target_platform" = "raspberry-pi" ; then
    -isystem${use_firmware}/opt/vc/include \
    -isystem${use_firmware}/opt/vc/include/interface/vcos/pthreads \
    -isystem${use_firmware}/opt/vc/include/interface/vmcs_host/linux"
-  platform_ldflags+=" -L${use_firmware}/opt/vc/lib -lEGL -lGLESv2 -lbcm_host -lvcos \
+  platform_ldflags+=" -L${use_firmware}/opt/vc/lib -lbrcmEGL -lbrcmGLESv2 -lbcm_host -lvcos \
    -lvchiq_arm"
 fi
 
-- 
2.7.4


From 93cdaf723b1d1c5ca693478b33acc3e017cef96f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 21 Apr 2016 16:49:02 +0100
Subject: [PATCH 164/175] Revert "[settings] remove show EXIF picture
 information setting"

This reverts commit e7d90188436b6966eff23fd695e1a9d18f4af1b4.
---
 addons/resource.language.en_gb/resources/strings.po | 10 ++++++++++
 system/settings/settings.xml                        |  5 +++++
 xbmc/pictures/GUIWindowPictures.cpp                 |  2 +-
 xbmc/pictures/PictureInfoLoader.cpp                 |  8 ++++++--
 xbmc/pictures/PictureInfoLoader.h                   |  1 +
 xbmc/settings/Settings.cpp                          |  1 +
 xbmc/settings/Settings.h                            |  1 +
 7 files changed, 25 insertions(+), 3 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 21b7f3f..742d299 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -19720,3 +19720,13 @@ msgstr ""
 msgctxt "#38052"
 msgid "Remote button press release time (ms)"
 msgstr ""
+
+#. Description of setting "Pictures -> Show EXIF picture information" with label #38207
+#: system/settings/settings.xml
+msgctxt "#38207"
+msgid "Show EXIF picture information"
+msgstr ""
+
+msgctxt "#38208"
+msgid "If EXIF information exists (date, time, camera used, etc.), it will be displayed."
+msgstr ""
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 472d79f..9dba38e 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1180,6 +1180,11 @@
     </category>
     <category id="pictures" label="14217" help="38109">
       <group id="1" label="744">
+        <setting id="pictures.usetags" type="boolean" label="38207" help="38208">
+          <level>0</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
         <setting id="pictures.generatethumbs" type="boolean" label="13360" help="36307">
           <level>0</level>
           <default>true</default>
diff --git a/xbmc/pictures/GUIWindowPictures.cpp b/xbmc/pictures/GUIWindowPictures.cpp
index c683719..6539422 100644
--- a/xbmc/pictures/GUIWindowPictures.cpp
+++ b/xbmc/pictures/GUIWindowPictures.cpp
@@ -203,7 +203,7 @@ void CGUIWindowPictures::OnPrepareFileItems(CFileItemList& items)
     if (StringUtils::EqualsNoCase(items[i]->GetLabel(), "folder.jpg"))
       items.Remove(i);
 
-  if (items.GetFolderCount() == items.Size())
+  if (items.GetFolderCount() == items.Size() || !CSettings::GetInstance().GetBool(CSettings::SETTING_PICTURES_USETAGS))
     return;
 
   // Start the music info loader thread
diff --git a/xbmc/pictures/PictureInfoLoader.cpp b/xbmc/pictures/PictureInfoLoader.cpp
index dd33472..05304f9 100644
--- a/xbmc/pictures/PictureInfoLoader.cpp
+++ b/xbmc/pictures/PictureInfoLoader.cpp
@@ -43,6 +43,7 @@ void CPictureInfoLoader::OnLoaderStart()
   m_mapFileItems->SetFastLookup(true);
 
   m_tagReads = 0;
+  m_loadTags = CSettings::GetInstance().GetBool(CSettings::SETTING_PICTURES_USETAGS);
 
   if (m_pProgressCallback)
     m_pProgressCallback->SetProgressMax(m_pVecItems->GetFileCount());
@@ -87,8 +88,11 @@ bool CPictureInfoLoader::LoadItemLookup(CFileItem* pItem)
   if (pItem->HasPictureInfoTag())
     return false;
 
-  pItem->GetPictureInfoTag()->Load(pItem->GetPath());
-  m_tagReads++;
+  if (m_loadTags)
+  { // Nothing found, load tag from file
+    pItem->GetPictureInfoTag()->Load(pItem->GetPath());
+    m_tagReads++;
+  }
 
   return true;
 }
diff --git a/xbmc/pictures/PictureInfoLoader.h b/xbmc/pictures/PictureInfoLoader.h
index 000b54f..2a022ff 100644
--- a/xbmc/pictures/PictureInfoLoader.h
+++ b/xbmc/pictures/PictureInfoLoader.h
@@ -39,5 +39,6 @@ protected:
 
   CFileItemList* m_mapFileItems;
   unsigned int m_tagReads;
+  bool m_loadTags;
 };
 
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 4ed74a4..c57fea5 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -298,6 +298,7 @@ const std::string CSettings::SETTING_AUDIOCDS_SETTINGS = "audiocds.settings";
 const std::string CSettings::SETTING_AUDIOCDS_EJECTONRIP = "audiocds.ejectonrip";
 const std::string CSettings::SETTING_MYMUSIC_SONGTHUMBINVIS = "mymusic.songthumbinvis";
 const std::string CSettings::SETTING_MYMUSIC_DEFAULTLIBVIEW = "mymusic.defaultlibview";
+const std::string CSettings::SETTING_PICTURES_USETAGS = "pictures.usetags";
 const std::string CSettings::SETTING_PICTURES_GENERATETHUMBS = "pictures.generatethumbs";
 const std::string CSettings::SETTING_PICTURES_SHOWVIDEOS = "pictures.showvideos";
 const std::string CSettings::SETTING_PICTURES_DISPLAYRESOLUTION = "pictures.displayresolution";
diff --git a/xbmc/settings/Settings.h b/xbmc/settings/Settings.h
index 0829f6b..432a23c 100644
--- a/xbmc/settings/Settings.h
+++ b/xbmc/settings/Settings.h
@@ -254,6 +254,7 @@ public:
   static const std::string SETTING_AUDIOCDS_EJECTONRIP;
   static const std::string SETTING_MYMUSIC_SONGTHUMBINVIS;
   static const std::string SETTING_MYMUSIC_DEFAULTLIBVIEW;
+  static const std::string SETTING_PICTURES_USETAGS;
   static const std::string SETTING_PICTURES_GENERATETHUMBS;
   static const std::string SETTING_PICTURES_SHOWVIDEOS;
   static const std::string SETTING_PICTURES_DISPLAYRESOLUTION;
-- 
2.7.4


From 2e05376a62d3e818ef5e69f7cf2c944835181391 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 28 Jun 2016 14:46:01 +0100
Subject: [PATCH 165/175] ffmpeg: hacky fix for files with GMC

---
 xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index ba73712..9524983 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -1410,8 +1410,8 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
           stereoMode = GetStereoModeFromMetadata(m_pFormatContext->metadata);
         if (!stereoMode.empty())
           st->stereo_mode = stereoMode;
-
-        st->workaround_bugs = pStream->codec->workaround_bugs;
+        AVCodecContext *c = (AVCodecContext *)(((uint32_t *)pStream->internal)[4]); /* Eek! */
+        st->workaround_bugs = c->workaround_bugs;
         if ( m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD) )
         {
           if (pStream->codec->codec_id == AV_CODEC_ID_PROBE)
-- 
2.7.4


From d8a30a061342dd8ac190f9583c91ef3bca7e0988 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 19 Jul 2016 20:39:18 +0100
Subject: [PATCH 166/175] mmalrender: Add sharpness control

---
 addons/resource.language.en_gb/resources/strings.po         |  2 +-
 .../VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp | 13 ++++++++++++-
 .../VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h   |  1 +
 3 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 742d299..ce9439c 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -8697,7 +8697,7 @@ msgstr ""
 
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
 msgctxt "#16313"
-msgid "VDPAU - Sharpness"
+msgid "Sharpness"
 msgstr ""
 
 #empty string with id 16314
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
index 96a8e61..a0104d9 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -403,6 +403,7 @@ CMMALRenderer::CMMALRenderer() : CThread("MMALRenderer"), m_processThread(this,
   m_queue_process = nullptr;
   m_error = 0.0;
   m_vsync_count = ~0U;
+  m_sharpness = -2.0f;
   m_vout_width = 0;
   m_vout_height = 0;
   m_vout_aligned_width = 0;
@@ -750,6 +751,15 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 
   ManageRenderArea();
 
+  // if sharpness setting has changed, we should update it
+  if (m_sharpness != CMediaSettings::GetInstance().GetCurrentVideoSettings().m_Sharpness)
+  {
+    m_sharpness = CMediaSettings::GetInstance().GetCurrentVideoSettings().m_Sharpness;
+    char command[80], response[80];
+    sprintf(command, "scaling_sharpness %d", ((int)(50.0f * (m_sharpness + 1.0f) + 0.5f)));
+    vc_gencmd(response, sizeof response, command);
+  }
+
   if (m_format != RENDER_FMT_MMAL)
   {
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
@@ -927,7 +937,8 @@ bool CMMALRenderer::Supports(ERENDERFEATURE feature)
       feature == RENDERFEATURE_ZOOM            ||
       feature == RENDERFEATURE_ROTATION        ||
       feature == RENDERFEATURE_VERTICAL_SHIFT  ||
-      feature == RENDERFEATURE_PIXEL_RATIO)
+      feature == RENDERFEATURE_PIXEL_RATIO     ||
+      feature == RENDERFEATURE_SHARPNESS)
     return true;
 
   return false;
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
index a056a25..5d3baa6 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
@@ -133,6 +133,7 @@ protected:
   RENDER_STEREO_MODE        m_video_stereo_mode;
   RENDER_STEREO_MODE        m_display_stereo_mode;
   bool                      m_StereoInvert;
+  float                     m_sharpness;
 
   CCriticalSection m_sharedSection;
   MMAL_COMPONENT_T *m_vout;
-- 
2.7.4


From 89b3f631bce8b3a059a69b29bede744b50e7ed92 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 26 Jul 2016 19:00:03 +0100
Subject: [PATCH 167/175] rbp: Ensure processinfo values are initialised

---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp | 2 ++
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp              | 5 ++---
 2 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
index 654a927..2c5144c 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
@@ -598,6 +598,8 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
   m_speed = DVD_PLAYSPEED_NORMAL;
 
   m_processInfo.SetVideoDecoderName(m_pFormatName, true);
+  m_processInfo.SetVideoDimensions(m_decoded_width, m_decoded_height);
+  m_processInfo.SetVideoDAR(m_aspect_ratio);
 
   return true;
 }
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index f54f53a..e653f1a 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -739,9 +739,6 @@ void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height, f
     m_bAllowFullscreen = false; // only allow on first configure
   }
 
-  m_processInfo.SetVideoDimensions(width, height);
-  m_processInfo.SetVideoDAR(display_aspect);
-
   unsigned int iDisplayWidth  = width;
   unsigned int iDisplayHeight = height;
 
@@ -753,6 +750,8 @@ void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height, f
 
   m_fFrameRate = DVD_TIME_BASE / CDVDCodecUtils::NormalizeFrameduration((double)DVD_TIME_BASE / framerate);
   m_processInfo.SetVideoFps(m_fFrameRate);
+  m_processInfo.SetVideoDimensions(width, height);
+  m_processInfo.SetVideoDAR((float)iDisplayWidth / (float)iDisplayHeight);
 
   CLog::Log(LOGDEBUG,"%s - change configuration. video:%dx%d. framerate: %4.2f. %dx%d format: BYPASS",
       __FUNCTION__, video_width, video_height, m_fFrameRate, iDisplayWidth, iDisplayHeight);
-- 
2.7.4


From 0a5f05786f6c321852458951bdab07ff503332ce Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 16 Sep 2016 15:37:07 +0100
Subject: [PATCH 168/175] MMAL: Indicate when picture came from still frame so
 advanced deinterlace can be disabled

MMAL Advanced deinterlace requires 3 frames of context so does not produce any output
from a dvd menu still.

We cannot easily submit the same frame multiple times (the MMAL buffer headers contain
linked list pointers), so the simple solution is to switch to the simpler
deinterlace that does not require context for stills.
---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp |  2 +-
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp           |  4 ++--
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h             |  1 +
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp          |  4 +++-
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h            |  3 ++-
 .../VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp    | 10 ++++++++++
 6 files changed, 19 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 63df727..539882d 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -244,7 +244,7 @@ enum AVPixelFormat CDVDVideoCodecFFmpeg::GetFormat(struct AVCodecContext * avctx
 #ifdef HAS_MMAL
     if (*cur == AV_PIX_FMT_YUV420P)
     {
-      MMAL::CDecoder* dec = new MMAL::CDecoder(ctx->m_processInfo);
+      MMAL::CDecoder* dec = new MMAL::CDecoder(ctx->m_processInfo, ctx->m_hints);
       if(dec->Open(avctx, ctx->m_pCodecContext, *cur, ctx->m_uSurfacesCount))
       {
         ctx->m_processInfo.SetVideoPixelFormat(pixFmtName ? pixFmtName : "");
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
index 2c5144c..1cb76f6 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
@@ -71,6 +71,7 @@ CMMALVideoBuffer::CMMALVideoBuffer(CMMALVideo *omv, std::shared_ptr<CMMALPool> p
   m_encoding = MMAL_ENCODING_UNKNOWN;
   m_aspect_ratio = 0.0f;
   m_rendered = false;
+  m_stills = false;
 }
 
 CMMALVideoBuffer::~CMMALVideoBuffer()
@@ -258,8 +259,6 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
         omvb->m_aligned_width = m_decoded_aligned_width;
         omvb->m_aligned_height = m_decoded_aligned_height;
         omvb->m_aspect_ratio = m_aspect_ratio;
-        if (m_hints.stills) // disable interlace in dvd stills mode
-          omvb->mmal_buffer->flags &= ~MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED;
         omvb->m_encoding = m_dec_output->format->encoding;
         {
           CSingleLock lock(m_output_mutex);
@@ -841,6 +840,7 @@ bool CMMALVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
           pDvdVideoPicture->iFlags, buffer->mmal_buffer->flags, pDvdVideoPicture->MMALBuffer, pDvdVideoPicture->MMALBuffer->mmal_buffer);
     assert(!(buffer->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_DECODEONLY));
     buffer->mmal_buffer->flags &= ~MMAL_BUFFER_HEADER_FLAG_USER3;
+    buffer->m_stills = m_hints.stills;
   }
   else
   {
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h
index d39dc1d..1b21fe1 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h
@@ -59,6 +59,7 @@ public:
   float m_aspect_ratio;
   MMALState m_state;
   bool m_rendered;
+  bool m_stills;
   const char *GetStateName() {
     static const char *names[] = { "MMALStateNone", "MMALStateHWDec", "MMALStateFFDec", "MMALStateDeint", };
     if ((size_t)m_state < vcos_countof(names))
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
index 864650d..244dced 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
@@ -54,6 +54,7 @@ CMMALYUVBuffer::CMMALYUVBuffer(std::shared_ptr<CMMALPool> pool, uint32_t mmal_en
   m_aspect_ratio = 0.0f;
   mmal_buffer = nullptr;
   m_rendered = false;
+  m_stills = false;
   if (m_encoding == MMAL_ENCODING_I420)
     size_pic = (m_aligned_width * m_aligned_height * 3) >> 1;
   else if (m_encoding == MMAL_ENCODING_YUVUV128)
@@ -93,7 +94,7 @@ CMMALYUVBuffer::~CMMALYUVBuffer()
 #undef CLASSNAME
 #define CLASSNAME "CDecoder"
 
-CDecoder::CDecoder(CProcessInfo &processInfo) : m_processInfo(processInfo)
+CDecoder::CDecoder(CProcessInfo &processInfo, CDVDStreamInfo &hints) : m_processInfo(processInfo), m_hints(hints)
 {
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s - create %p", CLASSNAME, __FUNCTION__, this);
@@ -289,6 +290,7 @@ bool CDecoder::GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture
   assert(picture->MMALBuffer->mmal_buffer);
   picture->MMALBuffer->mmal_buffer->data = (uint8_t *)gmem->m_vc_handle;
   picture->MMALBuffer->mmal_buffer->alloc_size = picture->MMALBuffer->mmal_buffer->length = gmem->m_numbytes;
+  picture->MMALBuffer->m_stills = m_hints.stills;
 
   // need to flush ARM cache so GPU can see it (HEVC will have already done this)
   if (avctx->codec_id != AV_CODEC_ID_HEVC)
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h
index ffc6161..60aff83 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h
@@ -52,7 +52,7 @@ class CDecoder
   : public CDVDVideoCodecFFmpeg::IHardwareDecoder
 {
 public:
-  CDecoder(CProcessInfo& processInfo);
+  CDecoder(CProcessInfo& processInfo, CDVDStreamInfo &hints);
   virtual ~CDecoder();
   virtual bool Open(AVCodecContext* avctx, AVCodecContext* mainctx, const enum AVPixelFormat, unsigned int surfaces);
   virtual int Decode(AVCodecContext* avctx, AVFrame* frame);
@@ -73,6 +73,7 @@ protected:
   CCriticalSection m_section;
   std::shared_ptr<CMMALPool> m_pool;
   enum AVPixelFormat m_fmt;
+  CDVDStreamInfo m_hints;
 };
 
 };
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
index a0104d9..2f9af72 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -526,6 +526,16 @@ void CMMALRenderer::Run()
         if (interlace_method == VS_INTERLACEMETHOD_AUTO)
           interlace_method = VS_INTERLACEMETHOD_MMAL_ADVANCED;
         bool interlace = (omvb->mmal_buffer->flags & MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED) ? true:false;
+
+        // advanced deinterlace requires 3 frames of context so disable when showing stills
+        if (omvb->m_stills)
+        {
+          if (interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED)
+             interlace_method = VS_INTERLACEMETHOD_MMAL_BOB;
+           if (interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF)
+             interlace_method = VS_INTERLACEMETHOD_MMAL_BOB_HALF;
+        }
+
         // we don't keep up when running at 60fps in the background so switch to half rate
         if (!g_graphicsContext.IsFullScreenVideo())
         {
-- 
2.7.4


From 68c2937e8c20eb788d88baddec68a1ac382f3056 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 18 Sep 2016 15:19:02 +0100
Subject: [PATCH 169/175] MMAL: Move pool into base class

---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp  |  2 +-
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h    | 11 ++++++-----
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp |  2 +-
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h   |  1 -
 4 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
index 1cb76f6..d62539a 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
@@ -59,7 +59,7 @@ using namespace KODI::MESSAGING;
 
 
 CMMALVideoBuffer::CMMALVideoBuffer(CMMALVideo *omv, std::shared_ptr<CMMALPool> pool)
-    : m_omv(omv), m_pool(pool)
+    : CMMALBuffer(pool), m_omv(omv)
 {
   if (VERBOSE && g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h
index 1b21fe1..5c741d3 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h
@@ -45,10 +45,15 @@
 
 enum MMALState { MMALStateNone, MMALStateHWDec, MMALStateFFDec, MMALStateDeint, };
 
+class CMMALVideo;
+class CMMALRenderer;
+class CMMALPool;
+
 // a mmal video frame
 class CMMALBuffer : public IDVDResourceCounted<CMMALBuffer>
 {
 public:
+  CMMALBuffer(std::shared_ptr<CMMALPool> pool) : m_pool(pool) {}
   virtual ~CMMALBuffer() {}
   MMAL_BUFFER_HEADER_T *mmal_buffer;
   unsigned int m_width;
@@ -60,6 +65,7 @@ public:
   MMALState m_state;
   bool m_rendered;
   bool m_stills;
+  std::shared_ptr<CMMALPool> m_pool;
   const char *GetStateName() {
     static const char *names[] = { "MMALStateNone", "MMALStateHWDec", "MMALStateFFDec", "MMALStateDeint", };
     if ((size_t)m_state < vcos_countof(names))
@@ -69,10 +75,6 @@ public:
   }
 };
 
-class CMMALVideo;
-class CMMALRenderer;
-class CMMALPool;
-
 // a mmal video frame
 class CMMALVideoBuffer : public CMMALBuffer
 {
@@ -81,7 +83,6 @@ public:
   virtual ~CMMALVideoBuffer();
   CMMALVideo *m_omv;
 protected:
-  std::shared_ptr<CMMALPool> m_pool;
 };
 
 class CMMALVideo : public CDVDVideoCodec
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
index 244dced..b0db274 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
@@ -43,7 +43,7 @@ using namespace MMAL;
 #define CLASSNAME "CMMALYUVBuffer"
 
 CMMALYUVBuffer::CMMALYUVBuffer(std::shared_ptr<CMMALPool> pool, uint32_t mmal_encoding, uint32_t width, uint32_t height, uint32_t aligned_width, uint32_t aligned_height, uint32_t size)
-  : m_pool(pool)
+  : CMMALBuffer(pool), m_omv(omv)
 {
   uint32_t size_pic = 0;
   m_width = width;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h
index 60aff83..20eab3b 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h
@@ -45,7 +45,6 @@ public:
 
   CGPUMEM *gmem;
 private:
-  std::shared_ptr<CMMALPool> m_pool;
 };
 
 class CDecoder
-- 
2.7.4


From 5216e07b50e1127edba5b9939ea0972206b6c71e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 18 Sep 2016 16:20:30 +0100
Subject: [PATCH 170/175] MMAL: Make setting the decoder more consistent
 between MMALCodec and MMALFFMpeg

---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp             | 5 +++--
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h               | 3 ++-
 .../cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp | 7 ++++---
 xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h  | 8 +++++---
 4 files changed, 14 insertions(+), 9 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
index b0db274..f20305a 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
@@ -42,8 +42,8 @@ using namespace MMAL;
 
 #define CLASSNAME "CMMALYUVBuffer"
 
-CMMALYUVBuffer::CMMALYUVBuffer(std::shared_ptr<CMMALPool> pool, uint32_t mmal_encoding, uint32_t width, uint32_t height, uint32_t aligned_width, uint32_t aligned_height, uint32_t size)
-  : CMMALBuffer(pool), m_omv(omv)
+CMMALYUVBuffer::CMMALYUVBuffer(CDecoder *omv, std::shared_ptr<CMMALPool> pool, uint32_t mmal_encoding, uint32_t width, uint32_t height, uint32_t aligned_width, uint32_t aligned_height, uint32_t size)
+: CMMALBuffer(pool), m_omv(omv)
 {
   uint32_t size_pic = 0;
   m_width = width;
@@ -244,6 +244,7 @@ bool CDecoder::Open(AVCodecContext *avctx, AVCodecContext* mainctx, enum AVPixel
     CLog::Log(LOGERROR, "%s::%s Failed to create pool for decoder output", CLASSNAME, __func__);
     return false;
   }
+  m_pool->SetDecoder(this);
 
   std::list<EINTERLACEMETHOD> deintMethods;
   deintMethods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_AUTO);
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h
index 20eab3b..b819c24 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.h
@@ -40,10 +40,11 @@ class CGPUPool;
 class CMMALYUVBuffer : public CMMALBuffer
 {
 public:
-  CMMALYUVBuffer(std::shared_ptr<CMMALPool> pool, uint32_t mmal_encoding, uint32_t width, uint32_t height, uint32_t aligned_width, uint32_t aligned_height, uint32_t size);
+  CMMALYUVBuffer(CDecoder *dec, std::shared_ptr<CMMALPool> pool, uint32_t mmal_encoding, uint32_t width, uint32_t height, uint32_t aligned_width, uint32_t aligned_height, uint32_t size);
   virtual ~CMMALYUVBuffer();
 
   CGPUMEM *gmem;
+  CDecoder *m_omv;
 private:
 };
 
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
index 2f9af72..65e09af 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -71,6 +71,7 @@ CMMALPool::CMMALPool(const char *component_name, bool input, uint32_t num_buffer
 
   m_mmal_pool = mmal_port_pool_create(port, port->buffer_num, port->buffer_size);
   m_closing = false;
+  m_software = false;
   m_mmal_format = 0;
   m_width = 0;
   m_height = 0;
@@ -207,14 +208,14 @@ CMMALBuffer *CMMALPool::GetBuffer(uint32_t timeout)
     // ffmpeg requirements
     uint32_t aligned_width = m_aligned_width, aligned_height = m_aligned_height;
     AlignedSize(m_avctx, aligned_width, aligned_height);
-    if (m_dec)
+    if (!IsSoftware())
     {
-      CMMALVideoBuffer *vid = new CMMALVideoBuffer(m_dec, shared_from_this());
+      CMMALVideoBuffer *vid = new CMMALVideoBuffer(static_cast<CMMALVideo *>(m_dec), shared_from_this());
       omvb = vid;
     }
     else
     {
-      MMAL::CMMALYUVBuffer *yuv = new MMAL::CMMALYUVBuffer(shared_from_this(), m_mmal_format, m_width, m_height, aligned_width, aligned_height, m_size);
+      MMAL::CMMALYUVBuffer *yuv = new MMAL::CMMALYUVBuffer(static_cast<MMAL::CDecoder *>(m_dec), shared_from_this(), m_mmal_format, m_width, m_height, aligned_width, aligned_height, m_size);
       if (yuv)
       {
         CGPUMEM *gmem = yuv->gmem;
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
index 5d3baa6..b7a61ea 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
@@ -62,13 +62,14 @@ public:
   void ReleaseBuffer(CGPUMEM *gmem);
   void Close();
   void Prime();
-  void SetDecoder(CMMALVideo *dec) { m_dec = dec; }
+  void SetDecoder(void *dec) { m_dec = dec; }
   void SetFormat(uint32_t mmal_format, uint32_t width, uint32_t height, uint32_t aligned_width, uint32_t aligned_height, uint32_t size, AVCodecContext *avctx)
-    { m_mmal_format = mmal_format; m_width = width; m_height = height; m_aligned_width = aligned_width; m_aligned_height = aligned_height; m_size = size, m_avctx = avctx; }
+    { m_mmal_format = mmal_format; m_width = width; m_height = height; m_aligned_width = aligned_width; m_aligned_height = aligned_height; m_size = size, m_avctx = avctx; m_software = true; }
+  bool IsSoftware() { return m_software; }
 protected:
   uint32_t m_mmal_format, m_width, m_height, m_aligned_width, m_aligned_height, m_size;
   AVCodecContext *m_avctx;
-  CMMALVideo *m_dec;
+  void *m_dec;
   MMALState m_state;
   bool m_input;
   MMAL_POOL_T *m_mmal_pool;
@@ -76,6 +77,7 @@ protected:
   CCriticalSection m_section;
   std::deque<CGPUMEM *> m_freeBuffers;
   bool m_closing;
+  bool m_software;
 };
 
 class CMMALRenderer : public CBaseRenderer, public CThread, public IRunnable
-- 
2.7.4


From 675bc6b147543fbb92dabb8c2203e1ff91ca757d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 18 Sep 2016 16:32:45 +0100
Subject: [PATCH 171/175] MMAL: Set processInfo in pool

---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp               | 1 +
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp              | 1 +
 xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp | 1 +
 xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h   | 2 ++
 4 files changed, 5 insertions(+)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
index d62539a..c65fc52 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
@@ -481,6 +481,7 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
     return false;
   }
   m_pool->SetDecoder(this);
+  m_pool->SetProcessInfo(&m_processInfo);
   m_dec = m_pool->GetComponent();
 
   m_dec->control->userdata = (struct MMAL_PORT_USERDATA_T *)this;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
index f20305a..d42e309 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
@@ -245,6 +245,7 @@ bool CDecoder::Open(AVCodecContext *avctx, AVCodecContext* mainctx, enum AVPixel
     return false;
   }
   m_pool->SetDecoder(this);
+  m_pool->SetProcessInfo(&m_processInfo);
 
   std::list<EINTERLACEMETHOD> deintMethods;
   deintMethods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_AUTO);
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
index 65e09af..297fca2 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -72,6 +72,7 @@ CMMALPool::CMMALPool(const char *component_name, bool input, uint32_t num_buffer
   m_mmal_pool = mmal_port_pool_create(port, port->buffer_num, port->buffer_size);
   m_closing = false;
   m_software = false;
+  m_processInfo = nullptr;
   m_mmal_format = 0;
   m_width = 0;
   m_height = 0;
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
index b7a61ea..b7621a8 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
@@ -63,6 +63,7 @@ public:
   void Close();
   void Prime();
   void SetDecoder(void *dec) { m_dec = dec; }
+  void SetProcessInfo(CProcessInfo *processInfo) { m_processInfo = processInfo; }
   void SetFormat(uint32_t mmal_format, uint32_t width, uint32_t height, uint32_t aligned_width, uint32_t aligned_height, uint32_t size, AVCodecContext *avctx)
     { m_mmal_format = mmal_format; m_width = width; m_height = height; m_aligned_width = aligned_width; m_aligned_height = aligned_height; m_size = size, m_avctx = avctx; m_software = true; }
   bool IsSoftware() { return m_software; }
@@ -78,6 +79,7 @@ protected:
   std::deque<CGPUMEM *> m_freeBuffers;
   bool m_closing;
   bool m_software;
+  CProcessInfo *m_processInfo;
 };
 
 class CMMALRenderer : public CBaseRenderer, public CThread, public IRunnable
-- 
2.7.4


From 6403f2624f77fba248341d4e7cf0b82274c5774d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 18 Sep 2016 18:35:55 +0100
Subject: [PATCH 172/175] MMAL: Report deinterlace method to processinfo
 overlay

---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp  |  3 +--
 xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h    |  1 +
 .../VideoRenderers/HwDecRender/MMALRenderer.cpp       | 19 ++++++++++++++++++-
 .../VideoRenderers/HwDecRender/MMALRenderer.h         |  1 +
 4 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
index c65fc52..1aca23f 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.cpp
@@ -57,6 +57,7 @@ using namespace KODI::MESSAGING;
 
 #define VERBOSE 0
 
+void CMMALBuffer::SetVideoDeintMethod(std::string method) { if (m_pool) m_pool->SetVideoDeintMethod(method); }
 
 CMMALVideoBuffer::CMMALVideoBuffer(CMMALVideo *omv, std::shared_ptr<CMMALPool> pool)
     : CMMALBuffer(pool), m_omv(omv)
@@ -376,8 +377,6 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
   if (hints.workaround_bugs & FF_BUG_GMC_UNSUPPORTED)
     return false;
 
-  m_processInfo.SetVideoDeintMethod("none");
-
   std::list<EINTERLACEMETHOD> deintMethods;
   deintMethods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_AUTO);
   deintMethods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_MMAL_ADVANCED);
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h
index 5c741d3..baff1f0 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h
@@ -66,6 +66,7 @@ public:
   bool m_rendered;
   bool m_stills;
   std::shared_ptr<CMMALPool> m_pool;
+  void SetVideoDeintMethod(std::string method);
   const char *GetStateName() {
     static const char *names[] = { "MMALStateNone", "MMALStateHWDec", "MMALStateFFDec", "MMALStateDeint", };
     if ((size_t)m_state < vcos_countof(names))
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
index 297fca2..a9566eb 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -524,6 +524,7 @@ void CMMALRenderer::Run()
     {
       if (buffer->length > 0)
       {
+        EINTERLACEMETHOD last_interlace_method = m_interlace_method;
         EINTERLACEMETHOD interlace_method = CMediaSettings::GetInstance().GetCurrentVideoSettings().m_InterlaceMethod;
         if (interlace_method == VS_INTERLACEMETHOD_AUTO)
           interlace_method = VS_INTERLACEMETHOD_MMAL_ADVANCED;
@@ -555,6 +556,22 @@ void CMMALRenderer::Run()
         else if (m_deint_input || interlace)
           CheckConfigurationDeint(omvb->m_width, omvb->m_height, omvb->m_aligned_width, omvb->m_aligned_height, omvb->m_encoding, interlace_method);
 
+        if (!m_deint_input)
+          m_interlace_method = VS_INTERLACEMETHOD_NONE;
+
+        if (last_interlace_method == m_interlace_method)
+          ;
+        else if (m_interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED)
+          omvb->SetVideoDeintMethod("adv(x2)");
+        else if (m_interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF)
+          omvb->SetVideoDeintMethod("adv(x1)");
+        else if (m_interlace_method == VS_INTERLACEMETHOD_MMAL_BOB)
+          omvb->SetVideoDeintMethod("bob(x2)");
+        else if (m_interlace_method == VS_INTERLACEMETHOD_MMAL_BOB_HALF)
+          omvb->SetVideoDeintMethod("bob(x1)");
+        else
+          omvb->SetVideoDeintMethod("none");
+
         if (m_deint_input)
         {
           MMAL_STATUS_T status = mmal_port_send_buffer(m_deint_input, omvb->mmal_buffer);
@@ -1150,7 +1167,7 @@ void CMMALRenderer::DestroyDeinterlace()
       CLog::Log(LOGERROR, "%s::%s Failed to disable deinterlace output port(status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
   }
   m_deint_output = nullptr;
-  m_interlace_method = VS_INTERLACEMETHOD_NONE;
+  m_interlace_method = VS_INTERLACEMETHOD_MAX;
   m_deint_width = 0;
   m_deint_height = 0;
   m_deint_aligned_width = 0;
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
index b7621a8..5758deb 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
@@ -67,6 +67,7 @@ public:
   void SetFormat(uint32_t mmal_format, uint32_t width, uint32_t height, uint32_t aligned_width, uint32_t aligned_height, uint32_t size, AVCodecContext *avctx)
     { m_mmal_format = mmal_format; m_width = width; m_height = height; m_aligned_width = aligned_width; m_aligned_height = aligned_height; m_size = size, m_avctx = avctx; m_software = true; }
   bool IsSoftware() { return m_software; }
+  void SetVideoDeintMethod(std::string method) { if (m_processInfo) m_processInfo->SetVideoDeintMethod(method); }
 protected:
   uint32_t m_mmal_format, m_width, m_height, m_aligned_width, m_aligned_height, m_size;
   AVCodecContext *m_avctx;
-- 
2.7.4


From 3539e276b3195b3201db8129cd5a57fd575a06a8 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 19 Sep 2016 19:56:07 +0100
Subject: [PATCH 173/175] MMALRenderer: Ensure updated aspect ratio is seen in
 the case of a single still frame

---
 .../VideoRenderers/HwDecRender/MMALRenderer.cpp           | 15 +++++++++++----
 .../VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h |  2 ++
 2 files changed, 13 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
index a9566eb..81dd061 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -388,6 +388,7 @@ bool CMMALRenderer::CheckConfigurationVout(uint32_t width, uint32_t height, uint
       Create();
     }
   }
+  SetVideoRect(m_cachedSourceRect, m_cachedDestRect);
   return true;
 }
 
@@ -417,6 +418,8 @@ CMMALRenderer::CMMALRenderer() : CThread("MMALRenderer"), m_processThread(this,
   m_deint_height = 0;
   m_deint_aligned_width = 0;
   m_deint_aligned_height = 0;
+  m_cachedSourceRect.SetRect(0, 0, 0, 0);
+  m_cachedDestRect.SetRect(0, 0, 0, 0);
 
   m_queue_process = mmal_queue_create();
   m_processThread.Create();
@@ -770,16 +773,22 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
   if (m_format == RENDER_FMT_MMAL)
     omvb = m_buffers[source];
 
+  if (g_graphicsContext.GetStereoView() != RENDER_STEREO_VIEW_RIGHT)
+  {
+    ManageRenderArea();
+    CRect view;
+    CBaseRenderer::GetVideoRect(m_cachedSourceRect, m_cachedDestRect, view);
+  }
+
   // we only want to upload frames once
   if (omvb && omvb->m_rendered)
   {
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
       CLog::Log(LOGDEBUG, "%s::%s - MMAL: clear:%d flags:%x alpha:%d source:%d omvb:%p mmal:%p mflags:%x skipping", CLASSNAME, __func__, clear, flags, alpha, source, omvb, omvb->mmal_buffer, omvb->mmal_buffer->flags);
+    SetVideoRect(m_cachedSourceRect, m_cachedDestRect);
     goto exit;
   }
 
-  ManageRenderArea();
-
   // if sharpness setting has changed, we should update it
   if (m_sharpness != CMediaSettings::GetInstance().GetCurrentVideoSettings().m_Sharpness)
   {
@@ -795,7 +804,6 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
       CLog::Log(LOGDEBUG, "%s::%s - bypass: clear:%d flags:%x alpha:%d source:%d format:%d", CLASSNAME, __func__, clear, flags, alpha, source, m_format);
     goto exit;
   }
-  SetVideoRect(m_sourceRect, m_destRect);
 
   if (omvb && omvb->mmal_buffer)
   {
@@ -981,7 +989,6 @@ bool CMMALRenderer::Supports(ESCALINGMETHOD method)
 void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect)
 {
   CSingleLock lock(m_sharedSection);
-  assert(g_graphicsContext.GetStereoView() != RENDER_STEREO_VIEW_RIGHT);
 
   if (!m_vout_input)
     return;
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
index 5758deb..a2af6d5 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
@@ -133,6 +133,8 @@ protected:
   unsigned int         m_extended_format;
   int                  m_neededBuffers;
 
+  CRect                     m_cachedSourceRect;
+  CRect                     m_cachedDestRect;
   CRect                     m_src_rect;
   CRect                     m_dst_rect;
   RENDER_STEREO_MODE        m_video_stereo_mode;
-- 
2.7.4


From df57a63cf0c86c97c12090867a853a583c3d9227 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 19 Jul 2016 20:37:46 +0100
Subject: [PATCH 174/175] mmalrender: Use computed framerate rather than
 version from configure

---
 .../VideoRenderers/HwDecRender/MMALRenderer.cpp    | 58 ++++++++++++++++++++--
 .../VideoRenderers/HwDecRender/MMALRenderer.h      |  5 +-
 2 files changed, 57 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
index 81dd061..d3ddcde 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -34,6 +34,7 @@
 #include "cores/VideoPlayer/DVDCodecs/Video/MMALCodec.h"
 #include "xbmc/Application.h"
 #include "linux/RBP.h"
+#include "cores/VideoPlayer/DVDClock.h"
 
 extern "C" {
 #include "libavutil/imgutils.h"
@@ -405,6 +406,10 @@ CMMALRenderer::CMMALRenderer() : CThread("MMALRenderer"), m_processThread(this,
   m_queue_render = nullptr;
   m_queue_process = nullptr;
   m_error = 0.0;
+  m_fps = 0.0;
+  m_lastPts = DVD_NOPTS_VALUE;
+  m_frameInterval = 0.0;
+  m_frameIntervalDiff = 1e5;
   m_vsync_count = ~0U;
   m_sharpness = -2.0f;
   m_vout_width = 0;
@@ -452,14 +457,32 @@ void CMMALRenderer::Process()
   CLog::Log(LOGDEBUG, "%s::%s - starting", CLASSNAME, __func__);
   while (!bStop)
   {
-    g_RBP.WaitVsync();
     double dfps = g_graphicsContext.GetFPS();
-    if (dfps <= 0.0)
-      dfps = m_fps;
+    double fps = 0.0;
+    double inc = 1.0;
+    g_RBP.WaitVsync();
+
+    CSingleLock lock(m_sharedSection);
+    // if good enough framerate measure then use it
+    if (dfps > 0.0 && m_frameInterval > 0.0 && m_frameIntervalDiff * 1e-6 < 1e-3)
+    {
+      fps = 1e6 / m_frameInterval;
+      inc = fps / dfps;
+      if (fabs(inc - 1.0) < 1e-2)
+        inc = 1.0;
+      else if (fabs(inc - 0.5) < 1e-2)
+        inc = 0.5;
+      else if (fabs(inc - 24.0/60.0) < 1e-2)
+        inc = 24.0/60.0;
+      if (m_deint)
+        inc *= 2.0;
+    }
     // This algorithm is basically making the decision according to Bresenham's line algorithm.  Imagine drawing a line where x-axis is display frames, and y-axis is video frames
-    m_error += m_fps / dfps;
+    m_error += inc;
+    if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+      CLog::Log(LOGDEBUG, "%s::%s - debug vsync:%d queue:%d fps:%.2f/%.2f/%.2f inc:%f diff:%f", CLASSNAME, __func__, g_RBP.LastVsync(), mmal_queue_length(m_queue_render), fps, m_fps, dfps, inc, m_error);
     // we may need to discard frames if queue length gets too high or video frame rate is above display frame rate
-    while (mmal_queue_length(m_queue_render) > 2 || m_error > 1.0)
+    while (mmal_queue_length(m_queue_render) > 2 || (mmal_queue_length(m_queue_render) > 1 && m_error > 1.0))
     {
       if (m_error > 1.0)
         m_error -= 1.0;
@@ -655,6 +678,26 @@ void CMMALRenderer::Run()
   CLog::Log(LOGDEBUG, "%s::%s - stopping", CLASSNAME, __func__);
 }
 
+void CMMALRenderer::UpdateFramerateStats(double pts)
+{
+  double diff = 0.0;
+  if (m_lastPts != DVD_NOPTS_VALUE && pts != DVD_NOPTS_VALUE && pts - m_lastPts > 0.0 && pts - m_lastPts < DVD_SEC_TO_TIME(1./20.0))
+  {
+    diff = pts - m_lastPts;
+    if (m_frameInterval == 0.0)
+      m_frameInterval = diff;
+    else if (diff > 0.0)
+    {
+      m_frameIntervalDiff = m_frameIntervalDiff * 0.9 + 0.1 * fabs(m_frameInterval - diff);
+      m_frameInterval = m_frameInterval * 0.9 + diff * 0.1;
+    }
+  }
+  if (pts != DVD_NOPTS_VALUE)
+    m_lastPts = pts;
+  if (VERBOSE && g_advancedSettings.CanLogComponent(LOGVIDEO))
+    CLog::Log(LOGDEBUG, "%s::%s pts:%.3f diff:%.3f m_frameInterval:%.6f m_frameIntervalDiff:%.6f", CLASSNAME, __func__, pts*1e-6, diff * 1e-6 , m_frameInterval * 1e-6, m_frameIntervalDiff *1e-6);
+}
+
 void CMMALRenderer::AddVideoPictureHW(DVDVideoPicture& pic, int index)
 {
   if (m_format != RENDER_FMT_MMAL)
@@ -669,6 +712,7 @@ void CMMALRenderer::AddVideoPictureHW(DVDVideoPicture& pic, int index)
     CLog::Log(LOGDEBUG, "%s::%s MMAL - %p (%p) %i", CLASSNAME, __func__, buffer, buffer->mmal_buffer, index);
 
   m_buffers[index] = buffer->Acquire();
+  UpdateFramerateStats(pic.pts);
 }
 
 bool CMMALRenderer::Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation)
@@ -682,6 +726,10 @@ bool CMMALRenderer::Configure(unsigned int width, unsigned int height, unsigned
 
   m_fps = fps;
   m_iFlags = flags;
+  m_error = 0.0;
+  m_lastPts = DVD_NOPTS_VALUE;
+  m_frameInterval = 0.0;
+  m_frameIntervalDiff = 1e5;
 
   // cause SetVideoRect to trigger - needed after a hdmi mode change
   m_src_rect.SetRect(0, 0, 0, 0);
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
index a2af6d5..69eae6c 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.h
@@ -150,7 +150,9 @@ protected:
   CThread m_processThread;
   MMAL_BUFFER_HEADER_T m_quitpacket;
   double m_error;
-
+  double m_lastPts;
+  double m_frameInterval;
+  double m_frameIntervalDiff;
   uint32_t m_vout_width, m_vout_height, m_vout_aligned_width, m_vout_aligned_height;
   // deinterlace
   MMAL_COMPONENT_T *m_deint;
@@ -168,5 +170,6 @@ protected:
   uint32_t m_vsync_count;
   void ReleaseBuffers();
   void UnInitMMAL();
+  void UpdateFramerateStats(double pts);
   virtual void Run() override;
 };
-- 
2.7.4


From 5c08d6be432bbce164cf99561713f05f27e4da33 Mon Sep 17 00:00:00 2001
From: Sam Nazarko <email@samnazarko.co.uk>
Date: Wed, 12 Oct 2016 13:29:04 +0100
Subject: [PATCH 175/175] Define RPI=1 so we can use VPU/QPU acceleration
 patches when building ffmpeg via autobuild.sh

Signed-off-by: Sam Nazarko <email@samnazarko.co.uk>
---
 tools/depends/target/ffmpeg/autobuild.sh | 1 +
 1 file changed, 1 insertion(+)

diff --git a/tools/depends/target/ffmpeg/autobuild.sh b/tools/depends/target/ffmpeg/autobuild.sh
index 0c323ac..aa12d8d 100755
--- a/tools/depends/target/ffmpeg/autobuild.sh
+++ b/tools/depends/target/ffmpeg/autobuild.sh
@@ -169,6 +169,7 @@ CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
 	--enable-zlib \
 	--disable-mipsdsp \
 	--disable-mipsdspr2 \
+	--extra-cflags="-DRPI=1" \
         ${FLAGS}
 
 make -j ${BUILDTHREADS} 
-- 
2.7.4

